{"file": "../dafny-sandbox/Stlc.dfy", "dafny": "// Proving type safety of a Simply Typed Lambda-Calculus in Dafny\n// adapted from Coq (http://www.cis.upenn.edu/~bcpierce/sf/Stlc.html)\n\n/// Utilities\n\n// ... handy for partial functions\ndatatype option<A> = None | Some(get: A)\n\n/// -----\n/// Model\n/// -----\n\n/// Syntax\n\n// Types\ndatatype ty =  TBase                             // (opaque base type)\n            |  TArrow(T1: ty, T2: ty)            // T1 => T2\n/*BOOL?\n            | TBool                              // (base type for booleans)\n?BOOL*/\n/*NAT?\n            |  TNat                              // (base type for naturals)\n?NAT*/\n/*REC?\n            | TVar(id: int) | TRec(X: nat, T: ty)// (iso-recursive types)\n?REC*/\n\n// Terms\ndatatype tm = tvar(id: int)                      // x                  (variable)\n            | tapp(f: tm, arg: tm)               // t t                (application)\n            | tabs(x: int, T: ty, body: tm)      // \\x:T.t             (abstraction)\n/*BOOL?\n            | ttrue | tfalse                     // true, false        (boolean values)\n            | tif(c: tm, a: tm, b: tm)           // if t then t else t (if expression)\n?BOOL*/\n/*NAT?\n            | tzero | tsucc(p: tm) | tprev(n: tm)//                    (naturals)\n/*BOOL?\n            | teq(n1: tm, n2: tm)                //                    (equality on naturals)\n?BOOL*/\n?NAT*/\n/*REC?\n            | tfold(Tf: ty, tf: tm) | tunfold(tu: tm)//                (iso-recursive terms)\n?REC*/\n\n/// Operational Semantics\n\n// Values\npredicate value(t: tm)\n{\n  t.tabs?\n/*BOOL?\n  || t.ttrue? || t.tfalse?\n?BOOL*/\n/*NAT?\n  || peano(t)\n?NAT*/\n/*REC?\n  || (t.tfold? && value(t.tf))\n?REC*/\n}\n\n/*NAT?\npredicate peano(t: tm)\n{\n  t.tzero? || (t.tsucc? && peano(t.p))\n}\n?NAT*/\n\n// Free Variables and Substitution\n\nfunction fv(t: tm): set<int> //of free variables of t\n{\n  match t\n  // interesting cases...\n  case tvar(id) => {id}\n  case tabs(x, T, body) => fv(body)-{x}//x is bound\n  // congruent cases...\n  case tapp(f, arg) => fv(f)+fv(arg)\n/*BOOL?\n  case tif(c, a, b) => fv(a)+fv(b)+fv(c)\n  case ttrue => {}\n  case tfalse => {}\n?BOOL*/\n/*NAT?\n  case tzero => {}\n  case tsucc(p) => fv(p)\n  case tprev(n) => fv(n)\n/*BOOL?\n  case teq(n1, n2) => fv(n1)+fv(n2)\n?BOOL*/\n?NAT*/\n/*REC?\n  case tfold(T, t1) => fv(t1)\n  case tunfold(t1) => fv(t1)\n?REC*/\n}\n\nfunction subst(x: int, s: tm, t: tm): tm //[x -> s]t\n{\n  match t\n  // interesting cases...\n  case tvar(x') => if x==x' then s else t\n  // N.B. only capture-avoiding if s is closed...\n  case tabs(x', T, t1) => tabs(x', T, if x==x' then t1 else subst(x, s, t1))\n  // congruent cases...\n  case tapp(t1, t2) => tapp(subst(x, s, t1), subst(x, s, t2))\n/*BOOL?\n  case ttrue => ttrue\n  case tfalse => tfalse\n  case tif(t1, t2, t3) => tif(subst(x, s, t1), subst(x, s, t2), subst(x, s, t3))\n?BOOL*/\n/*NAT?\n  case tzero => tzero\n  case tsucc(p) => tsucc(subst(x, s, p))\n  case tprev(n) => tprev(subst(x, s, n))\n/*BOOL?\n  case teq(n1, n2) => teq(subst(x, s, n1), subst(x, s, n2))\n?BOOL*/\n?NAT*/\n/*REC?\n  case tfold(T, t1) => tfold(T, subst(x, s, t1))\n  case tunfold(t1) => tunfold(subst(x, s, t1))\n?REC*/\n}\n\n/*REC?\nfunction ty_fv(T: ty): set<int> //of free type variables of T\n{\n  match T\n  case TVar(X) => {X}\n  case TRec(X, T1) => ty_fv(T1)-{X}\n  case TArrow(T1, T2) => ty_fv(T1)+ty_fv(T2)\n  case TBase => {}\n/*BOOL?\n  case TBool => {}\n?BOOL*/\n/*NAT?\n  case TNat => {}\n?NAT*/\n}\n\nfunction tsubst(X: int, S: ty, T: ty): ty\n{\n  match T\n  case TVar(X') => if X==X' then S else T\n  case TRec(X', T1) => TRec(X', if X==X' then T1 else tsubst(X, S, T1))\n  case TArrow(T1, T2) => TArrow(tsubst(X, S, T1), tsubst(X, S, T2))\n  case TBase => TBase\n/*BOOL?\n  case TBool => TBool\n?BOOL*/\n/*NAT?\n  case TNat => TNat\n?NAT*/\n}\n\npredicate ty_closed(T: ty)\n{\n  forall x :: x !in ty_fv(T)\n}\n?REC*/\n\n// Reduction\nfunction step(t: tm): option<tm>\n{\n  /* AppAbs */     if (t.tapp? && t.f.tabs? && value(t.arg)) then\n  Some(subst(t.f.x, t.arg, t.f.body))\n  /* App1 */       else if (t.tapp? && step(t.f).Some?) then\n  Some(tapp(step(t.f).get, t.arg))\n  /* App2 */       else if (t.tapp? && value(t.f) && step(t.arg).Some?) then\n  Some(tapp(t.f, step(t.arg).get))\n/*BOOL?\n  /* IfTrue */     else if (t.tif? && t.c == ttrue) then\n  Some(t.a)\n  /* IfFalse */    else if (t.tif? && t.c == tfalse) then\n  Some(t.b)\n  /* If */         else if (t.tif? && step(t.c).Some?) then\n  Some(tif(step(t.c).get, t.a, t.b))\n?BOOL*/\n/*NAT?\n  /* Prev0 */\n                   else if (t.tprev? && t.n.tzero?) then\n  Some(tzero)\n  /* PrevSucc */   else if (t.tprev? && peano(t.n) && t.n.tsucc?) then\n  Some(t.n.p)\n  /* Prev */       else if (t.tprev? && step(t.n).Some?) then\n  Some(tprev(step(t.n).get))\n  /* Succ */       else if (t.tsucc? && step(t.p).Some?) then\n  Some(tsucc(step(t.p).get))\n/*BOOL?\n  /* EqTrue0 */    else if (t.teq? && t.n1.tzero? && t.n2.tzero?) then\n  Some(ttrue)\n  /* EqFalse1 */   else if (t.teq? && t.n1.tsucc? && peano(t.n1) && t.n2.tzero?) then\n  Some(tfalse)\n  /* EqFalse2 */   else if (t.teq? && t.n1.tzero? && t.n2.tsucc? && peano(t.n2)) then\n  Some(tfalse)\n  /* EqRec */      else if (t.teq? && t.n1.tsucc? && t.n2.tsucc? && peano(t.n1) && peano(t.n2)) then\n  Some(teq(t.n1.p, t.n2.p))\n  /* Eq1 */        else if (t.teq? && step(t.n1).Some?) then\n  Some(teq(step(t.n1).get, t.n2))\n  /* Eq2 */        else if (t.teq? && peano(t.n1) && step(t.n2).Some?) then\n  Some(teq(t.n1, step(t.n2).get))\n?BOOL*/\n?NAT*/\n/*REC?\n  /* UnfoldFold */ else if (t.tunfold? && t.tu.tfold? && value(t.tu.tf)) then Some(t.tu.tf)\n  /* Fold */       else if (t.tfold? && step(t.tf).Some?) then Some(tfold(t.Tf, step(t.tf).get))\n  /* Unfold */     else if (t.tunfold? && step(t.tu).Some?) then Some(tunfold(step(t.tu).get))\n?REC*/\n  else None\n}\n\n// Multistep reduction:\n// The term t reduces to the term t' in n or less number of steps.\npredicate reduces_to(t: tm, t': tm, n: nat)\n  decreases n;\n{\n  t == t' || (n > 0 && step(t).Some? && reduces_to(step(t).get, t', n-1))\n}\n\n// Examples\nlemma lemma_step_example1(n: nat)\n  requires n > 0;\n  // (\\x:B=>B.x) (\\x:B.x) reduces to (\\x:B.x)\n  ensures reduces_to(tapp(tabs(0, TArrow(TBase, TBase), tvar(0)), tabs(0, TBase, tvar(0))),\n                     tabs(0, TBase, tvar(0)), n);\n{\n}\n\n\n/// Typing\n\n// A context is a partial map from variable names to types.\nfunction find(c: map<int,ty>, x: int): option<ty>\n{\n  if (x in c) then Some(c[x]) else None\n}\nfunction extend(x: int, T: ty, c: map<int,ty>): map<int,ty>\n{\n  c[x:=T]\n}\n\n// Typing Relation\nfunction has_type(c: map<int,ty>, t: tm): option<ty>\n  decreases t;\n{\n  match t\n  /* Var */  case tvar(id) => find(c, id)\n  /* Abs */  case tabs(x, T, body) =>\n  var ty_body := has_type(extend(x, T, c), body);\n                     if (ty_body.Some?) then\n  Some(TArrow(T, ty_body.get))          else None\n  /* App */  case tapp(f, arg) =>\n  var ty_f   := has_type(c, f);\n  var ty_arg := has_type(c, arg);\n                     if (ty_f.Some? && ty_arg.Some?) then\n  if ty_f.get.TArrow? && ty_f.get.T1 == ty_arg.get then\n  Some(ty_f.get.T2)  else None else None\n/*BOOL?\n  /* True */  case ttrue => Some(TBool)\n  /* False */ case tfalse => Some(TBool)\n  /* If */    case tif(cond, a, b) =>\n  var ty_c := has_type(c, cond);\n  var ty_a := has_type(c, a);\n  var ty_b := has_type(c, b);\n                     if (ty_c.Some? && ty_a.Some? && ty_b.Some?) then\n  if ty_c.get == TBool && ty_a.get == ty_b.get then\n  ty_a\n                     else None else None\n?BOOL*/\n/*NAT?\n  /* Zero */  case tzero => Some(TNat)\n  /* Prev */  case tprev(n) =>\n  var ty_n := has_type(c, n);\n                     if (ty_n.Some?) then\n  if ty_n.get == TNat then\n  Some(TNat)         else None else None\n  /* Succ */  case tsucc(p) =>\n  var ty_p := has_type(c, p);\n                     if (ty_p.Some?) then\n  if ty_p.get == TNat then\n  Some(TNat)         else None else None\n/*BOOL?\n  /* Eq */    case teq(n1, n2) =>\n  var ty_n1 := has_type(c, n1);\n  var ty_n2 := has_type(c, n2);\n                      if (ty_n1.Some? && ty_n2.Some?) then\n  if ty_n1.get == TNat && ty_n2.get == TNat then\n  Some(TBool)         else None else None\n?BOOL*/\n?NAT*/\n/*REC?\n  /* Fold */  case tfold(U, t1) =>\n  var ty_t1 := if (ty_closed(U)) then has_type(c, t1) else None;\n                      if (ty_t1.Some?) then\n  if U.TRec? && ty_t1.get==tsubst(U.X, U, U.T) then\n  Some(U)             else None else None\n  /* Unfold */ case tunfold(t1) =>\n  var ty_t1 := has_type(c, t1);\n                      if ty_t1.Some? then\n  var U := ty_t1.get;\n  if U.TRec? then\n  Some(tsubst(U.X, U, U.T)) else None else None\n?REC*/\n}\n\n// Examples\n\nlemma example_typing_1()\n  ensures has_type(map[], tabs(0, TBase, tvar(0))) == Some(TArrow(TBase, TBase));\n{\n}\n\nlemma example_typing_2()\n  ensures has_type(map[], tabs(0, TBase, tabs(1, TArrow(TBase, TBase), tapp(tvar(1), tapp(tvar(1), tvar(0)))))) ==\n          Some(TArrow(TBase, TArrow(TArrow(TBase, TBase), TBase)));\n{\n  var c := extend(1, TArrow(TBase, TBase), extend(0, TBase, map[]));\n  assert find(c, 0) == Some(TBase);\n  assert has_type(c, tvar(0)) == Some(TBase);\n  assert has_type(c, tvar(1)) == Some(TArrow(TBase, TBase));\n  assert has_type(c, tapp(tvar(1), tapp(tvar(1), tvar(0)))) == Some(TBase);\n}\n\nlemma nonexample_typing_1()\n  ensures has_type(map[], tabs(0, TBase, tabs(1, TBase, tapp(tvar(0), tvar(1))))) == None;\n{\n  var c := extend(1, TBase, extend(0, TBase, map[]));\n  assert find(c, 0) == Some(TBase);\n  assert has_type(c, tapp(tvar(0), tvar(1))) == None;\n}\n\nlemma nonexample_typing_3(S: ty, T: ty)\n  ensures has_type(map[], tabs(0, S, tapp(tvar(0), tvar(0)))) != Some(T);\n{\n  var c := extend(0, S, map[]);\n  assert has_type(c, tapp(tvar(0), tvar(0))) == None;\n}\n\n/*BOOL?\nlemma example_typing_bool()\n  ensures has_type(map[], tabs(0, TBase, tabs(1, TBase, tabs(2, TBool, tif(tvar(2), tvar(0), tvar(1)))))) ==\n          Some(TArrow(TBase, TArrow(TBase, TArrow(TBool, TBase))));\n{\n  var c0 := extend(0, TBase, map[]);\n  var c1 := extend(1, TBase, c0);\n  var c2 := extend(2, TBool, c1);\n  assert has_type(c2, tvar(2)) == Some(TBool);\n  assert has_type(c2, tvar(1)) == Some(TBase);\n  assert has_type(c2, tvar(0)) == Some(TBase);\n  assert has_type(c2, tif(tvar(2), tvar(0), tvar(1))) == Some(TBase);\n  assert has_type(c1, tabs(2, TBool, tif(tvar(2), tvar(0), tvar(1)))) == Some(TArrow(TBool, TBase));\n  assert has_type(c0, tabs(1, TBase, tabs(2, TBool, tif(tvar(2), tvar(0), tvar(1))))) == Some(TArrow(TBase, TArrow(TBool, TBase)));\n}\n?BOOL*/\n\n/*NAT?\nlemma example_typing_nat()\n  ensures has_type(map[], tabs(0, TNat, tprev(tvar(0)))) == Some(TArrow(TNat, TNat));\n{\n  var c := extend(0, TNat, map[]);\n  assert has_type(c, tprev(tvar(0)))==Some(TNat);\n}\n?NAT*/\n\n/*REC?\n// TODO\nlemma example_typing_rec()\n  ensures has_type(map[], tfold(TRec(0, TArrow(TVar(0), TBase)), tabs(0, TRec(0, TArrow(TVar(0), TBase)), tapp(tunfold(tvar(0)), tvar(0))))) ==\n          Some(TRec(0, TArrow(TVar(0), TBase)));\n{\n  var R := TRec(0, TArrow(TVar(0), TBase));\n  var c := extend(0, R, map[]);\n  assert has_type(c, tvar(0)) == Some(R);\n  assert tsubst(R.X, R, R.T) == TArrow(R, TBase);\n  assert has_type(c, tunfold(tvar(0))) == Some(TArrow(R, TBase));\n  assert has_type(c, tapp(tunfold(tvar(0)), tvar(0))) == Some(TBase);\n  assert has_type(map[], tabs(0, R, tapp(tunfold(tvar(0)), tvar(0)))) == Some(TArrow(R, TBase));\n  assert ty_fv(R)==ty_fv(TArrow(TVar(0),TBase))-{0}=={};\n  assert ty_closed(R);\n  assert has_type(map[], tfold(TRec(0, TArrow(TVar(0), TBase)), tabs(0, TRec(0, TArrow(TVar(0), TBase)), tapp(tunfold(tvar(0)), tvar(0))))).Some?;\n}\n?REC*/\n\n/// -----------------------\n/// Type-Safety Properties\n/// -----------------------\n\n// Progress:\n// A well-typed term is either a value or it can step.\nlemma theorem_progress(t: tm)\n  requires has_type(map[], t).Some?;\n  ensures value(t) || step(t).Some?;\n{\n}\n\n// Towards preservation and the substitution lemma\n\n// If x is free in t and t is well-typed in some context,\n// then this context must contain x.\nlemma {:induction c, t} lemma_free_in_context(c: map<int,ty>, x: int, t: tm)\n  requires x in fv(t);\n  requires has_type(c, t).Some?;\n  ensures find(c, x).Some?;\n  decreases t;\n{\n}\n\n// A closed term does not contain any free variables.\n// N.B. We're only interested in proving type soundness of closed terms.\npredicate closed(t: tm)\n{\n  forall x :: x !in fv(t)\n}\n\n// If a term can be well-typed in an empty context,\n// then it is closed.\nlemma corollary_typable_empty__closed(t: tm)\n  requires has_type(map[], t).Some?;\n  ensures closed(t);\n{\n  forall (x:int) ensures x !in fv(t);\n  {\n    if (x in fv(t)) {\n      lemma_free_in_context(map[], x, t);\n      assert false;\n    }\n  }\n}\n\n// If a term t is well-typed in context c,\n//    and context c' agrees with c on all free variables of t,\n// then the term t is well-typed in context c',\n//      with the same type as in context c.\nlemma {:induction t} lemma_context_invariance(c: map<int,ty>, c': map<int,ty>, t: tm)\n  requires has_type(c, t).Some?;\n  requires forall x: int :: x in fv(t) ==> find(c, x) == find(c', x);\n  ensures has_type(c, t) == has_type(c', t);\n  decreases t;\n{\n  if (t.tabs?) {\n    assert fv(t.body) == fv(t) || fv(t.body) == fv(t) + {t.x};\n    lemma_context_invariance(extend(t.x, t.T, c), extend(t.x, t.T, c'), t.body);\n  }\n}\n\n// Substitution preserves typing:\n// If  s has type S in an empty context,\n// and t has type T in a context extended with x having type S,\n// then [x -> s]t has type T as well.\nlemma lemma_substitution_preserves_typing(c: map<int,ty>, x: int, s: tm, t: tm)\n  requires has_type(map[], s).Some?;\n  requires has_type(extend(x, has_type(map[], s).get, c), t).Some?;\n  ensures has_type(c, subst(x, s, t)) == has_type(extend(x, has_type(map[], s).get, c), t);\n  decreases t;\n{\n  var S := has_type(map[], s).get;\n  var cs := extend(x, S, c);\n  var T  := has_type(cs, t).get;\n\n  if (t.tvar?) {\n    if (t.id==x) {\n      assert T == S;\n      corollary_typable_empty__closed(s);\n      lemma_context_invariance(map[], c, s);\n    }\n  }\n  if (t.tabs?) {\n    if (t.x==x) {\n      lemma_context_invariance(cs, c, t);\n    } else {\n      var cx  := extend(t.x, t.T, c);\n      var csx := extend(x, S, cx);\n      var cxs := extend(t.x, t.T, cs);\n      lemma_context_invariance(cxs, csx, t.body);\n      lemma_substitution_preserves_typing(cx, x, s, t.body);\n    }\n  }\n}\n\n\n// Preservation:\n// A well-type term which steps preserves its type.\nlemma theorem_preservation(t: tm)\n  requires has_type(map[], t).Some?;\n  requires step(t).Some?;\n  ensures has_type(map[], step(t).get) == has_type(map[], t);\n{\n  if (t.tapp? && value(t.f) && value(t.arg)) {\n    lemma_substitution_preserves_typing(map[], t.f.x, t.arg, t.f.body);\n  }\n}\n\n// A normal form cannot step.\npredicate normal_form(t: tm)\n{\n  step(t).None?\n}\n\n// A stuck term is a normal form that is not a value.\npredicate stuck(t: tm)\n{\n  normal_form(t) && !value(t)\n}\n\n// Type soundness:\n// A well-typed term cannot be stuck.\nlemma corollary_soundness(t: tm, t': tm, T: ty, n: nat)\n  requires has_type(map[], t) == Some(T);\n  requires reduces_to(t, t', n);\n  ensures !stuck(t');\n  decreases n;\n{\n  theorem_progress(t);\n  if (t != t') {\n   theorem_preservation(t);\n   corollary_soundness(step(t).get, t', T, n-1);\n  }\n}\n\n/// QED"}
{"file": "../dafny-sandbox/Norm.dfy", "dafny": "// Normalization of STLC\n// http://www.cis.upenn.edu/~bcpierce/sf/Norm.html\n\n// --- BEGIN excerpt from Stlc.dfy ---\n\n// Utilities\ndatatype option<A> = None | Some(get: A)\n\n\n// Syntax\n\n// Types\ndatatype ty = TBool | TArrow(paramT: ty, bodyT: ty)\n\n// Terms\ndatatype tm = tvar(id: nat) | tapp(f: tm, arg: tm) | tabs(x: nat, T: ty, body: tm) | ttrue | tfalse | tif(c: tm, a: tm, b: tm)\n\n\n// Operational Semantics\n\n// Values\nfunction value(t: tm): bool\n{\n  t.tabs? || t.ttrue? || t.tfalse?\n}\n\n// Free Variables and Substitution\nfunction subst(x: nat, s: tm, t: tm): tm\n{\n  match t\n  case tvar(x') => if x==x' then s else t\n  case tabs(x', T, t1) => tabs(x', T, if x==x' then t1 else subst(x, s, t1))\n  case tapp(t1, t2) => tapp(subst(x, s, t1), subst(x, s, t2))\n  case ttrue => ttrue\n  case tfalse => tfalse\n  case tif(t1, t2, t3) => tif(subst(x, s, t1), subst(x, s, t2), subst(x, s, t3))\n}\n\n// Reduction\nfunction step(t: tm): option<tm>\n{\n  /* AppAbs */     if (t.tapp? && t.f.tabs? && value(t.arg)) then Some(subst(t.f.x, t.arg, t.f.body))\n  /* App1 */       else if (t.tapp? && step(t.f).Some?) then Some(tapp(step(t.f).get, t.arg))\n  /* App2 */       else if (t.tapp? && step(t.arg).Some?) then Some(tapp(t.f, step(t.arg).get))\n  /* IfTrue */     else if (t.tif? && t.c == ttrue) then Some(t.a)\n  /* IfFalse */    else if (t.tif? && t.c == tfalse) then Some(t.b)\n  /* If */         else if (t.tif? && step(t.c).Some?) then Some(tif(step(t.c).get, t.a, t.b))\n                   else None\n}\n\nfunction reduces_to(t: tm, t': tm, n: nat): bool\n  decreases n\n{\n  t == t' || (n > 0 && step(t).Some? && reduces_to(step(t).get, t', n-1))\n}\n\n\n// Typing\n\n// Contexts\n\ndatatype partial_map<A> = Empty | Extend(x: nat, v: A, rest: partial_map<A>)\nfunction find<A>(m: partial_map<A>, x: nat): option<A>\n{\n  match m\n  case Empty => None\n  case Extend(x', v, rest) => if x==x' then Some(v) else find(rest, x)\n}\n\ndatatype context = Context(m: partial_map<ty>)\n\n// Typing Relation\nfunction has_type(c: context, t: tm): option<ty>\n  decreases t\n{\n  match t\n  /* Var */        case tvar(id) => find(c.m, id)\n  /* Abs */        case tabs(x, T, body) =>\n                     var ty_body := has_type(Context(Extend(x, T, c.m)), body);\n                     if (ty_body.Some?) then Some(TArrow(T, ty_body.get)) else None\n  /* App */        case tapp(f, arg) =>\n                     var ty_f := has_type(c, f);\n                     var ty_arg := has_type(c, arg);\n                     if (ty_f.Some? && ty_arg.Some? && ty_f.get.TArrow? && ty_f.get.paramT == ty_arg.get)\n                     then Some(ty_f.get.bodyT)\n                     else None\n /* True */        case ttrue => Some(TBool)\n /* False */       case tfalse => Some(TBool)\n /* If */          case tif(cond, a, b) =>\n                     var ty_c := has_type(c, cond);\n                     var ty_a := has_type(c, a);\n                     var ty_b := has_type(c, b);\n                     if (ty_c.Some? && ty_a.Some? && ty_b.Some? && ty_c.get == TBool && ty_a.get == ty_b.get)\n                     then ty_a\n                     else None\n}\n\n// Properties\n\n// Free Occurrences\nfunction appears_free_in(x: nat, t: tm): bool\n{\n  /* var */  (t.tvar? && t.id==x) ||\n  /* app1 */ (t.tapp? && appears_free_in(x, t.f)) ||\n  /* app2 */ (t.tapp? && appears_free_in(x, t.arg)) ||\n  /* abs */  (t.tabs? && t.x!=x && appears_free_in(x, t.body)) ||\n  /* if1 */  (t.tif? && appears_free_in(x, t.c)) ||\n  /* if2 */  (t.tif? && appears_free_in(x, t.a)) ||\n  /* if3 */  (t.tif? && appears_free_in(x, t.b))\n}\n\nghost function closed(t: tm): bool\n{\n  forall x: nat :: !appears_free_in(x, t)\n}\n\n\n// Substitution Lemma\n\nlemma lemma_free_in_context(c: context, x: nat, t: tm)\n  requires appears_free_in(x, t)\n  requires has_type(c, t).Some?\n  ensures find(c.m, x).Some?\n  ensures has_type(c, t).Some?\n  decreases t\n{\n  if (t.tabs?) {\n    assert t.x != x;\n    assert has_type(Context(Extend(t.x, t.T, c.m)), t.body).Some?;\n    lemma_free_in_context(Context(Extend(t.x, t.T, c.m)), x, t.body);\n    assert find(Extend(t.x, t.T, c.m), x).Some?;\n  }\n}\n\nlemma corollary_typable_empty__closed(t: tm)\n  requires has_type(Context(Empty), t).Some?\n  ensures closed(t)\n{\n  forall x: nat ensures !appears_free_in(x, t)\n  {\n    if (appears_free_in(x, t)) {\n      lemma_free_in_context(Context(Empty), x, t);\n      assert find<ty>(Empty, x).Some?;\n      assert false;\n    }\n    assert !appears_free_in(x, t);\n  }\n}\n\nlemma lemma_context_invariance(c: context, c': context, t: tm)\n  requires has_type(c, t).Some?\n  requires forall x: nat :: appears_free_in(x, t) ==> find(c.m, x) == find(c'.m, x)\n  ensures has_type(c, t) == has_type(c', t)\n  decreases t\n{\n  if (t.tabs?) {\n    assert find(Extend(t.x, t.T, c.m), t.x) == find(Extend(t.x, t.T, c'.m), t.x);\n    lemma_context_invariance(Context(Extend(t.x, t.T, c.m)), Context(Extend(t.x, t.T, c'.m)), t.body);\n  }\n}\n\nlemma lemma_substitution_preserves_typing(c: context, x: nat, t': tm, t: tm)\n  requires has_type(Context(Empty), t').Some?\n  requires has_type(Context(Extend(x, has_type(Context(Empty), t').get, c.m)), t).Some?\n  ensures has_type(c, subst(x, t', t)) == has_type(Context(Extend(x, has_type(Context(Empty), t').get, c.m)), t)\n  decreases t\n{\n  if (t.tvar? && t.id==x) {\n    corollary_typable_empty__closed(t');\n    lemma_context_invariance(Context(Empty), c, t');\n  }\n  if (t.tabs?) {\n    var U := has_type(Context(Empty), t').get;\n    if (t.x==x) {\n      lemma_context_invariance(Context(Extend(x, U, c.m)), c, t);\n    } else {\n      var c_px := Context(Extend(t.x, t.T, Extend(x, U, c.m)));\n      var c_xp := Context(Extend(x, U, Extend(t.x, t.T, c.m)));\n      var c_p := Context(Extend(t.x, t.T, c.m));\n      assert find(c_px.m, x) == find(c_xp.m, x);\n      assert find(c_px.m, t.x) == find(c_xp.m, t.x);\n      lemma_context_invariance(c_px, c_xp, t.body);\n      lemma_substitution_preserves_typing(c_p, x, t', t.body);\n    }\n  }\n}\n\n\n// Preservation\nlemma theorem_preservation(t: tm)\n  requires has_type(Context(Empty), t).Some?\n  requires step(t).Some?\n  ensures has_type(Context(Empty), step(t).get) == has_type(Context(Empty), t)\n{\n  if (t.tapp? && step(t.f).None? && step(t.arg).None?) {\n    lemma_substitution_preserves_typing(Context(Empty), t.f.x, t.arg, t.f.body);\n  }\n}\n\n// --- END excerpt from Stlc.dfy ---\n\nghost function halts(t: tm): bool\n{\n  exists t', n:nat :: reduces_to(t, t', n) && value(t')\n}\n\nlemma lemma_value_halts(v: tm)\n  requires value(v)\n  ensures halts(v)\n{\n  assert reduces_to(v, v, 0);\n}\n\nghost function R(T: ty, t: tm): bool\n{\n match T\n /* bool */  case TBool =>\n   has_type(Context(Empty), t) == Some(TBool) &&\n   halts(t)\n /* arrow */ case TArrow(T1, T2) =>\n   has_type(Context(Empty), t) == Some(TArrow(T1, T2)) &&\n   halts(t) &&\n   (forall s :: R(T1, s) ==> R(T2, tapp(t, s)))\n}\n\nlemma lemma_R_halts(T: ty, t: tm)\n  requires R(T, t)\n  ensures halts(t)\n{\n}\n\nlemma lemma_R_typable_empty(T: ty, t: tm)\n  requires R(T, t)\n  ensures has_type(Context(Empty), t) == Some(T)\n{\n}\n\n// Membership in R_T is invariant under evaluation\n\nlemma lemma_step_preserves_halting(t: tm, t': tm)\n  requires step(t) == Some(t')\n  ensures halts(t) <==> halts(t')\n{\n  if (halts(t)) {\n    forall (t'', n:nat | reduces_to(t, t'', n) && value(t''))\n      ensures reduces_to(t', t'', n-1) && value(t'')\n    {\n    }\n  }\n  if (!halts(t)) {\n    forall (t'', n:nat | !reduces_to(t, t'', n+1) || !value(t''))\n      ensures !reduces_to(t', t'', n) || !value(t'')\n    {\n    }\n  }\n}\n\nlemma lemma_step_preserves_R(T: ty, t: tm, t': tm)\n  requires step(t) == Some(t')\n  requires R(T, t)\n  ensures R(T, t')\n{\n  theorem_preservation(t);\n  lemma_step_preserves_halting(t, t');\n  if (T.TArrow?) {\n    var T1 := T.paramT;\n    var T2 := T.bodyT;\n    assert R(TArrow(T1, T2), t);\n    forall (s | R(T1, s))\n      ensures R(T2, tapp(t', s))\n    {\n      assert R(T2, tapp(t, s));\n      lemma_step_preserves_R(T2, tapp(t, s), tapp(t', s));\n    }\n  }\n}\n\nlemma lemma_multistep_preserves_R(T: ty, t: tm, t': tm, n: nat)\n  requires reduces_to(t, t', n)\n  requires R(T, t)\n  ensures R(T, t')\n  decreases n\n{\n  if (t != t' && n > 0) {\n    lemma_step_preserves_R(T, t, step(t).get);\n    lemma_multistep_preserves_R(T, step(t).get, t', n-1);\n  }\n}\n\nlemma lemma_step_preserves_R'(T: ty, t: tm, t': tm)\n  requires has_type(Context(Empty), t) == Some(T)\n  requires step(t) == Some(t')\n  requires R(T, t')\n  ensures R(T, t)\n{\n  lemma_step_preserves_halting(t, t');\n  if (T.TArrow?) {\n    var T1 := T.paramT;\n    var T2 := T.bodyT;\n    assert R(TArrow(T1, T2), t');\n    forall (s | R(T1, s))\n      ensures R(T2, tapp(t, s))\n    {\n      assert R(T2, tapp(t', s));\n      lemma_R_typable_empty(T1, s);\n      lemma_step_preserves_R'(T2, tapp(t, s), tapp(t', s));\n    }\n  }\n}\n\nlemma lemma_multistep_preserves_R'(T: ty, t: tm, t': tm, n: nat)\n  requires has_type(Context(Empty), t) == Some(T)\n  requires reduces_to(t, t', n)\n  requires R(T, t')\n  ensures R(T, t)\n  decreases n\n{\n  if (t != t' && n > 0) {\n    theorem_preservation(t);\n    lemma_multistep_preserves_R'(T, step(t).get, t', n-1);\n    lemma_step_preserves_R'(T, t, step(t).get);\n  }\n}\n\n\n// Closed instances of terms of type T belongs to R_T\n\n\n// Multisubstitutions, multi-extensions, and instantiations\n\nfunction msubst(e: partial_map<tm>, t: tm): tm\n{\n  match e\n  case Empty => t\n  case Extend(x, v, e') => msubst(e', subst(x, v, t))\n}\n\nfunction mextend<X>(init: partial_map<X>, c: partial_map<X>): partial_map<X>\n{\n  match c\n  case Empty => init\n  case Extend(x, v, c') => Extend(x, v, mextend(init, c'))\n}\n\nfunction lookup<X>(n: nat, nxs: partial_map<X>): option<X>\n{\n  find(nxs, n)\n}\n\nfunction drop<X>(n: nat, nxs: partial_map<X>): partial_map<X>\n{\n  match nxs\n  case Empty => Empty\n  case Extend(n', x, nxs') =>\n    if (n'==n) then drop(n, nxs') else Extend(n', x, drop(n, nxs'))\n}\n\nghost function instantiation(c: partial_map<ty>, e: partial_map<tm>): bool\n{\n  match c\n  case Empty => e.Empty?\n  case Extend(x, T, c') =>\n    match e\n    case Empty => false\n    case Extend(xe, v, e') =>\n      xe==x && value(v) && R(T, v) && instantiation(c', e')\n}\n\n// More substitution facts\n\nlemma lemma_vacuous_substitution(t: tm, x: nat)\n  requires !appears_free_in(x, t)\n  ensures forall t' :: subst(x, t', t) == t\n{\n}\n\nlemma lemma_subst_closed(t: tm)\n  requires closed(t)\n  ensures forall x:nat, t' :: subst(x, t', t) == t\n{\n  forall (x:nat)\n    ensures forall t' :: subst(x, t', t) == t\n  {\n    lemma_vacuous_substitution(t, x);\n  }\n}\n\nlemma lemma_subst_not_afi(t: tm, x: nat, v: tm)\n  requires closed(v)\n  ensures !appears_free_in(x, subst(x, v, t))\n{\n}\n\nlemma lemma_duplicate_subst(t': tm, x: nat, t: tm, v: tm)\n  requires closed(v)\n  ensures subst(x, t, subst(x, v, t')) == subst(x, v, t')\n{\n  lemma_subst_not_afi(t', x, v);\n  lemma_vacuous_substitution(subst(x, v, t'), x);\n}\n\nlemma lemma_swap_subst(t: tm, x: nat, x1: nat, v: tm, v1: tm)\n  requires x != x1\n  requires closed(v)\n  requires closed(v1)\n  ensures subst(x1, v1, subst(x, v, t)) == subst(x, v, subst(x1, v1, t))\n{\n  if (t.tvar?) {\n    if (t.id==x) {\n      lemma_subst_closed(v);\n    }\n    if (t.id==x1) {\n      lemma_subst_closed(v1);\n    }\n  }\n}\n\n// Properties of multi-substitutions\n\nlemma lemma_msubst_closed_any(t: tm, e: partial_map<tm>)\n  requires closed(t)\n  ensures msubst(e, t) == t\n{\n  match e {\n  case Empty =>\n  case Extend(x, v, e') =>\n    lemma_subst_closed(t);\n    lemma_msubst_closed_any(t, e');\n  }\n}\n\nlemma lemma_msubst_closed(t: tm)\n  requires closed(t)\n  ensures forall e :: msubst(e, t) == t\n{\n  forall (e: partial_map<tm>)\n    ensures msubst(e, t) == t\n  {\n    lemma_msubst_closed_any(t, e);\n  }\n}\n\nghost function closed_env(e: partial_map<tm>): bool\n{\n  match e\n  case Empty => true\n  case Extend(x, t, e') => closed(t) && closed_env(e')\n}\n\nlemma lemma_subst_msubst(e: partial_map<tm>, x: nat, v: tm, t: tm)\n  requires closed(v)\n  requires closed_env(e)\n  ensures msubst(e, subst(x, v, t)) == subst(x, v, msubst(drop(x, e), t))\n{\n  match e {\n  case Empty =>\n  case Extend(x', v', e') =>\n    if (x==x') {\n      lemma_duplicate_subst(t, x, v', v);\n    }\n    else {\n      lemma_swap_subst(t, x, x', v, v');\n    }\n  }\n}\n\nlemma lemma_msubst_var(e: partial_map<tm>, x: nat)\n  requires closed_env(e)\n  ensures lookup(x, e).None? ==> msubst(e, tvar(x)) == tvar(x)\n  ensures lookup(x, e).Some? ==> msubst(e, tvar(x)) == lookup(x, e).get\n{\n  match e {\n  case Empty =>\n  case Extend(x', t, e) =>\n    if (x'==x) {\n      lemma_msubst_closed(t);\n    }\n  }\n}\n\nlemma lemma_msubst_abs(e: partial_map<tm>, x: nat, T: ty, t: tm)\n  ensures msubst(e, tabs(x, T, t)) == tabs(x, T, msubst(drop(x, e), t))\n{\n  match e {\n  case Empty =>\n  case Extend(x', t', e') =>\n  }\n}\n\nlemma lemma_msubst_app(e: partial_map<tm>, t1: tm, t2: tm)\n  ensures msubst(e, tapp(t1, t2)) == tapp(msubst(e, t1), msubst(e, t2))\n{\n  match e {\n  case Empty =>\n  case Extend(x, t, e') =>\n  }\n}\n\nlemma lemma_msubst_true(e: partial_map<tm>)\n  ensures msubst(e, ttrue) == ttrue\n{\n  match e {\n  case Empty =>\n  case Extend(x, t, e') =>\n  }\n}\n\nlemma lemma_msubst_false(e: partial_map<tm>)\n  ensures msubst(e, tfalse) == tfalse\n{\n  match e {\n  case Empty =>\n  case Extend(x, t, e') =>\n  }\n}\n\nlemma lemma_msubst_if(e: partial_map<tm>, c: tm, a: tm, b: tm)\n  ensures msubst(e, tif(c, a, b)) == tif(msubst(e, c), msubst(e, a), msubst(e, b))\n{\n  match e {\n  case Empty =>\n  case Extend(x, t, e') =>\n  }\n}\n\n// Properties of multi-extensions\n\nlemma lemma_mextend(c: partial_map<ty>)\n  ensures mextend(Empty, c) == c\n{\n}\n\nlemma lemma_mextend_lookup(c: partial_map<ty>, x: nat)\n  ensures lookup(x, c) == lookup(x, mextend(Empty, c))\n{\n}\n\nlemma lemma_mextend_drop(c: partial_map<ty>, init: partial_map<ty>, x: nat, x': nat)\n  ensures lookup(x', mextend(init, drop(x, c))) == if x==x' then lookup(x', init) else lookup(x', mextend(init, c))\n{\n}\n\n// Properties of Instantiations\n\nlemma lemma_instantiation_domains_match_any(c: partial_map<ty>, e: partial_map<tm>, x: nat)\n  requires instantiation(c, e)\n  requires lookup(x, c).Some?\n  ensures lookup(x, e).Some?\n{\n  match c {\n  case Empty =>\n  case Extend(x', T, c') =>\n    match e {\n    case Empty =>\n    case Extend(xe, t, e') =>\n      assert x'==xe;\n      if (x!=x') {\n        lemma_instantiation_domains_match_any(c', e', x);\n      }\n    }\n  }\n}\n\nlemma lemma_instantiation_domains_match(c: partial_map<ty>, e: partial_map<tm>)\n  requires instantiation(c, e)\n  ensures forall x:nat :: lookup(x, c).Some? ==> lookup(x, e).Some?\n{\n  forall (x:nat | lookup(x, c).Some?)\n    ensures lookup(x, e).Some?\n  {\n    lemma_instantiation_domains_match_any(c, e, x);\n  }\n}\n\nlemma lemma_instantiation_env_closed(c: partial_map<ty>, e: partial_map<tm>)\n  requires instantiation(c, e)\n  ensures closed_env(e)\n{\n  match e {\n  case Empty =>\n  case Extend(x, t, e') =>\n    match c {\n    case Empty =>\n    case Extend(x', T, c') =>\n      assert x==x';\n      lemma_R_typable_empty(T, t);\n      corollary_typable_empty__closed(t);\n      lemma_instantiation_env_closed(c', e');\n    }\n  }\n}\n\nlemma lemma_instantiation_R(c: partial_map<ty>, e: partial_map<tm>, x: nat, t: tm, T: ty)\n  requires instantiation(c, e)\n  requires lookup(x, c) == Some(T)\n  requires lookup(x, e) == Some(t)\n  ensures R(T, t)\n{\n  match e {\n  case Empty =>\n  case Extend(x', t', e') =>\n    match c {\n    case Empty =>\n    case Extend(x'', T', c') =>\n      assert x'==x'';\n      if (x==x') {\n      }\n      else {\n        lemma_instantiation_R(c', e', x, t, T);\n      }\n    }\n  }\n}\n\nlemma lemma_instantiation_drop_any(c: partial_map<ty>, e: partial_map<tm>, x: nat)\n  requires instantiation(c, e)\n  ensures instantiation(drop(x, c), drop(x, e))\n{\n  match e {\n  case Empty =>\n    assert drop(x, e) == e;\n    match c {\n    case Empty =>\n      assert drop(x, c) == c;\n    case Extend(x'', T', c') =>\n    }\n  case Extend(x', t', e') =>\n    match c {\n    case Empty =>\n    case Extend(x'', T', c') =>\n      assert x'==x'';\n      lemma_instantiation_drop_any(c', e', x);\n    }\n  }\n}\n\nlemma lemma_instantiation_drop(c: partial_map<ty>, e: partial_map<tm>)\n  requires instantiation(c, e)\n  ensures forall x:nat :: instantiation(drop(x, c), drop(x, e))\n{\n  forall (x:nat)\n    ensures instantiation(drop(x, c), drop(x, e))\n  {\n    lemma_instantiation_drop_any(c, e, x);\n  }\n}\n\n// Congruence lemmas on multistep\nlemma lemma_multistep_App2(v: tm, t: tm, t': tm, n: nat)\n  requires value(v)\n  requires reduces_to(t, t', n)\n  ensures reduces_to(tapp(v, t), tapp(v, t'), n)\n  decreases n\n{\n  if (t != t') {\n    lemma_multistep_App2(v, step(t).get, t', n-1);\n  }\n}\n\n\n// The R Lemma\n\n\nlemma lemma_msubst_preserves_typing_any(c: partial_map<ty>, e: partial_map<tm>, init: partial_map<ty>, t: tm, S: ty)\n  requires instantiation(c, e)\n  requires has_type(Context(mextend(init, c)), t) == Some(S)\n  ensures has_type(Context(init), msubst(e, t)) == Some(S)\n{\n  match c {\n  case Empty =>\n  case Extend(x, T, c') =>\n    match e {\n    case Empty =>\n    case Extend(xe, v, e') =>\n      lemma_R_typable_empty(T, v);\n      lemma_substitution_preserves_typing(Context(mextend(init, c')), x, v, t);\n      lemma_msubst_preserves_typing_any(c', e', init, subst(x, v, t), S);\n    }\n  }\n}\n\nlemma lemma_msubst_preserves_typing(c: partial_map<ty>, e: partial_map<tm>)\n  requires instantiation(c, e)\n  ensures forall init, t, S ::\n    has_type(Context(mextend(init, c)), t) == Some(S) ==>\n    has_type(Context(init), msubst(e, t)) == Some(S)\n{\n  forall (init, t, S | has_type(Context(mextend(init, c)), t) == Some(S))\n    ensures has_type(Context(init), msubst(e, t)) == Some(S)\n  {\n    lemma_msubst_preserves_typing_any(c, e, init, t, S);\n  }\n}\n\n// more helpers for R lemma\n\nlemma lemma_reduces_to_value_if(T: ty, c: tm, a: tm, b: tm, c': tm, a': tm, b': tm, nc: nat, na: nat, nb: nat)\n  requires has_type(Context(Empty), c) == Some(TBool)\n  requires has_type(Context(Empty), a) == Some(T)\n  requires has_type(Context(Empty), b) == Some(T)\n  requires reduces_to(c, c', nc) && value(c')\n  requires reduces_to(a, a', na) && value(a')\n  requires reduces_to(b, b', nb) && value(b')\n  ensures c' == ttrue ==> reduces_to(tif(c, a, b), a', nc+na+1)\n  ensures c' == tfalse ==> reduces_to(tif(c, a, b), b', nc+nb+1)\n  ensures c' == ttrue || c' == tfalse\n  ensures has_type(Context(Empty), tif(c, a, b)) == Some(T)\n  decreases nc+na+nb\n{\n  if (c != c') {\n    theorem_preservation(c);\n    lemma_reduces_to_value_if(T, step(c).get, a, b, c', a', b', nc-1, na, nb);\n  } else {\n    if (c' == ttrue) {\n      if (a != a') {\n        theorem_preservation(a);\n        lemma_reduces_to_value_if(T, c, step(a).get, b, c', a', b', nc, na-1, nb);\n      }\n    }\n    if (c' == tfalse) {\n      if (b != b') {\n        theorem_preservation(b);\n        lemma_reduces_to_value_if(T, c, a, step(b).get, c', a', b', nc, na, nb-1);\n      }\n    }\n  }\n}\n\nlemma lemma_R_if(T: ty, c: tm, a: tm, b: tm)\n  requires R(TBool, c)\n  requires R(T, a)\n  requires R(T, b)\n  requires has_type(Context(Empty), tif(c, a, b)) == Some(T)\n  ensures R(T, tif(c, a, b))\n{\n  assert R(TBool, c);\n  assert R(T, a);\n  assert R(T, b);\n  assert exists c', nc:nat :: reduces_to(c, c', nc) && value(c');\n  assert exists a', na:nat :: reduces_to(a, a', na) && value(a');\n  assert exists b', nb:nat :: reduces_to(b, b', nb) && value(b');\n  forall (c', a', b', nc:nat, na:nat, nb:nat |\n            reduces_to(c, c', nc) && value(c') &&\n            reduces_to(a, a', na) && value(a') &&\n            reduces_to(b, b', nb) && value(b'))\n  ensures R(T, tif(c, a, b))\n  {\n    lemma_reduces_to_value_if(has_type(Context(Empty), a).get, c, a, b, c', a', b', nc, na, nb);\n    if (c' == ttrue) {\n      lemma_multistep_preserves_R(T, a, a', na);\n      lemma_multistep_preserves_R'(T, tif(c, a, b), a', nc+na+1);\n    }\n    if (c' == tfalse) {\n      lemma_multistep_preserves_R(T, b, b', nb);\n      lemma_multistep_preserves_R'(T, tif(c, a, b), b', nc+nb+1);\n    }\n  }\n}\n\n// the R lemma, finally...\n\nlemma lemma_msubst_R(c: partial_map<ty>, e: partial_map<tm>, t: tm, T: ty)\n  requires has_type(Context(c), t) == Some(T)\n  requires instantiation(c, e)\n  ensures R(T, msubst(e, t))\n  decreases t\n{\n  lemma_instantiation_env_closed(c, e);\n  match t {\n  case tvar(id) =>\n    lemma_instantiation_domains_match(c, e);\n    lemma_msubst_var(e, id);\n    lemma_instantiation_R(c, e, id, lookup(id, e).get, T);\n  case tabs(x, T1, body) =>\n    lemma_mextend(c);\n    lemma_msubst_preserves_typing_any(c, e, Empty, tabs(x, T1, body), T);\n    lemma_msubst_abs(e, x, T1, body);\n    assert has_type(Context(Empty), tabs(x, T1, msubst(drop(x, e), body))) == Some(T);\n    assert has_type(Context(Empty), msubst(e, t)) == Some(T);\n\n    assert reduces_to(msubst(e, t), msubst(e, t), 0);\n    assert value(msubst(e, t));\n    assert halts(msubst(e, t));\n\n    forall (s | R(T1, s))\n      ensures R(T.bodyT, tapp(msubst(e, t), s))\n    {\n      forall (s', n:nat | reduces_to(s, s', n) && value(s'))\n        ensures R(T.bodyT, tapp(msubst(e, t), s))\n      {\n        lemma_multistep_preserves_R(T1, s, s', n);\n        lemma_R_typable_empty(T1, s');\n        assert has_type(Context(Empty), tapp(msubst(e, t), s')) == Some(T.bodyT);\n\n        corollary_typable_empty__closed(s');\n        lemma_msubst_preserves_typing_any(c, e, Empty, tabs(x, T1, body), T);\n        lemma_subst_msubst(e, x, s', body);\n        lemma_msubst_R(Extend(x, T1, c), Extend(x, s', e), body, T.bodyT);\n        lemma_step_preserves_R'(T.bodyT, tapp(msubst(e, t), s'), msubst(Extend(x, s', e), body));\n        assert R(T.bodyT, tapp(msubst(e, t), s'));\n        lemma_multistep_App2(msubst(e, t), s, s', n);\n        lemma_multistep_preserves_R'(T.bodyT, tapp(msubst(e, t), s), tapp(msubst(e, t), s'), n);\n      }\n      assert forall s', n:nat :: reduces_to(s, s', n) && value(s') ==> R(T.bodyT, tapp(msubst(e, t), s));\n      lemma_R_halts(T1, s);\n      assert exists s', n:nat :: reduces_to(s, s', n) && value(s');\n      assert R(T.bodyT, tapp(msubst(e, t), s));\n    }\n  case tapp(f, arg) =>\n    lemma_msubst_R(c, e, f, has_type(Context(c), f).get);\n    lemma_msubst_R(c, e, arg, has_type(Context(c), arg).get);\n    lemma_msubst_app(e, f, arg);\n  case ttrue =>\n    lemma_msubst_true(e);\n    assert reduces_to(ttrue, ttrue, 0);\n  case tfalse =>\n    lemma_msubst_false(e);\n    assert reduces_to(tfalse, tfalse, 0);\n  case tif(cond, a, b) =>\n    lemma_msubst_R(c, e, cond, TBool);\n    lemma_msubst_R(c, e, a, T);\n    lemma_msubst_R(c, e, b, T);\n    lemma_msubst_if(e, cond, a, b);\n    lemma_mextend(c);\n    lemma_msubst_preserves_typing_any(c, e, Empty, t, T);\n    lemma_R_if(T, msubst(e, cond), msubst(e, a), msubst(e, b));\n  }\n}\n\n// Normalization Theorem\nlemma theorem_normalization(t: tm)\n  requires has_type(Context(Empty), t).Some?\n  ensures halts(t)\n{\n  var T := has_type(Context(Empty), t).get;\n  lemma_msubst_R(Empty, Empty, t, T);\n  lemma_R_halts(T, t);\n}"}
{"file": "../dafny-sandbox/Imp.dfy", "dafny": "// http://www.cis.upenn.edu/~bcpierce/sf/Imp.html\n\n// Arithmetic and Boolean Expressions\n\n// Syntax\ndatatype aexp = ANum(int) | APlus(aexp, aexp) | AMinus(aexp, aexp) | AMult(aexp, aexp)\n\ndatatype bexp = BTrue | BFalse | BEq(aexp, aexp) | BLe(aexp, aexp) | BNot(bexp) | BAnd(bexp, bexp)\n\n// Evaluation\nfunction aeval(e: aexp): int\n{\n  match e\n  case ANum(n) => n\n  case APlus(a1, a2) => aeval(a1) + aeval(a2)\n  case AMinus(a1, a2) => aeval(a1) - aeval(a2)\n  case AMult(a1, a2) => aeval(a1) * aeval(a2)\n}\n\nfunction beval(e: bexp): bool\n{\n  match e\n  case BTrue => true\n  case BFalse => false\n  case BEq(a1, a2) => aeval(a1) == aeval(a2)\n  case BLe(a1, a2) => aeval(a1) < aeval(a2)\n  case BNot(b1) => !beval(b1)\n  case BAnd(b1, b2) => beval(b1) && beval(b2)\n}\n\n// Optimization\nfunction optimize_0plus(e: aexp): aexp\n  ensures aeval(optimize_0plus(e)) == aeval(e)\n{\n  match e\n  case ANum(n) => ANum(n)\n  case APlus(e1, e2) =>\n    if (e1 == ANum(0)) then optimize_0plus(e2)\n    else APlus(optimize_0plus(e1), optimize_0plus(e2))\n  case AMinus(e1, e2) => AMinus(optimize_0plus(e1), optimize_0plus(e2))\n  case AMult(e1, e2) => AMult(optimize_0plus(e1), optimize_0plus(e2))\n}"}
{"file": "../bench-dafny/eval0.dfy", "dafny": "// In Dafny, write an AST for expressions that are either numbers, variables or binary additions. Using pattern matching, write an evaluation function that takes an environment as a function.\n\n// Define the abstract syntax tree for arithmetic expressions\ndatatype Expr = Const(val: int)\n             | Var(name: string)\n             | Add(e1: Expr, e2: Expr)\n\n// Define the semantics function\nfunction eval(e: Expr, env: (string -> int)): int\n{\n match e\n {\n   case Const(val) => val\n   case Var(name) => env(name)\n   case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n }\n}"}
{"file": "../bench-dafny/factorial.dfy", "dafny": "// Write the factorial function in Dafny.\nfunction factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n-1)\n}"}
{"file": "../bench-dafny/eval_opt.dfy", "dafny": "// In Dafny, write an AST for expressions that are either numbers, variables or binary additions. Using pattern matching, write an evaluation function that takes an environment as a function. Write an optimizer that removes addition by 0. Prove that the optimizer preserves the semantics.\n\n// Define the abstract syntax tree for arithmetic expressions\ndatatype Expr = Num(val: int)\n             | Var(name: string)\n             | Add(e1: Expr, e2: Expr)\n\n// Define the semantics function\nfunction eval(e: Expr, env: (string -> int)): int\n{\n match e\n {\n   case Num(val) => val\n   case Var(name) => env(name)\n   case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n }\n}\n\n// Define the optimizer\nfunction optimize(e: Expr): Expr\n{\n    match e\n    {\n        case Num(n) => Num(n)\n        case Var(x) => Var(x)\n        case Add(e1, e2) =>\n            var optE1 := optimize(e1);\n            var optE2 := optimize(e2);\n            match (optE1, optE2)\n            {\n                case (Num(0), _) => optE2\n                case (_, Num(0)) => optE1\n                case _ => Add(optE1, optE2)\n            }\n    }\n}\n\n// Prove that the optimizer preserves the semantics\nlemma OptimizePreservesSemantics(e: Expr, env: (string -> int))\n ensures eval(optimize(e), env) == eval(e, env)\n{\n    match e\n    {\n        case Add(e1, e2) =>\n            OptimizePreservesSemantics(e1, env);\n            OptimizePreservesSemantics(e2, env);\n        case _ =>\n    }\n}"}
{"file": "../bench-dafny/factorial_proof.dfy", "dafny": "// Write the factorial function in Dafny and prove that the factorial is positive.\n\nfunction factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n-1)\n}\n\nlemma FactorialIsPositive(n: nat)\n    ensures factorial(n) >= 1\n{}"}
{"file": "../libraries/examples/MathExamples.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"../src/dafny/Math.dfy\"\ninclude \"../src/dafny/Relations.dfy\"\n\nimport Dafny.Math\nimport Dafny.Relations\n\nmethod m() {\n  assert Math.Max(-2, -3) == -2;\n  assert Math.Min(-2, -3) == -3;\n  assert Math.Abs(07) == Math.Abs(7) == 7;\n  assert Relations.Associative(Math.Min);\n  assert Relations.Commutative(Math.Max);\n}\n\nlemma MinAssociates(a: int, b: int, c: int)\n  ensures Math.Min3(a,b,c) == Math.Min3(c,b,a)\n{}\n\nlemma MaxAssociates(a: int, b: int, c: int)\n  ensures Math.Max3(a,b,c) == Math.Max3(c,b,a)\n{}\n"}
{"file": "../libraries/examples/RelationsExamples.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../src/dafny/Relations.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} RelationsExamples {\n\n  import opened Dafny.Relations\n\n  lemma BuiltInIntLTIsStrictTotalOrdering()\n    ensures StrictTotalOrdering((x: int, y: int) => x < y)\n  {}\n\n  lemma BuiltInIntLEIsTotalOrdering()\n    ensures TotalOrdering((x: int, y: int) => x <= y)\n  {}\n\n  function Modulo(n: nat): (R: (int, int) -> bool)\n    requires n >= 1\n    ensures EquivalenceRelation(R)\n  {\n    (x, y) => (x % n ==  y % n)\n  }\n\n  lemma BuiltInIntEqIsEquivalenceRelation()\n    ensures EquivalenceRelation((x: int, y: int) => (x == y))\n  {}\n\n  lemma BuiltInIntGeIsAntiSymmetricRelation()\n    ensures AntiSymmetric((x: int, y: int) => (x >= y))\n  {}\n\n  lemma BuiltInIntLtIsAsymmetricRelation()\n    ensures Asymmetric((x: int, y: int) => (x < y))\n  {\n  }\n\n  lemma AlwaysTrueIsNotAntiSymmetric()\n    ensures !AntiSymmetric((x: int, y: int) => true)\n  {\n    var f := (x: int, y: int) => true;\n    assert f(2,3) && f(3,2) && 3 != 2;\n    assert !AntiSymmetric(f);\n  }\n\n  lemma BuiltInIntLtIsNotReflexiveRelation()\n    ensures !Reflexive((x: int, y: int) => (x < y))\n  {\n    var f := (x: int, y: int) => (x < y);\n    assert !f(0,0);\n    assert !forall x: int :: f(x,x);\n    assert !Reflexive(f);\n  }\n\n  lemma BuiltInIntLtIsIrreflexiveRelation()\n    ensures Irreflexive((x: int, y: int) => (x < y))\n  {}\n\n  lemma BuiltInIntEqIsNotIrreflexiveRelation()\n    ensures !Irreflexive((x: int, y: int) => (x == y))\n  {\n    var f := (x: int, y: int) => (x == y);\n    assert f(0,0);\n    assert !Irreflexive(f);\n  }\n\n  lemma AsymmetricIsAntiSymmetric<T>(f: (T,T)->bool)\n    ensures Asymmetric(f) ==> AntiSymmetric(f)\n  {}\n\n  lemma AsymmetricIsIrreflexive<T>(f: (T,T)->bool)\n    ensures Asymmetric(f) ==> Irreflexive(f)\n  {}\n}\n"}
{"file": "../libraries/examples/BinaryOperations.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../src/dafny/BinaryOperations.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} IntegersExample {\n\n  import opened BinaryOperations\n\n  ghost function add(x: int, y: int): int {\n    x + y\n  }\n\n  ghost function minus(x: int): int {\n    -x\n  }\n\n  ghost function mult(x: int, y: int): int {\n    x * y\n  }\n\n  lemma IntegersAreAssociative()\n    ensures IsAssociative(add)\n    ensures IsAssociative(mult)\n  {}\n\n  lemma IntegersAreMonoid()\n    ensures IsMonoid(add, 0)\n    ensures IsMonoid(mult, 1)\n  {}\n\n  lemma IntegersHaveUnit()\n    ensures IsLeftUnital(add, 0)\n    ensures IsRightUnital(add, 0)\n    ensures IsUnital(add, 0)\n    ensures IsLeftUnital(mult, 1)\n    ensures IsRightUnital(mult, 1)\n    ensures IsUnital(mult, 1)\n  {}\n\n  lemma IntegersAreAbelian()\n    ensures IsCommutative(add)\n    ensures IsCommutative(mult)\n  {}\n\n  lemma IntegersAreAdditiveGroup()\n    ensures IsGroup(add, minus, 0)\n  {}\n\n  lemma IntegersAreAdditiveAbelianGroup()\n    ensures IsAbelianGroup(add, minus, 0)\n  {}\n\n  lemma IntegersHaveAdditiveInverse()\n    ensures IsInverse(add, minus, 0)\n  {}\n\n  lemma IntegersAreDistributive()\n    ensures IsLeftDistributive(add, mult)\n    ensures IsRightDistributive(add, mult)\n    ensures IsDistributive(add, mult)\n  {}\n\n  lemma IntegersAreRing()\n    ensures IsRing(add, minus, 0, mult, 1)\n  {}\n\n}\n\nmodule {:options \"-functionSyntax:4\"} RealsExample {\n\n  import opened BinaryOperations\n\n  ghost function add(x: real, y: real): real {\n    x + y\n  }\n\n  ghost function minus(x: real): real {\n    -x\n  }\n\n  ghost function mult(x: real, y: real): real {\n    x * y\n  }\n\n  ghost function div(x: real): real\n    requires x != 0.0\n  {\n    1.0 / x\n  }\n\n  lemma RealsAreAssociative()\n    ensures IsAssociative(add)\n    ensures IsAssociative(mult)\n  {}\n\n  lemma RealsAreMonoid()\n    ensures IsMonoid(add, 0.0)\n    ensures IsMonoid(mult, 1.0)\n  {}\n\n  lemma RealsHaveUnit()\n    ensures IsLeftUnital(add, 0.0)\n    ensures IsRightUnital(add, 0.0)\n    ensures IsUnital(add, 0.0)\n    ensures IsLeftUnital(mult, 1.0)\n    ensures IsRightUnital(mult, 1.0)\n    ensures IsUnital(mult, 1.0)\n  {}\n\n  lemma RealsAreAbelian()\n    ensures IsCommutative(add)\n    ensures IsCommutative(mult)\n  {}\n\n  lemma RealsAreAdditiveGroup()\n    ensures IsGroup(add, minus, 0.0)\n  {}\n\n  lemma RealsAreAdditiveAbelianGroup()\n    ensures IsAbelianGroup(add, minus, 0.0)\n  {}\n\n  lemma NonZeroRealsAreMultiplicativeGroup()\n    ensures IsGroup(mult, div, 1.0)\n  {}\n\n  lemma NonZeroRealsAreMultiplicativeAbelianGroup()\n    ensures IsAbelianGroup(mult, div, 1.0)\n  {}\n\n  lemma RealsHaveAdditiveInverse()\n    ensures IsInverse(add, minus, 0.0)\n  {}\n\n  lemma RealsAreDistributive()\n    ensures IsLeftDistributive(add, mult)\n    ensures IsRightDistributive(add, mult)\n    ensures IsDistributive(add, mult)\n  {}\n\n  lemma RealsAreRing()\n    ensures IsRing(add, minus, 0.0, mult, 1.0)\n  {\n    assert IsDistributive(add, mult);\n  }\n\n  lemma RealsAreField()\n    ensures IsField(add, minus, 0.0, mult, div, 1.0)\n  {}\n\n}\n\nmodule {:options \"-functionSyntax:4\"} HomomorphismExamples {\n\n  import opened BinaryOperations\n  import IntegersExample\n  import RealsExample\n\n  lemma IdentityIsHomomorphism<T>(bop: (T, T) -> T)\n    ensures IsHomomorphism(bop, bop, x => x)\n  {}\n\n  lemma IntRealEmbeddingIsHomomorphism()\n    ensures IsHomomorphism(IntegersExample.add, RealsExample.add, (x: int) => x as real)\n  {}\n\n  lemma ConstUnitIsHomomorphism<S,T>(bop1: (S, S) -> S, bop2: (T, T) -> T, unit: T)\n    requires IsUnital(bop2, unit)\n    ensures IsHomomorphism(bop1, bop2, x => unit)\n  {}\n\n  lemma ConstMultIsHomomorphism(n: int)\n    ensures IsHomomorphism(IntegersExample.add, IntegersExample.add, x => n * x)\n  {}\n\n}\n\n"}
{"file": "../libraries/examples/FileIO/WriteBytesToFile.dfy", "dafny": "/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\n// RUN: %verify \"%s\"\n\n// RUN: %run --no-verify --unicode-char:false --target:cs \"%s\" --input \"%S/../../src/FileIO/FileIO.cs\" -- \"%t_cs\" \"System.ArgumentException:\"\n// RUN: %run --no-verify --unicode-char:false --target:java \"%s\" --input \"%S/../../src/FileIO/FileIO.java\" -- \"%t_java\" \"java.nio.file.FileSystemException:\"\n// RUN: %run --no-verify --unicode-char:false --target:js \"%s\" --input \"%S/../../src/FileIO/FileIO.js\" -- \"%t_js\" \"Error: ENOENT\"\n\n//// Check that written files match expectations\n// RUN: %diff \"%S/data.txt\" \"%t_cs/output_plain\"\n// RUN: %diff \"%S/data.txt\" \"%t_cs/foo/bar/output_nested\"\n// RUN: %diff \"%S/data.txt\" \"%t_cs/foo/output_up\"\n// RUN: %diff \"%S/data.txt\" \"%t_java/output_plain\"\n// RUN: %diff \"%S/data.txt\" \"%t_java/foo/bar/output_nested\"\n// RUN: %diff \"%S/data.txt\" \"%t_java/foo/output_up\"\n// RUN: %diff \"%S/data.txt\" \"%t_js/output_plain\"\n// RUN: %diff \"%S/data.txt\" \"%t_js/foo/bar/output_nested\"\n// RUN: %diff \"%S/data.txt\" \"%t_js/foo/output_up\"\n\ninclude \"../../src/dafny/FileIO/FileIO.dfy\"\n\nmodule WriteBytesToFile {\n  import Dafny.FileIO\n\n  method Main(args: seq<string>) {\n    expect |args| > 0;\n    expect |args| == 3, \"usage: \" + args[0] + \" OUTPUT_DIR EXPECTED_ERROR_PREFIX\";\n    var outputDir := args[1];\n    var expectedErrorPrefix := args[2];\n\n      // Happy paths: write files to the output dir. (The %diff LIT commands check that we wrote the correct content.)\n    {\n      // Ideally we would define `str` as a constant and compute `bytes` automatically.\n      // To do so, we would need to convert each `char` in `str` to a `bv8` value, by using `as bv8`.\n      // But that triggers a bug in the Java compiler: <https://github.com/dafny-lang/dafny/issues/2942>.\n      // So for now we settle for manually writing out the desired `bytes`,\n      // and statically verifying that these values match the characters of `str`.\n      ghost var str := \"Hello world\\nGoodbye\\n\";\n      var bytes: seq<bv8> := [\n        // \"Hello world\\n\"\n        0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x0a,\n        // \"Goodbye\\n\"\n        0x47, 0x6f, 0x6f, 0x64, 0x62, 0x79, 0x65, 0x0a\n      ];\n      assert forall i | 0 <= i < |bytes| :: bytes[i] as int == str[i] as int;\n\n        // Write directly into the output directory\n      {\n        var res := FileIO.WriteBytesToFile(outputDir + \"/output_plain\", bytes);\n        expect res.Success?, \"unexpected failure writing to output_plain: \" + res.error;\n      }\n      // Ensure that nonexistent parent directories are created as necessary\n      {\n        var res := FileIO.WriteBytesToFile(outputDir + \"/foo/bar/output_nested\", bytes);\n        expect res.Success?, \"unexpected failure writing to output_nested: \" + res.error;\n      }\n      // Ensure that file paths with .. are handled correctly\n      {\n        var res := FileIO.WriteBytesToFile(outputDir + \"/foo/bar/../output_up\", bytes);\n        expect res.Success?, \"unexpected failure writing to output_up: \" + res.error;\n      }\n    }\n\n      // Failure path: attempting to write to a blank file path should never work.\n    {\n      var res := FileIO.WriteBytesToFile(\"\", []);\n      expect res.Failure?, \"unexpected success\";\n      expect expectedErrorPrefix <= res.error, \"unexpected error message: \" + res.error;\n    }\n  }\n}\n"}
{"file": "../libraries/examples/FileIO/ReadBytesFromFile.dfy", "dafny": "/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\n// RUN: %verify \"%s\"\n\n// #RUN: %run --no-verify --unicode-char:false --target:cs \"%s\" --input \"%S/../../src/FileIO/FileIO.cs\" -- \"%S/data.txt\" \"System.ArgumentException:\"\n// #RUN: %run --no-verify --unicode-char:false --target:java \"%s\" --input \"%S/../../src/FileIO/FileIO.java\" -- \"%S/data.txt\" \"java.io.IOException:\"\n// #RUN: %run --no-verify --unicode-char:false --target:js \"%s\" --input \"%S/../../src/FileIO/FileIO.js\" -- \"%S/data.txt\" \"Error: ENOENT\"\n\ninclude \"../../src/dafny/FileIO/FileIO.dfy\"\n\nmodule ReadBytesFromFile {\n  import Dafny.FileIO\n\n  method Main(args: seq<string>) {\n    expect |args| > 0;\n    expect |args| == 3, \"usage: \" + args[0] + \" DATA_PATH EXPECTED_ERROR_PREFIX\";\n    var dataPath := args[1];\n    var expectedErrorPrefix := args[2];\n\n      // Happy path: read from the data file, and check that we see the expected content.\n    {\n      var expectedStr := \"Hello world\\nGoodbye\\n\";\n      // This conversion is safe only for ASCII values. For Unicode conversions, see the Unicode modules.\n      var expectedBytes := seq(|expectedStr|, i requires 0 <= i < |expectedStr| => expectedStr[i] as int);\n\n      var res := FileIO.ReadBytesFromFile(dataPath);\n      expect res.Success?, \"unexpected failure: \" + res.error;\n\n      var readBytes := seq(|res.value|, i requires 0 <= i < |res.value| => res.value[i] as int);\n      expect readBytes == expectedBytes, \"read unexpected byte sequence\";\n    }\n\n      // Failure path: attempting to read from a blank file path should never work.\n    {\n      var res := FileIO.ReadBytesFromFile(\"\");\n      expect res.Failure?, \"unexpected success\";\n      expect expectedErrorPrefix <= res.error, \"unexpected error message: \" + res.error;\n    }\n  }\n}\n"}
{"file": "../libraries/examples/LittleEndianNat/LittleEndianNatExample.dfy", "dafny": "// RUN: %run --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../src/Collections/Sequences/LittleEndianNatConversions.dfy\"\n\nmodule LittleEndianNatExample {\n\n  import opened Uint8_32\n\n  method Main() {\n    var n := 49602234234;\n\n    // Convert n to uint8 and uint32 sequences\n    var smallSeq, largeSeq := Small.FromNat(n), Large.FromNat(n);\n    expect smallSeq == [122, 7, 134, 140, 11];\n    expect largeSeq == [2357593978, 11];\n\n    Small.LemmaNatSeqNat(n);\n    Large.LemmaNatSeqNat(n);\n    assert Small.ToNatRight(smallSeq) == Large.ToNatRight(largeSeq) == n;\n\n    // Extend smallSeq\n    smallSeq := Small.SeqExtendMultiple(smallSeq, E());\n    assert Small.ToNatRight(smallSeq) == n;\n\n    // Convert between smallSeqExtended and largeSeq\n    LemmaToSmall(largeSeq);\n    LemmaToLarge(smallSeq);\n    assert Small.ToNatRight(ToSmall(largeSeq)) == n;\n    assert Large.ToNatRight(ToLarge(smallSeq)) == n;\n    assert |ToSmall(largeSeq)|  == |largeSeq| * E();\n    assert |ToLarge(smallSeq)|  == |smallSeq| / E();\n\n    LemmaSmallLargeSmall(smallSeq);\n    LemmaLargeSmallLarge(largeSeq);\n    assert ToSmall(ToLarge(smallSeq)) == smallSeq;\n    assert ToLarge(ToSmall(largeSeq)) == largeSeq;\n  }\n\n}\n"}
{"file": "../libraries/examples/LittleEndianNat/LittleEndianNatCustomExample.dfy", "dafny": "// RUN: %run --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../src/Collections/Sequences/LittleEndianNatConversions.dfy\"\n\nmodule {:options \"--function-syntax:4\"} Uint3_6 refines LittleEndianNatConversions {\n\n  module Uint3Seq refines SmallSeq {\n    function BITS(): nat { 3 }\n  }\n  module Uint6Seq refines LargeSeq {\n    import Small = Uint3Seq\n    function BITS(): nat { 6 }\n  }\n  import opened Large = Uint6Seq\n  import Small = Large.Small\n\n}\n\nmodule {:options \"--function-syntax:4\"} LittleEndianNatCustomExample {\n\n  import opened Uint3_6\n\n  method Main() {\n    var n := 165;\n\n    // Convert n to uint3 and uint6 sequences\n    var smallSeq, largeSeq := Small.FromNat(n), Large.FromNat(n);\n    expect smallSeq == [5, 4, 2];\n    expect largeSeq == [37, 2];\n\n    Small.LemmaNatSeqNat(n);\n    Large.LemmaNatSeqNat(n);\n    assert Small.ToNatRight(smallSeq) == Large.ToNatRight(largeSeq) == n;\n  }\n\n}\n"}
{"file": "../libraries/examples/WrappersExamples.dfy", "dafny": "// RUN: %run \"%s\" > \"%t\"\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK-L: Hello\n// CHECK-NEXT-L: Error: 'name' was not found\n// CHECK-NEXT-L: Hello\n// CHECK-NEXT-L: Dafny\n// CHECK-NEXT-L: Test dummy file\n\ninclude \"../src/dafny/Wrappers.dfy\"\n\nmodule {:options \"--function-syntax:4\"} Demo {\n  import opened Dafny.Wrappers\n\n  // ------ Demo for Option ----------------------------\n  // We use Option when we don't need to pass around a reason for the failure,\n  // ie when just 'None' is sufficient:\n\n  class MyMap<K(==), V> {\n    var m: map<K, V>\n    constructor () {\n      m := map[];\n    }\n    function Get(k: K): Option<V>\n      reads this\n    {\n      if k in m then Some(m[k]) else None()\n    }\n    method Put(k: K, v: V)\n      modifies this\n    {\n      this.m := this.m[k := v];\n    }\n  }\n\n  method TestMyMap() {\n    var m := new MyMap<string, string>();\n    m.Put(\"message\", \"Hello\");\n    Greet(m);\n\n    m.Put(\"name\", \"Dafny\");\n    Greet(m);\n  }\n\n  method Greet(m: MyMap<string, string>) {\n    var o: Option<string> := m.Get(\"message\");\n    if o.Some? {\n      print o.value, \"\\n\";\n    } else {\n      print \"oops\\n\";\n    }\n\n    var r: Result<string, string> := FindName(m);\n    if r.Success? {\n      print r.value, \"\\n\";\n    } else {\n      print \"Error: \", r.error, \"\\n\";\n    }\n  }\n\n  // Sometimes we want to go from Option to Result:\n  method FindName(m: MyMap<string, string>) returns (res: Result<string, string>) {\n    // Will return a default error message in case of None:\n    res := m.Get(\"name\").ToResult(\"'name' not found\");\n    // We can also match on the option to write a custom error:\n    match m.Get(\"name\")\n    case Some(n) => res := Success(n);\n    case None => res := Failure(\"'name' was not found\");\n  }\n\n  // Propagating failures using :- statements\n  method GetGreeting(m: MyMap<string, string>) returns (res: Option<string>) {\n    var message: string :- m.Get(\"message\");\n    var nameResult := FindName(m);\n    var name :- nameResult.ToOption();\n    res := Some(message + \" \" + name);\n  }\n\n  // ------ Demo for Result ----------------------------\n  // We use Result when we want to give a reason for the failure:\n\n  class MyFilesystem {\n    var files: map<string, string>\n    constructor() {\n      files := map[];\n    }\n\n    // Result<()> is used to return a Result without any data\n    method WriteFile(path: string, contents: string) returns (res: Result<(), string>)\n      modifies this\n    {\n      if path in files {\n        files := files[path := contents];\n        res := Success(()); // `()` is the only value of type `()`\n      } else {\n        // The \"Result\" datatype allows us to give precise error messages\n        // instead of just \"None\"\n        res := Failure(\"File not found, use 'Create' before\");\n      }\n    }\n\n    method CreateFile(path: string) returns (res: Result<(), string>)\n      modifies this\n    {\n      if path in files {\n        res := Failure(\"File already exists\");\n      } else {\n        files := files[path := \"\"];\n        res := Success(());\n      }\n    }\n\n    method ReadFile(path: string) returns (res: Result<string, string>) {\n      if path in files {\n        res := Success(files[path]);\n      } else {\n        res := Failure(\"File not found\");\n      }\n    }\n  }\n\n  // Propagating failures using :- statements\n  method CopyFile(fs: MyFilesystem, fromPath: string, toPath: string) returns (res: Result<(), string>)\n    modifies fs\n  {\n    var contents :- fs.ReadFile(fromPath);\n    var _ :- fs.CreateFile(toPath);\n    var _ :- fs.WriteFile(toPath, contents);\n    res := Success(());\n  }\n\n  method TestMyFilesystem() {\n    var fs := new MyFilesystem();\n    // Note: these verbose \"outcome.Failure?\" patterns will soon\n    // not be needed any more, see https://github.com/dafny-lang/rfcs/pull/1\n    var outcome: Result<(), string> := fs.CreateFile(\"test.txt\");\n    if outcome.Failure? {\n      print outcome.error, \"\\n\";\n      return;\n    }\n    outcome := fs.WriteFile(\"test.txt\", \"Test dummy file\");\n    if outcome.Failure? {\n      print outcome.error, \"\\n\";\n      return;\n    }\n    var fileResult: Result<string, string> := fs.ReadFile(\"test.txt\");\n    if outcome.Failure? {\n      print fileResult.error, \"\\n\";\n      return;\n    }\n    if fileResult.Success? {\n      print fileResult.value, \"\\n\";\n    }\n  }\n\n  // ------ Demo for Need ----------------------------\n  // We use Need when something has to be true but we can't prove it statically\n  // This is a very contrived example\n\n  method whatIsCharacterFive(fs: MyFilesystem, fromPath: string) returns (res: Result<char, string>)\n    modifies fs\n  {\n\n    // Get a string that we can't reason about statically\n    var contents :- fs.ReadFile(fromPath);\n\n    // Dynamically test whether the string is at least 5 characters long, and return a failure if not.\n    // If we pass this line, Dafny can now assume that the string is long enough.\n    :- Need<string>(|contents| >= 5, \"File contents not long enough.\");\n\n    // Now we can get the character\n    var c := contents[4];\n\n    return Success(c);\n  }\n\n  // For a method that returns an Outcome, use Outcome.Need\n  method whatIsCharacterFive'(fs: MyFilesystem, fromPath: string) returns (res: Outcome<string>)\n    modifies fs\n  {\n\n    // Get a string that we can't reason about statically\n    var contents: string := *;\n\n    // Dynamically test whether the string is at least 5 characters long, and return a failure if not.\n    // If we pass this line, Dafny can now assume that the string is long enough.\n    :- Outcome.Need(|contents| >= 5, \"File contents not long enough.\");\n\n    // Now we can get the character\n    var c := contents[4];\n    // and do other stuff\n\n    return Pass;\n  }\n\n  method Main() {\n    TestMyMap();\n    TestMyFilesystem();\n  }\n\n}\n"}
{"file": "../libraries/examples/Unicode/Utf8EncodingFormExamples.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../../src/Unicode/Utf8EncodingForm.dfy\"\n\nmodule Utf8EncodingFormExamples {\n  import Unicode\n  import opened Utf8EncodingForm\n\n  const TEST_SCALAR_VALUES: seq<(Unicode.ScalarValue, WellFormedCodeUnitSeq)> := [\n    // One byte: dollar sign\n    (0x0024, [0x24]),\n    // Two bytes: pound sign\n    (0x00A3, [0xC2, 0xA3]),\n    // Three bytes: euro sign\n    (0x20AC, [0xE2, 0x82, 0xAC]),\n    // Four bytes: money bag emoji\n    (0x1F4B0, [0xF0, 0x9F, 0x92, 0xB0])\n  ]\n\n  lemma TestEncodeScalarValue()\n    ensures forall pair | pair in TEST_SCALAR_VALUES\n              :: EncodeScalarValue(pair.0) == pair.1\n  {}\n\n  // Examples taken from description of Table 3-7.\n  const TEST_ILL_FORMED_SEQUENCES: seq<CodeUnitSeq> := [\n    // C0 is not well-formed as a first byte\n    [0xC0, 0xAF],\n    // 9F is not well-formed as a second byte when E0 is a well-formed first byte\n    [0xE0, 0x9F, 0x80]\n  ]\n\n  lemma TestDecodeIllFormedSequence()\n    ensures forall s | s in TEST_ILL_FORMED_SEQUENCES\n              :: DecodeCodeUnitSequenceChecked(s).None?\n  {}\n\n}\n"}
{"file": "../libraries/examples/Unicode/UnicodeExamples.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../../src/Unicode/Unicode.dfy\"\n\nmodule UnicodeExamples {\n  import opened Unicode\n\n  const TEST_ASSIGNED_PLANE_CODE_POINTS: set<CodePoint> := {\n    0x000055,  // Latin capital letter U\n    0x01F11D,  // Parenthesized Latin capital letter N\n    0x02053C,  // CJK unified ideograph 𠔼\n    0x030256,  // CJK unified ideograph 𰉖\n    0x0E004F,  // Tag Latin capital letter O\n    0x0FDDDD,  // arbitrary code point in Private Use Area-A\n    0x10EEEE   // arbitrary code point in Private Use Area-B\n  }\n\n  lemma LemmaAssignedCodePoints()\n    ensures forall p | p in TEST_ASSIGNED_PLANE_CODE_POINTS :: IsInAssignedPlane(p)\n  {\n    reveal IsInAssignedPlane();\n  }\n}\n"}
{"file": "../libraries/examples/Unicode/Utf16EncodingFormExamples.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../../src/Unicode/Utf16EncodingForm.dfy\"\n\nmodule Utf16EncodingFormExamples {\n  import Unicode\n  import opened Utf16EncodingForm\n\n  const TEST_SCALAR_VALUES: seq<(Unicode.ScalarValue, WellFormedCodeUnitSeq)> := [\n    // One code unit: dollar sign\n    (0x0024, [0x0024]),\n    // Two code units: money bag emoji\n    (0x1F4B0, [0xD83D, 0xDCB0])\n  ]\n\n  lemma TestEncodeScalarValue()\n    ensures forall pair | pair in TEST_SCALAR_VALUES\n              :: EncodeScalarValue(pair.0) == pair.1\n  {}\n\n  // Because surrogate code points are not Unicode scalar values, isolated UTF-16 code units in the range\n  // D800_16 .. DFFF_16 are ill-formed. (Section 3.9 D91)\n  const TEST_ILL_FORMED_SEQUENCES: seq<CodeUnitSeq> := [\n    [0xD800],\n    [0xDABC],\n    [0xDFFF]\n  ]\n\n  lemma TestDecodeIllFormedSequence()\n    ensures forall s | s in TEST_ILL_FORMED_SEQUENCES\n              :: DecodeCodeUnitSequenceChecked(s).None?\n  {}\n}\n"}
{"file": "../libraries/examples/Collections/Arrays/BinarySearch.dfy", "dafny": "// RUN: %run \"%s\" > \"%t\"\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK-L: [-6, 0, 1, 3, 7, 7, 9]\n// CHECK-NEXT-L: 3\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../../src/Relations.dfy\"\ninclude \"../../../src/Collections/Arrays/BinarySearch.dfy\"\ninclude \"../../../src/Collections/Sequences/Seq.dfy\"\ninclude \"../../../src/Collections/Sequences/MergeSort.dfy\"\n\nmodule BinarySearchExamples {\n\n  import BinarySearch\n  import opened Seq\n  import opened Seq.MergeSort\n  import opened Relations\n\n  lemma SortedByLessThanOrEqualTo(s: seq<int>)\n    requires SortedBy(s, (x, y) => x <= y)\n    ensures SortedBy(s, (x, y) => x < y || x == y)\n  {}\n\n  method {:vcs_split_on_every_assert} SortAndSearch() {\n    var input := [1, 7, 7, 3, 9, 0, -6];\n\n    var sortedInput := MergeSortBy(input, (x, y) => x <= y);\n    print sortedInput, \"\\n\";\n\n    assert SortedBy(sortedInput, (x, y) => x <= y);\n    var sortedArray := ToArray(sortedInput);\n    SortedByLessThanOrEqualTo(sortedArray[..]);\n    var indexOfThree := BinarySearch.BinarySearch(sortedArray, 3, (x, y) => x < y);\n    if indexOfThree.Some? {\n      print indexOfThree.value, \"\\n\";\n    } else {\n      print \"Not found\\n\";\n    }\n  }\n\n  method Main() {\n    SortAndSearch();\n  }\n}\n"}
{"file": "../libraries/examples/Collections/Sets/Sets.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../../src/Collections/Sets/Sets.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} SetsExamples {\n\n  import opened Sets\n\n  method TestExtract() {\n    var s: set<int> := {0, 1};\n    var t: set<int> := {0};\n\n    var x := ExtractFromNonEmptySet(s);\n    assert x == 0 || x == 1;\n    // assert x == 0; fails due to non-determinacy\n    // assert x == 1; fails due to non-determinacy\n\n    var y := ExtractFromSingleton(t);\n    assert y == 0;\n\n    // var z := ExtractFromSingleton(s); fails as s is not a singleton\n  }\n\n}"}
{"file": "../libraries/examples/MutableMap/MutableMapTrait.dfy", "dafny": "/*******************************************************************************\n*  Copyright by the contributors to the Dafny Project\n*  SPDX-License-Identifier: MIT\n*******************************************************************************/\n\n// RUN: %verify \"%s\"\n\n/**\n  *  Specifications that should be satisfied by any implementation of mutable maps.\n  *  Possible instantiations are given in \"MutableMapDafny.dfy\" (not meant for usage, \n  *  only exists to verify feasability) and \"../../src/MutableMap/MutableMap.dfy\" \n  *  (meant for usage; interfaces with external code, e.g. \"../../src/MutableMap/\n  *  MutableMap.java\").\n  */\nmodule {:options \"-functionSyntax:4\"} MutableMapTrait {\n  trait {:termination false} MutableMapTrait<K(==),V(==)> {\n    function content(): map<K, V>\n      reads this\n\n    method Put(k: K, v: V)\n      modifies this\n      ensures this.content() == old(this.content())[k := v]   \n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values + {v}\n      ensures k !in old(this.content()).Keys ==> this.content().Values == old(this.content()).Values + {v}\n\n    function Keys(): (keys: set<K>)\n      reads this\n      ensures keys == this.content().Keys\n\n    predicate HasKey(k: K)\n      reads this\n      ensures HasKey(k) <==> k in this.content().Keys\n\n    function Values(): (values: set<V>)\n      reads this\n      ensures values == this.content().Values\n\n    function Items(): (items: set<(K,V)>)\n      reads this\n      ensures items == this.content().Items\n      ensures items == set k | k in this.content().Keys :: (k, this.content()[k])\n\n    function Select(k: K): (v: V)\n      reads this\n      requires this.HasKey(k)\n      ensures v in this.content().Values\n      ensures this.content()[k] == v\n\n    method Remove(k: K)\n      modifies this\n      ensures this.content() == old(this.content()) - {k}\n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values\n \n    function Size(): (size: int)\n      reads this\n      ensures size == |this.content().Items|\n  }\n}"}
{"file": "../libraries/examples/MutableMap/MutableMapExamples.dfy", "dafny": "/*******************************************************************************\n*  Copyright by the contributors to the Dafny Project\n*  SPDX-License-Identifier: MIT\n*******************************************************************************/\n\n// RUN: %run --target:java \"%s\" --input \"%S/../../src/MutableMap/MutableMap.java\"\n\ninclude \"../../src/MutableMap/MutableMap.dfy\"\ninclude \"../../src/Wrappers.dfy\"\n\n/**\n  *  Tests the Java interfacing implementation of mutable maps.\n  */\nmodule {:options \"-functionSyntax:4\"} MutableMapExamples {\n  import opened DafnyLibraries\n  import opened Wrappers\n\n  method AssertAndExpect(p: bool, maybeMsg: Option<string> := None) requires p {\n    match maybeMsg {\n      case None => {\n          expect p;\n      }\n      case Some(msg) => {\n          expect p, msg;\n      }\n    }\n  }\n\n  method Main() {\n    var m := new MutableMap<string,string>();\n    AssertAndExpect(m.Keys() == {});\n    AssertAndExpect(m.Values() == {});\n    AssertAndExpect(m.Items() == {});\n    AssertAndExpect(m.Size() == 0);\n\n    m.Put(\"testkey\", \"testvalue\");\n    AssertAndExpect(m.Select(\"testkey\") == \"testvalue\");\n    AssertAndExpect(m.Keys() == {\"testkey\"});\n    AssertAndExpect(m.Values() == {\"testvalue\"});\n    AssertAndExpect(m.Items() == {(\"testkey\", \"testvalue\")});\n    print m.Select(\"testkey\"), \"\\n\";\n\n    AssertAndExpect(m.Size() == 1);\n    m.Put(\"testkey\", \"testvalue2\");\n    AssertAndExpect(m.Keys() == {\"testkey\"});\n    AssertAndExpect(m.Values() == {\"testvalue2\"});\n    AssertAndExpect(m.Items() == {(\"testkey\", \"testvalue2\")});\n\n    m.Put(\"testkey2\", \"testvalue2\");\n    AssertAndExpect(m.Keys() == {\"testkey\", \"testkey2\"});\n    AssertAndExpect(m.Values() == {\"testvalue2\"});\n    AssertAndExpect(m.Items() == {(\"testkey\", \"testvalue2\"), (\"testkey2\", \"testvalue2\")});\n    AssertAndExpect(m.Size() == 2);\n    AssertAndExpect(\"testkey\" in m.Keys());\n    AssertAndExpect(\"testkey2\" in m.Keys());\n    print m.Select(\"testkey\"), \"\\n\";\n    print m.Select(\"testkey2\"), \"\\n\";\n\n    m.Remove(\"testkey\");\n    AssertAndExpect(m.SelectOpt(\"testkey\").None?);\n    AssertAndExpect(m.SelectOpt(\"testkey2\").Some? && m.SelectOpt(\"testkey2\").value == \"testvalue2\");\n    AssertAndExpect(m.Keys() == {\"testkey2\"});\n    AssertAndExpect(m.Values() == {\"testvalue2\"});\n    AssertAndExpect(m.Items() == {(\"testkey2\", \"testvalue2\")});\n  }\n}"}
{"file": "../libraries/examples/MutableMap/MutableMapDafny.dfy", "dafny": "/*******************************************************************************\n*  Copyright by the contributors to the Dafny Project\n*  SPDX-License-Identifier: MIT\n*******************************************************************************/\n\n// RUN: %verify \"%s\"\n   \n/**\n  *  Implements mutable maps in Dafny to guard against inconsistent specifications.\n  *  Only exists to verify feasability; not meant for actual usage.\n  */\nmodule {:options \"-functionSyntax:4\"} MutableMapDafny {\n  /**\n    *  NOTE: Only here because of #2500; once resolved import \"MutableMapTrait.dfy\".\n    */\n  trait {:termination false} MutableMapTrait<K(==),V(==)> {\n    function content(): map<K, V>\n      reads this\n\n    method Put(k: K, v: V)\n      modifies this\n      ensures this.content() == old(this.content())[k := v]   \n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values + {v}\n      ensures k !in old(this.content()).Keys ==> this.content().Values == old(this.content()).Values + {v}\n\n    function Keys(): (keys: set<K>)\n      reads this\n      ensures keys == this.content().Keys\n\n    predicate HasKey(k: K)\n      reads this\n      ensures HasKey(k) <==> k in this.content().Keys\n\n    function Values(): (values: set<V>)\n      reads this\n      ensures values == this.content().Values\n\n    function Items(): (items: set<(K,V)>)\n      reads this\n      ensures items == this.content().Items\n      ensures items == set k | k in this.content().Keys :: (k, this.content()[k])\n\n    function Select(k: K): (v: V)\n      reads this\n      requires this.HasKey(k)\n      ensures v in this.content().Values\n      ensures this.content()[k] == v\n\n    method Remove(k: K)\n      modifies this\n      ensures this.content() == old(this.content()) - {k}\n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values\n \n    function Size(): (size: int)\n      reads this\n      ensures size == |this.content().Items|\n  }\n\n  class MutableMapDafny<K(==),V(==)> extends MutableMapTrait<K,V> {\n    var m: map<K,V>\n\n    function content(): map<K, V> \n      reads this\n    {\n      m\n    }\n\n    constructor ()\n      ensures this.content() == map[]\n    {\n      m := map[];\n    }\n\n    method Put(k: K, v: V)\n      modifies this\n      ensures this.content() == old(this.content())[k := v]   \n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values + {v}\n      ensures k !in old(this.content()).Keys ==> this.content().Values == old(this.content()).Values + {v}\n    {\n      m := m[k := v];\n      if k in old(m).Keys {\n        forall v' | v' in old(m).Values + {v} ensures v' in m.Values + {old(m)[k]} {\n          if v' == v || v' == old(m)[k] {\n            assert m[k] == v;\n          } else {\n            assert m.Keys == old(m).Keys + {k};\n          }\n        }\n      }\n      if k !in old(m).Keys {\n        forall v' | v' in old(m).Values + {v} ensures v' in m.Values {\n          if v' == v {\n            assert m[k] == v;\n            assert m[k] == v';\n            assert v' in m.Values;\n          } else {\n            assert m.Keys == old(m).Keys + {k};\n          }\n        }\n      }\n    }\n\n    function Keys(): (keys: set<K>)\n      reads this\n      ensures keys == this.content().Keys\n    {\n      m.Keys\n    }\n\n    predicate HasKey(k: K)\n      reads this\n      ensures HasKey(k) <==> k in this.content().Keys\n    {\n      k in m.Keys\n    }\n\n    function Values(): (values: set<V>)\n      reads this\n      ensures values == this.content().Values\n    {\n      m.Values\n    }\n\n    function Items(): (items: set<(K,V)>)\n      reads this\n      ensures items == this.content().Items\n      ensures items == set k | k in this.content().Keys :: (k, this.content()[k])\n    {\n      var items := set k | k in m.Keys :: (k, m[k]);\n      assert items == m.Items by {\n        forall k | k in m.Keys ensures (k, m[k]) in m.Items {\n          assert (k, m[k]) in m.Items;\n        }\n        assert items <= m.Items;\n        forall x | x in m.Items ensures x in items {\n          assert (x.0, m[x.0]) in items;\n        }\n        assert m.Items <= items;\n      }\n      items\n    }\n\n    function Select(k: K): (v: V)\n      reads this\n      requires this.HasKey(k)\n      ensures v in this.content().Values\n      ensures this.content()[k] == v\n    {\n      m[k]\n    }\n\n    method Remove(k: K)\n      modifies this\n      ensures this.content() == old(this.content()) - {k}\n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values\n    {\n      m := map k' | k' in m.Keys && k' != k :: m[k'];\n      if k in old(m).Keys {\n        var v := old(m)[k];\n        forall v' | v' in old(m).Values ensures v' in m.Values + {v} {\n          if v' == v {\n          } else {\n            assert exists k' | k' in m.Keys :: old(m)[k'] == v';\n          }\n        }\n      }\n    }\n\n    function Size(): (size: int)\n      reads this\n      ensures size == |this.content().Items|\n    {\n      |m|\n    }\n  }\n}"}
{"file": "../libraries/examples/BoundedIntsExamples.dfy", "dafny": "// RUN: %run %s \n\ninclude \"../src/dafny/BoundedInts.dfy\"\n\nimport opened Dafny.BoundedInts\nmethod m(x: uint32, z: nat16) {\n\n  assert TWO_TO_THE_15 * 2 == TWO_TO_THE_16;\n\n  assert 0 <= (x as int) < TWO_TO_THE_32;\n  var y: uint64 := x as int as uint64;\n  var int16 := z as int as int16;\n  var uint16 := z as int as uint16;\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Power.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* Every lemma comes in 2 forms: 'LemmaProperty' and 'LemmaPropertyAuto'. The\nformer takes arguments and may be more stable and less reliant on Z3\nheuristics. The latter includes automation and its use requires less effort */\n\ninclude \"DivMod.dfy\"\ninclude \"Internals/GeneralInternals.dfy\"\ninclude \"Mul.dfy\"\ninclude \"Internals/MulInternals.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Power {\n  import opened DivMod\n  import opened GeneralInternals\n  import opened Mul\n  import opened MulInternals\n\n  function {:opaque} Pow(b: int, e: nat): int\n    decreases e\n  {\n    if e == 0 then\n      1\n    else\n      b * Pow(b, e - 1)\n  }\n\n  /* A number raised to the power of 0 equals 1. */\n  lemma LemmaPow0(b: int)\n    ensures Pow(b, 0) == 1\n  {\n    reveal Pow();\n  }\n\n  lemma LemmaPow0Auto()\n    ensures forall b: nat {:trigger Pow(b, 0)} :: Pow(b, 0) == 1\n  {\n    reveal Pow();\n    forall b: nat {:trigger Pow(b, 0)}\n      ensures Pow(b, 0) == 1\n    {\n      LemmaPow0(b);\n    }\n  }\n\n  /* A number raised to the power of 1 equals the number itself. */\n  lemma LemmaPow1(b: int)\n    ensures Pow(b, 1) == b\n  {\n    calc {\n      Pow(b, 1);\n      { reveal Pow(); }\n      b * Pow(b, 0);\n      { LemmaPow0(b); }\n      b * 1;\n      { LemmaMulBasicsAuto(); }\n      b;\n    }\n  }\n\n  lemma LemmaPow1Auto()\n    ensures forall b: nat {:trigger Pow(b, 1)} :: Pow(b, 1) == b\n  {\n    reveal Pow();\n    forall b: nat {:trigger Pow(b, 1)}\n      ensures Pow(b, 1) == b\n    {\n      LemmaPow1(b);\n    }\n  }\n\n  /* 0 raised to a positive power equals 0. */\n  lemma Lemma0Pow(e: nat)\n    requires e > 0\n    ensures Pow(0, e) == 0\n  {\n    reveal Pow();\n    LemmaMulBasicsAuto();\n    if e != 1 {\n      Lemma0Pow(e - 1);\n    }\n  }\n\n  lemma Lemma0PowAuto()\n    ensures forall e: nat {:trigger Pow(0, e)} :: e > 0 ==> Pow(0, e) == 0\n  {\n    reveal Pow();\n    forall e: nat {:trigger Pow(0, e)} | e > 0\n      ensures Pow(0, e) == 0\n    {\n      Lemma0Pow(e);\n    }\n  }\n\n  /* 1 raised to any power equals 1. */\n  lemma Lemma1Pow(e: nat)\n    ensures Pow(1, e) == 1\n  {\n    reveal Pow();\n    LemmaMulBasicsAuto();\n    if e != 0 {\n      Lemma1Pow(e - 1);\n    }\n  }\n\n  lemma Lemma1PowAuto()\n    ensures forall e: nat {:trigger Pow(1, e)} :: Pow(1, e) == 1\n  {\n    reveal Pow();\n    forall e: nat {:trigger Pow(1, e)}\n      ensures Pow(1, e) == 1\n    {\n      Lemma1Pow(e);\n    }\n  }\n\n  /* Squaring a number is equal to raising it to the power of 2. */\n  lemma LemmaSquareIsPow2(x: nat)\n    ensures Pow(x, 2) == x * x\n  {\n    reveal Pow();\n  }\n\n  lemma LemmaSquareIsPow2Auto()\n    ensures forall x: nat {:trigger Pow(x, 2)} :: Pow(x, 2) == x * x\n  {\n    reveal Pow();\n    forall x: nat {:trigger Pow(x, 2)}\n      ensures Pow(x, 2) == x * x\n    {}\n  }\n\n  /* A positive number raised to any power is positive. */\n  lemma LemmaPowPositive(b: int, e: nat)\n    requires b > 0\n    ensures 0 < Pow(b, e)\n  {\n    LemmaMulIncreasesAuto();\n    LemmaMulInductionAuto(e, u => 0 <= u ==> 0 < Pow(b, u));\n  }\n\n  lemma LemmaPowPositiveAuto()\n    ensures forall b: int, e: nat {:trigger Pow(b, e)}\n              :: b > 0 ==> 0 < Pow(b, e)\n  {\n    reveal Pow();\n    forall b: int, e: nat {:trigger Pow(b, e)} | b > 0\n      ensures 0 < Pow(b, e)\n    {\n      LemmaPowPositive(b, e);\n    }\n  }\n\n  /* Add exponents when multiplying powers with the same base. */\n  lemma LemmaPowAdds(b: int, e1: nat, e2: nat)\n    decreases e1\n    ensures Pow(b, e1 + e2) == Pow(b, e1) * Pow(b, e2)\n  {\n    if e1 == 0 {\n      calc {\n        Pow(b, e1) * Pow(b, e2);\n        { LemmaPow0(b); }\n        1 * Pow(b, e2);\n        { LemmaMulBasicsAuto(); }\n        Pow(b, 0 + e2);\n      }\n    }\n    else {\n      calc {\n        Pow(b, e1) * Pow(b, e2);\n        { reveal Pow(); }\n        (b * Pow(b, e1 - 1)) * Pow(b, e2);\n        { LemmaMulIsAssociativeAuto(); }\n        b * (Pow(b, e1 - 1) * Pow(b, e2));\n        { LemmaPowAdds(b, e1 - 1, e2); }\n        b * Pow(b, e1 - 1 + e2);\n        { reveal Pow(); }\n        Pow(b, e1 + e2);\n      }\n    }\n  }\n\n  lemma LemmaPowAddsAuto()\n    ensures forall b: int, e1: nat, e2: nat {:trigger Pow(b, e1 + e2)}\n              :: Pow(b, e1 + e2) == Pow(b, e1) * Pow(b, e2)\n  {\n    reveal Pow();\n    forall b: int, e1: nat, e2: nat {:trigger Pow(b, e1 + e2)}\n      ensures Pow(b, e1 + e2) == Pow(b, e1) * Pow(b, e2)\n    {\n      LemmaPowAdds(b, e1, e2);\n    }\n  }\n\n  lemma LemmaPowSubAddCancel(b: int, e1: nat, e2: nat)\n    decreases e1\n    requires e1 >= e2\n    ensures Pow(b, e1 - e2) * Pow(b, e2) == Pow(b, e1)\n  {\n    LemmaPowAdds(b, e1 - e2, e2);\n  }\n\n  lemma LemmaPowSubAddCancelAuto()\n    ensures forall b: int, e1: nat, e2: nat {:trigger Pow(b, e1 - e2)} | e1 >= e2\n              :: Pow(b, e1 - e2) * Pow(b, e2) == Pow(b, e1)\n  {\n    reveal Pow();\n    forall b: int, e1: nat, e2: nat | e1 >= e2\n    {\n      LemmaPowSubAddCancel(b, e1, e2);\n    }\n  }\n\n  /* Subtract exponents when dividing powers. */\n  lemma LemmaPowSubtracts(b: nat, e1: nat, e2: nat)\n    requires b > 0\n    requires e1 <= e2\n    ensures Pow(b, e1) > 0\n    ensures Pow(b, e2 - e1) == Pow(b, e2) / Pow(b, e1) > 0\n  {\n    LemmaPowPositiveAuto();\n    calc {\n      Pow(b, e2) / Pow(b, e1);\n      { LemmaPowSubAddCancel(b, e2, e1); }\n      Pow(b, e2 - e1) * Pow(b, e1) / Pow(b, e1);\n      { LemmaDivByMultiple(Pow(b, e2 - e1), Pow(b, e1)); }\n      Pow(b, e2 - e1);\n    }\n  }\n\n  lemma LemmaPowSubtractsAuto()\n    ensures forall b: nat, e1: nat :: b > 0 ==> Pow(b, e1) > 0\n    ensures forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e2 - e1)}\n              :: b > 0 && e1 <= e2 ==>\n                   Pow(b, e2 - e1) == Pow(b, e2) / Pow(b, e1) > 0\n  {\n    reveal Pow();\n    LemmaPowPositiveAuto();\n    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e2 - e1)}\n      | b > 0 && e1 <= e2\n      ensures Pow(b, e2 - e1) == Pow(b, e2) / Pow(b, e1) > 0\n    {\n      LemmaPowSubtracts(b, e1, e2);\n    }\n  }\n\n  /* Multiply exponents when finding the power of a power. */\n  lemma LemmaPowMultiplies(a: int, b: nat, c: nat)\n    decreases c\n    ensures 0 <= b * c\n    ensures Pow(Pow(a, b), c) == Pow(a, b * c)\n  {\n    LemmaMulNonnegative(b, c);\n    if c == 0 {\n      LemmaMulBasicsAuto();\n      calc {\n        Pow(a, b * c);\n        { LemmaPow0(a); }\n        1;\n        { LemmaPow0(Pow(a, b)); }\n        Pow(Pow(a, b), c);\n      }\n    }\n    else {\n      calc {\n        b * c - b;\n        { LemmaMulBasicsAuto(); }\n        b * c - b * 1;\n        { LemmaMulIsDistributiveAuto(); }\n        b * (c - 1);\n      }\n      LemmaMulNonnegative(b, c - 1);\n      assert 0 <= b * c - b;\n\n      calc {\n        Pow(a, b * c);\n        Pow(a, b + b * c - b);\n        { LemmaPowAdds(a, b, b * c - b); }\n        Pow(a, b) * Pow(a, b * c - b);\n        Pow(a, b) * Pow(a, b * (c - 1));\n        { LemmaPowMultiplies(a, b, c - 1); }\n        Pow(a, b) * Pow(Pow(a, b), c - 1);\n        { reveal Pow(); }\n        Pow(Pow(a, b), c);\n      }\n    }\n  }\n\n  lemma LemmaPowMultipliesAuto()\n    ensures forall b: nat, c: nat {:trigger b * c} :: 0 <= b * c\n    ensures forall a: int, b: nat, c: nat {:trigger Pow(a, b * c)}\n              :: Pow(Pow(a, b), c) == Pow(a, b * c)\n  {\n    reveal Pow();\n    LemmaMulNonnegativeAuto();\n    forall a: int, b: nat, c: nat {:trigger Pow(a, b * c)}\n      ensures Pow(Pow(a, b), c) == Pow(a, b * c)\n    {\n      LemmaPowMultiplies(a, b, c);\n    }\n  }\n\n  /* Distribute the power to factors of a product. */\n  lemma LemmaPowDistributes(a: int, b: int, e: nat)\n    decreases e\n    ensures Pow(a * b, e) == Pow(a, e) * Pow(b, e)\n  {\n    reveal Pow();\n    LemmaMulBasicsAuto();\n    if e > 0 {\n      calc {\n        Pow(a * b, e);\n        (a * b) * Pow(a * b, e - 1);\n        { LemmaPowDistributes(a, b, e - 1); }\n        (a * b) * (Pow(a, e - 1) * Pow(b, e - 1));\n        { LemmaMulIsAssociativeAuto(); LemmaMulIsCommutativeAuto(); }\n        (a * Pow(a, e - 1)) * (b * Pow(b, e - 1));\n        Pow(a, e) * Pow(b, e);\n      }\n    }\n  }\n\n  lemma LemmaPowDistributesAuto()\n    ensures forall a: int, b: int, e: nat {:trigger Pow(a * b, e)}\n              :: Pow(a * b, e) == Pow(a, e) * Pow(b, e)\n  {\n    reveal Pow();\n    forall a: int, b: int, e: nat {:trigger Pow(a * b, e)}\n      ensures Pow(a * b, e) == Pow(a, e) * Pow(b, e)\n    {\n      LemmaPowDistributes(a, b, e);\n    }\n  }\n\n  /* Group properties of powers. */\n  lemma LemmaPowAuto()\n    ensures forall x: int {:trigger Pow(x, 0)} :: Pow(x, 0) == 1\n    ensures forall x: int {:trigger Pow(x, 1)} :: Pow(x, 1) == x\n    ensures forall x: int, y: int {:trigger Pow(x, y)} :: y == 0 ==> Pow(x, y) == 1\n    ensures forall x: int, y: int {:trigger Pow(x, y)} :: y == 1 ==> Pow(x, y) == x\n    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> x <= x * y\n    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 1 < y ==> x < x * y\n    ensures forall x: int, y: nat, z: nat {:trigger Pow(x, y + z)} :: Pow(x, y + z) == Pow(x, y) * Pow(x, z)\n    ensures forall x: int, y: nat, z: nat {:trigger Pow(x, y - z)} :: y >= z ==> Pow(x, y - z) * Pow(x, z) == Pow(x, y)\n    ensures forall x: int, y: int, z: nat {:trigger Pow(x * y, z)} :: Pow(x * y, z) == Pow(x, z) * Pow(y, z)\n  {\n    reveal Pow();\n\n    LemmaPow0Auto();\n    LemmaPow1Auto();\n\n    LemmaPowDistributesAuto();\n    LemmaPowAddsAuto();\n    LemmaPowSubAddCancelAuto();\n\n    LemmaMulAuto();\n    LemmaMulIncreasesAuto();\n    LemmaMulStrictlyIncreasesAuto();\n  }\n\n  /* A positive number raised to a power strictly increases as the power\n  strictly increases. */\n  lemma LemmaPowStrictlyIncreases(b: nat, e1: nat, e2: nat)\n    requires 1 < b\n    requires e1 < e2\n    ensures Pow(b, e1) < Pow(b, e2)\n  {\n    LemmaPowAuto();\n    var f := e => 0 < e ==> Pow(b, e1) < Pow(b, e1 + e);\n    forall i {:trigger IsLe(0, i)} | IsLe(0, i) && f(i)\n      ensures f(i + 1)\n    {\n      calc {\n        Pow(b, e1 + i);\n      <= { LemmaPowPositive(b, e1 + i);\n           LemmaMulLeftInequality(Pow(b, e1 + i), 1, b); }\n        Pow(b, e1 + i) * b;\n      == { LemmaPow1(b); }\n        Pow(b, e1 + i) * Pow(b, 1);\n      == { LemmaPowAdds(b, e1 + i, 1); }\n        Pow(b, e1 + i + 1);\n      }\n    }\n    LemmaMulInductionAuto(e2 - e1, f);\n  }\n\n  lemma LemmaPowStrictlyIncreasesAuto()\n    ensures forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1),\n              Pow(b, e2)} :: (1 < b && e1 < e2) ==> Pow(b, e1) < Pow(b, e2)\n  {\n    reveal Pow();\n    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)}\n      | 1 < b && e1 < e2\n      ensures Pow(b, e1) < Pow(b, e2)\n    {\n      LemmaPowStrictlyIncreases(b, e1, e2);\n    }\n  }\n\n  /* A positive number raised to a power increases as the power increases. */\n  lemma LemmaPowIncreases(b: nat, e1: nat, e2: nat)\n    requires b > 0\n    requires e1 <= e2\n    ensures Pow(b, e1) <= Pow(b, e2)\n  {\n    LemmaPowAuto();\n    var f := e => 0 <= e ==> Pow(b, e1) <= Pow(b, e1 + e);\n    forall i {:trigger IsLe(0, i)} | IsLe(0, i) && f(i)\n      ensures f(i + 1)\n    {\n      calc {\n        Pow(b, e1 + i);\n      <= { LemmaPowPositive(b, e1 + i);\n           LemmaMulLeftInequality(Pow(b, e1 + i), 1, b); }\n        Pow(b, e1 + i) * b;\n      == { LemmaPow1(b); }\n        Pow(b, e1 + i) * Pow(b, 1);\n      == { LemmaPowAdds(b, e1 + i, 1); }\n        Pow(b, e1 + i + 1);\n      }\n    }\n    LemmaMulInductionAuto(e2 - e1, f);\n  }\n\n  lemma LemmaPowIncreasesAuto()\n    ensures forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1),\n              Pow(b, e2)} :: (1 < b && e1 <= e2) ==> Pow(b, e1) <= Pow(b, e2)\n  {\n    reveal Pow();\n    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)}\n      | 1 < b && e1 <= e2\n      ensures Pow(b, e1) <= Pow(b, e2)\n    {\n      LemmaPowIncreases(b, e1, e2);\n    }\n  }\n\n  /* A power strictly increases as a positive number raised to the power\n  strictly increases. */\n  lemma LemmaPowStrictlyIncreasesConverse(b: nat, e1: nat, e2: nat)\n    requires b > 0\n    requires Pow(b, e1) < Pow(b, e2)\n    ensures e1 < e2\n  {\n    if e1 >= e2 {\n      LemmaPowIncreases(b, e2, e1);\n      assert false;\n    }\n  }\n\n  lemma LemmaPowStrictlyIncreasesConverseAuto()\n    ensures forall b: nat, e1: nat, e2: nat\n              {:trigger Pow(b, e1), Pow(b, e2)}\n              :: b > 0 && Pow(b, e1) < Pow(b, e2) ==> e1 < e2\n  {\n    reveal Pow();\n    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)}\n      | b > 0 && Pow(b, e1) < Pow(b, e2)\n      ensures e1 < e2\n    {\n      LemmaPowStrictlyIncreasesConverse(b, e1, e2);\n    }\n  }\n\n  /* A power increases as a positive number raised to the power increases. */\n  lemma LemmaPowIncreasesConverse(b: nat, e1: nat, e2: nat)\n    requires 1 < b\n    requires Pow(b, e1) <= Pow(b, e2)\n    ensures e1 <= e2\n  {\n    if e1 > e2 {\n      LemmaPowStrictlyIncreases(b, e2, e1);\n      assert false;\n    }\n  }\n\n  lemma LemmaPowIncreasesConverseAuto()\n    ensures forall b: nat, e1: nat, e2: nat\n              {:trigger Pow(b, e1), Pow(b, e2)}\n              :: 1 < b && Pow(b, e1) <= Pow(b, e2) ==> e1 <= e2\n  {\n    reveal Pow();\n    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)}\n      | 1 < b && Pow(b, e1) <= Pow(b, e2)\n      ensures e1 <= e2\n    {\n      LemmaPowIncreasesConverse(b, e1, e2);\n    }\n  }\n\n  /* (b^xy)^z = (b^x)^yz */\n  lemma LemmaPullOutPows(b: nat, x: nat, y: nat, z: nat)\n    requires b > 0\n    ensures 0 <= x * y\n    ensures 0 <= y * z\n    ensures Pow(Pow(b, x * y), z) == Pow(Pow(b, x), y * z)\n  {\n    LemmaMulNonnegative(x, y);\n    LemmaMulNonnegative(y, z);\n    LemmaPowPositive(b, x);\n    calc {\n      Pow(Pow(b, x * y), z);\n      { LemmaPowMultiplies(b, x, y); }\n      Pow(Pow(Pow(b, x), y), z);\n      { LemmaPowMultiplies(Pow(b, x), y, z); }\n      Pow(Pow(b, x), y * z);\n    }\n  }\n\n  lemma LemmaPullOutPowsAuto()\n    ensures forall y: nat, z: nat {:trigger z * y} :: 0 <= z * y && 0 <= y * z\n    ensures forall b: nat, x: nat, y: nat, z: nat\n              {:trigger Pow(Pow(b, x * y), z)}\n              :: b > 0 ==> Pow(Pow(b, x * y), z) == Pow(Pow(b, x), y * z)\n  {\n    reveal Pow();\n    LemmaMulNonnegativeAuto();\n    forall b: nat, x: nat, y: nat, z: nat {:trigger Pow(Pow(b, x * y), z)}\n      | b > 0 ensures Pow(Pow(b, x * y), z) == Pow(Pow(b, x), y * z)\n    {\n      LemmaPullOutPows(b, x, y, z);\n    }\n  }\n\n  /* Inequality due to smaller numerator, same denominator. */\n  lemma LemmaPowDivisionInequality(x: nat, b: nat, e1: nat, e2: nat)\n    requires b > 0\n    requires e2 <= e1\n    requires x < Pow(b, e1)\n    ensures Pow(b, e2) > 0\n    ensures x / Pow(b, e2) < Pow(b, e1 - e2)\n  {\n    LemmaPowPositiveAuto();\n    calc ==> {\n      x / Pow(b, e2) >= Pow(b, e1 - e2);\n      { LemmaMulInequality(Pow(b, e1 - e2), x / Pow(b, e2), Pow(b, e2)); }\n      x / Pow(b, e2) * Pow(b, e2) >= Pow(b, e1 - e2) * Pow(b, e2);\n      { LemmaFundamentalDivMod(x, Pow(b, e2));\n        LemmaMulIsCommutativeAuto(); }\n      x - x % Pow(b, e2) >= Pow(b, e1 - e2) * Pow(b, e2);\n      { LemmaPowAdds(b, e1 - e2, e2); }\n      x - x % Pow(b, e2) >= Pow(b, e1);\n      { LemmaModPropertiesAuto(); }\n      x >= Pow(b, e1);\n      false;\n    }\n  }\n\n  lemma LemmaPowDivisionInequalityAuto()\n    ensures forall b: nat, e2: nat :: b > 0 ==> Pow(b, e2) > 0\n    ensures forall x: nat, b: nat, e1: nat, e2: nat\n              {:trigger x / Pow(b, e2), Pow(b, e1 - e2)}\n              :: b > 0 && e2 <= e1 && x < Pow(b, e1) ==>\n                   x / Pow(b, e2) < Pow(b, e1 - e2)\n  {\n    reveal Pow();\n    LemmaPowPositiveAuto();\n    forall x: nat, b: nat, e1: nat, e2: nat\n      {:trigger x / Pow(b, e2), Pow(b, e1 - e2)}\n      | b > 0 && e2 <= e1 && x < Pow(b, e1)\n      ensures x / Pow(b, e2) < Pow(b, e1 - e2)\n    {\n      LemmaPowDivisionInequality(x, b, e1, e2);\n    }\n  }\n\n  /* b^e % b = 0 */\n  lemma LemmaPowMod(b: nat, e: nat)\n    requires b > 0 && e > 0\n    ensures Pow(b, e) % b == 0;\n  {\n    reveal Pow();\n    calc {\n      Pow(b, e) % b;\n      (b * Pow(b, e - 1)) % b;\n      { LemmaMulIsAssociativeAuto(); }\n      (Pow(b, e - 1) * b) % b;\n      {\n        LemmaPowPositiveAuto();\n        LemmaModMultiplesBasic(Pow(b, e-1) , b);\n      }\n      0;\n    }\n  }\n\n  lemma LemmaPowModAuto()\n    ensures forall b: nat, e: nat {:trigger Pow(b, e)}\n              :: b > 0 && e > 0 ==> Pow(b, e) % b == 0\n  {\n    reveal Pow();\n    forall b: nat, e: nat {:trigger Pow(b, e)} | b > 0 && e > 0\n      ensures Pow(b, e) % b == 0\n    {\n      LemmaPowMod(b, e);\n    }\n  }\n\n  /* ((b % e)^e) % m = b^e % m */\n  lemma LemmaPowModNoop(b: int, e: nat, m: int)\n    decreases e\n    requires m > 0\n    ensures Pow(b % m, e) % m == Pow(b, e) % m\n  {\n    reveal Pow();\n    LemmaModPropertiesAuto();\n    if e > 0 {\n      calc {\n        Pow(b % m, e) % m;\n        ((b % m) * Pow(b % m, e - 1)) % m;\n        { LemmaMulModNoopGeneral(b, Pow(b % m, e - 1), m); }\n        ((b % m) * (Pow(b % m, e - 1) % m) % m) % m;\n        { LemmaPowModNoop(b, e - 1, m); }\n        ((b % m) * (Pow(b, e - 1) % m) % m) % m;\n        { LemmaMulModNoopGeneral(b, Pow(b, e - 1), m); }\n        (b * (Pow(b, e - 1)) % m) % m;\n        (b * (Pow(b, e - 1))) % m;\n        Pow(b, e) % m;\n      }\n    }\n  }\n\n  lemma LemmaPowModNoopAuto()\n    ensures forall b: nat, e: nat, m: nat {:trigger Pow(b % m, e)}\n              :: m > 0 ==> Pow(b % m, e) % m == Pow(b, e) % m\n  {\n    reveal Pow();\n    forall b: nat, e: nat, m: nat {:trigger Pow(b % m, e)}\n      | m > 0 ensures Pow(b % m, e) % m == Pow(b, e) % m\n    {\n      LemmaPowModNoop(b, e, m);\n    }\n  }\n\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Logarithm.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\ninclude \"Mul.dfy\"\ninclude \"DivMod.dfy\"\ninclude \"Power.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Logarithm {\n  import opened Mul\n  import opened DivMod\n  import opened Power\n\n  function {:opaque} Log(base: nat, pow: nat): nat\n    requires base > 1\n    decreases pow\n  {\n    if pow < base then 0\n    else\n      LemmaDivPosIsPosAuto(); LemmaDivDecreasesAuto();\n      1 + Log(base, pow / base)\n  }\n\n  lemma {:induction false} LemmaLog0(base: nat, pow: nat)\n    requires base > 1\n    requires pow < base\n    ensures Log(base, pow) == 0\n  {\n    reveal Log();\n  }\n\n  lemma {:induction false} LemmaLogS(base: nat, pow: nat)\n    requires base > 1\n    requires pow >= base\n    ensures pow / base >= 0\n    ensures Log(base, pow) == 1 + Log(base, pow / base)\n  {\n    LemmaDivPosIsPosAuto();\n    reveal Log();\n  }\n\n  lemma {:induction false} LemmaLogSAuto()\n    ensures forall base: nat, pow: nat\n              {:trigger Log(base, pow / base)}\n              | && base > 1\n                && pow >= base\n              :: && pow / base >= 0\n                 && Log(base, pow) == 1 + Log(base, pow / base)\n  {\n    forall base: nat, pow: nat | && base > 1 && pow >= base\n      ensures && pow / base >= 0\n              && Log(base, pow) == 1 + Log(base, pow / base)\n    {\n      LemmaLogS(base, pow);\n    }\n  }\n\n  lemma {:induction false} LemmaLogIsOrdered(base: nat, pow: nat, pow': nat)\n    requires base > 1\n    requires pow <= pow'\n    ensures Log(base, pow) <= Log(base, pow')\n    decreases pow\n  {\n    reveal Log();\n    if pow' < base {\n      assert Log(base, pow) == 0 == Log(base, pow');\n    } else if pow < base {\n      assert Log(base, pow) == 0;\n    } else {\n      LemmaDivPosIsPosAuto(); LemmaDivDecreasesAuto(); LemmaDivIsOrderedAuto();\n      LemmaLogIsOrdered(base, pow / base, pow' / base);\n    }\n  }\n\n  lemma {:induction false} LemmaLogPow(base: nat, n: nat)\n    requires base > 1\n    ensures (LemmaPowPositive(base, n); Log(base, Pow(base, n)) == n)\n  {\n    if n == 0 {\n      reveal Pow();\n      reveal Log();\n    } else {\n      LemmaPowPositive(base, n);\n      calc {\n        Log(base, Pow(base, n));\n        { reveal Pow(); }\n        Log(base, base * Pow(base, n - 1));\n        { LemmaPowPositive(base, n - 1);\n          LemmaMulIncreases(Pow(base, n - 1), base);\n          LemmaLogS(base, base * Pow(base, n - 1)); }\n        1 + Log(base, (base * Pow(base, n - 1)) / base);\n        { LemmaDivMultiplesVanish(Pow(base, n - 1), base); }\n        1 + Log(base, Pow(base, n - 1));\n        { LemmaLogPow(base, n - 1); }\n        1 + (n - 1);\n      }\n    }\n  }\n\n  // TODO\n  // lemma {:induction false} Pow_Log(base: nat, pow: nat)\n  //   requires base > 1\n  //   requires pow > 0\n  //   ensures Pow(base, Log(base, pow)) <= pow < Pow(base, Log(base, pow) + 1)\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Internals/MulInternalsNonlinear.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\nmodule {:options \"-functionSyntax:4\"} MulInternalsNonlinear {\n\n  /* WARNING: Think three times before adding to this file, as nonlinear\n  verification is highly unstable! */\n\n  /* multiplying two positive integers will result in a positive integer */\n  lemma LemmaMulStrictlyPositive(x: int, y: int)\n    ensures (0 < x && 0 < y) ==> (0 < x * y)\n  {}\n\n  /* multiplying two nonzero integers will never result in 0 as the poduct */\n  lemma LemmaMulNonzero(x: int, y: int)\n    ensures x * y != 0 <==> x != 0 && y != 0\n  {}\n\n  /* multiplication is associative */\n  lemma LemmaMulIsAssociative(x: int, y: int, z: int)\n    ensures x * (y * z) == (x * y) * z\n  {}\n\n  /* multiplication is distributive */\n  lemma LemmaMulIsDistributiveAdd(x: int, y: int, z: int)\n    ensures x * (y + z) == x * y + x * z\n  {}\n\n  /* the product of two integers is greater than the value of each individual integer */\n  lemma LemmaMulOrdering(x: int, y: int)\n    requires x != 0\n    requires y != 0\n    requires 0 <= x * y\n    ensures x * y >= x && x * y >= y\n  {}\n\n  /* multiplying by a positive integer preserves inequality */\n  lemma LemmaMulStrictInequality(x: int, y: int, z: int)\n    requires x < y\n    requires z > 0\n    ensures  x * z < y * z\n  {}\n\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Internals/DivInternalsNonlinear.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\nmodule {:options \"-functionSyntax:4\"} DivInternalsNonlinear {\n\n  /* WARNING: Think three times before adding to this file, as nonlinear\n  verification is highly unstable! */\n\n  /* zero divided by an integer besides 0 is 0 */\n  lemma LemmaDivOf0(d:int)\n    requires d != 0\n    ensures 0 / d == 0\n  {\n  }\n\n  /* the quotient of an integer divided by itself is 1 */\n  lemma LemmaDivBySelf(d:int)\n    requires d != 0\n    ensures d / d == 1\n  {\n  }\n\n  /* dividing a smaller integer by a larger integer results in a quotient of 0  */\n  lemma LemmaSmallDiv()\n    ensures forall x, d {:trigger x / d} :: 0 <= x < d && d > 0 ==> x / d == 0\n  {\n  }\n\n  /* the quotient of dividing a positive real number (not 0) by a smaller positive real number\n  will be greater than 1 */\n  lemma LemmaRealDivGt(x:real, y:real)\n    requires x > y\n    requires x >= 0.0\n    requires y > 0.0\n    ensures  x / y > 1 as real\n  {\n  }\n\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Internals/ModInternalsNonlinear.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\nmodule {:options \"-functionSyntax:4\"} ModInternalsNonlinear {\n\n  /* WARNING: Think three times before adding to this file, as nonlinear\n  verification is highly unstable! */\n\n  /* the remainder of 0 divided by an integer is 0 */\n  lemma LemmaModOfZeroIsZero(m:int)\n    requires 0 < m\n    ensures 0 % m == 0\n  {\n  }\n\n  /* describes fundementals of the modulus operator */\n  lemma LemmaFundamentalDivMod(x:int, d:int)\n    requires d != 0\n    ensures x == d * (x / d) + (x % d)\n  {\n  }\n\n  /* the remained of 0 divided by any integer is always 0 */\n  lemma Lemma0ModAnything()\n    ensures forall m: int {:trigger 0 % m} :: m > 0 ==> 0 % m == 0\n  {\n  }\n\n  /* a natural number x divided by a larger natural number gives a remainder equal to x */\n  lemma LemmaSmallMod(x:nat, m:nat)\n    requires x < m\n    requires 0 < m\n    ensures x % m == x\n  {\n  }\n\n  /* the range of the modulus of any integer will be [0, m) where m is the divisor */\n  lemma LemmaModRange(x:int, m:int)\n    requires m > 0\n    ensures 0 <= x % m < m\n  {\n  }\n\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Internals/DivInternals.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* lemmas and functions in this file are used in the proofs in DivMod.dfy \n\nSpecs/implements mathematical div and mod, not the C version.\n(x div n) * n + (x mod n) == x, where 0 <= x mod n < n.\nhttps://en.wikipedia.org/wiki/Modulo_operation\n\nThis may produce \"surprising\" results for negative values.\nFor example, -3 div 5 is -1 and -3 mod 5 is 2.\nNote this is consistent: -3 * -1 + 2 == 5 */\n\ninclude \"GeneralInternals.dfy\"\ninclude \"ModInternals.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} DivInternals {\n\n  import opened GeneralInternals\n  import opened ModInternals\n  import opened ModInternalsNonlinear\n  import opened DivInternalsNonlinear\n  import opened MulInternals\n\n  /* Performs division recursively with positive denominator. */\n  function {:opaque} DivPos(x: int, d: int): int\n    requires d > 0\n    decreases if x < 0 then (d - x) else x\n  {\n    if x < 0 then\n      -1 + DivPos(x + d, d)\n    else if x < d then\n      0\n    else\n      1 + DivPos(x - d, d)\n  }\n\n  /* Performs division recursively. */\n  function {:opaque} DivRecursive(x: int, d: int): int\n    requires d != 0\n  {\n    reveal DivPos();\n    if d > 0 then\n      DivPos(x, d)\n    else\n      -1 * DivPos(x, -1 * d)\n  }\n\n  /* Proves the basics of the division operation */\n  lemma LemmaDivBasics(n: int)\n    requires n > 0\n    ensures  n / n == -((-n) / n) == 1\n    ensures  forall x:int {:trigger x / n} :: 0 <= x < n <==> x / n == 0\n    ensures  forall x:int {:trigger (x + n) / n} :: (x + n) / n == x / n + 1\n    ensures  forall x:int {:trigger (x - n) / n} :: (x - n) / n == x / n - 1\n  {\n    LemmaModAuto(n);\n    LemmaModBasics(n);\n    LemmaSmallDiv();\n    LemmaDivBySelf(n);\n    forall x: int | x / n == 0\n      ensures 0 <= x < n\n    {\n      LemmaFundamentalDivMod(x, n);\n    }\n  }\n\n  /* Automates the division operator process. Contains the identity property, a\n  fact about when quotients are zero, and facts about adding and subtracting\n  integers over a common denominator. */\n  ghost predicate DivAuto(n: int)\n    requires n > 0\n  {\n    && ModAuto(n)\n    && (n / n == -((-n) / n) == 1)\n    && (forall x: int {:trigger x / n} :: 0 <= x < n <==> x / n == 0)\n    && (forall x: int, y: int {:trigger (x + y) / n} ::\n          (var z := (x % n) + (y % n);\n           ((0 <= z < n && (x + y) / n == x / n + y / n) ||\n            (n <= z < n + n && (x + y) / n == x / n + y / n + 1))))\n    && (forall x: int, y: int {:trigger (x - y) / n} ::\n          (var z := (x % n) - (y % n);\n           ((0 <= z < n && (x - y) / n == x / n - y / n) ||\n            (-n <= z < 0 && (x - y) / n == x / n - y / n - 1))))\n  }\n\n  /* Ensures that DivAuto is true */\n  lemma LemmaDivAuto(n: int)\n    requires n > 0\n    ensures  DivAuto(n)\n  {\n    LemmaModAuto(n);\n    LemmaDivBasics(n);\n    assert (0 + n) / n == 1;\n    assert (0 - n) / n == -1;\n    forall x:int, y:int {:trigger (x + y) / n}\n      ensures  var z := (x % n) + (y % n);\n               (|| (0 <= z < n && (x + y) / n == x / n + y / n)\n                || (n <= z < 2 * n && (x + y) / n == x / n + y / n + 1))\n    {\n      var f := (xx:int, yy:int) =>\n          (var z := (xx % n) + (yy % n);\n           (   (0 <= z < n && (xx + yy) / n == xx / n + yy / n)\n               || (n <= z < 2 * n && (xx + yy) / n == xx / n + yy / n + 1)));\n      forall i, j\n        ensures j >= 0 && f(i, j) ==> f(i, j + n)\n        ensures i < n  && f(i, j) ==> f(i - n, j)\n        ensures j < n  && f(i, j) ==> f(i, j - n)\n        ensures i >= 0 && f(i, j) ==> f(i + n, j)\n      {\n        assert ((i + n) + j) / n == ((i + j) + n) / n;\n        assert (i + (j + n)) / n == ((i + j) + n) / n;\n        assert ((i - n) + j) / n == ((i + j) - n) / n;\n        assert (i + (j - n)) / n == ((i + j) - n) / n;\n      }\n      forall i, j\n        ensures 0 <= i < n && 0 <= j < n ==> f(i, j)\n      {\n        assert ((i + n) + j) / n == ((i + j) + n) / n;\n        assert (i + (j + n)) / n == ((i + j) + n) / n;\n        assert ((i - n) + j) / n == ((i + j) - n) / n;\n        assert (i + (j - n)) / n == ((i + j) - n) / n;\n      }\n      LemmaModInductionForall2(n, f);\n      assert f(x, y);\n    }\n    forall x:int, y:int {:trigger (x - y) / n}\n      ensures  var z := (x % n) - (y % n);\n               (|| (0 <= z < n && (x - y) / n == x / n - y / n)\n                || (-n <= z < 0 && (x - y) / n == x / n - y / n - 1))\n    {\n      var f := (xx:int, yy:int) =>\n          (var z := (xx % n) - (yy % n);\n           (   (0 <= z < n && (xx - yy) / n == xx / n - yy / n)\n               || (-n <= z < 0 && (xx - yy) / n == xx / n - yy / n - 1)));\n      forall i, j\n        ensures j >= 0 && f(i, j) ==> f(i, j + n)\n        ensures i < n  && f(i, j) ==> f(i - n, j)\n        ensures j < n  && f(i, j) ==> f(i, j - n)\n        ensures i >= 0 && f(i, j) ==> f(i + n, j)\n      {\n        assert ((i + n) - j) / n == ((i - j) + n) / n;\n        assert (i - (j - n)) / n == ((i - j) + n) / n;\n        assert ((i - n) - j) / n == ((i - j) - n) / n;\n        assert (i - (j + n)) / n == ((i - j) - n) / n;\n      }\n      forall i, j\n        ensures 0 <= i < n && 0 <= j < n ==> f(i, j)\n      {\n        assert ((i + n) - j) / n == ((i - j) + n) / n;\n        assert (i - (j - n)) / n == ((i - j) + n) / n;\n        assert ((i - n) - j) / n == ((i - j) - n) / n;\n        assert (i - (j + n)) / n == ((i - j) - n) / n;\n      }\n      LemmaModInductionForall2(n, f);\n      assert f(x, y);\n    }\n  }\n\n  /* Performs auto induction for division */\n  lemma LemmaDivInductionAuto(n: int, x: int, f: int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  f(x)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n\n  /* Performs auto induction on division for all i s.t. f(i) exists */\n  lemma LemmaDivInductionAutoForall(n:int, f:int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Internals/GeneralInternals.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\nmodule {:options \"-functionSyntax:4\"} GeneralInternals {\n\n  /* this predicate is primarily used as a trigger */\n  ghost predicate IsLe(x: int, y: int)\n  {\n    x <= y\n  }\n\n  /* aids in the process of induction for modulus */\n  lemma LemmaInductionHelper(n: int, f: int -> bool, x: int)\n    requires n > 0\n    requires forall i :: 0 <= i < n ==> f(i)\n    requires forall i {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)\n    requires forall i {:trigger f(i), f(i - n)} :: i < n  && f(i) ==> f(i - n)\n    ensures  f(x)\n    decreases if x >= n then x else -x\n  {\n    if (x >= n)\n    {\n      LemmaInductionHelper(n, f, x - n);\n      assert f((x - n) + n);\n    }\n    else if (x < 0)\n    {\n      LemmaInductionHelper(n, f, x + n);\n      assert f((x + n) - n);\n    }\n  }\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Internals/MulInternals.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* lemmas and functions in this file are used in the proofs in Mul.dfy */\n\ninclude \"GeneralInternals.dfy\"\ninclude \"MulInternalsNonlinear.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} MulInternals {\n\n  import opened GeneralInternals\n  import opened MulInternalsNonlinear\n\n  /* performs multiplication for positive integers using recursive addition */\n  function {:opaque} MulPos(x: int, y: int) : int\n    requires x >= 0\n  {\n    if x == 0 then 0\n    else y + MulPos(x - 1, y)\n  }\n\n  /* performs multiplication for both positive and negative integers */\n  function MulRecursive(x: int, y: int) : int\n  {\n    if x >= 0 then MulPos(x, y)\n    else -1 * MulPos(-1 * x, y)\n  }\n\n  /* performs induction on multiplication */\n  lemma LemmaMulInduction(f: int -> bool)\n    requires f(0)\n    requires forall i {:trigger f(i), f(i + 1)} :: i >= 0 && f(i) ==> f(i + 1)\n    requires forall i {:trigger f(i), f(i - 1)} :: i <= 0 && f(i) ==> f(i - 1)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    forall i ensures f(i) { LemmaInductionHelper(1, f, i); }\n  }\n\n  /* proves that multiplication is always commutative */\n  lemma LemmaMulCommutes()\n    ensures  forall x:int, y:int {:trigger x * y} :: x * y == y * x\n  {\n    forall x:int, y:int\n      ensures x * y == y * x\n    {\n      LemmaMulInduction(i => x * i == i * x);\n    }\n  }\n\n  /* proves the distributive property of multiplication when multiplying an interger\n  by (x +/- 1) */\n  //rename for both directions ???\n  lemma LemmaMulSuccessor()\n    ensures forall x:int, y:int {:trigger (x + 1) * y} :: (x + 1) * y == x * y + y\n    ensures forall x:int, y:int {:trigger (x - 1) * y} :: (x - 1) * y == x * y - y\n  {\n    LemmaMulCommutes();\n    forall x:int, y:int\n      ensures (x + 1) * y == x * y + y\n      ensures (x - 1) * y == x * y - y\n    {\n      LemmaMulIsDistributiveAdd(y, x, 1);\n      LemmaMulIsDistributiveAdd(y, x, -1);\n    }\n  }\n\n  /* proves the distributive property of multiplication */\n  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n\n  /* groups distributive and associative properties of multiplication */\n  ghost predicate MulAuto()\n  {\n    && (forall x:int, y:int {:trigger x * y} :: x * y == y * x)\n    && (forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z)\n    && (forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z)\n  }\n\n  /* proves that MulAuto is valid */\n  lemma LemmaMulAuto()\n    ensures  MulAuto()\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n  }\n\n  /* performs auto induction for multiplication */\n  lemma LemmaMulInductionAuto(x: int, f: int -> bool)\n    requires MulAuto() ==> f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  f(x)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n    assert forall i {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInduction(f);\n    assert f(x);\n  }\n\n  /* performs auto induction on multiplication for all i s.t. f(i) exists */\n  lemma LemmaMulInductionAutoForall(f: int -> bool)\n    requires MulAuto() ==> f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n    assert forall i {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInduction(f);\n  }\n\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Internals/ModInternals.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* lemmas and functions in this file are used in the proofs in DivMod.dfy\n\nSpecs/implements mathematical div and mod, not the C version.\n(x div n) * n + (x mod n) == x, where 0 <= x mod n < n.\nhttps://en.wikipedia.org/wiki/Modulo_operation\n\nThis may produce \"surprising\" results for negative values.\nFor example, -3 div 5 is -1 and -3 mod 5 is 2.\nNote this is consistent: -3 * -1 + 2 == 5 */\n\ninclude \"GeneralInternals.dfy\"\ninclude \"MulInternals.dfy\"\ninclude \"../Mul.dfy\"\ninclude \"ModInternalsNonlinear.dfy\"\ninclude \"DivInternalsNonlinear.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} ModInternals {\n\n  import opened GeneralInternals\n  import opened Mul\n  import opened MulInternalsNonlinear\n  import opened MulInternals\n  import opened ModInternalsNonlinear\n  import opened DivInternalsNonlinear\n\n  /* Performs modulus recursively. */\n  function {:opaque} ModRecursive(x: int, d: int): int\n    requires d > 0\n    decreases if x < 0 then (d - x) else x\n  {\n    if x < 0 then\n      ModRecursive(d + x, d)\n    else if x < d then\n      x\n    else\n      ModRecursive(x - d, d)\n  }\n\n  /* performs induction on modulus */\n  lemma LemmaModInductionForall(n: int, f: int -> bool)\n    requires n > 0\n    requires forall i :: 0 <= i < n ==> f(i)\n    requires forall i {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)\n    requires forall i {:trigger f(i), f(i - n)} :: i < n  && f(i) ==> f(i - n)\n    ensures  forall i :: f(i)\n  {\n    forall i ensures f(i) { LemmaInductionHelper(n, f, i); }\n  }\n\n  /* given an integer x and divisor n, the remainder of x%n is equivalent to the remainder of (x+m)%n\n  where m is a multiple of n */\n  lemma LemmaModInductionForall2(n: int, f:(int, int)->bool)\n    requires n > 0\n    requires forall i, j :: 0 <= i < n && 0 <= j < n ==> f(i, j)\n    requires forall i, j {:trigger f(i, j), f(i + n, j)} :: i >= 0 && f(i, j) ==> f(i + n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j + n)} :: j >= 0 && f(i, j) ==> f(i, j + n)\n    requires forall i, j {:trigger f(i, j), f(i - n, j)} :: i < n  && f(i, j) ==> f(i - n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j - n)} :: j < n  && f(i, j) ==> f(i, j - n)\n    ensures  forall i, j :: f(i, j)\n  {\n    forall x, y\n      ensures f(x, y)\n    {\n      forall i | 0 <= i < n\n        ensures f(i, y)\n      {\n        var fj := j => f(i, j);\n        LemmaModInductionForall(n, fj);\n        assert fj(y);\n      }\n      var fi := i => f(i, y);\n      LemmaModInductionForall(n, fi);\n      assert fi(x);\n    }\n  }\n\n  lemma LemmaDivAddDenominator(n: int, x: int)\n    requires n > 0\n    ensures (x + n) / n == x / n + 1\n  {\n    LemmaFundamentalDivMod(x, n);\n    LemmaFundamentalDivMod(x + n, n);\n    var zp := (x + n) / n - x / n - 1;\n    forall ensures 0 == n * zp + ((x + n) % n) - (x % n) { LemmaMulAuto(); }\n    if (zp > 0) { LemmaMulInequality(1, zp, n); }\n    if (zp < 0) { LemmaMulInequality(zp, -1, n); }\n  }\n\n  lemma LemmaDivSubDenominator(n: int, x: int)\n    requires n > 0\n    ensures (x - n) / n == x / n - 1\n  {\n    LemmaFundamentalDivMod(x, n);\n    LemmaFundamentalDivMod(x - n, n);\n    var zm := (x - n) / n - x / n + 1;\n    forall ensures 0 == n * zm + ((x - n) % n) - (x % n) { LemmaMulAuto(); }\n    if (zm > 0) { LemmaMulInequality(1, zm, n); }\n    if (zm < 0) { LemmaMulInequality(zm, -1, n); }\n  }\n\n  lemma LemmaModAddDenominator(n: int, x: int)\n    requires n > 0\n    ensures (x + n) % n == x % n\n  {\n    LemmaFundamentalDivMod(x, n);\n    LemmaFundamentalDivMod(x + n, n);\n    var zp := (x + n) / n - x / n - 1;\n    forall ensures 0 == n * zp + ((x + n) % n) - (x % n) { LemmaMulAuto(); }\n    if (zp > 0) { LemmaMulInequality(1, zp, n); }\n    if (zp < 0) { LemmaMulInequality(zp, -1, n); }\n  }\n\n  lemma LemmaModSubDenominator(n: int, x: int)\n    requires n > 0\n    ensures (x - n) % n == x % n\n  {\n    LemmaFundamentalDivMod(x, n);\n    LemmaFundamentalDivMod(x - n, n);\n    var zm := (x - n) / n - x / n + 1;\n    forall ensures 0 == n * zm + ((x - n) % n) - (x % n) { LemmaMulAuto(); }\n    if (zm > 0) { LemmaMulInequality(1, zm, n); }\n    if (zm < 0) { LemmaMulInequality(zm, -1, n); }\n  }\n\n  lemma LemmaModBelowDenominator(n: int, x: int)\n    requires n > 0\n    ensures 0 <= x < n <==> x % n == x\n  {\n    forall x: int\n      ensures 0 <= x < n <==> x % n == x\n    {\n      if (0 <= x < n) { LemmaSmallMod(x, n); }\n      LemmaModRange(x, n);\n    }\n  }\n\n  /* proves the basics of the modulus operation */\n  lemma LemmaModBasics(n: int)\n    requires n > 0\n    ensures  forall x: int {:trigger (x + n) % n} :: (x + n) % n == x % n\n    ensures  forall x: int {:trigger (x - n) % n} :: (x - n) % n == x % n\n    ensures  forall x: int {:trigger (x + n) / n} :: (x + n) / n == x / n + 1\n    ensures  forall x: int {:trigger (x - n) / n} :: (x - n) / n == x / n - 1\n    ensures  forall x: int {:trigger x % n} :: 0 <= x < n <==> x % n == x\n  {\n    forall x: int\n      ensures (x + n) % n == x % n\n      ensures (x - n) % n == x % n\n      ensures (x + n) / n == x / n + 1\n      ensures (x - n) / n == x / n - 1\n      ensures 0 <= x < n <==> x % n == x\n    {\n      LemmaModBelowDenominator(n, x);\n      LemmaModAddDenominator(n, x);\n      LemmaModSubDenominator(n, x);\n      LemmaDivAddDenominator(n, x);\n      LemmaDivSubDenominator(n, x);\n    }\n  }\n\n  /* proves the quotient remainder theorem */\n  lemma {:vcs_split_on_every_assert} LemmaQuotientAndRemainder(x: int, q: int, r: int, n: int)\n    requires n > 0\n    requires 0 <= r < n\n    requires x == q * n + r\n    ensures  q == x / n\n    ensures  r == x % n\n    decreases if q > 0 then q else -q\n  {\n    LemmaModBasics(n);\n\n    if q > 0 {\n      MulInternalsNonlinear.LemmaMulIsDistributiveAdd(n, q - 1, 1);\n      LemmaMulIsCommutativeAuto();\n      assert q * n + r == (q - 1) * n + n + r;\n      LemmaQuotientAndRemainder(x - n, q - 1, r, n);\n    }\n    else if q < 0 {\n      Mul.LemmaMulIsDistributiveSub(n, q + 1, 1);\n      LemmaMulIsCommutativeAuto();\n      assert q * n + r == (q + 1) * n - n + r;\n      LemmaQuotientAndRemainder(x + n, q + 1, r, n);\n    }\n    else {\n      LemmaSmallDiv();\n      assert r / n == 0;\n    }\n  }\n\n  /* automates the modulus operator process */\n  ghost predicate ModAuto(n: int)\n    requires n > 0;\n  {\n    && (n % n == (-n) % n == 0)\n    && (forall x: int {:trigger (x % n) % n} :: (x % n) % n == x % n)\n    && (forall x: int {:trigger x % n} :: 0 <= x < n <==> x % n == x)\n    && (forall x: int, y: int {:trigger (x + y) % n} ::\n          (var z := (x % n) + (y % n);\n           (  (0 <= z < n     && (x + y) % n == z)\n              || (n <= z < n + n && (x + y) % n == z - n))))\n    && (forall x: int, y: int {:trigger (x - y) % n} ::\n          (var z := (x % n) - (y % n);\n           (   (0 <= z < n && (x - y) % n == z)\n               || (-n <= z < 0 && (x - y) % n == z + n))))\n  }\n\n  /* ensures that ModAuto is true */\n  lemma LemmaModAuto(n: int)\n    requires n > 0\n    ensures  ModAuto(n)\n  {\n    LemmaModBasics(n);\n    LemmaMulIsCommutativeAuto();\n    LemmaMulIsDistributiveAddAuto();\n    LemmaMulIsDistributiveSubAuto();\n\n    forall x: int, y: int {:trigger (x + y) % n}\n      ensures var z := (x % n) + (y % n);\n              || (0 <= z < n && (x + y) % n == z)\n              || (n <= z < 2 * n && (x + y) % n == z - n)\n    {\n      var xq, xr := x / n, x % n;\n      LemmaFundamentalDivMod(x, n);\n      assert x == xq * n + xr;\n      var yq, yr := y / n, y % n;\n      LemmaFundamentalDivMod(y, n);\n      assert y == yq * n + yr;\n      if xr + yr < n {\n        LemmaQuotientAndRemainder(x + y, xq + yq, xr + yr, n);\n      }\n      else {\n        LemmaQuotientAndRemainder(x + y, xq + yq + 1, xr + yr - n, n);\n      }\n    }\n\n    forall x: int, y: int {:trigger (x - y) % n}\n      ensures var z := (x % n) - (y % n);\n              || (0 <= z < n && (x - y) % n == z)\n              || (-n <= z < 0 && (x - y) % n == z + n)\n    {\n      var xq, xr := x / n, x % n;\n      LemmaFundamentalDivMod(x, n);\n      assert x == xq * n + xr;\n      var yq, yr := y / n, y % n;\n      LemmaFundamentalDivMod(y, n);\n      assert y == yq * n + yr;\n      if xr - yr >= 0 {\n        LemmaQuotientAndRemainder(x - y, xq - yq, xr - yr, n);\n      }\n      else {\n        LemmaQuotientAndRemainder(x - y, xq - yq - 1, xr - yr + n, n);\n      }\n    }\n  }\n\n  /* performs auto induction for modulus */\n  lemma LemmaModInductionAuto(n: int, x: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  f(x)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n\n  // not used in other files\n  /* performs auto induction on modulus for all i s.t. f(i) exists */\n  lemma LemmaModInductionAutoForall(n: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/DivMod.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* Every lemma comes in 2 forms: 'LemmaProperty' and 'LemmaPropertyAuto'. The\nformer takes arguments and may be more stable and less reliant on Z3\nheuristics. The latter includes automation and its use requires less effort */\n\ninclude \"Internals/DivInternalsNonlinear.dfy\"\ninclude \"Internals/DivInternals.dfy\"\ninclude \"Internals/GeneralInternals.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} DivMod {\n\n  import opened DivInternals\n  import DivINL = DivInternalsNonlinear\n  import opened ModInternals\n  import ModINL = ModInternalsNonlinear\n  import opened MulInternals\n  import opened Mul\n  import opened GeneralInternals\n\n  /*****************************************************************************\n   * Division:\n   *****************************************************************************/\n\n  /* the common syntax of division gives the same quotient as performing division through recursion */\n  lemma LemmaDivIsDivRecursive(x: int, d: int)\n    requires 0 < d\n    ensures DivRecursive(x, d) == x / d\n  {\n    reveal DivRecursive();\n    LemmaDivInductionAuto(d, x, u => DivRecursive(u, d) == u / d);\n  }\n\n  lemma LemmaDivIsDivRecursiveAuto()\n    ensures forall x: int, d: int {:trigger x / d} :: d > 0 ==> DivRecursive(x, d) == x / d\n  {\n    reveal DivRecursive();\n    forall x: int, d: int | d > 0\n      ensures DivRecursive(x, d) == x / d\n    {\n      LemmaDivIsDivRecursive(x, d);\n    }\n  }\n\n  /* the quotient of an integer divided by itself is 1 */\n  lemma LemmaDivBySelf(d: int)\n    requires d != 0\n    ensures d / d == 1\n  {\n    DivINL.LemmaDivBySelf(d);\n  }\n\n  /* zero divided by an integer besides 0 is 0 */\n  lemma LemmaDivOf0(d: int)\n    requires d != 0\n    ensures 0 / d == 0\n  {\n    DivINL.LemmaDivOf0(d);\n  }\n\n  /* ensures the basic propoerties of division: 0 divided by any integer is 0; any integer \n  divided by 1 is itself; any integer divided by itself is 1 */\n  lemma LemmaDivBasics(x: int)\n    ensures x != 0 ==> 0 / x == 0\n    ensures x / 1 == x\n    ensures x != 0 ==> x / x == 1\n  {\n    if (x != 0) {\n      LemmaDivBySelf(x);\n      LemmaDivOf0(x);\n    }\n  }\n\n  lemma LemmaDivBasicsAuto()\n    ensures forall x {:trigger 0 / x} :: x != 0 ==> 0 / x == 0\n    ensures forall x {:trigger x / 1} :: x / 1 == x\n    ensures forall x, y {:trigger x / y} :: x >= 0 && y > 0 ==> x / y >= 0\n    ensures forall x, y {:trigger x / y} :: x >= 0 && y > 0 ==> x / y <= x\n  {\n    forall x: int\n      ensures x != 0 ==> 0 / x == 0\n      ensures x / 1 == x\n    {\n      LemmaDivBasics(x);\n    }\n    forall x: int, y: int | x >= 0 && y > 0\n      ensures 0 <= x / y <= x\n    {\n      LemmaDivPosIsPos(x, y);\n      LemmaDivIsOrderedByDenominator(x, 1, y);\n    }\n  }\n\n  /* if a dividend is a whole number and the divisor is a natural number and their\n  quotient is 0, this implies that the dividend is smaller than the divisor */\n  lemma LemmaSmallDivConverseAuto()\n    ensures forall x, d {:trigger x / d } :: 0 <= x && 0 < d && x / d == 0 ==> x < d\n  {\n    forall x, d | 0 <= x && 0 < d && x / d == 0\n      ensures x < d\n    {\n      LemmaDivInductionAuto(d, x, u => 0 <= u && 0 < d && u / d == 0 ==> u < d);\n    }\n  }\n\n  lemma LemmaDivNonZero(x: int, d: int)\n    requires x >= d > 0\n    ensures x / d > 0\n  {\n    LemmaDivPosIsPosAuto();\n    if x / d == 0 {\n      LemmaSmallDivConverseAuto();\n    }\n  }\n\n  lemma LemmaDivNonZeroAuto()\n    ensures forall x, d {:trigger x / d } | x >= d > 0 :: x / d > 0\n  {\n    forall x, d | x >= d > 0 { LemmaDivNonZero(x, d); }\n  }\n\n  /* given two fractions with the same numerator, the order of numbers is determined by \n  the denominators. However, if the numerator is 0, the fractions are equal regardless of \n  the denominators' values */\n  lemma LemmaDivIsOrderedByDenominator(x: int, y: int, z: int)\n    requires 0 <= x\n    requires 1 <= y <= z\n    ensures x / y >= x / z\n    decreases x\n  {\n    reveal DivRecursive();\n    LemmaDivIsDivRecursiveAuto();\n    assert forall u: int, d: int {:trigger u / d} {:trigger DivRecursive(u, d)}\n        :: d > 0 ==> DivRecursive(u, d) == u / d;\n\n    if (x < z)\n    {\n      LemmaDivIsOrdered(0, x, y);\n    }\n    else\n    {\n      LemmaDivIsOrdered(x - z, x - y, y);\n      LemmaDivIsOrderedByDenominator(x - z, y, z);\n    }\n  }\n\n  lemma LemmaDivIsOrderedByDenominatorAuto()\n    ensures forall x: int, y: int, z: int {:trigger x / y, x / z} :: 0 <= x && 1 <= y <= z ==> x / y >= x / z\n  {\n    forall (x: int, y: int, z: int | 0 <= x && 1 <= y <= z)\n      ensures x / y >= x / z\n    {\n      LemmaDivIsOrderedByDenominator(x, y, z);\n    }\n  }\n\n  /* given two fractions with the same numerator, the order of numbers is strictly determined by \n  the denominators.*/\n  lemma LemmaDivIsStrictlyOrderedByDenominator(x: int, d: int)\n    requires 0 < x\n    requires 1 < d\n    ensures x / d  < x\n    decreases x\n  {\n    LemmaDivInductionAuto(d, x, u => 0 < u ==> u / d < u);\n  }\n\n  lemma LemmaDivIsStrictlyOrderedByDenominatorAuto()\n    ensures forall x: int, d: int {:trigger x / d} :: 0 < x && 1 < d ==> x / d < x\n  {\n    forall (x: int, d: int | 0 < x && 1 < d )\n      ensures x / d < x\n    {\n      LemmaDivIsStrictlyOrderedByDenominator(x, d);\n    }\n  }\n\n  /* Rounding is different when multiplying the sum of two integers by a fraction d/d vs. \n  first multiplying each integer by d/d and then adding the quotients */\n  lemma LemmaDividingSums(a: int, b: int, d: int, R: int)\n    requires 0 < d\n    requires R == a % d + b % d - (a + b) % d\n    ensures d * ((a + b) / d) - R == d * (a / d) + d * (b / d)\n  {\n    calc ==> {\n      a % d + b % d == R + (a + b) % d;\n      (a + b) - (a + b) % d - R == a - (a % d) + b - (b % d);\n      {\n        LemmaFundamentalDivMod(a + b, d);\n        LemmaFundamentalDivMod(a, d);\n        LemmaFundamentalDivMod(b, d);\n      }\n      d * ((a + b) / d) - R == d * (a / d) + d * (b / d);\n    }\n  }\n\n  lemma LemmaDividingSumsAuto()\n    ensures forall a: int, b: int, d: int, R: int {:trigger d * ((a + b) / d) - R, d*(a/d) + d*(b/d)}\n              :: 0 < d &&  R == a%d + b%d - (a+b)%d ==> d*((a+b)/d) - R == d*(a/d) + d*(b/d)\n  {\n    forall (a: int, b: int, d: int, R: int | 0< d &&  R == a%d + b%d - (a+b)%d)\n      ensures d*((a+b)/d) - R == d*(a/d) + d*(b/d)\n    {\n      LemmaDividingSums(a, b, d, R);\n    }\n  }\n\n  /* dividing a whole number by a natural number will result in a quotient that is \n  greater than or equal to 0 */\n  lemma LemmaDivPosIsPos(x: int, d: int)\n    requires 0 <= x\n    requires 0 < d\n    ensures 0 <= x / d\n  {\n    LemmaDivInductionAuto(d, x, u => 0 <= u ==> u / d >= 0);\n  }\n\n  lemma LemmaDivPosIsPosAuto()\n    ensures forall x: int, d: int {:trigger x / d} :: 0 <= x && 0 < d ==> 0 <= x / d\n  {\n    forall (x: int, d: int | 0 <= x && 0 < d)\n      ensures 0 <= x / d\n    {\n      LemmaDivPosIsPos(x, d);\n    }\n  }\n\n  /* dividing an integer and then adding 1 to the quotient is the same as adding \n  the divisor and the integer, and then dividing that sum by the divisor */\n  lemma LemmaDivPlusOne(x: int, d: int)\n    requires 0 < d\n    ensures 1 + x / d == (d + x) / d\n  {\n    LemmaDivAuto(d);\n  }\n\n  lemma LemmaDivPlusOneAuto()\n    ensures forall x: int, d: int {:trigger 1 + x / d, (d + x) / d} :: 0 < d ==> 1 + x / d == (d + x) / d\n  {\n    forall (x: int, d: int | 0 < d)\n      ensures 1 + x / d == (d + x) / d\n    {\n      LemmaDivPlusOne(x, d);\n    }\n  }\n\n  /* dividing an integer and then subtracting 1 from the quotient is the same as subtracting \n  the divisor from the integer, and then dividing that difference by the divisor */\n  lemma LemmaDivMinusOne(x: int, d: int)\n    requires 0 < d\n    ensures -1 + x / d == (-d + x) / d\n  {\n    LemmaDivAuto(d);\n  }\n\n  lemma LemmaDivMinusOneAuto()\n    ensures forall x: int, d: int {:trigger -1 + x / d, (-d + x) / d} :: 0 < d ==> -1 + x / d == (-d + x) / d\n  {\n    forall (x: int, d: int | 0 < d)\n      ensures -1 + x / d == (-d + x) / d\n    {\n      LemmaDivMinusOne(x, d);\n    }\n  }\n\n  /* dividing a smaller integer by a larger integer results in a quotient of 0 */\n  lemma LemmaBasicDiv(d: int)\n    requires 0 < d\n    ensures forall x {:trigger x / d} :: 0 <= x < d ==> x / d == 0\n  {\n    LemmaDivAuto(d);\n  }\n\n  lemma LemmaBasicDivAuto()\n    ensures forall x: int, d: int {:trigger x / d} :: 0 <= x < d ==> x / d == 0\n  {\n    forall (x: int, d: int | 0 <= x < d)\n      ensures x / d == 0\n    {\n      LemmaBasicDiv(d);\n    }\n  }\n\n  /* numerical order is preserved when dividing two seperate integers by a common positive divisor */\n  lemma LemmaDivIsOrdered(x: int, y: int, z: int)\n    requires x <= y\n    requires 0 < z\n    ensures x / z <= y / z\n  {\n    LemmaDivInductionAuto(z, x - y, xy => xy <= 0 ==> (xy + y) / z <= y / z);\n  }\n\n  lemma LemmaDivIsOrderedAuto()\n    ensures forall x: int, y: int, z: int {:trigger x / z, y / z} :: x <= y && 0 < z ==> x / z <= y / z\n  {\n    forall (x: int, y: int, z: int | x <= y && 0 < z)\n      ensures x / z <= y / z\n    {\n      LemmaDivIsOrdered(x, y, z);\n    }\n  }\n\n  /* dividing an integer by 2 or more results in a quotient that is smaller than the \n  original dividend */\n  lemma LemmaDivDecreases(x: int, d: int)\n    requires 0 < x\n    requires 1 < d\n    ensures x / d  < x\n  {\n    LemmaDivInductionAuto(d, x, u => 0 < u ==> u / d < u);\n  }\n\n  lemma LemmaDivDecreasesAuto()\n    ensures forall x: int, d: int {:trigger x / d} :: 0 < x && 1 < d ==> x / d < x\n  {\n    forall (x: int, d: int | 0 < x && 1 < d)\n      ensures x / d < x\n    {\n      LemmaDivDecreases(x, d);\n    }\n  }\n\n  /* dividing an integer by 1 or more results in a quotient that is less than or equal to \n  the original dividend */\n  lemma LemmaDivNonincreasing(x: int, d: int)\n    requires 0 <= x\n    requires 0 < d\n    ensures x / d  <= x\n  {\n    LemmaDivInductionAuto(d, x, u => 0 <= u ==> u / d <= u);\n  }\n\n  lemma LemmaDivNonincreasingAuto()\n    ensures forall x: int, d: int {:trigger x / d } :: 0 <= x && 0 < d ==> x / d <= x\n  {\n    forall (x: int, d: int | 0 <= x && 0 < d)\n      ensures x / d <= x\n    {\n      LemmaDivNonincreasing(x, d);\n    }\n  }\n\n  /* a natural number x divided by a larger natural number gives a remainder equal to x */\n  lemma LemmaSmallMod(x: nat, m: nat)\n    requires x < m\n    requires 0 < m\n    ensures x % m == x\n  {\n    ModINL.LemmaSmallMod(x, m);\n  }\n\n  lemma LemmaBreakdown(x: int, y: int, z: int)\n    requires 0 <= x\n    requires 0 < y\n    requires 0 < z\n    ensures 0 < y * z\n    ensures x % (y * z) ==y * ((x / y) % z) + x % y\n  {\n    LemmaMulStrictlyPositiveAuto();\n    LemmaDivPosIsPos(x, y);\n    assert 0 <= x / y;\n\n    calc {\n      (y * (x / y)) % (y * z) + (x % y) % (y * z);\n    <=    { LemmaPartBound1(x, y, z); }\n      y * (z - 1) + (x % y) % (y * z);\n    <    { LemmaPartBound2(x, y, z); }\n      y * (z - 1) + y;\n          { LemmaMulBasicsAuto(); }\n      y * (z - 1) + y * 1;\n          { LemmaMulIsDistributiveAuto(); }\n      y * (z - 1 + 1);\n      y * z;\n    }\n\n    calc {\n      x % (y * z);\n      { LemmaFundamentalDivMod(x,y); }\n      (y * (x / y) + x % y) % (y * z);\n      {\n        LemmaModPropertiesAuto();\n        assert 0 <= x % y;\n        LemmaMulNonnegative(y, x / y);\n        assert (y * (x / y)) % (y * z) + (x % y) % (y * z) < y * z;\n        LemmaModAdds(y * (x / y), x % y, y * z);\n      }\n      (y * (x / y)) % (y * z) + (x % y) % (y * z);\n      {\n        LemmaModPropertiesAuto();\n        LemmaMulIncreases(z, y);\n        LemmaMulIsCommutativeAuto();\n        assert x % y < y <= y * z;\n        LemmaSmallMod(x % y, y * z);\n        assert (x % y) % (y * z) == x % y;\n      }\n      (y * (x / y)) % (y * z) + x % y;\n      { LemmaTruncateMiddle(x / y, y, z); }\n      y * ((x / y) % z) + x % y;\n    }\n  }\n\n  lemma LemmaBreakdownAuto()\n    ensures forall x: int, y: int, z: int {:trigger y * z, x % (y * z), y * ((x / y) % z) + x % y}\n              :: 0 <= x && 0 < y && 0 < z ==> 0 < y * z && x % (y * z) == y * ((x / y) % z) + x % y\n  {\n    forall (x: int, y: int, z: int  | 0 <= x && 0 < y && 0 < z)\n      ensures 0 < y * z && x % (y * z) == y * ((x / y) % z) + x % y\n    {\n      LemmaBreakdown(x, y, z);\n    }\n  }\n\n  lemma LemmaRemainderUpper(x: int, d: int)\n    requires 0 <= x\n    requires 0 < d\n    ensures x - d < x / d * d\n  {\n    LemmaMulAuto();\n    LemmaDivInductionAuto(d, x, u => 0 <= u ==> u - d < u / d * d);\n  }\n\n  lemma LemmaRemainderUpperAuto()\n    ensures forall x: int, d: int {:trigger x - d, d * d} :: 0 <= x && 0 < d ==> x - d < x / d * d\n  {\n    forall (x: int, d: int | 0 <= x && 0 < d)\n      ensures x - d < x / d * d\n    {\n      LemmaRemainderUpper(x, d);\n    }\n  }\n\n  lemma LemmaRemainderLower(x: int, d: int)\n    requires 0 <= x\n    requires 0 < d\n    ensures  x >= x / d * d\n  {\n    LemmaMulAuto();\n    LemmaDivInductionAuto(d, x, u => 0 <= u ==> u >= u / d * d);\n  }\n\n  lemma LemmaRemainderLowerAuto()\n    ensures forall x: int, d: int {:trigger x / d * d} :: 0 <= x && 0 < d ==> x >= x / d * d\n  {\n    forall x: int, d: int | 0 <= x && 0 < d\n      ensures x >= x / d * d\n    {\n      LemmaRemainderLower(x, d);\n    }\n  }\n\n  lemma LemmaRemainder(x: int, d: int)\n    requires 0 <= x\n    requires 0 < d\n    ensures  0 <= x - (x / d * d) < d\n  {\n    LemmaMulAuto();\n    LemmaDivInductionAuto(d, x, u => 0 <= u - u / d * d < d);\n  }\n\n  lemma LemmaRemainderAuto()\n    ensures forall x: int, d: int {:trigger x - (x / d * d)} :: 0 <= x && 0 < d ==> 0 <= x - (x / d * d) < d\n  {\n    forall x: int, d: int | 0 <= x && 0 < d\n      ensures 0 <= x - (x / d * d) < d\n    {\n      LemmaRemainder(x, d);\n    }\n  }\n\n  /* describes fundementals of the modulus operator */\n  lemma LemmaFundamentalDivMod(x: int, d: int)\n    requires d != 0\n    ensures x == d * (x / d) + (x % d)\n  {\n    ModINL.LemmaFundamentalDivMod(x, d);\n  }\n\n  lemma LemmaFundamentalDivModAuto()\n    ensures forall x: int, d: int {:trigger d * (x / d) + (x % d)} :: d != 0 ==> x == d * (x / d) + (x % d)\n  {\n    forall x: int, d: int | d != 0\n      ensures x == d * (x / d) + (x % d)\n    {\n      LemmaFundamentalDivMod(x, d);\n    }\n  }\n\n  /* dividing a fraction by a divisor is equivalent to multiplying the fraction's \n  denominator with the divisor */\n  lemma LemmaDivDenominator(x: int,c: nat,d: nat)\n    requires 0 <= x\n    requires 0 < c\n    requires 0 < d\n    ensures c * d != 0\n    ensures (x / c) / d == x / (c * d)\n  {\n    LemmaMulStrictlyPositiveAuto();\n    var R := x % (c * d);\n    LemmaModPropertiesAuto();\n\n    LemmaDivPosIsPos(R, c);\n    if (R / c >= d) {\n      LemmaFundamentalDivMod(R, c);\n      LemmaMulInequality(d, R / c, c);\n      LemmaMulIsCommutativeAuto();\n      assert false;\n    }\n    assert R / c < d;\n\n    LemmaMulBasicsAuto();\n    LemmaFundamentalDivModConverse(R / c, d, 0, R / c);\n    assert (R / c) % d == R / c;\n\n    LemmaFundamentalDivMod(R, c);\n    assert c * (R / c) + R % c == R;\n\n    assert c * ((R / c) % d) + R % c == R;\n\n    var k := x / (c * d);\n    LemmaFundamentalDivMod(x, c * d);\n    assert x == (c * d) * (x / (c * d)) + x % (c * d);\n    assert R == x - (c * d) * (x / (c * d));\n    assert R == x - (c * d) * k;\n\n    calc {\n      c * ((x / c) % d) + x % c;\n      { LemmaModMultiplesVanish(-k, x / c, d); LemmaMulIsCommutativeAuto(); }\n      c * ((x / c + (-k) * d) % d) + x % c;\n      { LemmaHoistOverDenominator(x, (-k)*d, c); }\n      c * (((x + (((-k) * d) * c)) / c) % d) + x % c;\n      { LemmaMulIsAssociative(-k, d, c); }\n      c * (((x + ((-k) * (d * c))) / c) % d) + x % c;\n      { LemmaMulUnaryNegation(k, d * c); }\n      c * (((x + (-(k * (d * c)))) / c) % d) + x % c;\n      { LemmaMulIsAssociative(k, d, c); }\n      c * (((x + (-(k * d * c))) / c) % d) + x % c;\n      c * (((x - k * d * c) / c) % d) + x % c;\n      {\n        LemmaMulIsAssociativeAuto();\n        LemmaMulIsCommutativeAuto();\n      }\n      c * ((R / c) % d) + x % c;\n      c * (R / c) + x % c;\n      { LemmaFundamentalDivMod(R, c);\n        assert R == c * (R / c) + R % c;\n        LemmaModMod(x, c, d);\n        assert R % c == x % c;\n      }\n      R;\n      { LemmaModIsModRecursiveAuto(); }\n      R % (c * d);\n      (x - (c * d) * k) % (c * d);\n      { LemmaMulUnaryNegation(c * d, k); }\n      (x + (c * d) * (-k)) % (c * d);\n      { LemmaModMultiplesVanish(-k, x, c * d); }\n      x % (c * d);\n    }\n    calc ==> {\n      c * (x / c) + x % c - R == c * (x / c) - c * ((x / c) % d);\n      { LemmaFundamentalDivMod(x, c); }\n      x - R == c * (x / c) - c * ((x / c) % d);\n    }\n    calc ==> {\n      true;\n      { LemmaFundamentalDivMod(x / c, d); }\n      d * ((x / c) / d) == x / c - ((x / c) % d);\n      c * (d * ((x / c) / d)) == c * (x / c - ((x / c) % d));\n      { LemmaMulIsAssociativeAuto(); }\n      (c * d) * ((x / c) / d) == c * (x / c - ((x / c) % d));\n      { LemmaMulIsDistributiveAuto(); }\n      (c * d) * ((x / c) / d) == c * (x / c) - c * ((x / c) % d);\n      (c * d) * ((x / c) / d) == x - R;\n      { LemmaFundamentalDivMod(x, c * d); }\n      (c * d) * ((x / c) / d) == (c * d) * (x / (c * d)) + x % (c * d) - R;\n      (c * d) * ((x / c) / d) == (c * d) * (x / (c * d));\n      { LemmaMulEqualityConverse(c * d, (x / c) / d, x / (c * d)); }\n      (x / c) / d == x / (c * d);\n    }\n  }\n\n  lemma LemmaDivDenominatorAuto()\n    ensures forall c: nat, d: nat {:trigger c * d} :: 0 < c && 0 < d ==> c * d != 0\n    ensures forall x: int, c: nat, d: nat {:trigger (x / c) / d}\n              :: 0 <= x && 0 < c && 0 < d ==> (x / c) / d == x / (c * d)\n  {\n    LemmaMulNonzeroAuto();\n    forall x: int, c: nat, d: nat | 0 <= x && 0 < c && 0 < d\n      ensures (x / c) / d == x / (c * d)\n    {\n      LemmaDivDenominator(x, c, d);\n    }\n  }\n\n  /* multiplying an integer by a fraction is equivalent to multiplying the integer by the\n  fraction's numerator */\n  lemma LemmaMulHoistInequality(x: int, y: int, z: int)\n    requires 0 <= x\n    requires 0 < z\n    ensures x * (y / z) <= (x * y) / z\n  {\n    calc {\n      (x * y) / z;\n        { LemmaFundamentalDivMod(y, z); }\n      (x * (z * (y / z) + y % z)) / z;\n        { LemmaMulIsDistributiveAuto(); }\n      (x * (z * (y / z)) + x * (y % z)) / z;\n    >=  {\n          LemmaModPropertiesAuto();\n          LemmaMulNonnegative(x, y % z);\n          LemmaDivIsOrdered(x * (z * (y / z)), x * (z * (y / z)) + x * (y % z), z); }\n      (x * (z * (y / z))) / z;\n        { LemmaMulIsAssociativeAuto();\n          LemmaMulIsCommutativeAuto(); }\n      (z * (x * (y / z))) / z;\n        { LemmaDivMultiplesVanish(x * (y / z), z); }\n      x * (y / z);\n    }\n  }\n\n  lemma LemmaMulHoistInequalityAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * (y / z), (x * y) / z}\n              :: 0 <= x && 0 < z ==> x * (y / z) <= (x * y) / z\n  {\n    forall (x: int, y: int, z: int | 0 <= x && 0 < z)\n      ensures x * (y / z) <= (x * y) / z\n    {\n      LemmaMulHoistInequality(x, y, z);\n    }\n  }\n\n  lemma LemmaIndistinguishableQuotients(a: int, b: int, d: int)\n    requires 0 < d\n    requires 0 <= a - a % d <= b < a + d - a % d\n    ensures a / d == b / d\n  {\n    LemmaDivInductionAuto(d, a - b, ab => var u := ab + b; 0 <= u - u % d <= b < u + d - u % d ==> u / d == b / d);\n  }\n\n  lemma LemmaIndistinguishableQuotientsAuto()\n    ensures forall a: int, b: int, d: int {:trigger a / d, b / d}\n              :: 0 < d && 0 <= a - a % d <= b < a + d - a % d ==> a / d == b / d\n  {\n    forall a: int, b: int, d: int | 0 < d && 0 <= a - a % d <= b < a + d - a % d\n      ensures a / d == b / d\n    {\n      LemmaIndistinguishableQuotients(a, b, d);\n    }\n  }\n\n  /* common factors from the dividend and divisor of a modulus operation can be factored out */\n  lemma LemmaTruncateMiddle(x: int, b: int, c: int)\n    requires 0 <= x\n    requires 0 < b\n    requires 0 < c\n    ensures 0 < b * c\n    ensures (b * x) % (b * c) == b * (x % c)\n  {\n    LemmaMulStrictlyPositiveAuto();\n    LemmaMulNonnegativeAuto();\n    calc {\n      b * x;\n      { LemmaFundamentalDivMod(b * x, b * c); }\n      (b * c) * ((b * x) / (b * c)) + (b * x) % (b * c);\n      { LemmaDivDenominator(b * x, b, c); }\n      (b * c) * (((b * x) / b) / c) + (b * x) % (b * c);\n      { LemmaMulIsCommutativeAuto(); LemmaDivByMultiple(x, b); }\n      (b * c) * (x / c) + (b * x) % (b * c);\n    }\n    calc ==> {\n      true;\n      { LemmaFundamentalDivMod(x, c); }\n      x == c * (x / c) + x % c;\n      b * x == b * (c * (x / c) + x % c);\n      { LemmaMulIsDistributiveAuto(); }\n      b * x == b * (c * (x / c)) + b * (x % c);\n      { LemmaMulIsAssociativeAuto(); }\n      b * x == (b * c) * (x / c) + b * (x % c);\n    }\n  }\n\n  lemma LemmaTruncateMiddleAuto()\n    ensures forall x: int, b: int, c: int {:trigger b * (x % c)}\n              :: 0 <= x && 0 < b && 0 < c && 0 < b * c ==> (b * x) % (b * c) == b * (x % c)\n  {\n    forall x: int, b: int, c: int | 0 <= x && 0 < b && 0 < c && 0 < b * c\n      ensures (b * x) % (b * c) == b * (x % c)\n    {\n      LemmaTruncateMiddle(x, b, c);\n    }\n  }\n\n  /* multiplying the numerator and denominator by an integer does not change the quotient */\n  lemma LemmaDivMultiplesVanishQuotient(x: int, a: int, d: int)\n    requires 0 < x\n    requires 0 <= a\n    requires 0 < d\n    ensures 0 < x * d\n    ensures a / d == (x * a) / (x * d)\n  {\n    LemmaMulStrictlyPositive(x,d);\n    calc {\n      (x * a) / (x * d);\n      {\n        LemmaMulNonnegative(x, a);\n        LemmaDivDenominator(x * a, x, d); }\n      ((x * a) / x) / d;\n      { LemmaDivMultiplesVanish(a, x); }\n      a / d;\n    }\n  }\n\n  lemma LemmaDivMultiplesVanishQuotientAuto()\n    ensures forall x: int, a: int, d: int {:trigger a / d, x * d, x * a}\n              :: 0 < x && 0 <= a && 0 < d ==> 0 < x * d  &&  a / d == (x * a) / (x * d)\n  {\n    forall x: int, a: int, d: int | 0 < x && 0 <= a && 0 < d\n      ensures 0 < x * d  &&  a / d == (x * a) / (x * d)\n    {\n      LemmaDivMultiplesVanishQuotient(x, a, d);\n    }\n  }\n\n  /* rounds down when adding an integer r to the dividend a that is smaller than the divisor d, and then\n  multiplying by d */\n  lemma LemmaRoundDown(a: int, r: int, d: int)\n    requires 0 < d\n    requires a % d == 0\n    requires 0 <= r < d\n    ensures a == d * ((a + r) / d)\n  {\n    LemmaMulAuto();\n    LemmaDivInductionAuto(d, a, u => u % d == 0 ==> u == d * ((u + r) / d));\n  }\n\n  lemma LemmaRoundDownAuto()\n    ensures forall a: int, r: int, d: int {:trigger d * ((a + r) / d)}\n              :: 0 < d && a % d == 0 && 0 <= r < d ==> a == d * ((a + r) / d)\n  {\n    forall a: int, r: int, d: int | 0 < d && a % d == 0 && 0 <= r < d\n      ensures a == d * ((a + r) / d)\n    {\n      LemmaRoundDown(a, r, d);\n    }\n  }\n\n  /* this is the same as writing x + (b/d) == x when b is less than d; this is true because (b/d) == 0 */\n  lemma LemmaDivMultiplesVanishFancy(x: int, b: int, d: int)\n    requires 0 < d\n    requires 0 <= b < d\n    ensures (d * x + b) / d == x\n  {\n    LemmaDivAuto(d);\n    var f := u => (d * u + b) / d == u;\n    LemmaMulInductionAuto(x, f);\n    assert f(x);\n  }\n\n  lemma LemmaDivMultiplesVanishFancyAuto()\n    ensures forall x: int, b: int, d: int {:trigger (d * x + b) / d}\n              :: 0 < d && 0 <= b < d ==> (d * x + b) / d == x\n  {\n    forall x: int, b: int, d: int | 0 < d && 0 <= b < d\n      ensures (d * x + b) / d == x\n    {\n      LemmaDivMultiplesVanishFancy(x, b, d);\n    }\n  }\n\n  /* multiplying an integer by a common numerator and denominator results in the original integer */\n  lemma LemmaDivMultiplesVanish(x: int, d: int)\n    requires 0 < d\n    ensures (d * x) / d == x\n  {\n    LemmaDivMultiplesVanishFancy(x, 0, d);\n  }\n\n  lemma LemmaDivMultiplesVanishAuto()\n    ensures forall x: int, d: int {:trigger (d * x) / d} :: 0 < d ==> (d * x) / d == x\n  {\n    forall x: int, d: int | 0 < d\n      ensures (d * x) / d == x\n    {\n      LemmaDivMultiplesVanish(x, d);\n    }\n  }\n\n  /* multiplying a whole number by a common numerator and denominator results in the original integer */\n  lemma LemmaDivByMultiple(b: int, d: int)\n    requires 0 <= b\n    requires 0 < d\n    ensures  (b * d) / d == b\n  {\n    LemmaDivMultiplesVanish(b,d);\n  }\n\n  lemma LemmaDivByMultipleAuto()\n    ensures forall b: int, d: int {:trigger (b * d) / d} :: 0 <= b && 0 < d ==> (b * d) / d == b\n  {\n    forall b: int, d: int | 0 <= b && 0 < d\n      ensures (b * d) / d == b\n    {\n      LemmaDivByMultiple(b, d);\n    }\n  }\n\n  /* a dividend y that is a positive multiple of the divisor z will always yield a greater quotient \n  than a dividend x that is less than y */\n  lemma LemmaDivByMultipleIsStronglyOrdered(x: int, y: int, m: int, z: int)\n    requires x < y\n    requires y == m * z\n    requires 0 < z\n    ensures  x / z < y / z\n  {\n    LemmaModMultiplesBasic(m, z);\n    LemmaDivInductionAuto(z, y - x, yx => var u := yx + x; x < u && u % z == 0 ==> x / z < u / z);\n  }\n\n  lemma LemmaDivByMultipleIsStronglyOrderedAuto()\n    ensures forall x: int, y: int, m: int, z: int {:trigger x / z, m * z, y / z}\n              :: x < y && y == m * z && 0 < z ==> x / z < y / z\n  {\n    forall x: int, y: int, m: int, z: int | x < y && y == m * z && 0 < z\n      ensures x / z < y / z\n    {\n      LemmaDivByMultipleIsStronglyOrdered(x, y, m, z);\n    }\n  }\n\n  /* if an integer a is less than or equal to the product of two other integers b and c, then the \n  quotient of a/b will be less than or equal to c */\n  lemma LemmaMultiplyDivideLe(a: int, b: int, c: int)\n    requires 0 < b\n    requires a <= b * c\n    ensures  a / b <= c\n  {\n    LemmaModMultiplesBasic(c, b);\n    LemmaDivInductionAuto(b, b * c - a, i => 0 <= i && (i + a) % b == 0 ==> a / b <= (i + a) / b);\n    LemmaDivMultiplesVanish(c, b);\n  }\n\n  lemma LemmaMultiplyDivideLeAuto()\n    ensures forall a: int, b: int, c: int {:trigger a / b , b * c} :: 0 < b && a <= b * c ==> a / b <= c\n  {\n    forall a: int, b: int, c: int | 0 < b && a <= b * c\n      ensures a / b <= c\n    {\n      LemmaMultiplyDivideLe(a, b, c);\n    }\n  }\n\n  /* if an integer a is less than the product of two other integers b and c, then the quotient \n  of a/b will be less than c */\n  lemma LemmaMultiplyDivideLt(a: int, b: int, c: int)\n    requires 0 < b\n    requires a < b * c\n    ensures  a / b < c\n  {\n    LemmaModMultiplesBasic(c, b);\n    LemmaDivInductionAuto(b, b * c - a, i => 0 < i && (i + a) % b == 0 ==> a / b < (i + a) / b);\n    LemmaDivMultiplesVanish(c, b);\n  }\n\n  lemma LemmaMultiplyDivideLtAuto()\n    ensures forall a: int, b: int, c: int {:trigger a / b, b * c} :: 0 < b && a < b * c ==> a / b < c\n  {\n    forall a: int, b: int, c: int | 0 < b && a < b * c\n      ensures a / b < c\n    {\n      LemmaMultiplyDivideLt(a, b, c);\n    }\n  }\n\n  /* expresses the equality of giving fractions common denominators and then adding them together */\n  lemma LemmaHoistOverDenominator(x: int, j: int, d: nat)\n    requires 0 < d\n    ensures x / d + j == (x + j * d) / d\n  {\n    LemmaDivAuto(d);\n    LemmaMulInductionAuto(j, u => x / d  + u == (x + u * d) / d);\n  }\n\n  lemma LemmaHoistOverDenominatorAuto()\n    ensures forall x: int, j: int, d: nat {:trigger  x / d + j} :: 0 < d ==> x / d + j == (x + j * d) / d\n  {\n    forall x: int, j: int, d: nat | 0 < d\n      ensures x / d + j == (x + j * d) / d\n    {\n      LemmaHoistOverDenominator(x, j, d);\n    }\n  }\n\n  lemma LemmaPartBound1(a: int, b: int, c: int)\n    requires 0 <= a\n    requires 0 < b\n    requires 0 < c\n    ensures 0 < b * c\n    ensures (b * (a / b) % (b * c)) <= b * (c - 1)\n  {\n    LemmaMulStrictlyPositiveAuto();\n    calc {\n      b * (a / b) % (b * c);\n      { LemmaFundamentalDivMod(b * (a / b), b * c); }\n      b * (a / b) - (b * c) * ((b * (a / b)) / (b * c));\n      { LemmaMulIsAssociativeAuto(); }\n      b * (a / b) - b * (c * ((b * (a / b)) / (b * c)));\n      { LemmaMulIsDistributiveAuto(); }\n      b * ((a / b) - (c * ((b * (a / b)) / (b * c))));\n    }\n\n    calc ==> {\n      true;\n      { LemmaModPropertiesAuto(); }\n      b * (a / b) % (b * c) < b * c;\n      b * ((a / b) - (c * ((b * (a / b)) / (b * c)))) < b * c;\n      { LemmaMulIsCommutativeAuto(); LemmaMulStrictInequalityConverseAuto(); }\n      ((a / b) - (c * ((b * (a / b)) / (b * c)))) < c;\n      ((a / b) - (c * ((b * (a / b)) / (b * c)))) <= c - 1;\n      { LemmaMulIsCommutativeAuto(); LemmaMulInequalityAuto(); }\n      b * ((a / b) - (c * ((b * (a / b)) / (b * c)))) <= b * (c - 1);\n      b * (a / b) % (b * c) <= b * (c - 1);\n    }\n  }\n\n  lemma LemmaPartBound1Auto()\n    ensures forall a: int, b: int, c: int {:trigger b * (a / b) % (b * c)}\n              :: 0 <= a && 0 < b && 0 < c ==> 0 < b * c && (b * (a / b) % (b * c)) <= b * (c - 1)\n  {\n    forall a: int, b: int, c: int | 0 <= a && 0 < b && 0 < c\n      ensures 0 < b * c && (b * (a / b) % (b * c)) <= b * (c - 1)\n    {\n      LemmaPartBound1(a, b, c);\n    }\n  }\n\n\n  /*******************************************************************************\n   * Modulus:\n   *******************************************************************************/\n\n  /* the common syntax of the modulus operation results in the same remainder as recursively\n  calculating the modulus */\n  lemma LemmaModIsModRecursive(x: int, m: int)\n    requires m > 0\n    ensures ModRecursive(x, m) == x % m\n    decreases if x < 0 then -x + m else x\n  {\n    reveal ModRecursive();\n    if x < 0 {\n      calc {\n        ModRecursive(x, m);\n        ModRecursive(x + m, m);\n        { LemmaModIsModRecursive(x + m, m); }\n        (x + m) % m;\n        { LemmaAddModNoop(x, m, m); }\n        ((x % m) + (m % m)) % m;\n        { LemmaModBasicsAuto(); }\n        (x % m) % m;\n        { LemmaModBasicsAuto(); }\n        x % m;\n      }\n    } else if x < m {\n      LemmaSmallMod(x, m);\n    } else {\n      calc {\n        ModRecursive(x, m);\n        ModRecursive(x - m, m);\n        { LemmaModIsModRecursive(x - m, m); }\n        (x - m) % m;\n        { LemmaSubModNoop(x, m, m); }\n        ((x % m) - (m % m)) % m;\n        { LemmaModBasicsAuto(); }\n        (x % m) % m;\n        { LemmaModBasicsAuto(); }\n        x % m;\n      }\n    }\n  }\n\n  lemma LemmaModIsModRecursiveAuto()\n    ensures forall x: int, d: int {:trigger x % d}:: d > 0 ==> ModRecursive(x, d) == x % d\n  {\n    reveal ModRecursive();\n    forall x: int, d: int | d > 0\n      ensures ModRecursive(x, d) == x % d\n    {\n      LemmaModIsModRecursive(x, d);\n    }\n  }\n\n  /* proves basic properties of the modulus operation: any integer divided by itself does not have a\n  remainder; performing (x % m) % m gives the same result as simply perfoming x % m  */\n  lemma LemmaModBasicsAuto()\n    ensures forall m: int {:trigger m % m} :: m > 0 ==> m % m == 0\n    ensures forall x: int, m: int {:trigger (x % m) % m} :: m > 0 ==> (x % m) % m == x % m\n  {\n    forall m: int | m > 0\n      ensures m % m == 0\n    {\n      LemmaModAuto(m);\n    }\n    forall x: int, m: int | m > 0\n      ensures (x % m) % m == x % m\n    {\n      LemmaModAuto(m);\n    }\n  }\n\n  /* describes the properties of the modulus operation including those described in LemmaModBasicsAuto. \n  This lemma also states that the remainder of any division will be less than the divisor's value  */\n  lemma LemmaModPropertiesAuto()\n    ensures forall m: int {:trigger m % m} :: m > 0 ==> m % m == 0\n    ensures forall x: int, m: int {:trigger (x % m) % m} :: m > 0 ==> (x % m) % m == x % m\n    ensures forall x: int, m: int {:trigger x % m} :: m > 0 ==> 0 <= x % m < m\n  {\n    LemmaModBasicsAuto();\n\n    forall x: int, m: int | m > 0\n      ensures 0 <= x % m < m\n    {\n      LemmaModAuto(m);\n    }\n  }\n\n  /* the remainder of a natural number x divided by a natural number d will be less\n  than or equal to x */\n  lemma LemmaModDecreases(x: nat, m: nat)\n    requires 0 < m\n    ensures x % m <= x\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaModDecreasesAuto()\n    ensures forall x: nat, m: nat {:trigger x % m} :: 0 < m ==> x % m <= x\n  {\n    forall x: nat, m: nat | 0 < m\n      ensures x % m <= x\n    {\n      LemmaModDecreases(x, m);\n    }\n  }\n\n  /* if x % y is zero and x is greater than zero, x is greater than y. */\n  lemma LemmaModIsZero(x: nat, m: nat)\n    requires x > 0 && m > 0\n    requires x % m == 0\n    ensures x >= m\n  {\n    calc ==> {\n      x < m;\n      { LemmaSmallMod(x, m); }\n      x % m == x;\n      false;\n    }\n  }\n\n  lemma LemmaModIsZeroAuto()\n    ensures forall x: nat, m: nat {:trigger x % m} :: (x > 0 && m > 0\n                                                       && x % m == 0) ==> x >= m\n  {\n    forall x: nat, m: nat | x > 0 && m > 0 && x % m == 0\n      ensures x >= m\n    {\n      LemmaModIsZero(x, m);\n    }\n  }\n\n  /* a dividend that is any multiple of the divisor will result in a remainder of 0 */\n  lemma LemmaModMultiplesBasic(x: int, m: int)\n    requires m > 0\n    ensures (x * m) % m == 0\n  {\n    LemmaModAuto(m);\n    LemmaMulInductionAuto(x, u => (u * m) % m == 0);\n  }\n\n  lemma LemmaModMultiplesBasicAuto()\n    ensures forall x: int, m: int {:trigger (x * m) % m} :: m > 0 ==> (x * m) % m == 0\n  {\n    forall x: int, m: int | m > 0\n      ensures (x * m) % m == 0\n    {\n      LemmaModMultiplesBasic(x, m);\n    }\n  }\n\n  /* the remainder of adding the divisor m to the dividend b will be the same\n  as simply performing b % m */\n  lemma LemmaModAddMultiplesVanish(b: int, m: int)\n    requires 0 < m\n    ensures (m + b) % m == b % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaModAddMultiplesVanishAuto()\n    ensures forall b: int, m: int {:trigger b % m} :: 0 < m ==> (m + b) % m == b % m\n  {\n    forall b: int, m: int | 0 < m\n      ensures (m + b) % m == b % m\n    {\n      LemmaModAddMultiplesVanish(b, m);\n    }\n  }\n\n  /* the remainder of subtracting the divisor m from the dividend b will be the same\n  as simply performing b % m */\n  lemma LemmaModSubMultiplesVanish(b: int, m: int)\n    requires 0 < m\n    ensures (-m + b) % m == b % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaModSubMultiplesVanishAuto()\n    ensures forall b: int, m: int {:trigger b % m} :: 0 < m ==> (-m + b) % m == b % m\n  {\n    forall b: int, m: int | 0 < m\n      ensures (-m + b) % m == b % m\n    {\n      LemmaModSubMultiplesVanish(b, m);\n    }\n  }\n\n  /* the remainder of adding any multiple of the divisor m to the dividend b will be the same\n  as simply performing b % m */\n  lemma LemmaModMultiplesVanish(a: int, b: int, m: int)\n    decreases if a > 0 then a else -a\n    requires 0 < m\n    ensures (m * a + b) % m == b % m\n  {\n    LemmaModAuto(m);\n    LemmaMulInductionAuto(a, u => (m * u + b) % m == b % m);\n  }\n\n  lemma LemmaModMultiplesVanishAuto()\n    ensures forall a: int, b: int, m: int {:trigger (m * a + b) % m} :: 0 < m ==> (m * a + b) % m == b % m\n  {\n    forall a: int, b: int, m: int | 0 < m\n      ensures (m * a + b) % m == b % m\n    {\n      LemmaModMultiplesVanish(a, b, m);\n    }\n  }\n\n  /* proves equivalent forms of modulus subtraction */\n  lemma LemmaModSubtraction(x: nat, s: nat, d: nat)\n    requires 0 < d\n    requires 0 <= s <= x % d\n    ensures x % d - s % d == (x - s) % d\n  {\n    LemmaModAuto(d);\n  }\n\n  lemma LemmaModSubtractionAuto()\n    ensures forall x: nat, s: nat, d: nat {:trigger (x - s) % d}\n              :: 0 < d && 0 <= s <= x % d ==> x % d - s % d == (x - s) % d\n  {\n    forall x: nat, s: nat, d: nat | 0 < d && 0 <= s <= x % d\n      ensures x % d - s % d == (x - s) % d\n    {\n      LemmaModSubtraction(x, s, d);\n    }\n  }\n\n  /* describes expanded and succinct version of modulus operator in relation to addition (read \"ensures\") */\n  lemma LemmaAddModNoop(x: int, y: int, m: int)\n    requires 0 < m\n    ensures ((x % m) + (y % m)) % m == (x + y) % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaAddModNoopAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x + y) % m}\n              :: 0 < m ==> ((x % m) + (y % m)) % m == (x + y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures ((x % m) + (y % m)) % m == (x + y) % m\n    {\n      LemmaAddModNoop(x, y, m);\n    }\n  }\n\n  /* describes expanded and succinct version of modulus operator in relation to addition (read \"ensures\") */\n  lemma LemmaAddModNoopRight(x: int, y: int, m: int)\n    requires 0 < m\n    ensures (x + (y % m)) % m == (x + y) % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaAddModNoopRightAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x + y) % m}\n              :: 0 < m ==> (x + (y % m)) % m == (x + y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures (x + (y % m)) % m == (x + y) % m\n    {\n      LemmaAddModNoopRight(x, y, m);\n    }\n  }\n\n  /* describes expanded and succinct version of modulus operator in relation to subtraction (read \"ensures\") */\n  lemma LemmaSubModNoop(x: int, y: int, m: int)\n    requires 0 < m\n    ensures ((x % m) - (y % m)) % m == (x - y) % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaSubModNoopAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x - y) % m}\n              :: 0 < m ==> ((x % m) - (y % m)) % m == (x - y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures ((x % m) - (y % m)) % m == (x - y) % m\n    {\n      LemmaSubModNoop(x, y, m);\n    }\n  }\n\n  /* describes expanded and succinct version of modulus operator in relation to subtraction (read \"ensures\") */\n  lemma LemmaSubModNoopRight(x: int, y: int, m: int)\n    requires 0 < m\n    ensures (x - (y % m)) % m == (x - y) % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaSubModNoopRightAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x - y) % m}\n              :: 0 < m ==> (x - (y % m)) % m == (x - y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures (x - (y % m)) % m == (x - y) % m\n    {\n      LemmaSubModNoopRight(x, y, m);\n    }\n  }\n\n  /* proves equivalent forms of modulus addition */\n  lemma LemmaModAdds(a: int, b: int, d: int)\n    requires 0 < d\n    ensures a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d)\n    ensures (a % d + b % d) < d ==> a % d + b % d == (a + b) % d\n  {\n    LemmaMulAuto();\n    LemmaDivAuto(d);\n  }\n\n  lemma LemmaModAddsAuto()\n    ensures forall a: int, b: int, d: int {:trigger (a + b) % d}\n              :: 0 < d ==> && a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d)\n                           && ((a % d + b % d) < d ==> a % d + b % d == (a + b) % d)\n  {\n    forall a: int, b: int, d: int | 0 < d\n      ensures && a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d)\n              && ((a % d + b % d) < d ==> a % d + b % d == (a + b) % d)\n    {\n      LemmaModAdds(a, b, d);\n    }\n  }\n\n  lemma {:vcs_split_on_every_assert} LemmaModNegNeg(x: int, d: int)\n    requires 0 < d\n    ensures x % d == (x * (1 - d)) % d\n  {\n    assert (x - x * d) % d == x % d\n    by {\n      LemmaModAuto(d);\n      var f := i => (x - i * d) % d == x % d;\n      assert  MulAuto() ==> && f(0)\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                            && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1));\n      LemmaMulInductionAuto(x, f);\n    }\n    LemmaMulAuto();\n  }\n\n  /* proves the validity of the quotient and remainder */\n  lemma {:timeLimitMultiplier 5} LemmaFundamentalDivModConverse(x: int, d: int, q: int, r: int)\n    requires d != 0\n    requires 0 <= r < d\n    requires x == q * d + r\n    ensures q == x / d\n    ensures r == x % d\n  {\n    LemmaDivAuto(d);\n    LemmaMulInductionAuto(q, u => u == (u * d + r) / d);\n    LemmaMulInductionAuto(q, u => r == (u * d + r) % d);\n  }\n\n  lemma {:timeLimitMultiplier 5} LemmaFundamentalDivModConverseAuto()\n    ensures forall x: int, d: int, q: int, r: int {:trigger q * d + r, x % d}\n              :: d != 0 && 0 <= r < d && x == q * d + r ==> q == x / d && r == x % d\n  {\n    forall x: int, d: int, q: int, r: int | d != 0 && 0 <= r < d && x == q * d + r\n      ensures q == x / d && r == x % d\n    {\n      LemmaFundamentalDivModConverse(x, d, q, r);\n    }\n  }\n\n\n  /* the remainder of any natural number x divided by a positive integer m is always less than m */\n  lemma LemmaModPosBound(x: int, m: int)\n    decreases x\n    requires 0 <= x\n    requires 0 < m\n    ensures  0 <= x % m < m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaModPosBoundAuto()\n    ensures forall x: int, m: int {:trigger x % m} :: 0 <= x && 0 < m ==> 0 <= x % m < m\n  {\n    forall x: int, m: int | 0 <= x && 0 < m\n      ensures 0 <= x % m < m\n    {\n      LemmaModPosBound(x, m);\n    }\n  }\n\n  lemma LemmaMulModNoopLeft(x: int, y: int, m: int)\n    requires 0 < m\n    ensures (x % m) * y % m == x * y % m\n  {\n    LemmaModAuto(m);\n    LemmaMulInductionAuto(y, u => (x % m) * u % m == x * u % m);\n  }\n\n  lemma LemmaMulModNoopLeftAuto()\n    ensures forall x: int, y: int, m: int {:trigger x * y % m} :: 0 < m ==> (x % m) * y % m == x * y % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures (x % m) * y % m == x * y % m\n    {\n      LemmaMulModNoopLeft(x, y, m);\n    }\n  }\n\n  lemma LemmaMulModNoopRight(x: int, y: int, m: int)\n    requires 0 < m\n    ensures x * (y % m) % m == (x * y) % m\n  {\n    LemmaModAuto(m);\n    LemmaMulInductionAuto(x, u => u * (y % m) % m == (u * y) % m);\n  }\n\n  lemma LemmaMulModNoopRightAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x * y) % m}\n              :: 0 < m ==> x * (y % m) % m == (x * y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures x * (y % m) % m == (x * y) % m\n    {\n      LemmaMulModNoopRight(x, y, m);\n    }\n  }\n\n  /* combines previous no-op mod lemmas into a general, overarching lemma */\n  lemma LemmaMulModNoopGeneral(x: int, y: int, m: int)\n    requires 0 < m\n    ensures ((x % m) * y      ) % m == (x * y) % m\n    ensures ( x      * (y % m)) % m == (x * y) % m\n    ensures ((x % m) * (y % m)) % m == (x * y) % m\n  {\n    LemmaModPropertiesAuto();\n    LemmaMulModNoopLeft(x, y, m);\n    LemmaMulModNoopRight(x, y, m);\n    LemmaMulModNoopRight(x % m, y, m);\n  }\n\n  lemma LemmaMulModNoopGeneralAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x * y) % m}\n              :: 0 < m ==> ((x % m) * y) % m == (x * (y % m)) % m == ((x % m) * (y % m)) % m == (x * y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures ((x % m) * y) % m == (x * (y % m)) % m == ((x % m) * (y % m)) % m == (x * y) % m\n    {\n      LemmaMulModNoopGeneral(x, y, m);\n    }\n  }\n\n  lemma LemmaMulModNoop(x: int, y: int, m: int)\n    requires 0 < m\n    ensures (x % m) * (y % m) % m == (x * y) % m\n  {\n    LemmaMulModNoopGeneral(x, y, m);\n  }\n\n  lemma LemmaMulModNoopAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x * y) % m}\n              :: 0 < m ==> (x % m) * (y % m) % m == (x * y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures (x % m) * (y % m) % m == (x * y) % m\n    {\n      LemmaMulModNoop(x, y, m);\n    }\n  }\n\n  /* proves modulus equivalence in two forms */\n  lemma LemmaModEquivalence(x: int, y: int, m: int)\n    requires 0 < m\n    ensures x % m == y % m <==> (x - y) % m == 0\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaModEquivalenceAuto()\n    ensures forall x: int, y: int, m: int {:trigger  x % m , y % m}\n              :: 0 < m && x % m == y % m <==> 0 < m && (x - y) % m == 0\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures x % m == y % m <==> 0 < m && (x - y) % m == 0\n    {\n      LemmaModEquivalence(x, y, m);\n    }\n  }\n\n  /* true if x%n and y%n are equal */\n  ghost predicate IsModEquivalent(x: int, y: int, m: int)\n    requires m > 0\n    ensures x % m == y % m <==> (x - y) % m == 0\n  {\n    LemmaModEquivalence(x, y, m);\n    (x - y) % m == 0 // same as x % n == y % n, but easier to do induction on x - y than x and y separately\n  }\n\n  /* if x % m == y % m, then (x * z) % m == (y * z) % m. */\n  lemma LemmaModMulEquivalent(x: int, y: int, z: int, m: int)\n    requires m > 0\n    requires IsModEquivalent(x, y, m)\n    ensures IsModEquivalent(x * z, y * z, m)\n  {\n    LemmaMulModNoopLeft(x, z, m);\n    LemmaMulModNoopLeft(y, z, m);\n  }\n\n  lemma LemmaModMulEquivalentAuto()\n    ensures forall x: int, y: int, z: int, m: int\n              {:trigger IsModEquivalent(x * z, y * z, m)}\n              :: m > 0 && IsModEquivalent(x, y, m) ==> IsModEquivalent(x * z, y * z, m)\n  {\n    forall x: int, y: int, z: int, m: int | m > 0 && IsModEquivalent(x, y, m)\n      ensures IsModEquivalent(x * z, y * z, m)\n    {\n      LemmaModMulEquivalent(x, y, z, m);\n    }\n  }\n\n  /* the remainder can increase with a larger divisor */\n  lemma LemmaModOrdering(x: int, k: int, d: int)\n    requires 1 < d\n    requires 0 < k\n    ensures 0 < d * k\n    ensures x % d <= x % (d * k)\n  {\n    LemmaMulStrictlyIncreases(d,k);\n    calc {\n      x % d + d * (x / d);\n      { LemmaFundamentalDivMod(x, d); }\n      x;\n      { LemmaFundamentalDivMod(x, d * k); }\n      x % (d * k) + (d * k) * (x / (d * k));\n      { LemmaMulIsAssociativeAuto(); }\n      x % (d * k) + d * (k * (x / (d * k)));\n    }\n    calc {\n      x % d;\n       { LemmaModPropertiesAuto(); }\n      (x % d) % d;\n       { LemmaModMultiplesVanish(x / d  - k * (x / (d * k)), x % d, d); }\n      (x % d + d * (x / d  - k * (x / (d * k)))) % d;\n       { LemmaMulIsDistributiveSubAuto(); }\n      (x % d + d * (x / d) - d * (k * (x / (d * k)))) % d;\n      (x % (d * k)) % d;\n    <= { LemmaModPropertiesAuto();\n         LemmaModDecreases(x % (d * k), d); }\n      x % (d * k);\n    }\n  }\n\n  lemma LemmaModOrderingAuto()\n    ensures forall x: int, k: int, d: int {:trigger x % (d * k)}\n              :: 1 < d && 0 < k ==> 0 < d * k && x % d <= x % (d * k)\n  {\n    forall x: int, k: int, d: int | 1 < d && 0 < k\n      ensures d * k > 0 && x % d <= x % (d * k)\n    {\n      LemmaModOrdering(x, k, d);\n    }\n  }\n\n  lemma LemmaModMod(x: int, a: int, b: int)\n    requires 0 < a\n    requires 0 < b\n    ensures 0 < a * b\n    ensures (x % (a * b)) % a == x % a\n  {\n    LemmaMulStrictlyPositiveAuto();\n    calc {\n      x;\n      { LemmaFundamentalDivMod(x, a * b); }\n      (a * b) * (x / (a * b)) + x % (a * b);\n      { LemmaMulIsAssociativeAuto(); }\n      a * (b * (x / (a * b))) + x % (a * b);\n      { LemmaFundamentalDivMod(x % (a * b), a); }\n      a * (b * (x / (a * b))) + a * (x % (a * b) / a) + (x % (a * b)) % a;\n      { LemmaMulIsDistributiveAuto(); }\n      a * (b * (x / (a * b)) + x % (a * b) / a) + (x % (a * b)) % a;\n    }\n    LemmaModPropertiesAuto();\n    LemmaMulIsCommutativeAuto();\n    LemmaFundamentalDivModConverse(x, a, b * (x / (a * b)) + x % (a * b) / a, (x % (a * b)) % a);\n  }\n\n  lemma LemmaModModAuto()\n    ensures forall x: int, a: int, b: int {:trigger a * b, x % a}\n              :: 0 < a && 0 < b ==> 0 < a * b && (x % (a * b)) % a == x % a\n  {\n    forall x: int, a: int, b: int | 0 < a && 0 < b\n      ensures 0 < a * b && (x % (a * b)) % a == x % a\n    {\n      LemmaModMod(x, a, b);\n    }\n  }\n\n  lemma LemmaPartBound2(x: int, y: int, z: int)\n    requires 0 <= x\n    requires 0 < y\n    requires 0 < z\n    ensures y * z > 0\n    ensures (x % y) % (y * z) < y\n  {\n    LemmaMulStrictlyPositiveAuto();\n    LemmaModPropertiesAuto();\n    assert x % y < y;\n    LemmaMulIncreasesAuto();\n    LemmaMulIsCommutativeAuto();\n    assert y <= y * z;\n    assert 0 <= x % y < y * z;\n    LemmaModPropertiesAuto();\n    LemmaSmallMod(x % y, y * z);\n    assert (x % y) % (y * z) == x % y;\n  }\n\n  lemma LemmaPartBound2Auto()\n    ensures forall x: int, y: int, z: int {:trigger y * z, x % y}\n              :: 0 <= x && 0 < y && 0 < z ==> y * z > 0 && (x % y) % (y * z) < y\n  {\n    forall x: int, y: int, z: int | 0 <= x && 0 < y && 0 < z\n      ensures y * z > 0 && (x % y) % (y * z) < y\n    {\n      LemmaPartBound2(x, y, z);\n    }\n  }\n\n  /* ensures the validity of an expanded form of the modulus operation,\n   as expressed in the pre and post conditions */\n  lemma LemmaModBreakdown(x: int, y: int, z: int)\n    requires 0 <= x\n    requires 0 < y\n    requires 0 < z\n    ensures y * z > 0\n    ensures x % (y * z) == y * ((x / y) % z) + x % y\n  {\n    LemmaMulStrictlyPositiveAuto();\n    LemmaDivPosIsPos(x, y);\n    assert 0 <= x / y;\n\n    calc {\n      (y * (x / y)) % (y * z) + (x % y) % (y * z);\n    <=    { LemmaPartBound1(x, y, z); }\n      y * (z - 1) + (x % y) % (y * z);\n    <    { LemmaPartBound2(x, y, z); }\n      y * (z - 1) + y;\n          { LemmaMulBasicsAuto(); }\n      y * (z - 1) + y * 1;\n          { LemmaMulIsDistributiveAuto(); }\n      y * (z - 1 + 1);\n      y * z;\n    }\n\n    calc {\n      x % (y * z);\n      { LemmaFundamentalDivMod(x, y); }\n      (y * (x / y) + x%  y) % (y * z);\n      {\n        LemmaModPropertiesAuto();\n        assert 0 <= x % y;\n        LemmaMulNonnegative(y, x / y);\n        assert (y * (x / y)) % (y * z) + (x % y) % (y * z) < y * z;\n        LemmaModAdds(y * (x / y), x % y, y * z);\n      }\n      (y * (x / y)) % (y * z) + (x % y) % (y * z);\n      {\n        LemmaModPropertiesAuto();\n        LemmaMulIncreases(z, y);\n        LemmaMulIsCommutativeAuto();\n        assert x % y < y <= y * z;\n        LemmaSmallMod(x % y, y * z);\n        assert (x % y) % (y * z) == x % y;\n      }\n      (y * (x / y)) % (y * z) + x % y;\n      { LemmaTruncateMiddle(x / y, y, z); }\n      y * ((x / y) % z) + x % y;\n    }\n  }\n\n  lemma LemmaModBreakdownAuto()\n    ensures forall x: int, y: int, z: int {:trigger x % (y * z)}\n              :: 0 <= x && 0 < y && 0 < z ==> y * z > 0 && x % (y * z) == y * ((x / y) % z) + x % y\n  {\n    forall x: int, y: int, z: int | 0 <= x && 0 < y && 0 < z\n      ensures y * z > 0 && x % (y * z) == y * ((x / y) % z) + x % y\n    {\n      LemmaModBreakdown(x, y, z);\n    }\n  }\n\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Mul.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* Every lemma comes in 2 forms: 'LemmaProperty' and 'LemmaPropertyAuto'. The\nformer takes arguments and may be more stable and less reliant on Z3\nheuristics. The latter includes automation and its use requires less effort */\n\ninclude \"Internals/MulInternalsNonlinear.dfy\"\ninclude \"Internals/MulInternals.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Mul {\n\n  import MulINL = MulInternalsNonlinear\n  import opened MulInternals\n\n  /* the built-in syntax of multiplication results in the same product as multiplication \n  through recursive addition */\n  lemma LemmaMulIsMulRecursive(x: int, y: int)\n    ensures x * y == MulRecursive(x, y)\n  {\n    if (x >= 0) { LemmaMulIsMulPos(x, y); }\n    if (x <= 0) { LemmaMulIsMulPos(-x, y); }\n    LemmaMulAuto();\n  }\n\n  lemma LemmaMulIsMulRecursiveAuto()\n    ensures forall x: int, y: int :: x * y == MulRecursive(x, y)\n  {\n    forall x: int, y: int\n      ensures x * y == MulRecursive(x, y)\n    {\n      LemmaMulIsMulRecursive(x, y);\n    }\n  }\n\n  /* the built-in syntax of multiplying two positive integers results in the same product as \n  MulPos, which is achieved by recursive addition */\n  lemma LemmaMulIsMulPos(x: int, y: int)\n    requires x >= 0\n    ensures x * y == MulPos(x, y)\n  {\n    reveal MulPos();\n    LemmaMulInductionAuto(x, u => u >= 0 ==> u * y == MulPos(u, y));\n  }\n\n  /* ensures that the basic properties of multiplication, including the identity and zero properties */\n  lemma LemmaMulBasics(x: int)\n    ensures 0 * x == 0\n    ensures x * 0 == 0\n    ensures 1 * x == x\n    ensures x * 1 == x\n  {\n  }\n\n  lemma LemmaMulBasicsAuto()\n    ensures forall x: int {:trigger 0 * x} :: 0 * x == 0\n    ensures forall x: int {:trigger x * 0} :: x * 0 == 0\n    ensures forall x: int {:trigger 1 * x} :: 1 * x == x\n    ensures forall x: int {:trigger x * 1} :: x * 1 == x\n  {\n  }\n\n  /* multiplying two nonzero integers will never result in 0 as the poduct */\n  lemma LemmaMulNonzero(x: int, y: int)\n    ensures x * y != 0 <==> x != 0 && y != 0\n  {\n    MulINL.LemmaMulNonzero(x, y);\n  }\n\n  /* multiplying any two nonzero integers will never result in 0 as the poduct */\n  lemma LemmaMulNonzeroAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: x * y != 0 <==> x != 0 && y != 0\n  {\n    forall (x: int, y: int)\n      ensures x * y != 0 <==> x != 0 && y != 0;\n    {\n      LemmaMulNonzero(x, y);\n    }\n  }\n\n  /* any integer multiplied by 0 results in a product of 0 */\n  lemma LemmaMulByZeroIsZeroAuto()\n    ensures forall x: int {:trigger 0 * x} {:trigger x * 0} :: x * 0 == 0 * x == 0\n  {\n    forall x: int {:trigger 0 * x} {:trigger x * 0}\n      ensures x * 0 == 0 * x == 0\n    {\n      LemmaMulBasics(x);\n    }\n  }\n\n  /* multiplication is associative */\n  lemma LemmaMulIsAssociative(x: int, y: int, z: int)\n    ensures x * (y * z) == (x * y) * z\n  {\n    MulINL.LemmaMulIsAssociative(x, y, z);\n  }\n\n  /* multiplication is always associative for all integers*/\n  lemma LemmaMulIsAssociativeAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * (y * z)} {:trigger (x * y) * z}\n              :: x * (y * z) == (x * y) * z\n  {\n    forall (x: int, y: int, z: int)\n      ensures x * (y * z) == (x * y) * z\n    {\n      LemmaMulIsAssociative(x, y, z);\n    }\n  }\n\n  /* multiplication is commutative */\n  lemma LemmaMulIsCommutative(x: int, y: int)\n    ensures x * y == y * x\n  {\n  }\n\n  /* multiplication is always commutative for all integers */\n  lemma LemmaMulIsCommutativeAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: x * y == y * x\n  {\n  }\n\n  /* the product of two integers is greater than the value of each individual integer */\n  lemma LemmaMulOrdering(x: int, y: int)\n    requires x != 0\n    requires y != 0\n    requires 0 <= x * y\n    ensures x * y >= x && x * y >= y\n  {\n    MulINL.LemmaMulOrdering(x, y);\n  }\n\n  /* the product of two positive integers is always greater than the individual value of either \n  multiplied integer */\n  lemma LemmaMulOrderingAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: (0 != x && 0 != y && x * y >= 0) ==> x * y >= x && x * y >= y\n  {\n    forall x: int, y: int | 0 != x && 0 != y && x * y >= 0\n      ensures x * y >= x && x * y >= y\n    {\n      LemmaMulOrdering(x, y);\n    }\n  }\n\n  lemma LemmaMulEquality(x: int, y: int, z: int)\n    requires x == y\n    ensures x * z == y * z\n  {}\n\n  lemma LemmaMulEqualityAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * z, y * z } :: x == y ==> x * z == y * z\n  {\n    forall (x: int, y: int, z: int | x == y)\n      ensures x * z == y * z\n    {\n      LemmaMulEquality(x, y, z);\n    }\n  }\n\n  /* two integers that are multiplied by a positive number will maintain their numerical order */\n  lemma LemmaMulInequality(x: int, y: int, z: int)\n    requires x <= y\n    requires z >= 0\n    ensures  x * z <= y * z\n  {\n    LemmaMulInductionAuto(z, u => u >= 0 ==> x * u <= y * u);\n  }\n\n  /* any two integers that are multiplied by a positive number will maintain their numerical order */\n  lemma LemmaMulInequalityAuto()\n    ensures  forall x: int, y: int, z: int {:trigger x * z, y * z} :: x <= y && z >= 0 ==> x * z <= y * z\n  {\n    forall (x: int, y: int, z: int | x <= y && z >= 0)\n      ensures x * z <= y * z\n    {\n      LemmaMulInequality(x, y, z);\n    }\n  }\n\n  /* multiplying by a positive integer preserves inequality */\n  lemma LemmaMulStrictInequality(x: int, y: int, z: int)\n    requires x < y\n    requires z > 0\n    ensures  x * z < y * z\n  {\n    MulINL.LemmaMulStrictInequality(x, y, z);\n  }\n\n  /* multiplying by a positive integer preserves inequality for all integers*/\n  lemma LemmaMulStrictInequalityAuto()\n    ensures  forall x: int, y: int, z: int {:trigger x * z, y * z} :: x < y && z > 0 ==> x * z < y * z\n  {\n    forall (x: int, y: int, z: int | x < y && z > 0)\n      ensures x * z < y * z\n    {\n      LemmaMulStrictInequality(x, y, z);\n    }\n  }\n\n  /* the product of two bounded integers is less than or equal to the product of their upper bounds */\n  lemma LemmaMulUpperBound(x: int, XBound: int, y: int, YBound: int)\n    requires x <= XBound\n    requires y <= YBound\n    requires 0 <= x\n    requires 0 <= y\n    ensures x * y <= XBound * YBound\n  {\n    LemmaMulInequality(x, XBound, y);\n    LemmaMulInequality(y, YBound, XBound);\n  }\n\n  lemma LemmaMulUpperBoundAuto()\n    ensures forall x: int, XBound: int, y: int, YBound: int {:trigger x * y, XBound * YBound}\n              :: x <= XBound && y <= YBound && 0 <= x && 0 <= y ==> x * y <= XBound * YBound\n  {\n    forall (x: int, XBound: int, y: int, YBound: int | x <= XBound && y <= YBound && 0 <= x && 0 <= y)\n      ensures x * y <= XBound * YBound\n    {\n      LemmaMulUpperBound(x, XBound, y, YBound);\n    }\n  }\n\n  /* the product of two strictly upper bounded integers is less than the product of their upper bounds */\n  lemma LemmaMulStrictUpperBound(x: int, XBound: int, y: int, YBound: int)\n    requires x < XBound\n    requires y < YBound\n    requires 0 < x\n    requires 0 < y\n    ensures x * y <= (XBound - 1) * (YBound - 1)\n  {\n    LemmaMulInequality(x, XBound - 1, y);\n    LemmaMulInequality(y, YBound - 1, XBound - 1);\n  }\n\n  lemma LemmaMulStrictUpperBoundAuto()\n    ensures forall x: int, XBound: int, y: int, YBound: int {:trigger x * y, (XBound - 1) * (YBound - 1)}\n              :: x < XBound && y < YBound && 0 < x && 0 < y ==> x * y <= (XBound - 1) * (YBound - 1)\n  {\n    forall (x: int, XBound: int, y: int, YBound: int | x < XBound && y < YBound && 0 < x && 0 < y)\n      ensures x * y <= (XBound - 1) * (YBound - 1)\n    {\n      LemmaMulStrictUpperBound(x, XBound, y, YBound);\n    }\n  }\n\n  /* any two integers that are multiplied by a positive number will maintain their numerical order */\n  lemma LemmaMulLeftInequality(x: int, y: int, z: int)\n    requires 0 < x\n    ensures y <= z ==> x * y <= x * z\n    ensures y < z ==> x * y < x * z\n  {\n    LemmaMulInductionAuto(x, u => u > 0 ==> y <= z ==> u * y <= u * z);\n    LemmaMulInductionAuto(x, u => u > 0 ==> y < z ==> u * y < u * z);\n  }\n\n  lemma LemmaMulLeftInequalityAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * y, x * z}\n              :: x > 0 ==> (y <= z ==> x * y <= x * z) && (y < z ==> x * y < x * z)\n  {\n    forall (x: int, y: int, z: int | (y <= z || y < z) && 0 < x)\n      ensures (y <= z ==> x * y <= x * z) && (y < z ==> x * y < x * z)\n    {\n      LemmaMulLeftInequality(x, y, z);\n    }\n  }\n\n  /* if two seperate integers are each multiplied by a common integer and the products are equal, the \n    two original integers are equal */\n  lemma LemmaMulEqualityConverse(m: int, x: int, y: int)\n    requires m != 0\n    requires m * x == m * y\n    ensures x == y\n  {\n    LemmaMulInductionAuto(m, u => x > y && 0 < u ==> x * u > y * u);\n    LemmaMulInductionAuto(m, u => x > y && 0 > u ==> x * u < y * u);\n    LemmaMulInductionAuto(m, u => x < y && 0 < u ==> x * u < y * u);\n    LemmaMulInductionAuto(m, u => x < y && 0 > u ==> x * u > y * u);\n  }\n\n  /* if any two seperate integers are each multiplied by a common integer and the products are equal, the \n  two original integers are equal */\n  lemma LemmaMulEqualityConverseAuto()\n    ensures forall m: int, x: int, y: int {:trigger m * x, m * y} :: (m != 0 && m * x == m * y) ==> x == y\n  {\n    forall (m: int, x: int, y: int | m != 0 && m * x == m * y)\n      ensures x == y\n    {\n      LemmaMulEqualityConverse(m, x, y);\n    }\n  }\n\n  /* when two integers, x and y, are each multiplied by a positive integer, z, if x <= z then the x*z <= y*z */\n  lemma LemmaMulInequalityConverse(x: int, y: int, z: int)\n    requires x * z <= y * z\n    requires z > 0\n    ensures  x <= y\n  {\n    LemmaMulInductionAuto(z, u => x * u <= y * u && u > 0 ==> x <= y);\n  }\n\n  /* when two integers, x and y, are each multiplied by a positive integer, z, if x <= z then the x*z <= y*z \n  for all valid values of x, y, and z*/\n  lemma LemmaMulInequalityConverseAuto()\n    ensures  forall x: int, y: int, z: int {:trigger x * z, y * z} :: x * z <= y * z && z > 0 ==> x <= y\n  {\n    forall (x: int, y: int, z: int | x * z <= y * z && z > 0)\n      ensures x <= y\n    {\n      LemmaMulInequalityConverse(x, y, z);\n    }\n  }\n\n  /* when two integers, x and y, are each multiplied by a positive integer, z, if x < z then the x*z < y*z */\n  lemma LemmaMulStrictInequalityConverse(x: int, y: int, z: int)\n    requires x * z < y * z\n    requires z >= 0\n    ensures  x < y\n  {\n    LemmaMulInductionAuto(z, u => x * u < y * u && u >= 0 ==> x < y);\n  }\n\n  /* when two integers, x and y, are each multiplied by a positive integer, z, if x < z then the x*z < y*z \n  for all valid values of x, y, and z*/\n  lemma LemmaMulStrictInequalityConverseAuto()\n    ensures  forall x: int, y: int, z: int {:trigger x * z, y * z} :: x * z < y * z && z >= 0 ==> x < y\n  {\n    forall (x: int, y: int, z: int | x * z < y * z && z >= 0)\n      ensures x < y;\n    {\n      LemmaMulStrictInequalityConverse(x, y, z);\n    }\n  }\n\n  /* multiplication is distributive */\n  lemma LemmaMulIsDistributiveAdd(x: int, y: int, z: int)\n    ensures x * (y + z) == x * y + x * z\n  {\n    MulINL.LemmaMulIsDistributiveAdd(x, y, z);\n  }\n\n  /* for all integers, multiplication is distributive with addition in the form x * (y + z) */\n  lemma LemmaMulIsDistributiveAddAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z\n  {\n    forall (x: int, y: int, z: int)\n      ensures x * (y + z) == x * y + x * z\n    {\n      LemmaMulIsDistributiveAdd(x, y, z);\n    }\n  }\n\n  /* for all integers, multiplication is distributive with addition in the form (y + z) * x */\n  lemma LemmaMulIsDistributiveAddOtherWay(x: int, y: int, z: int)\n    ensures (y + z) * x == y * x + z * x\n  {\n    LemmaMulAuto();\n  }\n\n  lemma LemmaMulIsDistributiveAddOtherWayAuto()\n    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x\n  {\n    forall (x: int, y: int, z: int)\n      ensures (y+z) * x == y * x + z * x\n    {\n      LemmaMulIsDistributiveAddOtherWay(x, y, z);\n    }\n  }\n\n  /* multiplication is distributive with subtraction */\n  lemma LemmaMulIsDistributiveSub(x: int, y: int, z: int)\n    ensures x * (y - z) == x * y - x * z\n  {\n    LemmaMulAuto();\n  }\n\n  /* for all integers, multiplication is distributive with subtraction */\n  lemma LemmaMulIsDistributiveSubAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z\n  {\n    forall (x: int, y: int, z: int)\n      ensures x * (y - z) == x * y - x * z;\n    {\n      LemmaMulIsDistributiveSub(x, y, z);\n    }\n  }\n\n  /* proves the overall distributive nature of multiplication*/\n  lemma LemmaMulIsDistributive(x: int, y: int, z: int)\n    ensures x * (y + z) == x * y + x * z\n    ensures x * (y - z) == x * y - x * z\n    ensures (y + z) * x == y * x + z * x\n    ensures (y - z) * x == y * x - z * x\n    ensures x * (y + z) == (y + z) * x\n    ensures x * (y - z) == (y - z) * x\n    ensures x * y == y * x\n    ensures x * z == z * x\n  {\n    LemmaMulAuto();\n  }\n\n  /* for all integers, multiplication is distributive */\n  lemma LemmaMulIsDistributiveAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z\n    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z\n    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x\n    ensures forall x: int, y: int, z: int {:trigger (y - z) * x} :: (y - z) * x == y * x - z * x\n  {\n    LemmaMulIsDistributiveAddAuto();\n    LemmaMulIsDistributiveSubAuto();\n    LemmaMulIsCommutativeAuto();\n  }\n\n  /* multiplying two positive integers will result in a positive integer */\n  lemma LemmaMulStrictlyPositive(x: int, y: int)\n    ensures (0 < x && 0 < y) ==> (0 < x * y)\n  {\n    MulINL.LemmaMulStrictlyPositive(x, y);\n  }\n\n  /* multiplying any two positive integers will result in a positive integer */\n  lemma LemmaMulStrictlyPositiveAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y) ==> (0 < x * y)\n  {\n    forall (x: int, y: int | 0 < x && 0 < y)\n      ensures 0 < x * y\n    {\n      LemmaMulStrictlyPositive(x,y);\n    }\n  }\n\n  /* multiplying a positive integer by an integer greater than 1 will result in a product that \n  is greater than the original integer */\n  lemma LemmaMulStrictlyIncreases(x: int, y: int)\n    requires 1 < x\n    requires 0 < y\n    ensures y < x * y\n  {\n    LemmaMulInductionAuto(x, u => 1 < u ==> y < u * y);\n  }\n\n  /* multiplying any positive integer by any integer greater than 1 will result in a product that \n  is greater than the original integer */\n  lemma LemmaMulStrictlyIncreasesAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: 1 < x && 0 < y  ==> y < x * y\n  {\n    forall (x: int, y: int | 1 < x && 0 < y)\n      ensures y < x * y\n    {\n      LemmaMulStrictlyIncreases(x, y);\n    }\n  }\n\n  /* multiplying an integer by a positive integer will result in a product that is greater than or\n  equal to the original integer */\n  lemma LemmaMulIncreases(x: int, y: int)\n    requires 0 < x\n    requires 0 < y\n    ensures y <= x * y\n  {\n    LemmaMulInductionAuto(x, u => 0 < u ==> y <= u * y);\n  }\n\n  /* multiplying any integer by any positive integer will result in a product that is greater than or\n  equal to the original integer */\n  lemma LemmaMulIncreasesAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y) ==> (y <= x * y)\n  {\n    forall (x: int, y: int | 0 < x && 0 < y)\n      ensures y <= x * y\n    {\n      LemmaMulIncreases(x, y);\n    }\n  }\n\n  /* multiplying two positive numbers will result in a positive product */\n  lemma LemmaMulNonnegative(x: int, y: int)\n    requires 0 <= x\n    requires 0 <= y\n    ensures  0 <= x * y\n  {\n    LemmaMulInductionAuto(x, u => 0 <= u ==> 0 <= u * y);\n  }\n\n  /* multiplying any two positive numbers will result in a positive product */\n  lemma LemmaMulNonnegativeAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: 0 <= x && 0 <= y ==> 0 <= x * y\n  {\n    forall (x: int, y: int | 0 <= x && 0 <= y)\n      ensures 0 <= x * y\n    {\n      LemmaMulNonnegative(x, y);\n    }\n  }\n\n  /* shows the equivalent forms of using the unary negation operator */\n  lemma LemmaMulUnaryNegation(x: int, y: int)\n    ensures (-x) * y == -(x * y) == x * (-y)\n  {\n    LemmaMulInductionAuto(x, u => (-u) * y == -(u * y) == u * (-y));\n  }\n\n  /* shows the equivalent forms of using the unary negation operator for any integers*/\n  lemma LemmaMulUnaryNegationAuto()\n    ensures forall x: int, y: int {:trigger (-x) * y} {:trigger x * (-y)} :: (-x) * y == -(x * y) == x * (-y)\n  {\n    forall (x: int, y: int)\n      ensures (-x) * y == -(x * y) == x * (-y)\n    {\n      LemmaMulUnaryNegation(x, y);\n    }\n  }\n\n  /* multiplying two negative integers, -x and -y, is equivalent to multiplying x and y */\n  lemma LemmaMulCancelsNegatives(x: int, y: int)\n    ensures x * y == (-x) * (-y)\n  {\n    LemmaMulUnaryNegationAuto();\n  }\n\n  /* multiplying two negative integers, -x and -y, is equivalent to multiplying x and y */\n  lemma LemmaMulCancelsNegativesAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: x * y == (-x) * (-y)\n  {\n    forall x: int, y: int\n      ensures x * y == (-x) * (-y)\n    {\n      LemmaMulCancelsNegatives(x, y);\n    }\n  }\n\n  /* includes all properties of multiplication */\n  lemma LemmaMulProperties()\n    ensures forall x: int, y: int {:trigger x * y} :: x * y == y * x\n    ensures forall x: int {:trigger x * 1}{:trigger 1 * x} :: x * 1 == 1 * x == x\n    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x < y && z > 0 ==> x * z < y * z\n    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x <= y && z >= 0 ==> x * z <= y * z\n    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z\n    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z\n    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x\n    ensures forall x: int, y: int, z: int {:trigger (y - z) * x} :: (y - z) * x == y * x - z * x\n    ensures forall x: int, y: int, z: int {:trigger x * (y * z)}{:trigger (x * y) * z} :: x * (y * z) == (x * y) * z\n    ensures forall x: int, y: int {:trigger x * y} :: x * y != 0 <==> x != 0 && y != 0\n    ensures forall x: int, y: int {:trigger x * y} :: 0 <= x && 0 <= y ==> 0 <= x * y\n    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y && 0 <= x * y ==> x <= x * y && y <= x * y\n    ensures forall x: int, y: int {:trigger x * y} :: (1 < x && 0 < y) ==> (y < x * y)\n    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y) ==> (y <= x * y)\n    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y) ==> (0 < x * y)\n  {\n    LemmaMulStrictInequalityAuto();\n    LemmaMulInequalityAuto();\n    LemmaMulIsDistributiveAuto();\n    LemmaMulIsAssociativeAuto();\n    LemmaMulOrderingAuto();\n    LemmaMulNonzeroAuto();\n    LemmaMulNonnegativeAuto();\n    LemmaMulStrictlyIncreasesAuto();\n    LemmaMulIncreasesAuto();\n  }\n\n}\n"}
{"file": "../libraries/src/NonlinearArithmetic/Power2.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* Every lemma comes in 2 forms: 'LemmaProperty' and 'LemmaPropertyAuto'. The\nformer takes arguments and may be more stable and less reliant on Z3\nheuristics. The latter includes automation and its use requires less effort */\n\ninclude \"Internals/GeneralInternals.dfy\"\ninclude \"Internals/MulInternals.dfy\"\ninclude \"Power.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Power2 {\n  import opened GeneralInternals\n  import opened MulInternals\n  import opened Power\n\n  function {:opaque} Pow2(e: nat): nat\n    ensures Pow2(e) > 0\n  {\n    reveal Pow();\n    LemmaPowPositive(2, e);\n    Pow(2, e)\n  }\n\n  /* Pow2() is equivalent to Pow() with base 2. */\n  lemma LemmaPow2(e: nat)\n    ensures Pow2(e) == Pow(2, e)\n  {\n    reveal Pow();\n    reveal Pow2();\n\n    if e != 0 {\n      LemmaPow2(e - 1);\n    }\n  }\n\n  lemma LemmaPow2Auto()\n    ensures forall e: nat {:trigger Pow2(e)} :: Pow2(e) == Pow(2, e)\n  {\n    reveal Pow();\n    reveal Pow2();\n\n    forall e: nat {:trigger Pow2(e)}\n      ensures Pow2(e) == Pow(2, e)\n    {\n      LemmaPow2(e);\n    }\n  }\n\n  /* (2^e - 1) / 2 = 2^(e - 1) - 1 */\n  // keep\n  lemma LemmaPow2MaskDiv2(e: nat)\n    requires 0 < e\n    ensures (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1\n  {\n    LemmaPowAuto();\n    var f := e => 0 < e ==> (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1;\n    assert forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInductionAuto(e, f);\n  }\n\n  lemma LemmaPow2MaskDiv2Auto()\n    ensures forall e: nat {:trigger Pow2(e)} :: 0 < e ==>\n                                                  (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1\n  {\n    reveal Pow2();\n    forall e: nat {:trigger Pow2(e)} | 0 < e\n      ensures (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1\n    {\n      LemmaPow2MaskDiv2(e);\n    }\n  }\n\n  lemma Lemma2To64()\n    ensures Pow2(0) == 0x1\n    ensures Pow2(1) == 0x2\n    ensures Pow2(2) == 0x4\n    ensures Pow2(3) == 0x8\n    ensures Pow2(4) == 0x10\n    ensures Pow2(5) == 0x20\n    ensures Pow2(6) == 0x40\n    ensures Pow2(7) == 0x80\n    ensures Pow2(8) == 0x100\n    ensures Pow2(9) == 0x200\n    ensures Pow2(10) == 0x400\n    ensures Pow2(11) == 0x800\n    ensures Pow2(12) == 0x1000\n    ensures Pow2(13) == 0x2000\n    ensures Pow2(14) == 0x4000\n    ensures Pow2(15) == 0x8000\n    ensures Pow2(16) == 0x10000\n    ensures Pow2(17) == 0x20000\n    ensures Pow2(18) == 0x40000\n    ensures Pow2(19) == 0x80000\n    ensures Pow2(20) == 0x100000\n    ensures Pow2(21) == 0x200000\n    ensures Pow2(22) == 0x400000\n    ensures Pow2(23) == 0x800000\n    ensures Pow2(24) == 0x1000000\n    ensures Pow2(25) == 0x2000000\n    ensures Pow2(26) == 0x4000000\n    ensures Pow2(27) == 0x8000000\n    ensures Pow2(28) == 0x10000000\n    ensures Pow2(29) == 0x20000000\n    ensures Pow2(30) == 0x40000000\n    ensures Pow2(31) == 0x80000000\n    ensures Pow2(32) == 0x100000000\n    ensures Pow2(64) == 0x10000000000000000\n  {\n    reveal Pow2();\n  }\n\n}\n"}
{"file": "../libraries/src/FileIO/FileIO.dfy", "dafny": "/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\n// RUN: %verify \"%s\"\n\ninclude \"../Wrappers.dfy\"\n\n/**\n  * This module provides basic file I/O operations: reading and writing bytes from/to a file.\n  * The provided API is intentionally limited in scope and will be expanded later.\n  *\n  * Where the API accepts file paths as strings, there are some limitations.\n  * File paths containing only ASCII characters work identically across languages and platforms;\n  * non-ASCII Unicode codepoints may cause different language- or platform-specific behavior.\n  *\n  * File path symbols including . and .. are allowed.\n  */\nmodule {:options \"-functionSyntax:4\"} FileIO {\n  import opened Wrappers\n\n  export provides ReadBytesFromFile, WriteBytesToFile, Wrappers\n\n  /*\n   * Public API\n   */\n\n  /**\n    * Attempts to read all bytes from the file at the given file path.\n    * If an error occurs, a `Result.Failure` value is returned containing an implementation-specific\n    * error message (which may also contain a stack trace).\n    *\n    * NOTE: See the module description for limitations on the path argument.\n    */\n  method ReadBytesFromFile(path: string) returns (res: Result<seq<bv8>, string>) {\n    var isError, bytesRead, errorMsg := INTERNAL_ReadBytesFromFile(path);\n    return if isError then Failure(errorMsg) else Success(bytesRead);\n  }\n\n  /**\n    * Attempts to write the given bytes to the file at the given file path,\n    * creating nonexistent parent directories as necessary.\n    * If an error occurs, a `Result.Failure` value is returned containing an implementation-specific\n    * error message (which may also contain a stack trace).\n    *\n    * NOTE: See the module description for limitations on the path argument.\n    */\n  method WriteBytesToFile(path: string, bytes: seq<bv8>) returns (res: Result<(), string>)\n  {\n    var isError, errorMsg := INTERNAL_WriteBytesToFile(path, bytes);\n    return if isError then Failure(errorMsg) else Success(());\n  }\n\n  /*\n   * Private API - these are intentionally not exported from the module and should not be used elsewhere\n   */\n\n  method\n    {:extern \"DafnyLibraries.FileIO\", \"INTERNAL_ReadBytesFromFile\"}\n  INTERNAL_ReadBytesFromFile(path: string)\n    returns (isError: bool, bytesRead: seq<bv8>, errorMsg: string)\n\n  method\n    {:extern \"DafnyLibraries.FileIO\", \"INTERNAL_WriteBytesToFile\"}\n  INTERNAL_WriteBytesToFile(path: string, bytes: seq<bv8>)\n    returns (isError: bool, errorMsg: string)\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/NonlinearArithmetic.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"DivMod.dfy\"\ninclude \"Multiply.dfy\"\ninclude \"Power.dfy\"\ninclude \"Power2.dfy\"\ninclude \"Internals/Internals.dfy\"\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Power.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* Every lemma comes in 2 forms: 'LemmaProperty' and 'LemmaPropertyAuto'. The\nformer takes arguments and may be more stable and less reliant on Z3\nheuristics. The latter includes automation and its use requires less effort */\n\ninclude \"DivMod.dfy\"\ninclude \"Internals/GeneralInternals.dfy\"\ninclude \"Multiply.dfy\"\ninclude \"Internals/MulInternals.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.Power {\n  import opened DivMod\n  import opened GeneralInternals\n  import opened Multiply\n  import opened MulInternals\n\n  function {:opaque} Pow(b: int, e: nat): int\n    decreases e\n  {\n    if e == 0 then\n      1\n    else\n      b * Pow(b, e - 1)\n  }\n\n  /* A number raised to the power of 0 equals 1. */\n  lemma LemmaPow0(b: int)\n    ensures Pow(b, 0) == 1\n  {\n    reveal Pow();\n  }\n\n  lemma LemmaPow0Auto()\n    ensures forall b: nat {:trigger Pow(b, 0)} :: Pow(b, 0) == 1\n  {\n    reveal Pow();\n    forall b: nat {:trigger Pow(b, 0)}\n      ensures Pow(b, 0) == 1\n    {\n      LemmaPow0(b);\n    }\n  }\n\n  /* A number raised to the power of 1 equals the number itself. */\n  lemma LemmaPow1(b: int)\n    ensures Pow(b, 1) == b\n  {\n    calc {\n      Pow(b, 1);\n      { reveal Pow(); }\n      b * Pow(b, 0);\n      { LemmaPow0(b); }\n      b * 1;\n      { LemmaMulBasicsAuto(); }\n      b;\n    }\n  }\n\n  lemma LemmaPow1Auto()\n    ensures forall b: nat {:trigger Pow(b, 1)} :: Pow(b, 1) == b\n  {\n    reveal Pow();\n    forall b: nat {:trigger Pow(b, 1)}\n      ensures Pow(b, 1) == b\n    {\n      LemmaPow1(b);\n    }\n  }\n\n  /* 0 raised to a positive power equals 0. */\n  lemma Lemma0Pow(e: nat)\n    requires e > 0\n    ensures Pow(0, e) == 0\n  {\n    reveal Pow();\n    LemmaMulBasicsAuto();\n    if e != 1 {\n      Lemma0Pow(e - 1);\n    }\n  }\n\n  lemma Lemma0PowAuto()\n    ensures forall e: nat {:trigger Pow(0, e)} :: e > 0 ==> Pow(0, e) == 0\n  {\n    reveal Pow();\n    forall e: nat {:trigger Pow(0, e)} | e > 0\n      ensures Pow(0, e) == 0\n    {\n      Lemma0Pow(e);\n    }\n  }\n\n  /* 1 raised to any power equals 1. */\n  lemma Lemma1Pow(e: nat)\n    ensures Pow(1, e) == 1\n  {\n    reveal Pow();\n    LemmaMulBasicsAuto();\n    if e != 0 {\n      Lemma1Pow(e - 1);\n    }\n  }\n\n  lemma Lemma1PowAuto()\n    ensures forall e: nat {:trigger Pow(1, e)} :: Pow(1, e) == 1\n  {\n    reveal Pow();\n    forall e: nat {:trigger Pow(1, e)}\n      ensures Pow(1, e) == 1\n    {\n      Lemma1Pow(e);\n    }\n  }\n\n  /* Squaring a number is equal to raising it to the power of 2. */\n  lemma LemmaSquareIsPow2(x: nat)\n    ensures Pow(x, 2) == x * x\n  {\n    reveal Pow();\n  }\n\n  lemma LemmaSquareIsPow2Auto()\n    ensures forall x: nat {:trigger Pow(x, 2)} :: Pow(x, 2) == x * x\n  {\n    reveal Pow();\n    forall x: nat {:trigger Pow(x, 2)}\n      ensures Pow(x, 2) == x * x\n    {}\n  }\n\n  /* A positive number raised to any power is positive. */\n  lemma LemmaPowPositive(b: int, e: nat)\n    requires b > 0\n    ensures 0 < Pow(b, e)\n  {\n    LemmaMulIncreasesAuto();\n    LemmaMulInductionAuto(e, u => 0 <= u ==> 0 < Pow(b, u));\n  }\n\n  lemma LemmaPowPositiveAuto()\n    ensures forall b: int, e: nat {:trigger Pow(b, e)}\n              :: b > 0 ==> 0 < Pow(b, e)\n  {\n    reveal Pow();\n    forall b: int, e: nat {:trigger Pow(b, e)} | b > 0\n      ensures 0 < Pow(b, e)\n    {\n      LemmaPowPositive(b, e);\n    }\n  }\n\n  /* Add exponents when multiplying powers with the same base. */\n  lemma LemmaPowAdds(b: int, e1: nat, e2: nat)\n    decreases e1\n    ensures Pow(b, e1 + e2) == Pow(b, e1) * Pow(b, e2)\n  {\n    if e1 == 0 {\n      calc {\n        Pow(b, e1) * Pow(b, e2);\n        { LemmaPow0(b); }\n        1 * Pow(b, e2);\n        { LemmaMulBasicsAuto(); }\n        Pow(b, 0 + e2);\n      }\n    }\n    else {\n      calc {\n        Pow(b, e1) * Pow(b, e2);\n        { reveal Pow(); }\n        (b * Pow(b, e1 - 1)) * Pow(b, e2);\n        { LemmaMulIsAssociativeAuto(); }\n        b * (Pow(b, e1 - 1) * Pow(b, e2));\n        { LemmaPowAdds(b, e1 - 1, e2); }\n        b * Pow(b, e1 - 1 + e2);\n        { reveal Pow(); }\n        Pow(b, e1 + e2);\n      }\n    }\n  }\n\n  lemma LemmaPowAddsAuto()\n    ensures forall b: int, e1: nat, e2: nat {:trigger Pow(b, e1 + e2)}\n              :: Pow(b, e1 + e2) == Pow(b, e1) * Pow(b, e2)\n  {\n    reveal Pow();\n    forall b: int, e1: nat, e2: nat {:trigger Pow(b, e1 + e2)}\n      ensures Pow(b, e1 + e2) == Pow(b, e1) * Pow(b, e2)\n    {\n      LemmaPowAdds(b, e1, e2);\n    }\n  }\n\n  lemma LemmaPowSubAddCancel(b: int, e1: nat, e2: nat)\n    decreases e1\n    requires e1 >= e2\n    ensures Pow(b, e1 - e2) * Pow(b, e2) == Pow(b, e1)\n  {\n    LemmaPowAdds(b, e1 - e2, e2);\n  }\n\n  lemma LemmaPowSubAddCancelAuto()\n    ensures forall b: int, e1: nat, e2: nat {:trigger Pow(b, e1 - e2)} | e1 >= e2\n              :: Pow(b, e1 - e2) * Pow(b, e2) == Pow(b, e1)\n  {\n    reveal Pow();\n    forall b: int, e1: nat, e2: nat | e1 >= e2\n    {\n      LemmaPowSubAddCancel(b, e1, e2);\n    }\n  }\n\n  /* Subtract exponents when dividing powers. */\n  lemma LemmaPowSubtracts(b: nat, e1: nat, e2: nat)\n    requires b > 0\n    requires e1 <= e2\n    ensures Pow(b, e1) > 0\n    ensures Pow(b, e2 - e1) == Pow(b, e2) / Pow(b, e1) > 0\n  {\n    LemmaPowPositiveAuto();\n    calc {\n      Pow(b, e2) / Pow(b, e1);\n      { LemmaPowSubAddCancel(b, e2, e1); }\n      Pow(b, e2 - e1) * Pow(b, e1) / Pow(b, e1);\n      { LemmaDivByMultiple(Pow(b, e2 - e1), Pow(b, e1)); }\n      Pow(b, e2 - e1);\n    }\n  }\n\n  lemma LemmaPowSubtractsAuto()\n    ensures forall b: nat, e1: nat :: b > 0 ==> Pow(b, e1) > 0\n    ensures forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e2 - e1)}\n              :: b > 0 && e1 <= e2 ==>\n                   Pow(b, e2 - e1) == Pow(b, e2) / Pow(b, e1) > 0\n  {\n    reveal Pow();\n    LemmaPowPositiveAuto();\n    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e2 - e1)}\n      | b > 0 && e1 <= e2\n      ensures Pow(b, e2 - e1) == Pow(b, e2) / Pow(b, e1) > 0\n    {\n      LemmaPowSubtracts(b, e1, e2);\n    }\n  }\n\n  /* Multiply exponents when finding the power of a power. */\n  lemma LemmaPowMultiplies(a: int, b: nat, c: nat)\n    decreases c\n    ensures 0 <= b * c\n    ensures Pow(Pow(a, b), c) == Pow(a, b * c)\n  {\n    LemmaMulNonnegative(b, c);\n    if c == 0 {\n      LemmaMulBasicsAuto();\n      calc {\n        Pow(a, b * c);\n        { LemmaPow0(a); }\n        1;\n        { LemmaPow0(Pow(a, b)); }\n        Pow(Pow(a, b), c);\n      }\n    }\n    else {\n      calc {\n        b * c - b;\n        { LemmaMulBasicsAuto(); }\n        b * c - b * 1;\n        { LemmaMulIsDistributiveAuto(); }\n        b * (c - 1);\n      }\n      LemmaMulNonnegative(b, c - 1);\n      assert 0 <= b * c - b;\n\n      calc {\n        Pow(a, b * c);\n        Pow(a, b + b * c - b);\n        { LemmaPowAdds(a, b, b * c - b); }\n        Pow(a, b) * Pow(a, b * c - b);\n        Pow(a, b) * Pow(a, b * (c - 1));\n        { LemmaPowMultiplies(a, b, c - 1); }\n        Pow(a, b) * Pow(Pow(a, b), c - 1);\n        { reveal Pow(); }\n        Pow(Pow(a, b), c);\n      }\n    }\n  }\n\n  lemma LemmaPowMultipliesAuto()\n    ensures forall b: nat, c: nat {:trigger b * c} :: 0 <= b * c\n    ensures forall a: int, b: nat, c: nat {:trigger Pow(a, b * c)}\n              :: Pow(Pow(a, b), c) == Pow(a, b * c)\n  {\n    reveal Pow();\n    LemmaMulNonnegativeAuto();\n    forall a: int, b: nat, c: nat {:trigger Pow(a, b * c)}\n      ensures Pow(Pow(a, b), c) == Pow(a, b * c)\n    {\n      LemmaPowMultiplies(a, b, c);\n    }\n  }\n\n  /* Distribute the power to factors of a product. */\n  lemma LemmaPowDistributes(a: int, b: int, e: nat)\n    decreases e\n    ensures Pow(a * b, e) == Pow(a, e) * Pow(b, e)\n  {\n    reveal Pow();\n    LemmaMulBasicsAuto();\n    if e > 0 {\n      calc {\n        Pow(a * b, e);\n        (a * b) * Pow(a * b, e - 1);\n        { LemmaPowDistributes(a, b, e - 1); }\n        (a * b) * (Pow(a, e - 1) * Pow(b, e - 1));\n        { LemmaMulIsAssociativeAuto(); LemmaMulIsCommutativeAuto(); }\n        (a * Pow(a, e - 1)) * (b * Pow(b, e - 1));\n        Pow(a, e) * Pow(b, e);\n      }\n    }\n  }\n\n  lemma LemmaPowDistributesAuto()\n    ensures forall a: int, b: int, e: nat {:trigger Pow(a * b, e)}\n              :: Pow(a * b, e) == Pow(a, e) * Pow(b, e)\n  {\n    reveal Pow();\n    forall a: int, b: int, e: nat {:trigger Pow(a * b, e)}\n      ensures Pow(a * b, e) == Pow(a, e) * Pow(b, e)\n    {\n      LemmaPowDistributes(a, b, e);\n    }\n  }\n\n  /* Group properties of powers. */\n  lemma LemmaPowAuto()\n    ensures forall x: int {:trigger Pow(x, 0)} :: Pow(x, 0) == 1\n    ensures forall x: int {:trigger Pow(x, 1)} :: Pow(x, 1) == x\n    ensures forall x: int, y: int {:trigger Pow(x, y)} :: y == 0 ==> Pow(x, y) == 1\n    ensures forall x: int, y: int {:trigger Pow(x, y)} :: y == 1 ==> Pow(x, y) == x\n    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> x <= x * y\n    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 1 < y ==> x < x * y\n    ensures forall x: int, y: nat, z: nat {:trigger Pow(x, y + z)} :: Pow(x, y + z) == Pow(x, y) * Pow(x, z)\n    ensures forall x: int, y: nat, z: nat {:trigger Pow(x, y - z)} :: y >= z ==> Pow(x, y - z) * Pow(x, z) == Pow(x, y)\n    ensures forall x: int, y: int, z: nat {:trigger Pow(x * y, z)} :: Pow(x * y, z) == Pow(x, z) * Pow(y, z)\n  {\n    reveal Pow();\n\n    LemmaPow0Auto();\n    LemmaPow1Auto();\n\n    LemmaPowDistributesAuto();\n    LemmaPowAddsAuto();\n    LemmaPowSubAddCancelAuto();\n\n    LemmaMulAuto();\n    LemmaMulIncreasesAuto();\n    LemmaMulStrictlyIncreasesAuto();\n  }\n\n  /* A positive number raised to a power strictly increases as the power\n  strictly increases. */\n  lemma LemmaPowStrictlyIncreases(b: nat, e1: nat, e2: nat)\n    requires 1 < b\n    requires e1 < e2\n    ensures Pow(b, e1) < Pow(b, e2)\n  {\n    LemmaPowAuto();\n    var f := e => 0 < e ==> Pow(b, e1) < Pow(b, e1 + e);\n    forall i {:trigger IsLe(0, i)} | IsLe(0, i) && f(i)\n      ensures f(i + 1)\n    {\n      calc {\n        Pow(b, e1 + i);\n      <= { LemmaPowPositive(b, e1 + i);\n           LemmaMulLeftInequality(Pow(b, e1 + i), 1, b); }\n        Pow(b, e1 + i) * b;\n      == { LemmaPow1(b); }\n        Pow(b, e1 + i) * Pow(b, 1);\n      == { LemmaPowAdds(b, e1 + i, 1); }\n        Pow(b, e1 + i + 1);\n      }\n    }\n    LemmaMulInductionAuto(e2 - e1, f);\n  }\n\n  lemma LemmaPowStrictlyIncreasesAuto()\n    ensures forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1),\n              Pow(b, e2)} :: (1 < b && e1 < e2) ==> Pow(b, e1) < Pow(b, e2)\n  {\n    reveal Pow();\n    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)}\n      | 1 < b && e1 < e2\n      ensures Pow(b, e1) < Pow(b, e2)\n    {\n      LemmaPowStrictlyIncreases(b, e1, e2);\n    }\n  }\n\n  /* A positive number raised to a power increases as the power increases. */\n  lemma LemmaPowIncreases(b: nat, e1: nat, e2: nat)\n    requires b > 0\n    requires e1 <= e2\n    ensures Pow(b, e1) <= Pow(b, e2)\n  {\n    LemmaPowAuto();\n    var f := e => 0 <= e ==> Pow(b, e1) <= Pow(b, e1 + e);\n    forall i {:trigger IsLe(0, i)} | IsLe(0, i) && f(i)\n      ensures f(i + 1)\n    {\n      calc {\n        Pow(b, e1 + i);\n      <= { LemmaPowPositive(b, e1 + i);\n           LemmaMulLeftInequality(Pow(b, e1 + i), 1, b); }\n        Pow(b, e1 + i) * b;\n      == { LemmaPow1(b); }\n        Pow(b, e1 + i) * Pow(b, 1);\n      == { LemmaPowAdds(b, e1 + i, 1); }\n        Pow(b, e1 + i + 1);\n      }\n    }\n    LemmaMulInductionAuto(e2 - e1, f);\n  }\n\n  lemma LemmaPowIncreasesAuto()\n    ensures forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1),\n              Pow(b, e2)} :: (1 < b && e1 <= e2) ==> Pow(b, e1) <= Pow(b, e2)\n  {\n    reveal Pow();\n    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)}\n      | 1 < b && e1 <= e2\n      ensures Pow(b, e1) <= Pow(b, e2)\n    {\n      LemmaPowIncreases(b, e1, e2);\n    }\n  }\n\n  /* A power strictly increases as a positive number raised to the power\n  strictly increases. */\n  lemma LemmaPowStrictlyIncreasesConverse(b: nat, e1: nat, e2: nat)\n    requires b > 0\n    requires Pow(b, e1) < Pow(b, e2)\n    ensures e1 < e2\n  {\n    if e1 >= e2 {\n      LemmaPowIncreases(b, e2, e1);\n      assert false;\n    }\n  }\n\n  lemma LemmaPowStrictlyIncreasesConverseAuto()\n    ensures forall b: nat, e1: nat, e2: nat\n              {:trigger Pow(b, e1), Pow(b, e2)}\n              :: b > 0 && Pow(b, e1) < Pow(b, e2) ==> e1 < e2\n  {\n    reveal Pow();\n    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)}\n      | b > 0 && Pow(b, e1) < Pow(b, e2)\n      ensures e1 < e2\n    {\n      LemmaPowStrictlyIncreasesConverse(b, e1, e2);\n    }\n  }\n\n  /* A power increases as a positive number raised to the power increases. */\n  lemma LemmaPowIncreasesConverse(b: nat, e1: nat, e2: nat)\n    requires 1 < b\n    requires Pow(b, e1) <= Pow(b, e2)\n    ensures e1 <= e2\n  {\n    if e1 > e2 {\n      LemmaPowStrictlyIncreases(b, e2, e1);\n      assert false;\n    }\n  }\n\n  lemma LemmaPowIncreasesConverseAuto()\n    ensures forall b: nat, e1: nat, e2: nat\n              {:trigger Pow(b, e1), Pow(b, e2)}\n              :: 1 < b && Pow(b, e1) <= Pow(b, e2) ==> e1 <= e2\n  {\n    reveal Pow();\n    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)}\n      | 1 < b && Pow(b, e1) <= Pow(b, e2)\n      ensures e1 <= e2\n    {\n      LemmaPowIncreasesConverse(b, e1, e2);\n    }\n  }\n\n  /* (b^xy)^z = (b^x)^yz */\n  lemma LemmaPullOutPows(b: nat, x: nat, y: nat, z: nat)\n    requires b > 0\n    ensures 0 <= x * y\n    ensures 0 <= y * z\n    ensures Pow(Pow(b, x * y), z) == Pow(Pow(b, x), y * z)\n  {\n    LemmaMulNonnegative(x, y);\n    LemmaMulNonnegative(y, z);\n    LemmaPowPositive(b, x);\n    calc {\n      Pow(Pow(b, x * y), z);\n      { LemmaPowMultiplies(b, x, y); }\n      Pow(Pow(Pow(b, x), y), z);\n      { LemmaPowMultiplies(Pow(b, x), y, z); }\n      Pow(Pow(b, x), y * z);\n    }\n  }\n\n  lemma LemmaPullOutPowsAuto()\n    ensures forall y: nat, z: nat {:trigger z * y} :: 0 <= z * y && 0 <= y * z\n    ensures forall b: nat, x: nat, y: nat, z: nat\n              {:trigger Pow(Pow(b, x * y), z)}\n              :: b > 0 ==> Pow(Pow(b, x * y), z) == Pow(Pow(b, x), y * z)\n  {\n    reveal Pow();\n    LemmaMulNonnegativeAuto();\n    forall b: nat, x: nat, y: nat, z: nat {:trigger Pow(Pow(b, x * y), z)}\n      | b > 0 ensures Pow(Pow(b, x * y), z) == Pow(Pow(b, x), y * z)\n    {\n      LemmaPullOutPows(b, x, y, z);\n    }\n  }\n\n  /* Inequality due to smaller numerator, same denominator. */\n  lemma LemmaPowDivisionInequality(x: nat, b: nat, e1: nat, e2: nat)\n    requires b > 0\n    requires e2 <= e1\n    requires x < Pow(b, e1)\n    ensures Pow(b, e2) > 0\n    ensures x / Pow(b, e2) < Pow(b, e1 - e2)\n  {\n    LemmaPowPositiveAuto();\n    calc ==> {\n      x / Pow(b, e2) >= Pow(b, e1 - e2);\n      { LemmaMulInequality(Pow(b, e1 - e2), x / Pow(b, e2), Pow(b, e2)); }\n      x / Pow(b, e2) * Pow(b, e2) >= Pow(b, e1 - e2) * Pow(b, e2);\n      { LemmaFundamentalDivMod(x, Pow(b, e2));\n        LemmaMulIsCommutativeAuto(); }\n      x - x % Pow(b, e2) >= Pow(b, e1 - e2) * Pow(b, e2);\n      { LemmaPowAdds(b, e1 - e2, e2); }\n      x - x % Pow(b, e2) >= Pow(b, e1);\n      { LemmaModPropertiesAuto(); }\n      x >= Pow(b, e1);\n      false;\n    }\n  }\n\n  lemma LemmaPowDivisionInequalityAuto()\n    ensures forall b: nat, e2: nat :: b > 0 ==> Pow(b, e2) > 0\n    ensures forall x: nat, b: nat, e1: nat, e2: nat\n              {:trigger x / Pow(b, e2), Pow(b, e1 - e2)}\n              :: b > 0 && e2 <= e1 && x < Pow(b, e1) ==>\n                   x / Pow(b, e2) < Pow(b, e1 - e2)\n  {\n    reveal Pow();\n    LemmaPowPositiveAuto();\n    forall x: nat, b: nat, e1: nat, e2: nat\n      {:trigger x / Pow(b, e2), Pow(b, e1 - e2)}\n      | b > 0 && e2 <= e1 && x < Pow(b, e1)\n      ensures x / Pow(b, e2) < Pow(b, e1 - e2)\n    {\n      LemmaPowDivisionInequality(x, b, e1, e2);\n    }\n  }\n\n  /* b^e % b = 0 */\n  lemma LemmaPowMod(b: nat, e: nat)\n    requires b > 0 && e > 0\n    ensures Pow(b, e) % b == 0;\n  {\n    reveal Pow();\n    calc {\n      Pow(b, e) % b;\n      (b * Pow(b, e - 1)) % b;\n      { LemmaMulIsAssociativeAuto(); }\n      (Pow(b, e - 1) * b) % b;\n      {\n        LemmaPowPositiveAuto();\n        LemmaModMultiplesBasic(Pow(b, e-1) , b);\n      }\n      0;\n    }\n  }\n\n  lemma LemmaPowModAuto()\n    ensures forall b: nat, e: nat {:trigger Pow(b, e)}\n              :: b > 0 && e > 0 ==> Pow(b, e) % b == 0\n  {\n    reveal Pow();\n    forall b: nat, e: nat {:trigger Pow(b, e)} | b > 0 && e > 0\n      ensures Pow(b, e) % b == 0\n    {\n      LemmaPowMod(b, e);\n    }\n  }\n\n  /* ((b % e)^e) % m = b^e % m */\n  lemma LemmaPowModNoop(b: int, e: nat, m: int)\n    decreases e\n    requires m > 0\n    ensures Pow(b % m, e) % m == Pow(b, e) % m\n  {\n    reveal Pow();\n    LemmaModPropertiesAuto();\n    if e > 0 {\n      calc {\n        Pow(b % m, e) % m;\n        ((b % m) * Pow(b % m, e - 1)) % m;\n        { LemmaMulModNoopGeneral(b, Pow(b % m, e - 1), m); }\n        ((b % m) * (Pow(b % m, e - 1) % m) % m) % m;\n        { LemmaPowModNoop(b, e - 1, m); }\n        ((b % m) * (Pow(b, e - 1) % m) % m) % m;\n        { LemmaMulModNoopGeneral(b, Pow(b, e - 1), m); }\n        (b * (Pow(b, e - 1)) % m) % m;\n        (b * (Pow(b, e - 1))) % m;\n        Pow(b, e) % m;\n      }\n    }\n  }\n\n  lemma LemmaPowModNoopAuto()\n    ensures forall b: nat, e: nat, m: nat {:trigger Pow(b % m, e)}\n              :: m > 0 ==> Pow(b % m, e) % m == Pow(b, e) % m\n  {\n    reveal Pow();\n    forall b: nat, e: nat, m: nat {:trigger Pow(b % m, e)}\n      | m > 0 ensures Pow(b % m, e) % m == Pow(b, e) % m\n    {\n      LemmaPowModNoop(b, e, m);\n    }\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Multiply.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* Every lemma comes in 2 forms: 'LemmaProperty' and 'LemmaPropertyAuto'. The\nformer takes arguments and may be more stable and less reliant on Z3\nheuristics. The latter includes automation and its use requires less effort */\n\ninclude \"Internals/MulInternalsNonlinear.dfy\"\ninclude \"Internals/MulInternals.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.Multiply {\n\n  import MulINL = MulInternalsNonlinear\n  import opened MulInternals\n\n  /* the built-in syntax of multiplication results in the same product as multiplication \n  through recursive addition */\n  lemma LemmaMulIsMulRecursive(x: int, y: int)\n    ensures x * y == MulRecursive(x, y)\n  {\n    if (x >= 0) { LemmaMulIsMulPos(x, y); }\n    if (x <= 0) { LemmaMulIsMulPos(-x, y); }\n    LemmaMulAuto();\n  }\n\n  lemma LemmaMulIsMulRecursiveAuto()\n    ensures forall x: int, y: int :: x * y == MulRecursive(x, y)\n  {\n    forall x: int, y: int\n      ensures x * y == MulRecursive(x, y)\n    {\n      LemmaMulIsMulRecursive(x, y);\n    }\n  }\n\n  /* the built-in syntax of multiplying two positive integers results in the same product as \n  MulPos, which is achieved by recursive addition */\n  lemma LemmaMulIsMulPos(x: int, y: int)\n    requires x >= 0\n    ensures x * y == MulPos(x, y)\n  {\n    reveal MulPos();\n    LemmaMulInductionAuto(x, u => u >= 0 ==> u * y == MulPos(u, y));\n  }\n\n  /* ensures that the basic properties of multiplication, including the identity and zero properties */\n  lemma LemmaMulBasics(x: int)\n    ensures 0 * x == 0\n    ensures x * 0 == 0\n    ensures 1 * x == x\n    ensures x * 1 == x\n  {\n  }\n\n  lemma LemmaMulBasicsAuto()\n    ensures forall x: int {:trigger 0 * x} :: 0 * x == 0\n    ensures forall x: int {:trigger x * 0} :: x * 0 == 0\n    ensures forall x: int {:trigger 1 * x} :: 1 * x == x\n    ensures forall x: int {:trigger x * 1} :: x * 1 == x\n  {\n  }\n\n  /* multiplying two nonzero integers will never result in 0 as the poduct */\n  lemma LemmaMulNonzero(x: int, y: int)\n    ensures x * y != 0 <==> x != 0 && y != 0\n  {\n    MulINL.LemmaMulNonzero(x, y);\n  }\n\n  /* multiplying any two nonzero integers will never result in 0 as the poduct */\n  lemma LemmaMulNonzeroAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: x * y != 0 <==> x != 0 && y != 0\n  {\n    forall (x: int, y: int)\n      ensures x * y != 0 <==> x != 0 && y != 0;\n    {\n      LemmaMulNonzero(x, y);\n    }\n  }\n\n  /* any integer multiplied by 0 results in a product of 0 */\n  lemma LemmaMulByZeroIsZeroAuto()\n    ensures forall x: int {:trigger 0 * x} {:trigger x * 0} :: x * 0 == 0 * x == 0\n  {\n    forall x: int {:trigger 0 * x} {:trigger x * 0}\n      ensures x * 0 == 0 * x == 0\n    {\n      LemmaMulBasics(x);\n    }\n  }\n\n  /* multiplication is associative */\n  lemma LemmaMulIsAssociative(x: int, y: int, z: int)\n    ensures x * (y * z) == (x * y) * z\n  {\n    MulINL.LemmaMulIsAssociative(x, y, z);\n  }\n\n  /* multiplication is always associative for all integers*/\n  lemma LemmaMulIsAssociativeAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * (y * z)} {:trigger (x * y) * z}\n              :: x * (y * z) == (x * y) * z\n  {\n    forall (x: int, y: int, z: int)\n      ensures x * (y * z) == (x * y) * z\n    {\n      LemmaMulIsAssociative(x, y, z);\n    }\n  }\n\n  /* multiplication is commutative */\n  lemma LemmaMulIsCommutative(x: int, y: int)\n    ensures x * y == y * x\n  {\n  }\n\n  /* multiplication is always commutative for all integers */\n  lemma LemmaMulIsCommutativeAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: x * y == y * x\n  {\n  }\n\n  /* the product of two integers is greater than the value of each individual integer */\n  lemma LemmaMulOrdering(x: int, y: int)\n    requires x != 0\n    requires y != 0\n    requires 0 <= x * y\n    ensures x * y >= x && x * y >= y\n  {\n    MulINL.LemmaMulOrdering(x, y);\n  }\n\n  /* the product of two positive integers is always greater than the individual value of either \n  multiplied integer */\n  lemma LemmaMulOrderingAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: (0 != x && 0 != y && x * y >= 0) ==> x * y >= x && x * y >= y\n  {\n    forall x: int, y: int | 0 != x && 0 != y && x * y >= 0\n      ensures x * y >= x && x * y >= y\n    {\n      LemmaMulOrdering(x, y);\n    }\n  }\n\n  lemma LemmaMulEquality(x: int, y: int, z: int)\n    requires x == y\n    ensures x * z == y * z\n  {}\n\n  lemma LemmaMulEqualityAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * z, y * z } :: x == y ==> x * z == y * z\n  {\n    forall (x: int, y: int, z: int | x == y)\n      ensures x * z == y * z\n    {\n      LemmaMulEquality(x, y, z);\n    }\n  }\n\n  /* two integers that are multiplied by a positive number will maintain their numerical order */\n  lemma LemmaMulInequality(x: int, y: int, z: int)\n    requires x <= y\n    requires z >= 0\n    ensures  x * z <= y * z\n  {\n    LemmaMulInductionAuto(z, u => u >= 0 ==> x * u <= y * u);\n  }\n\n  /* any two integers that are multiplied by a positive number will maintain their numerical order */\n  lemma LemmaMulInequalityAuto()\n    ensures  forall x: int, y: int, z: int {:trigger x * z, y * z} :: x <= y && z >= 0 ==> x * z <= y * z\n  {\n    forall (x: int, y: int, z: int | x <= y && z >= 0)\n      ensures x * z <= y * z\n    {\n      LemmaMulInequality(x, y, z);\n    }\n  }\n\n  /* multiplying by a positive integer preserves inequality */\n  lemma LemmaMulStrictInequality(x: int, y: int, z: int)\n    requires x < y\n    requires z > 0\n    ensures  x * z < y * z\n  {\n    MulINL.LemmaMulStrictInequality(x, y, z);\n  }\n\n  /* multiplying by a positive integer preserves inequality for all integers*/\n  lemma LemmaMulStrictInequalityAuto()\n    ensures  forall x: int, y: int, z: int {:trigger x * z, y * z} :: x < y && z > 0 ==> x * z < y * z\n  {\n    forall (x: int, y: int, z: int | x < y && z > 0)\n      ensures x * z < y * z\n    {\n      LemmaMulStrictInequality(x, y, z);\n    }\n  }\n\n  /* the product of two bounded integers is less than or equal to the product of their upper bounds */\n  lemma LemmaMulUpperBound(x: int, XBound: int, y: int, YBound: int)\n    requires x <= XBound\n    requires y <= YBound\n    requires 0 <= x\n    requires 0 <= y\n    ensures x * y <= XBound * YBound\n  {\n    LemmaMulInequality(x, XBound, y);\n    LemmaMulInequality(y, YBound, XBound);\n  }\n\n  lemma LemmaMulUpperBoundAuto()\n    ensures forall x: int, XBound: int, y: int, YBound: int {:trigger x * y, XBound * YBound}\n              :: x <= XBound && y <= YBound && 0 <= x && 0 <= y ==> x * y <= XBound * YBound\n  {\n    forall (x: int, XBound: int, y: int, YBound: int | x <= XBound && y <= YBound && 0 <= x && 0 <= y)\n      ensures x * y <= XBound * YBound\n    {\n      LemmaMulUpperBound(x, XBound, y, YBound);\n    }\n  }\n\n  /* the product of two strictly upper bounded integers is less than the product of their upper bounds */\n  lemma LemmaMulStrictUpperBound(x: int, XBound: int, y: int, YBound: int)\n    requires x < XBound\n    requires y < YBound\n    requires 0 < x\n    requires 0 < y\n    ensures x * y <= (XBound - 1) * (YBound - 1)\n  {\n    LemmaMulInequality(x, XBound - 1, y);\n    LemmaMulInequality(y, YBound - 1, XBound - 1);\n  }\n\n  lemma LemmaMulStrictUpperBoundAuto()\n    ensures forall x: int, XBound: int, y: int, YBound: int {:trigger x * y, (XBound - 1) * (YBound - 1)}\n              :: x < XBound && y < YBound && 0 < x && 0 < y ==> x * y <= (XBound - 1) * (YBound - 1)\n  {\n    forall (x: int, XBound: int, y: int, YBound: int | x < XBound && y < YBound && 0 < x && 0 < y)\n      ensures x * y <= (XBound - 1) * (YBound - 1)\n    {\n      LemmaMulStrictUpperBound(x, XBound, y, YBound);\n    }\n  }\n\n  /* any two integers that are multiplied by a positive number will maintain their numerical order */\n  lemma LemmaMulLeftInequality(x: int, y: int, z: int)\n    requires 0 < x\n    ensures y <= z ==> x * y <= x * z\n    ensures y < z ==> x * y < x * z\n  {\n    LemmaMulInductionAuto(x, u => u > 0 ==> y <= z ==> u * y <= u * z);\n    LemmaMulInductionAuto(x, u => u > 0 ==> y < z ==> u * y < u * z);\n  }\n\n  lemma LemmaMulLeftInequalityAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * y, x * z}\n              :: x > 0 ==> (y <= z ==> x * y <= x * z) && (y < z ==> x * y < x * z)\n  {\n    forall (x: int, y: int, z: int | (y <= z || y < z) && 0 < x)\n      ensures (y <= z ==> x * y <= x * z) && (y < z ==> x * y < x * z)\n    {\n      LemmaMulLeftInequality(x, y, z);\n    }\n  }\n\n  /* if two seperate integers are each multiplied by a common integer and the products are equal, the \n    two original integers are equal */\n  lemma LemmaMulEqualityConverse(m: int, x: int, y: int)\n    requires m != 0\n    requires m * x == m * y\n    ensures x == y\n  {\n    LemmaMulInductionAuto(m, u => x > y && 0 < u ==> x * u > y * u);\n    LemmaMulInductionAuto(m, u => x > y && 0 > u ==> x * u < y * u);\n    LemmaMulInductionAuto(m, u => x < y && 0 < u ==> x * u < y * u);\n    LemmaMulInductionAuto(m, u => x < y && 0 > u ==> x * u > y * u);\n  }\n\n  /* if any two seperate integers are each multiplied by a common integer and the products are equal, the \n  two original integers are equal */\n  lemma LemmaMulEqualityConverseAuto()\n    ensures forall m: int, x: int, y: int {:trigger m * x, m * y} :: (m != 0 && m * x == m * y) ==> x == y\n  {\n    forall (m: int, x: int, y: int | m != 0 && m * x == m * y)\n      ensures x == y\n    {\n      LemmaMulEqualityConverse(m, x, y);\n    }\n  }\n\n  /* when two integers, x and y, are each multiplied by a positive integer, z, if x <= z then the x*z <= y*z */\n  lemma LemmaMulInequalityConverse(x: int, y: int, z: int)\n    requires x * z <= y * z\n    requires z > 0\n    ensures  x <= y\n  {\n    LemmaMulInductionAuto(z, u => x * u <= y * u && u > 0 ==> x <= y);\n  }\n\n  /* when two integers, x and y, are each multiplied by a positive integer, z, if x <= z then the x*z <= y*z \n  for all valid values of x, y, and z*/\n  lemma LemmaMulInequalityConverseAuto()\n    ensures  forall x: int, y: int, z: int {:trigger x * z, y * z} :: x * z <= y * z && z > 0 ==> x <= y\n  {\n    forall (x: int, y: int, z: int | x * z <= y * z && z > 0)\n      ensures x <= y\n    {\n      LemmaMulInequalityConverse(x, y, z);\n    }\n  }\n\n  /* when two integers, x and y, are each multiplied by a positive integer, z, if x < z then the x*z < y*z */\n  lemma LemmaMulStrictInequalityConverse(x: int, y: int, z: int)\n    requires x * z < y * z\n    requires z >= 0\n    ensures  x < y\n  {\n    LemmaMulInductionAuto(z, u => x * u < y * u && u >= 0 ==> x < y);\n  }\n\n  /* when two integers, x and y, are each multiplied by a positive integer, z, if x < z then the x*z < y*z \n  for all valid values of x, y, and z*/\n  lemma LemmaMulStrictInequalityConverseAuto()\n    ensures  forall x: int, y: int, z: int {:trigger x * z, y * z} :: x * z < y * z && z >= 0 ==> x < y\n  {\n    forall (x: int, y: int, z: int | x * z < y * z && z >= 0)\n      ensures x < y;\n    {\n      LemmaMulStrictInequalityConverse(x, y, z);\n    }\n  }\n\n  /* multiplication is distributive */\n  lemma LemmaMulIsDistributiveAdd(x: int, y: int, z: int)\n    ensures x * (y + z) == x * y + x * z\n  {\n    MulINL.LemmaMulIsDistributiveAdd(x, y, z);\n  }\n\n  /* for all integers, multiplication is distributive with addition in the form x * (y + z) */\n  lemma LemmaMulIsDistributiveAddAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z\n  {\n    forall (x: int, y: int, z: int)\n      ensures x * (y + z) == x * y + x * z\n    {\n      LemmaMulIsDistributiveAdd(x, y, z);\n    }\n  }\n\n  /* for all integers, multiplication is distributive with addition in the form (y + z) * x */\n  lemma LemmaMulIsDistributiveAddOtherWay(x: int, y: int, z: int)\n    ensures (y + z) * x == y * x + z * x\n  {\n    LemmaMulAuto();\n  }\n\n  lemma LemmaMulIsDistributiveAddOtherWayAuto()\n    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x\n  {\n    forall (x: int, y: int, z: int)\n      ensures (y+z) * x == y * x + z * x\n    {\n      LemmaMulIsDistributiveAddOtherWay(x, y, z);\n    }\n  }\n\n  /* multiplication is distributive with subtraction */\n  lemma LemmaMulIsDistributiveSub(x: int, y: int, z: int)\n    ensures x * (y - z) == x * y - x * z\n  {\n    LemmaMulAuto();\n  }\n\n  /* for all integers, multiplication is distributive with subtraction */\n  lemma LemmaMulIsDistributiveSubAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z\n  {\n    forall (x: int, y: int, z: int)\n      ensures x * (y - z) == x * y - x * z;\n    {\n      LemmaMulIsDistributiveSub(x, y, z);\n    }\n  }\n\n  /* proves the overall distributive nature of multiplication*/\n  lemma LemmaMulIsDistributive(x: int, y: int, z: int)\n    ensures x * (y + z) == x * y + x * z\n    ensures x * (y - z) == x * y - x * z\n    ensures (y + z) * x == y * x + z * x\n    ensures (y - z) * x == y * x - z * x\n    ensures x * (y + z) == (y + z) * x\n    ensures x * (y - z) == (y - z) * x\n    ensures x * y == y * x\n    ensures x * z == z * x\n  {\n    LemmaMulAuto();\n  }\n\n  /* for all integers, multiplication is distributive */\n  lemma LemmaMulIsDistributiveAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z\n    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z\n    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x\n    ensures forall x: int, y: int, z: int {:trigger (y - z) * x} :: (y - z) * x == y * x - z * x\n  {\n    LemmaMulIsDistributiveAddAuto();\n    LemmaMulIsDistributiveSubAuto();\n    LemmaMulIsCommutativeAuto();\n  }\n\n  /* multiplying two positive integers will result in a positive integer */\n  lemma LemmaMulStrictlyPositive(x: int, y: int)\n    ensures (0 < x && 0 < y) ==> (0 < x * y)\n  {\n    MulINL.LemmaMulStrictlyPositive(x, y);\n  }\n\n  /* multiplying any two positive integers will result in a positive integer */\n  lemma LemmaMulStrictlyPositiveAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y) ==> (0 < x * y)\n  {\n    forall (x: int, y: int | 0 < x && 0 < y)\n      ensures 0 < x * y\n    {\n      LemmaMulStrictlyPositive(x,y);\n    }\n  }\n\n  /* multiplying a positive integer by an integer greater than 1 will result in a product that \n  is greater than the original integer */\n  lemma LemmaMulStrictlyIncreases(x: int, y: int)\n    requires 1 < x\n    requires 0 < y\n    ensures y < x * y\n  {\n    LemmaMulInductionAuto(x, u => 1 < u ==> y < u * y);\n  }\n\n  /* multiplying any positive integer by any integer greater than 1 will result in a product that \n  is greater than the original integer */\n  lemma LemmaMulStrictlyIncreasesAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: 1 < x && 0 < y  ==> y < x * y\n  {\n    forall (x: int, y: int | 1 < x && 0 < y)\n      ensures y < x * y\n    {\n      LemmaMulStrictlyIncreases(x, y);\n    }\n  }\n\n  /* multiplying an integer by a positive integer will result in a product that is greater than or\n  equal to the original integer */\n  lemma LemmaMulIncreases(x: int, y: int)\n    requires 0 < x\n    requires 0 < y\n    ensures y <= x * y\n  {\n    LemmaMulInductionAuto(x, u => 0 < u ==> y <= u * y);\n  }\n\n  /* multiplying any integer by any positive integer will result in a product that is greater than or\n  equal to the original integer */\n  lemma LemmaMulIncreasesAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y) ==> (y <= x * y)\n  {\n    forall (x: int, y: int | 0 < x && 0 < y)\n      ensures y <= x * y\n    {\n      LemmaMulIncreases(x, y);\n    }\n  }\n\n  /* multiplying two positive numbers will result in a positive product */\n  lemma LemmaMulNonnegative(x: int, y: int)\n    requires 0 <= x\n    requires 0 <= y\n    ensures  0 <= x * y\n  {\n    LemmaMulInductionAuto(x, u => 0 <= u ==> 0 <= u * y);\n  }\n\n  /* multiplying any two positive numbers will result in a positive product */\n  lemma LemmaMulNonnegativeAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: 0 <= x && 0 <= y ==> 0 <= x * y\n  {\n    forall (x: int, y: int | 0 <= x && 0 <= y)\n      ensures 0 <= x * y\n    {\n      LemmaMulNonnegative(x, y);\n    }\n  }\n\n  /* shows the equivalent forms of using the unary negation operator */\n  lemma LemmaMulUnaryNegation(x: int, y: int)\n    ensures (-x) * y == -(x * y) == x * (-y)\n  {\n    LemmaMulInductionAuto(x, u => (-u) * y == -(u * y) == u * (-y));\n  }\n\n  /* shows the equivalent forms of using the unary negation operator for any integers*/\n  lemma LemmaMulUnaryNegationAuto()\n    ensures forall x: int, y: int {:trigger (-x) * y} {:trigger x * (-y)} :: (-x) * y == -(x * y) == x * (-y)\n  {\n    forall (x: int, y: int)\n      ensures (-x) * y == -(x * y) == x * (-y)\n    {\n      LemmaMulUnaryNegation(x, y);\n    }\n  }\n\n  /* multiplying two negative integers, -x and -y, is equivalent to multiplying x and y */\n  lemma LemmaMulCancelsNegatives(x: int, y: int)\n    ensures x * y == (-x) * (-y)\n  {\n    LemmaMulUnaryNegationAuto();\n  }\n\n  /* multiplying two negative integers, -x and -y, is equivalent to multiplying x and y */\n  lemma LemmaMulCancelsNegativesAuto()\n    ensures forall x: int, y: int {:trigger x * y} :: x * y == (-x) * (-y)\n  {\n    forall x: int, y: int\n      ensures x * y == (-x) * (-y)\n    {\n      LemmaMulCancelsNegatives(x, y);\n    }\n  }\n\n  /* includes all properties of multiplication */\n  lemma LemmaMulProperties()\n    ensures forall x: int, y: int {:trigger x * y} :: x * y == y * x\n    ensures forall x: int {:trigger x * 1}{:trigger 1 * x} :: x * 1 == 1 * x == x\n    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x < y && z > 0 ==> x * z < y * z\n    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x <= y && z >= 0 ==> x * z <= y * z\n    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z\n    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z\n    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x\n    ensures forall x: int, y: int, z: int {:trigger (y - z) * x} :: (y - z) * x == y * x - z * x\n    ensures forall x: int, y: int, z: int {:trigger x * (y * z)}{:trigger (x * y) * z} :: x * (y * z) == (x * y) * z\n    ensures forall x: int, y: int {:trigger x * y} :: x * y != 0 <==> x != 0 && y != 0\n    ensures forall x: int, y: int {:trigger x * y} :: 0 <= x && 0 <= y ==> 0 <= x * y\n    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y && 0 <= x * y ==> x <= x * y && y <= x * y\n    ensures forall x: int, y: int {:trigger x * y} :: (1 < x && 0 < y) ==> (y < x * y)\n    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y) ==> (y <= x * y)\n    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y) ==> (0 < x * y)\n  {\n    LemmaMulStrictInequalityAuto();\n    LemmaMulInequalityAuto();\n    LemmaMulIsDistributiveAuto();\n    LemmaMulIsAssociativeAuto();\n    LemmaMulOrderingAuto();\n    LemmaMulNonzeroAuto();\n    LemmaMulNonnegativeAuto();\n    LemmaMulStrictlyIncreasesAuto();\n    LemmaMulIncreasesAuto();\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Internals/MulInternalsNonlinear.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/** Declares some helper lemmas about multiply, for internal use */\nmodule {:options \"-functionSyntax:4\"} Dafny.MulInternalsNonlinear\n{\n\n  /* WARNING: Think three times before adding to this file, as nonlinear\n  verification is highly unstable! */\n\n  /* multiplying two positive integers will result in a positive integer */\n  lemma LemmaMulStrictlyPositive(x: int, y: int)\n    ensures (0 < x && 0 < y) ==> (0 < x * y)\n  {}\n\n  /* multiplying two nonzero integers will never result in 0 as the poduct */\n  lemma LemmaMulNonzero(x: int, y: int)\n    ensures x * y != 0 <==> x != 0 && y != 0\n  {}\n\n  /* multiplication is associative */\n  lemma LemmaMulIsAssociative(x: int, y: int, z: int)\n    ensures x * (y * z) == (x * y) * z\n  {}\n\n  /* multiplication is distributive */\n  lemma LemmaMulIsDistributiveAdd(x: int, y: int, z: int)\n    ensures x * (y + z) == x * y + x * z\n  {}\n\n  /* the product of two integers is greater than the value of each individual integer */\n  lemma LemmaMulOrdering(x: int, y: int)\n    requires x != 0\n    requires y != 0\n    requires 0 <= x * y\n    ensures x * y >= x && x * y >= y\n  {}\n\n  /* multiplying by a positive integer preserves inequality */\n  lemma LemmaMulStrictInequality(x: int, y: int, z: int)\n    requires x < y\n    requires z > 0\n    ensures  x * z < y * z\n  {}\n\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Internals/DivInternalsNonlinear.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/** Declares a few helper lemmas for internal use in non-linear arithmetic */\nmodule {:options \"-functionSyntax:4\"} Dafny.DivInternalsNonlinear\n{\n\n  /* WARNING: Think three times before adding to this file, as nonlinear\n  verification is highly unstable! */\n\n  /* zero divided by an integer besides 0 is 0 */\n  lemma LemmaDivOf0(d:int)\n    requires d != 0\n    ensures 0 / d == 0\n  {\n  }\n\n  /* the quotient of an integer divided by itself is 1 */\n  lemma LemmaDivBySelf(d:int)\n    requires d != 0\n    ensures d / d == 1\n  {\n  }\n\n  /* dividing a smaller integer by a larger integer results in a quotient of 0  */\n  lemma LemmaSmallDiv()\n    ensures forall x, d {:trigger x / d} :: 0 <= x < d && d > 0 ==> x / d == 0\n  {\n  }\n\n  /* the quotient of dividing a positive real number (not 0) by a smaller positive real number\n  will be greater than 1 */\n  lemma LemmaRealDivGt(x:real, y:real)\n    requires x > y\n    requires x >= 0.0\n    requires y > 0.0\n    ensures  x / y > 1 as real\n  {\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Internals/ModInternalsNonlinear.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/** Declares helper lemmas about the mod operation */\nmodule {:options \"-functionSyntax:4\"} Dafny.ModInternalsNonlinear\n{\n\n  /* WARNING: Think three times before adding to this file, as nonlinear\n  verification is highly unstable! */\n\n  /* the remainder of 0 divided by an integer is 0 */\n  lemma LemmaModOfZeroIsZero(m:int)\n    requires 0 < m\n    ensures 0 % m == 0\n  {\n  }\n\n  /* describes fundementals of the modulus operator */\n  lemma LemmaFundamentalDivMod(x:int, d:int)\n    requires d != 0\n    ensures x == d * (x / d) + (x % d)\n  {\n  }\n\n  /* the remained of 0 divided by any integer is always 0 */\n  lemma Lemma0ModAnything()\n    ensures forall m: int {:trigger 0 % m} :: m > 0 ==> 0 % m == 0\n  {\n  }\n\n  /* a natural number x divided by a larger natural number gives a remainder equal to x */\n  lemma LemmaSmallMod(x:nat, m:nat)\n    requires x < m\n    requires 0 < m\n    ensures x % m == x\n  {\n  }\n\n  /* the range of the modulus of any integer will be [0, m) where m is the divisor */\n  lemma LemmaModRange(x:int, m:int)\n    requires m > 0\n    ensures 0 <= x % m < m\n  {\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Internals/Internals.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"DivInternals.dfy\"\ninclude \"DivInternalsNonlinear.dfy\"\ninclude \"GeneralInternals.dfy\"\ninclude \"ModInternals.dfy\"\ninclude \"ModInternalsNonlinear.dfy\"\ninclude \"MulInternals.dfy\"\ninclude \"MulInternalsNonlinear.dfy\"\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Internals/DivInternals.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* lemmas and functions in this file are used in the proofs in DivMod.dfy \n\nSpecs/implements mathematical div and mod, not the C version.\n(x div n) * n + (x mod n) == x, where 0 <= x mod n < n.\nhttps://en.wikipedia.org/wiki/Modulo_operation\n\nThis may produce \"surprising\" results for negative values.\nFor example, -3 div 5 is -1 and -3 mod 5 is 2.\nNote this is consistent: -3 * -1 + 2 == 5 */\n\ninclude \"GeneralInternals.dfy\"\ninclude \"ModInternals.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.DivInternals {\n\n  import opened GeneralInternals\n  import opened ModInternals\n  import opened ModInternalsNonlinear\n  import opened DivInternalsNonlinear\n  import opened MulInternals\n\n  /* Performs division recursively with positive denominator. */\n  function {:opaque} DivPos(x: int, d: int): int\n    requires d > 0\n    decreases if x < 0 then (d - x) else x\n  {\n    if x < 0 then\n      -1 + DivPos(x + d, d)\n    else if x < d then\n      0\n    else\n      1 + DivPos(x - d, d)\n  }\n\n  /* Performs division recursively. */\n  function {:opaque} DivRecursive(x: int, d: int): int\n    requires d != 0\n  {\n    reveal DivPos();\n    if d > 0 then\n      DivPos(x, d)\n    else\n      -1 * DivPos(x, -1 * d)\n  }\n\n  /* Proves the basics of the division operation */\n  lemma LemmaDivBasics(n: int)\n    requires n > 0\n    ensures  n / n == -((-n) / n) == 1\n    ensures  forall x:int {:trigger x / n} :: 0 <= x < n <==> x / n == 0\n    ensures  forall x:int {:trigger (x + n) / n} :: (x + n) / n == x / n + 1\n    ensures  forall x:int {:trigger (x - n) / n} :: (x - n) / n == x / n - 1\n  {\n    LemmaModAuto(n);\n    LemmaModBasics(n);\n    LemmaSmallDiv();\n    LemmaDivBySelf(n);\n    forall x: int | x / n == 0\n      ensures 0 <= x < n\n    {\n      LemmaFundamentalDivMod(x, n);\n    }\n  }\n\n  /* Automates the division operator process. Contains the identity property, a\n  fact about when quotients are zero, and facts about adding and subtracting\n  integers over a common denominator. */\n  ghost predicate DivAuto(n: int)\n    requires n > 0\n  {\n    && ModAuto(n)\n    && (n / n == -((-n) / n) == 1)\n    && (forall x: int {:trigger x / n} :: 0 <= x < n <==> x / n == 0)\n    && (forall x: int, y: int {:trigger (x + y) / n} ::\n          (var z := (x % n) + (y % n);\n           ((0 <= z < n && (x + y) / n == x / n + y / n) ||\n            (n <= z < n + n && (x + y) / n == x / n + y / n + 1))))\n    && (forall x: int, y: int {:trigger (x - y) / n} ::\n          (var z := (x % n) - (y % n);\n           ((0 <= z < n && (x - y) / n == x / n - y / n) ||\n            (-n <= z < 0 && (x - y) / n == x / n - y / n - 1))))\n  }\n\n  /* Ensures that DivAuto is true */\n  lemma LemmaDivAuto(n: int)\n    requires n > 0\n    ensures  DivAuto(n)\n  {\n    LemmaModAuto(n);\n    LemmaDivBasics(n);\n    assert (0 + n) / n == 1;\n    assert (0 - n) / n == -1;\n    forall x:int, y:int {:trigger (x + y) / n}\n      ensures  var z := (x % n) + (y % n);\n               (|| (0 <= z < n && (x + y) / n == x / n + y / n)\n                || (n <= z < 2 * n && (x + y) / n == x / n + y / n + 1))\n    {\n      var f := (xx:int, yy:int) =>\n          (var z := (xx % n) + (yy % n);\n           (   (0 <= z < n && (xx + yy) / n == xx / n + yy / n)\n               || (n <= z < 2 * n && (xx + yy) / n == xx / n + yy / n + 1)));\n      forall i, j\n        ensures j >= 0 && f(i, j) ==> f(i, j + n)\n        ensures i < n  && f(i, j) ==> f(i - n, j)\n        ensures j < n  && f(i, j) ==> f(i, j - n)\n        ensures i >= 0 && f(i, j) ==> f(i + n, j)\n      {\n        assert ((i + n) + j) / n == ((i + j) + n) / n;\n        assert (i + (j + n)) / n == ((i + j) + n) / n;\n        assert ((i - n) + j) / n == ((i + j) - n) / n;\n        assert (i + (j - n)) / n == ((i + j) - n) / n;\n      }\n      forall i, j\n        ensures 0 <= i < n && 0 <= j < n ==> f(i, j)\n      {\n        assert ((i + n) + j) / n == ((i + j) + n) / n;\n        assert (i + (j + n)) / n == ((i + j) + n) / n;\n        assert ((i - n) + j) / n == ((i + j) - n) / n;\n        assert (i + (j - n)) / n == ((i + j) - n) / n;\n      }\n      LemmaModInductionForall2(n, f);\n      assert f(x, y);\n    }\n    forall x:int, y:int {:trigger (x - y) / n}\n      ensures  var z := (x % n) - (y % n);\n               (|| (0 <= z < n && (x - y) / n == x / n - y / n)\n                || (-n <= z < 0 && (x - y) / n == x / n - y / n - 1))\n    {\n      var f := (xx:int, yy:int) =>\n          (var z := (xx % n) - (yy % n);\n           (   (0 <= z < n && (xx - yy) / n == xx / n - yy / n)\n               || (-n <= z < 0 && (xx - yy) / n == xx / n - yy / n - 1)));\n      forall i, j\n        ensures j >= 0 && f(i, j) ==> f(i, j + n)\n        ensures i < n  && f(i, j) ==> f(i - n, j)\n        ensures j < n  && f(i, j) ==> f(i, j - n)\n        ensures i >= 0 && f(i, j) ==> f(i + n, j)\n      {\n        assert ((i + n) - j) / n == ((i - j) + n) / n;\n        assert (i - (j - n)) / n == ((i - j) + n) / n;\n        assert ((i - n) - j) / n == ((i - j) - n) / n;\n        assert (i - (j + n)) / n == ((i - j) - n) / n;\n      }\n      forall i, j\n        ensures 0 <= i < n && 0 <= j < n ==> f(i, j)\n      {\n        assert ((i + n) - j) / n == ((i - j) + n) / n;\n        assert (i - (j - n)) / n == ((i - j) + n) / n;\n        assert ((i - n) - j) / n == ((i - j) - n) / n;\n        assert (i - (j + n)) / n == ((i - j) - n) / n;\n      }\n      LemmaModInductionForall2(n, f);\n      assert f(x, y);\n    }\n  }\n\n  /* Performs auto induction for division */\n  lemma LemmaDivInductionAuto(n: int, x: int, f: int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  f(x)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n\n  /* Performs auto induction on division for all i s.t. f(i) exists */\n  lemma LemmaDivInductionAutoForall(n:int, f:int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Internals/GeneralInternals.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/** Declares helper lemmas and predicates for non-linear arithmetic */\nmodule {:options \"-functionSyntax:4\"} Dafny.GeneralInternals\n{\n\n  /* this predicate is primarily used as a trigger */\n  ghost predicate IsLe(x: int, y: int)\n  {\n    x <= y\n  }\n\n  /* aids in the process of induction for modulus */\n  lemma LemmaInductionHelper(n: int, f: int -> bool, x: int)\n    requires n > 0\n    requires forall i :: 0 <= i < n ==> f(i)\n    requires forall i {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)\n    requires forall i {:trigger f(i), f(i - n)} :: i < n  && f(i) ==> f(i - n)\n    ensures  f(x)\n    decreases if x >= n then x else -x\n  {\n    if (x >= n)\n    {\n      LemmaInductionHelper(n, f, x - n);\n      assert f((x - n) + n);\n    }\n    else if (x < 0)\n    {\n      LemmaInductionHelper(n, f, x + n);\n      assert f((x + n) - n);\n    }\n  }\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Internals/MulInternals.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* lemmas and functions in this file are used in the proofs in Mul.dfy */\n\ninclude \"GeneralInternals.dfy\"\ninclude \"MulInternalsNonlinear.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.MulInternals {\n\n  import opened GeneralInternals\n  import opened MulInternalsNonlinear\n\n  /* performs multiplication for positive integers using recursive addition */\n  function {:opaque} MulPos(x: int, y: int) : int\n    requires x >= 0\n  {\n    if x == 0 then 0\n    else y + MulPos(x - 1, y)\n  }\n\n  /* performs multiplication for both positive and negative integers */\n  function MulRecursive(x: int, y: int) : int\n  {\n    if x >= 0 then MulPos(x, y)\n    else -1 * MulPos(-1 * x, y)\n  }\n\n  /* performs induction on multiplication */\n  lemma LemmaMulInduction(f: int -> bool)\n    requires f(0)\n    requires forall i {:trigger f(i), f(i + 1)} :: i >= 0 && f(i) ==> f(i + 1)\n    requires forall i {:trigger f(i), f(i - 1)} :: i <= 0 && f(i) ==> f(i - 1)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    forall i ensures f(i) { LemmaInductionHelper(1, f, i); }\n  }\n\n  /* proves that multiplication is always commutative */\n  lemma LemmaMulCommutes()\n    ensures  forall x:int, y:int {:trigger x * y} :: x * y == y * x\n  {\n    forall x:int, y:int\n      ensures x * y == y * x\n    {\n      LemmaMulInduction(i => x * i == i * x);\n    }\n  }\n\n  /* proves the distributive property of multiplication when multiplying an interger\n  by (x +/- 1) */\n  //rename for both directions ???\n  lemma LemmaMulSuccessor()\n    ensures forall x:int, y:int {:trigger (x + 1) * y} :: (x + 1) * y == x * y + y\n    ensures forall x:int, y:int {:trigger (x - 1) * y} :: (x - 1) * y == x * y - y\n  {\n    LemmaMulCommutes();\n    forall x:int, y:int\n      ensures (x + 1) * y == x * y + y\n      ensures (x - 1) * y == x * y - y\n    {\n      LemmaMulIsDistributiveAdd(y, x, 1);\n      LemmaMulIsDistributiveAdd(y, x, -1);\n    }\n  }\n\n  /* proves the distributive property of multiplication */\n  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n\n  /* groups distributive and associative properties of multiplication */\n  ghost predicate MulAuto()\n  {\n    && (forall x:int, y:int {:trigger x * y} :: x * y == y * x)\n    && (forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z)\n    && (forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z)\n  }\n\n  /* proves that MulAuto is valid */\n  lemma LemmaMulAuto()\n    ensures  MulAuto()\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n  }\n\n  /* performs auto induction for multiplication */\n  lemma LemmaMulInductionAuto(x: int, f: int -> bool)\n    requires MulAuto() ==> && f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  f(x)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n    assert forall i {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInduction(f);\n    assert f(x);\n  }\n\n  /* performs auto induction on multiplication for all i s.t. f(i) exists */\n  lemma LemmaMulInductionAutoForall(f: int -> bool)\n    requires MulAuto() ==> && f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n    assert forall i {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInduction(f);\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Internals/ModInternals.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* lemmas and functions in this file are used in the proofs in DivMod.dfy\n\nSpecs/implements mathematical div and mod, not the C version.\n(x div n) * n + (x mod n) == x, where 0 <= x mod n < n.\nhttps://en.wikipedia.org/wiki/Modulo_operation\n\nThis may produce \"surprising\" results for negative values.\nFor example, -3 div 5 is -1 and -3 mod 5 is 2.\nNote this is consistent: -3 * -1 + 2 == 5 */\n\ninclude \"GeneralInternals.dfy\"\ninclude \"MulInternals.dfy\"\ninclude \"../Multiply.dfy\"\ninclude \"ModInternalsNonlinear.dfy\"\ninclude \"DivInternalsNonlinear.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.ModInternals {\n\n  import opened GeneralInternals\n  import opened Multiply\n  import opened MulInternalsNonlinear\n  import opened MulInternals\n  import opened ModInternalsNonlinear\n  import opened DivInternalsNonlinear\n\n  /* Performs modulus recursively. */\n  function {:opaque} ModRecursive(x: int, d: int): int\n    requires d > 0\n    decreases if x < 0 then (d - x) else x\n  {\n    if x < 0 then\n      ModRecursive(d + x, d)\n    else if x < d then\n      x\n    else\n      ModRecursive(x - d, d)\n  }\n\n  /* performs induction on modulus */\n  lemma LemmaModInductionForall(n: int, f: int -> bool)\n    requires n > 0\n    requires forall i :: 0 <= i < n ==> f(i)\n    requires forall i {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)\n    requires forall i {:trigger f(i), f(i - n)} :: i < n  && f(i) ==> f(i - n)\n    ensures  forall i :: f(i)\n  {\n    forall i ensures f(i) { LemmaInductionHelper(n, f, i); }\n  }\n\n  /* given an integer x and divisor n, the remainder of x%n is equivalent to the remainder of (x+m)%n\n  where m is a multiple of n */\n  lemma LemmaModInductionForall2(n: int, f:(int, int)->bool)\n    requires n > 0\n    requires forall i, j :: 0 <= i < n && 0 <= j < n ==> f(i, j)\n    requires forall i, j {:trigger f(i, j), f(i + n, j)} :: i >= 0 && f(i, j) ==> f(i + n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j + n)} :: j >= 0 && f(i, j) ==> f(i, j + n)\n    requires forall i, j {:trigger f(i, j), f(i - n, j)} :: i < n  && f(i, j) ==> f(i - n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j - n)} :: j < n  && f(i, j) ==> f(i, j - n)\n    ensures  forall i, j :: f(i, j)\n  {\n    forall x, y\n      ensures f(x, y)\n    {\n      forall i | 0 <= i < n\n        ensures f(i, y)\n      {\n        var fj := j => f(i, j);\n        LemmaModInductionForall(n, fj);\n        assert fj(y);\n      }\n      var fi := i => f(i, y);\n      LemmaModInductionForall(n, fi);\n      assert fi(x);\n    }\n  }\n\n  lemma LemmaDivAddDenominator(n: int, x: int)\n    requires n > 0\n    ensures (x + n) / n == x / n + 1\n  {\n    LemmaFundamentalDivMod(x, n);\n    LemmaFundamentalDivMod(x + n, n);\n    var zp := (x + n) / n - x / n - 1;\n    forall ensures 0 == n * zp + ((x + n) % n) - (x % n) { LemmaMulAuto(); }\n    if (zp > 0) { LemmaMulInequality(1, zp, n); }\n    if (zp < 0) { LemmaMulInequality(zp, -1, n); }\n  }\n\n  lemma LemmaDivSubDenominator(n: int, x: int)\n    requires n > 0\n    ensures (x - n) / n == x / n - 1\n  {\n    LemmaFundamentalDivMod(x, n);\n    LemmaFundamentalDivMod(x - n, n);\n    var zm := (x - n) / n - x / n + 1;\n    forall ensures 0 == n * zm + ((x - n) % n) - (x % n) { LemmaMulAuto(); }\n    if (zm > 0) { LemmaMulInequality(1, zm, n); }\n    if (zm < 0) { LemmaMulInequality(zm, -1, n); }\n  }\n\n  lemma LemmaModAddDenominator(n: int, x: int)\n    requires n > 0\n    ensures (x + n) % n == x % n\n  {\n    LemmaFundamentalDivMod(x, n);\n    LemmaFundamentalDivMod(x + n, n);\n    var zp := (x + n) / n - x / n - 1;\n    forall ensures 0 == n * zp + ((x + n) % n) - (x % n) { LemmaMulAuto(); }\n    if (zp > 0) { LemmaMulInequality(1, zp, n); }\n    if (zp < 0) { LemmaMulInequality(zp, -1, n); }\n  }\n\n  lemma LemmaModSubDenominator(n: int, x: int)\n    requires n > 0\n    ensures (x - n) % n == x % n\n  {\n    LemmaFundamentalDivMod(x, n);\n    LemmaFundamentalDivMod(x - n, n);\n    var zm := (x - n) / n - x / n + 1;\n    forall ensures 0 == n * zm + ((x - n) % n) - (x % n) { LemmaMulAuto(); }\n    if (zm > 0) { LemmaMulInequality(1, zm, n); }\n    if (zm < 0) { LemmaMulInequality(zm, -1, n); }\n  }\n\n  lemma LemmaModBelowDenominator(n: int, x: int)\n    requires n > 0\n    ensures 0 <= x < n <==> x % n == x\n  {\n    forall x: int\n      ensures 0 <= x < n <==> x % n == x\n    {\n      if (0 <= x < n) { LemmaSmallMod(x, n); }\n      LemmaModRange(x, n);\n    }\n  }\n\n  /* proves the basics of the modulus operation */\n  lemma LemmaModBasics(n: int)\n    requires n > 0\n    ensures  forall x: int {:trigger (x + n) % n} :: (x + n) % n == x % n\n    ensures  forall x: int {:trigger (x - n) % n} :: (x - n) % n == x % n\n    ensures  forall x: int {:trigger (x + n) / n} :: (x + n) / n == x / n + 1\n    ensures  forall x: int {:trigger (x - n) / n} :: (x - n) / n == x / n - 1\n    ensures  forall x: int {:trigger x % n} :: 0 <= x < n <==> x % n == x\n  {\n    forall x: int\n      ensures (x + n) % n == x % n\n      ensures (x - n) % n == x % n\n      ensures (x + n) / n == x / n + 1\n      ensures (x - n) / n == x / n - 1\n      ensures 0 <= x < n <==> x % n == x\n    {\n      LemmaModBelowDenominator(n, x);\n      LemmaModAddDenominator(n, x);\n      LemmaModSubDenominator(n, x);\n      LemmaDivAddDenominator(n, x);\n      LemmaDivSubDenominator(n, x);\n    }\n  }\n\n  /* proves the quotient remainder theorem */\n  lemma {:vcs_split_on_every_assert} LemmaQuotientAndRemainder(x: int, q: int, r: int, n: int)\n    requires n > 0\n    requires 0 <= r < n\n    requires x == q * n + r\n    ensures  q == x / n\n    ensures  r == x % n\n    decreases if q > 0 then q else -q\n  {\n    LemmaModBasics(n);\n\n    if q > 0 {\n      MulInternalsNonlinear.LemmaMulIsDistributiveAdd(n, q - 1, 1);\n      LemmaMulIsCommutativeAuto();\n      assert q * n + r == (q - 1) * n + n + r;\n      LemmaQuotientAndRemainder(x - n, q - 1, r, n);\n    }\n    else if q < 0 {\n      Multiply.LemmaMulIsDistributiveSub(n, q + 1, 1);\n      LemmaMulIsCommutativeAuto();\n      assert q * n + r == (q + 1) * n - n + r;\n      LemmaQuotientAndRemainder(x + n, q + 1, r, n);\n    }\n    else {\n      LemmaSmallDiv();\n      assert r / n == 0;\n    }\n  }\n\n  /* automates the modulus operator process */\n  ghost predicate ModAuto(n: int)\n    requires n > 0;\n  {\n    && (n % n == (-n) % n == 0)\n    && (forall x: int {:trigger (x % n) % n} :: (x % n) % n == x % n)\n    && (forall x: int {:trigger x % n} :: 0 <= x < n <==> x % n == x)\n    && (forall x: int, y: int {:trigger (x + y) % n} ::\n          (var z := (x % n) + (y % n);\n           (  (0 <= z < n     && (x + y) % n == z)\n              || (n <= z < n + n && (x + y) % n == z - n))))\n    && (forall x: int, y: int {:trigger (x - y) % n} ::\n          (var z := (x % n) - (y % n);\n           (   (0 <= z < n && (x - y) % n == z)\n               || (-n <= z < 0 && (x - y) % n == z + n))))\n  }\n\n  /* ensures that ModAuto is true */\n  lemma LemmaModAuto(n: int)\n    requires n > 0\n    ensures  ModAuto(n)\n  {\n    LemmaModBasics(n);\n    LemmaMulIsCommutativeAuto();\n    LemmaMulIsDistributiveAddAuto();\n    LemmaMulIsDistributiveSubAuto();\n\n    forall x: int, y: int {:trigger (x + y) % n}\n      ensures var z := (x % n) + (y % n);\n              || (0 <= z < n && (x + y) % n == z)\n              || (n <= z < 2 * n && (x + y) % n == z - n)\n    {\n      var xq, xr := x / n, x % n;\n      LemmaFundamentalDivMod(x, n);\n      assert x == xq * n + xr;\n      var yq, yr := y / n, y % n;\n      LemmaFundamentalDivMod(y, n);\n      assert y == yq * n + yr;\n      if xr + yr < n {\n        LemmaQuotientAndRemainder(x + y, xq + yq, xr + yr, n);\n      }\n      else {\n        LemmaQuotientAndRemainder(x + y, xq + yq + 1, xr + yr - n, n);\n      }\n    }\n\n    forall x: int, y: int {:trigger (x - y) % n}\n      ensures var z := (x % n) - (y % n);\n              || (0 <= z < n && (x - y) % n == z)\n              || (-n <= z < 0 && (x - y) % n == z + n)\n    {\n      var xq, xr := x / n, x % n;\n      LemmaFundamentalDivMod(x, n);\n      assert x == xq * n + xr;\n      var yq, yr := y / n, y % n;\n      LemmaFundamentalDivMod(y, n);\n      assert y == yq * n + yr;\n      if xr - yr >= 0 {\n        LemmaQuotientAndRemainder(x - y, xq - yq, xr - yr, n);\n      }\n      else {\n        LemmaQuotientAndRemainder(x - y, xq - yq - 1, xr - yr + n, n);\n      }\n    }\n  }\n\n  /* performs auto induction for modulus */\n  lemma LemmaModInductionAuto(n: int, x: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  f(x)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n\n  // not used in other files\n  /* performs auto induction on modulus for all i s.t. f(i) exists */\n  lemma LemmaModInductionAutoForall(n: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/DivMod.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* Every lemma comes in 2 forms: 'LemmaProperty' and 'LemmaPropertyAuto'. The\nformer takes arguments and may be more stable and less reliant on Z3\nheuristics. The latter includes automation and its use requires less effort */\n\ninclude \"Internals/DivInternalsNonlinear.dfy\"\ninclude \"Internals/DivInternals.dfy\"\ninclude \"Internals/GeneralInternals.dfy\"\ninclude \"Multiply.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.DivMod {\n\n  import opened DivInternals\n  import DivINL = DivInternalsNonlinear\n  import opened ModInternals\n  import ModINL = ModInternalsNonlinear\n  import opened MulInternals\n  import opened Multiply\n  import opened GeneralInternals\n\n  /*****************************************************************************\n   * Division:\n   *****************************************************************************/\n\n  /* the common syntax of division gives the same quotient as performing division through recursion */\n  lemma LemmaDivIsDivRecursive(x: int, d: int)\n    requires 0 < d\n    ensures DivRecursive(x, d) == x / d\n  {\n    reveal DivRecursive();\n    LemmaDivInductionAuto(d, x, u => DivRecursive(u, d) == u / d);\n  }\n\n  lemma LemmaDivIsDivRecursiveAuto()\n    ensures forall x: int, d: int {:trigger x / d} :: d > 0 ==> DivRecursive(x, d) == x / d\n  {\n    reveal DivRecursive();\n    forall x: int, d: int | d > 0\n      ensures DivRecursive(x, d) == x / d\n    {\n      LemmaDivIsDivRecursive(x, d);\n    }\n  }\n\n  /* the quotient of an integer divided by itself is 1 */\n  lemma LemmaDivBySelf(d: int)\n    requires d != 0\n    ensures d / d == 1\n  {\n    DivINL.LemmaDivBySelf(d);\n  }\n\n  /* zero divided by an integer besides 0 is 0 */\n  lemma LemmaDivOf0(d: int)\n    requires d != 0\n    ensures 0 / d == 0\n  {\n    DivINL.LemmaDivOf0(d);\n  }\n\n  /* ensures the basic propoerties of division: 0 divided by any integer is 0; any integer \n  divided by 1 is itself; any integer divided by itself is 1 */\n  lemma LemmaDivBasics(x: int)\n    ensures x != 0 ==> 0 / x == 0\n    ensures x / 1 == x\n    ensures x != 0 ==> x / x == 1\n  {\n    if (x != 0) {\n      LemmaDivBySelf(x);\n      LemmaDivOf0(x);\n    }\n  }\n\n  lemma LemmaDivBasicsAuto()\n    ensures forall x {:trigger 0 / x} :: x != 0 ==> 0 / x == 0\n    ensures forall x {:trigger x / 1} :: x / 1 == x\n    ensures forall x, y {:trigger x / y} :: x >= 0 && y > 0 ==> x / y >= 0\n    ensures forall x, y {:trigger x / y} :: x >= 0 && y > 0 ==> x / y <= x\n  {\n    forall x: int\n      ensures x != 0 ==> 0 / x == 0\n      ensures x / 1 == x\n    {\n      LemmaDivBasics(x);\n    }\n    forall x: int, y: int | x >= 0 && y > 0\n      ensures 0 <= x / y <= x\n    {\n      LemmaDivPosIsPos(x, y);\n      LemmaDivIsOrderedByDenominator(x, 1, y);\n    }\n  }\n\n  /* if a dividend is a whole number and the divisor is a natural number and their\n  quotient is 0, this implies that the dividend is smaller than the divisor */\n  lemma LemmaSmallDivConverseAuto()\n    ensures forall x, d {:trigger x / d } :: 0 <= x && 0 < d && x / d == 0 ==> x < d\n  {\n    forall x, d | 0 <= x && 0 < d && x / d == 0\n      ensures x < d\n    {\n      LemmaDivInductionAuto(d, x, u => 0 <= u && 0 < d && u / d == 0 ==> u < d);\n    }\n  }\n\n  /* given two fractions with the same numerator, the order of numbers is determined by \n  the denominators. However, if the numerator is 0, the fractions are equal regardless of \n  the denominators' values */\n  lemma LemmaDivIsOrderedByDenominator(x: int, y: int, z: int)\n    requires 0 <= x\n    requires 1 <= y <= z\n    ensures x / y >= x / z\n    decreases x\n  {\n    reveal DivRecursive();\n    LemmaDivIsDivRecursiveAuto();\n    assert forall u: int, d: int {:trigger u / d} {:trigger DivRecursive(u, d)}\n        :: d > 0 ==> DivRecursive(u, d) == u / d;\n\n    if (x < z)\n    {\n      LemmaDivIsOrdered(0, x, y);\n    }\n    else\n    {\n      LemmaDivIsOrdered(x - z, x - y, y);\n      LemmaDivIsOrderedByDenominator(x - z, y, z);\n    }\n  }\n\n  lemma LemmaDivIsOrderedByDenominatorAuto()\n    ensures forall x: int, y: int, z: int {:trigger x / y, x / z} :: 0 <= x && 1 <= y <= z ==> x / y >= x / z\n  {\n    forall (x: int, y: int, z: int | 0 <= x && 1 <= y <= z)\n      ensures x / y >= x / z\n    {\n      LemmaDivIsOrderedByDenominator(x, y, z);\n    }\n  }\n\n  /* given two fractions with the same numerator, the order of numbers is strictly determined by \n  the denominators.*/\n  lemma LemmaDivIsStrictlyOrderedByDenominator(x: int, d: int)\n    requires 0 < x\n    requires 1 < d\n    ensures x / d  < x\n    decreases x\n  {\n    LemmaDivInductionAuto(d, x, u => 0 < u ==> u / d < u);\n  }\n\n  lemma LemmaDivIsStrictlyOrderedByDenominatorAuto()\n    ensures forall x: int, d: int {:trigger x / d} :: 0 < x && 1 < d ==> x / d < x\n  {\n    forall (x: int, d: int | 0 < x && 1 < d )\n      ensures x / d < x\n    {\n      LemmaDivIsStrictlyOrderedByDenominator(x, d);\n    }\n  }\n\n  /* Rounding is different when multiplying the sum of two integers by a fraction d/d vs. \n  first multiplying each integer by d/d and then adding the quotients */\n  lemma LemmaDividingSums(a: int, b: int, d: int, R: int)\n    requires 0 < d\n    requires R == a % d + b % d - (a + b) % d\n    ensures d * ((a + b) / d) - R == d * (a / d) + d * (b / d)\n  {\n    calc ==> {\n      a % d + b % d == R + (a + b) % d;\n      (a + b) - (a + b) % d - R == a - (a % d) + b - (b % d);\n      {\n        LemmaFundamentalDivMod(a + b, d);\n        LemmaFundamentalDivMod(a, d);\n        LemmaFundamentalDivMod(b, d);\n      }\n      d * ((a + b) / d) - R == d * (a / d) + d * (b / d);\n    }\n  }\n\n  lemma LemmaDividingSumsAuto()\n    ensures forall a: int, b: int, d: int, R: int {:trigger d * ((a + b) / d) - R, d*(a/d) + d*(b/d)}\n              :: 0 < d &&  R == a%d + b%d - (a+b)%d ==> d*((a+b)/d) - R == d*(a/d) + d*(b/d)\n  {\n    forall (a: int, b: int, d: int, R: int | 0< d &&  R == a%d + b%d - (a+b)%d)\n      ensures d*((a+b)/d) - R == d*(a/d) + d*(b/d)\n    {\n      LemmaDividingSums(a, b, d, R);\n    }\n  }\n\n  /* dividing a whole number by a natural number will result in a quotient that is \n  greater than or equal to 0 */\n  lemma LemmaDivPosIsPos(x: int, d: int)\n    requires 0 <= x\n    requires 0 < d\n    ensures 0 <= x / d\n  {\n    LemmaDivInductionAuto(d, x, u => 0 <= u ==> u / d >= 0);\n  }\n\n  lemma LemmaDivPosIsPosAuto()\n    ensures forall x: int, d: int {:trigger x / d} :: 0 <= x && 0 < d ==> 0 <= x / d\n  {\n    forall (x: int, d: int | 0 <= x && 0 < d)\n      ensures 0 <= x / d\n    {\n      LemmaDivPosIsPos(x, d);\n    }\n  }\n\n  /* dividing an integer and then adding 1 to the quotient is the same as adding \n  the divisor and the integer, and then dividing that sum by the divisor */\n  lemma LemmaDivPlusOne(x: int, d: int)\n    requires 0 < d\n    ensures 1 + x / d == (d + x) / d\n  {\n    LemmaDivAuto(d);\n  }\n\n  lemma LemmaDivPlusOneAuto()\n    ensures forall x: int, d: int {:trigger 1 + x / d, (d + x) / d} :: 0 < d ==> 1 + x / d == (d + x) / d\n  {\n    forall (x: int, d: int | 0 < d)\n      ensures 1 + x / d == (d + x) / d\n    {\n      LemmaDivPlusOne(x, d);\n    }\n  }\n\n  /* dividing an integer and then subtracting 1 from the quotient is the same as subtracting \n  the divisor from the integer, and then dividing that difference by the divisor */\n  lemma LemmaDivMinusOne(x: int, d: int)\n    requires 0 < d\n    ensures -1 + x / d == (-d + x) / d\n  {\n    LemmaDivAuto(d);\n  }\n\n  lemma LemmaDivMinusOneAuto()\n    ensures forall x: int, d: int {:trigger -1 + x / d, (-d + x) / d} :: 0 < d ==> -1 + x / d == (-d + x) / d\n  {\n    forall (x: int, d: int | 0 < d)\n      ensures -1 + x / d == (-d + x) / d\n    {\n      LemmaDivMinusOne(x, d);\n    }\n  }\n\n  /* dividing a smaller integer by a larger integer results in a quotient of 0 */\n  lemma LemmaBasicDiv(d: int)\n    requires 0 < d\n    ensures forall x {:trigger x / d} :: 0 <= x < d ==> x / d == 0\n  {\n    LemmaDivAuto(d);\n  }\n\n  lemma LemmaBasicDivAuto()\n    ensures forall x: int, d: int {:trigger x / d} :: 0 <= x < d ==> x / d == 0\n  {\n    forall (x: int, d: int | 0 <= x < d)\n      ensures x / d == 0\n    {\n      LemmaBasicDiv(d);\n    }\n  }\n\n  /* numerical order is preserved when dividing two seperate integers by a common positive divisor */\n  lemma LemmaDivIsOrdered(x: int, y: int, z: int)\n    requires x <= y\n    requires 0 < z\n    ensures x / z <= y / z\n  {\n    LemmaDivInductionAuto(z, x - y, xy => xy <= 0 ==> (xy + y) / z <= y / z);\n  }\n\n  lemma LemmaDivIsOrderedAuto()\n    ensures forall x: int, y: int, z: int {:trigger x / z, y / z} :: x <= y && 0 < z ==> x / z <= y / z\n  {\n    forall (x: int, y: int, z: int | x <= y && 0 < z)\n      ensures x / z <= y / z\n    {\n      LemmaDivIsOrdered(x, y, z);\n    }\n  }\n\n  /* dividing an integer by 2 or more results in a quotient that is smaller than the \n  original dividend */\n  lemma LemmaDivDecreases(x: int, d: int)\n    requires 0 < x\n    requires 1 < d\n    ensures x / d  < x\n  {\n    LemmaDivInductionAuto(d, x, u => 0 < u ==> u / d < u);\n  }\n\n  lemma LemmaDivDecreasesAuto()\n    ensures forall x: int, d: int {:trigger x / d} :: 0 < x && 1 < d ==> x / d < x\n  {\n    forall (x: int, d: int | 0 < x && 1 < d)\n      ensures x / d < x\n    {\n      LemmaDivDecreases(x, d);\n    }\n  }\n\n  /* dividing an integer by 1 or more results in a quotient that is less than or equal to \n  the original dividend */\n  lemma LemmaDivNonincreasing(x: int, d: int)\n    requires 0 <= x\n    requires 0 < d\n    ensures x / d  <= x\n  {\n    LemmaDivInductionAuto(d, x, u => 0 <= u ==> u / d <= u);\n  }\n\n  lemma LemmaDivNonincreasingAuto()\n    ensures forall x: int, d: int {:trigger x / d } :: 0 <= x && 0 < d ==> x / d <= x\n  {\n    forall (x: int, d: int | 0 <= x && 0 < d)\n      ensures x / d <= x\n    {\n      LemmaDivNonincreasing(x, d);\n    }\n  }\n\n  /* a natural number x divided by a larger natural number gives a remainder equal to x */\n  lemma LemmaSmallMod(x: nat, m: nat)\n    requires x < m\n    requires 0 < m\n    ensures x % m == x\n  {\n    ModINL.LemmaSmallMod(x, m);\n  }\n\n  lemma LemmaBreakdown(x: int, y: int, z: int)\n    requires 0 <= x\n    requires 0 < y\n    requires 0 < z\n    ensures 0 < y * z\n    ensures x % (y * z) ==y * ((x / y) % z) + x % y\n  {\n    LemmaMulStrictlyPositiveAuto();\n    LemmaDivPosIsPos(x, y);\n    assert 0 <= x / y;\n\n    calc {\n      (y * (x / y)) % (y * z) + (x % y) % (y * z);\n    <=    { LemmaPartBound1(x, y, z); }\n      y * (z - 1) + (x % y) % (y * z);\n    <    { LemmaPartBound2(x, y, z); }\n      y * (z - 1) + y;\n          { LemmaMulBasicsAuto(); }\n      y * (z - 1) + y * 1;\n          { LemmaMulIsDistributiveAuto(); }\n      y * (z - 1 + 1);\n      y * z;\n    }\n\n    calc {\n      x % (y * z);\n      { LemmaFundamentalDivMod(x,y); }\n      (y * (x / y) + x % y) % (y * z);\n      {\n        LemmaModPropertiesAuto();\n        assert 0 <= x % y;\n        LemmaMulNonnegative(y, x / y);\n        assert (y * (x / y)) % (y * z) + (x % y) % (y * z) < y * z;\n        LemmaModAdds(y * (x / y), x % y, y * z);\n      }\n      (y * (x / y)) % (y * z) + (x % y) % (y * z);\n      {\n        LemmaModPropertiesAuto();\n        LemmaMulIncreases(z, y);\n        LemmaMulIsCommutativeAuto();\n        assert x % y < y <= y * z;\n        LemmaSmallMod(x % y, y * z);\n        assert (x % y) % (y * z) == x % y;\n      }\n      (y * (x / y)) % (y * z) + x % y;\n      { LemmaTruncateMiddle(x / y, y, z); }\n      y * ((x / y) % z) + x % y;\n    }\n  }\n\n  lemma LemmaBreakdownAuto()\n    ensures forall x: int, y: int, z: int {:trigger y * z, x % (y * z), y * ((x / y) % z) + x % y}\n              :: 0 <= x && 0 < y && 0 < z ==> 0 < y * z && x % (y * z) == y * ((x / y) % z) + x % y\n  {\n    forall (x: int, y: int, z: int  | 0 <= x && 0 < y && 0 < z)\n      ensures 0 < y * z && x % (y * z) == y * ((x / y) % z) + x % y\n    {\n      LemmaBreakdown(x, y, z);\n    }\n  }\n\n  lemma LemmaRemainderUpper(x: int, d: int)\n    requires 0 <= x\n    requires 0 < d\n    ensures x - d < x / d * d\n  {\n    LemmaMulAuto();\n    LemmaDivInductionAuto(d, x, u => 0 <= u ==> u - d < u / d * d);\n  }\n\n  lemma LemmaRemainderUpperAuto()\n    ensures forall x: int, d: int {:trigger x - d, d * d} :: 0 <= x && 0 < d ==> x - d < x / d * d\n  {\n    forall (x: int, d: int | 0 <= x && 0 < d)\n      ensures x - d < x / d * d\n    {\n      LemmaRemainderUpper(x, d);\n    }\n  }\n\n  lemma LemmaRemainderLower(x: int, d: int)\n    requires 0 <= x\n    requires 0 < d\n    ensures  x >= x / d * d\n  {\n    LemmaMulAuto();\n    LemmaDivInductionAuto(d, x, u => 0 <= u ==> u >= u / d * d);\n  }\n\n  lemma LemmaRemainderLowerAuto()\n    ensures forall x: int, d: int {:trigger x / d * d} :: 0 <= x && 0 < d ==> x >= x / d * d\n  {\n    forall x: int, d: int | 0 <= x && 0 < d\n      ensures x >= x / d * d\n    {\n      LemmaRemainderLower(x, d);\n    }\n  }\n\n  lemma LemmaRemainder(x: int, d: int)\n    requires 0 <= x\n    requires 0 < d\n    ensures  0 <= x - (x / d * d) < d\n  {\n    LemmaMulAuto();\n    LemmaDivInductionAuto(d, x, u => 0 <= u - u / d * d < d);\n  }\n\n  lemma LemmaRemainderAuto()\n    ensures forall x: int, d: int {:trigger x - (x / d * d)} :: 0 <= x && 0 < d ==> 0 <= x - (x / d * d) < d\n  {\n    forall x: int, d: int | 0 <= x && 0 < d\n      ensures 0 <= x - (x / d * d) < d\n    {\n      LemmaRemainder(x, d);\n    }\n  }\n\n  /* describes fundementals of the modulus operator */\n  lemma LemmaFundamentalDivMod(x: int, d: int)\n    requires d != 0\n    ensures x == d * (x / d) + (x % d)\n  {\n    ModINL.LemmaFundamentalDivMod(x, d);\n  }\n\n  lemma LemmaFundamentalDivModAuto()\n    ensures forall x: int, d: int {:trigger d * (x / d) + (x % d)} :: d != 0 ==> x == d * (x / d) + (x % d)\n  {\n    forall x: int, d: int | d != 0\n      ensures x == d * (x / d) + (x % d)\n    {\n      LemmaFundamentalDivMod(x, d);\n    }\n  }\n\n  /* dividing a fraction by a divisor is equivalent to multiplying the fraction's \n  denominator with the divisor */\n  lemma LemmaDivDenominator(x: int,c: nat,d: nat)\n    requires 0 <= x\n    requires 0 < c\n    requires 0 < d\n    ensures c * d != 0\n    ensures (x / c) / d == x / (c * d)\n  {\n    LemmaMulStrictlyPositiveAuto();\n    var R := x % (c * d);\n    LemmaModPropertiesAuto();\n\n    LemmaDivPosIsPos(R, c);\n    if (R / c >= d) {\n      LemmaFundamentalDivMod(R, c);\n      LemmaMulInequality(d, R / c, c);\n      LemmaMulIsCommutativeAuto();\n      assert false;\n    }\n    assert R / c < d;\n\n    LemmaMulBasicsAuto();\n    LemmaFundamentalDivModConverse(R / c, d, 0, R / c);\n    assert (R / c) % d == R / c;\n\n    LemmaFundamentalDivMod(R, c);\n    assert c * (R / c) + R % c == R;\n\n    assert c * ((R / c) % d) + R % c == R;\n\n    var k := x / (c * d);\n    LemmaFundamentalDivMod(x, c * d);\n    assert x == (c * d) * (x / (c * d)) + x % (c * d);\n    assert R == x - (c * d) * (x / (c * d));\n    assert R == x - (c * d) * k;\n\n    calc {\n      c * ((x / c) % d) + x % c;\n      { LemmaModMultiplesVanish(-k, x / c, d); LemmaMulIsCommutativeAuto(); }\n      c * ((x / c + (-k) * d) % d) + x % c;\n      { LemmaHoistOverDenominator(x, (-k)*d, c); }\n      c * (((x + (((-k) * d) * c)) / c) % d) + x % c;\n      { LemmaMulIsAssociative(-k, d, c); }\n      c * (((x + ((-k) * (d * c))) / c) % d) + x % c;\n      { LemmaMulUnaryNegation(k, d * c); }\n      c * (((x + (-(k * (d * c)))) / c) % d) + x % c;\n      { LemmaMulIsAssociative(k, d, c); }\n      c * (((x + (-(k * d * c))) / c) % d) + x % c;\n      c * (((x - k * d * c) / c) % d) + x % c;\n      {\n        LemmaMulIsAssociativeAuto();\n        LemmaMulIsCommutativeAuto();\n      }\n      c * ((R / c) % d) + x % c;\n      c * (R / c) + x % c;\n      { LemmaFundamentalDivMod(R, c);\n        assert R == c * (R / c) + R % c;\n        LemmaModMod(x, c, d);\n        assert R % c == x % c;\n      }\n      R;\n      { LemmaModIsModRecursiveAuto(); }\n      R % (c * d);\n      (x - (c * d) * k) % (c * d);\n      { LemmaMulUnaryNegation(c * d, k); }\n      (x + (c * d) * (-k)) % (c * d);\n      { LemmaModMultiplesVanish(-k, x, c * d); }\n      x % (c * d);\n    }\n    calc ==> {\n      c * (x / c) + x % c - R == c * (x / c) - c * ((x / c) % d);\n      { LemmaFundamentalDivMod(x, c); }\n      x - R == c * (x / c) - c * ((x / c) % d);\n    }\n    calc ==> {\n      true;\n      { LemmaFundamentalDivMod(x / c, d); }\n      d * ((x / c) / d) == x / c - ((x / c) % d);\n      c * (d * ((x / c) / d)) == c * (x / c - ((x / c) % d));\n      { LemmaMulIsAssociativeAuto(); }\n      (c * d) * ((x / c) / d) == c * (x / c - ((x / c) % d));\n      { LemmaMulIsDistributiveAuto(); }\n      (c * d) * ((x / c) / d) == c * (x / c) - c * ((x / c) % d);\n      (c * d) * ((x / c) / d) == x - R;\n      { LemmaFundamentalDivMod(x, c * d); }\n      (c * d) * ((x / c) / d) == (c * d) * (x / (c * d)) + x % (c * d) - R;\n      (c * d) * ((x / c) / d) == (c * d) * (x / (c * d));\n      { LemmaMulEqualityConverse(c * d, (x / c) / d, x / (c * d)); }\n      (x / c) / d == x / (c * d);\n    }\n  }\n\n  lemma LemmaDivDenominatorAuto()\n    ensures forall c: nat, d: nat {:trigger c * d} :: 0 < c && 0 < d ==> c * d != 0\n    ensures forall x: int, c: nat, d: nat {:trigger (x / c) / d}\n              :: 0 <= x && 0 < c && 0 < d ==> (x / c) / d == x / (c * d)\n  {\n    LemmaMulNonzeroAuto();\n    forall x: int, c: nat, d: nat | 0 <= x && 0 < c && 0 < d\n      ensures (x / c) / d == x / (c * d)\n    {\n      LemmaDivDenominator(x, c, d);\n    }\n  }\n\n  /* multiplying an integer by a fraction is equivalent to multiplying the integer by the\n  fraction's numerator */\n  lemma LemmaMulHoistInequality(x: int, y: int, z: int)\n    requires 0 <= x\n    requires 0 < z\n    ensures x * (y / z) <= (x * y) / z\n  {\n    calc {\n      (x * y) / z;\n        { LemmaFundamentalDivMod(y, z); }\n      (x * (z * (y / z) + y % z)) / z;\n        { LemmaMulIsDistributiveAuto(); }\n      (x * (z * (y / z)) + x * (y % z)) / z;\n    >=  {\n          LemmaModPropertiesAuto();\n          LemmaMulNonnegative(x, y % z);\n          LemmaDivIsOrdered(x * (z * (y / z)), x * (z * (y / z)) + x * (y % z), z); }\n      (x * (z * (y / z))) / z;\n        { LemmaMulIsAssociativeAuto();\n          LemmaMulIsCommutativeAuto(); }\n      (z * (x * (y / z))) / z;\n        { LemmaDivMultiplesVanish(x * (y / z), z); }\n      x * (y / z);\n    }\n  }\n\n  lemma LemmaMulHoistInequalityAuto()\n    ensures forall x: int, y: int, z: int {:trigger x * (y / z), (x * y) / z}\n              :: 0 <= x && 0 < z ==> x * (y / z) <= (x * y) / z\n  {\n    forall (x: int, y: int, z: int | 0 <= x && 0 < z)\n      ensures x * (y / z) <= (x * y) / z\n    {\n      LemmaMulHoistInequality(x, y, z);\n    }\n  }\n\n  lemma LemmaIndistinguishableQuotients(a: int, b: int, d: int)\n    requires 0 < d\n    requires 0 <= a - a % d <= b < a + d - a % d\n    ensures a / d == b / d\n  {\n    LemmaDivInductionAuto(d, a - b, ab => var u := ab + b; 0 <= u - u % d <= b < u + d - u % d ==> u / d == b / d);\n  }\n\n  lemma LemmaIndistinguishableQuotientsAuto()\n    ensures forall a: int, b: int, d: int {:trigger a / d, b / d}\n              :: 0 < d && 0 <= a - a % d <= b < a + d - a % d ==> a / d == b / d\n  {\n    forall a: int, b: int, d: int | 0 < d && 0 <= a - a % d <= b < a + d - a % d\n      ensures a / d == b / d\n    {\n      LemmaIndistinguishableQuotients(a, b, d);\n    }\n  }\n\n  /* common factors from the dividend and divisor of a modulus operation can be factored out */\n  lemma LemmaTruncateMiddle(x: int, b: int, c: int)\n    requires 0 <= x\n    requires 0 < b\n    requires 0 < c\n    ensures 0 < b * c\n    ensures (b * x) % (b * c) == b * (x % c)\n  {\n    LemmaMulStrictlyPositiveAuto();\n    LemmaMulNonnegativeAuto();\n    calc {\n      b * x;\n      { LemmaFundamentalDivMod(b * x, b * c); }\n      (b * c) * ((b * x) / (b * c)) + (b * x) % (b * c);\n      { LemmaDivDenominator(b * x, b, c); }\n      (b * c) * (((b * x) / b) / c) + (b * x) % (b * c);\n      { LemmaMulIsCommutativeAuto(); LemmaDivByMultiple(x, b); }\n      (b * c) * (x / c) + (b * x) % (b * c);\n    }\n    calc ==> {\n      true;\n      { LemmaFundamentalDivMod(x, c); }\n      x == c * (x / c) + x % c;\n      b * x == b * (c * (x / c) + x % c);\n      { LemmaMulIsDistributiveAuto(); }\n      b * x == b * (c * (x / c)) + b * (x % c);\n      { LemmaMulIsAssociativeAuto(); }\n      b * x == (b * c) * (x / c) + b * (x % c);\n    }\n  }\n\n  lemma LemmaTruncateMiddleAuto()\n    ensures forall x: int, b: int, c: int {:trigger b * (x % c)}\n              :: 0 <= x && 0 < b && 0 < c && 0 < b * c ==> (b * x) % (b * c) == b * (x % c)\n  {\n    forall x: int, b: int, c: int | 0 <= x && 0 < b && 0 < c && 0 < b * c\n      ensures (b * x) % (b * c) == b * (x % c)\n    {\n      LemmaTruncateMiddle(x, b, c);\n    }\n  }\n\n  /* multiplying the numerator and denominator by an integer does not change the quotient */\n  lemma LemmaDivMultiplesVanishQuotient(x: int, a: int, d: int)\n    requires 0 < x\n    requires 0 <= a\n    requires 0 < d\n    ensures 0 < x * d\n    ensures a / d == (x * a) / (x * d)\n  {\n    LemmaMulStrictlyPositive(x,d);\n    calc {\n      (x * a) / (x * d);\n      {\n        LemmaMulNonnegative(x, a);\n        LemmaDivDenominator(x * a, x, d); }\n      ((x * a) / x) / d;\n      { LemmaDivMultiplesVanish(a, x); }\n      a / d;\n    }\n  }\n\n  lemma LemmaDivMultiplesVanishQuotientAuto()\n    ensures forall x: int, a: int, d: int {:trigger a / d, x * d, x * a}\n              :: 0 < x && 0 <= a && 0 < d ==> 0 < x * d  &&  a / d == (x * a) / (x * d)\n  {\n    forall x: int, a: int, d: int | 0 < x && 0 <= a && 0 < d\n      ensures 0 < x * d  &&  a / d == (x * a) / (x * d)\n    {\n      LemmaDivMultiplesVanishQuotient(x, a, d);\n    }\n  }\n\n  /* rounds down when adding an integer r to the dividend a that is smaller than the divisor d, and then\n  multiplying by d */\n  lemma LemmaRoundDown(a: int, r: int, d: int)\n    requires 0 < d\n    requires a % d == 0\n    requires 0 <= r < d\n    ensures a == d * ((a + r) / d)\n  {\n    LemmaMulAuto();\n    LemmaDivInductionAuto(d, a, u => u % d == 0 ==> u == d * ((u + r) / d));\n  }\n\n  lemma LemmaRoundDownAuto()\n    ensures forall a: int, r: int, d: int {:trigger d * ((a + r) / d)}\n              :: 0 < d && a % d == 0 && 0 <= r < d ==> a == d * ((a + r) / d)\n  {\n    forall a: int, r: int, d: int | 0 < d && a % d == 0 && 0 <= r < d\n      ensures a == d * ((a + r) / d)\n    {\n      LemmaRoundDown(a, r, d);\n    }\n  }\n\n  /* this is the same as writing x + (b/d) == x when b is less than d; this is true because (b/d) == 0 */\n  lemma LemmaDivMultiplesVanishFancy(x: int, b: int, d: int)\n    requires 0 < d\n    requires 0 <= b < d\n    ensures (d * x + b) / d == x\n  {\n    LemmaDivAuto(d);\n    var f := u => (d * u + b) / d == u;\n    LemmaMulInductionAuto(x, f);\n    assert f(x);\n  }\n\n  lemma LemmaDivMultiplesVanishFancyAuto()\n    ensures forall x: int, b: int, d: int {:trigger (d * x + b) / d}\n              :: 0 < d && 0 <= b < d ==> (d * x + b) / d == x\n  {\n    forall x: int, b: int, d: int | 0 < d && 0 <= b < d\n      ensures (d * x + b) / d == x\n    {\n      LemmaDivMultiplesVanishFancy(x, b, d);\n    }\n  }\n\n  /* multiplying an integer by a common numerator and denominator results in the original integer */\n  lemma LemmaDivMultiplesVanish(x: int, d: int)\n    requires 0 < d\n    ensures (d * x) / d == x\n  {\n    LemmaDivMultiplesVanishFancy(x, 0, d);\n  }\n\n  lemma LemmaDivMultiplesVanishAuto()\n    ensures forall x: int, d: int {:trigger (d * x) / d} :: 0 < d ==> (d * x) / d == x\n  {\n    forall x: int, d: int | 0 < d\n      ensures (d * x) / d == x\n    {\n      LemmaDivMultiplesVanish(x, d);\n    }\n  }\n\n  /* multiplying a whole number by a common numerator and denominator results in the original integer */\n  lemma LemmaDivByMultiple(b: int, d: int)\n    requires 0 <= b\n    requires 0 < d\n    ensures  (b * d) / d == b\n  {\n    LemmaDivMultiplesVanish(b,d);\n  }\n\n  lemma LemmaDivByMultipleAuto()\n    ensures forall b: int, d: int {:trigger (b * d) / d} :: 0 <= b && 0 < d ==> (b * d) / d == b\n  {\n    forall b: int, d: int | 0 <= b && 0 < d\n      ensures (b * d) / d == b\n    {\n      LemmaDivByMultiple(b, d);\n    }\n  }\n\n  /* a dividend y that is a positive multiple of the divisor z will always yield a greater quotient \n  than a dividend x that is less than y */\n  lemma LemmaDivByMultipleIsStronglyOrdered(x: int, y: int, m: int, z: int)\n    requires x < y\n    requires y == m * z\n    requires 0 < z\n    ensures  x / z < y / z\n  {\n    LemmaModMultiplesBasic(m, z);\n    LemmaDivInductionAuto(z, y - x, yx => var u := yx + x; x < u && u % z == 0 ==> x / z < u / z);\n  }\n\n  lemma LemmaDivByMultipleIsStronglyOrderedAuto()\n    ensures forall x: int, y: int, m: int, z: int {:trigger x / z, m * z, y / z}\n              :: x < y && y == m * z && 0 < z ==> x / z < y / z\n  {\n    forall x: int, y: int, m: int, z: int | x < y && y == m * z && 0 < z\n      ensures x / z < y / z\n    {\n      LemmaDivByMultipleIsStronglyOrdered(x, y, m, z);\n    }\n  }\n\n  /* if an integer a is less than or equal to the product of two other integers b and c, then the \n  quotient of a/b will be less than or equal to c */\n  lemma LemmaMultiplyDivideLe(a: int, b: int, c: int)\n    requires 0 < b\n    requires a <= b * c\n    ensures  a / b <= c\n  {\n    LemmaModMultiplesBasic(c, b);\n    LemmaDivInductionAuto(b, b * c - a, i => 0 <= i && (i + a) % b == 0 ==> a / b <= (i + a) / b);\n    LemmaDivMultiplesVanish(c, b);\n  }\n\n  lemma LemmaMultiplyDivideLeAuto()\n    ensures forall a: int, b: int, c: int {:trigger a / b , b * c} :: 0 < b && a <= b * c ==> a / b <= c\n  {\n    forall a: int, b: int, c: int | 0 < b && a <= b * c\n      ensures a / b <= c\n    {\n      LemmaMultiplyDivideLe(a, b, c);\n    }\n  }\n\n  /* if an integer a is less than the product of two other integers b and c, then the quotient \n  of a/b will be less than c */\n  lemma LemmaMultiplyDivideLt(a: int, b: int, c: int)\n    requires 0 < b\n    requires a < b * c\n    ensures  a / b < c\n  {\n    LemmaModMultiplesBasic(c, b);\n    LemmaDivInductionAuto(b, b * c - a, i => 0 < i && (i + a) % b == 0 ==> a / b < (i + a) / b);\n    LemmaDivMultiplesVanish(c, b);\n  }\n\n  lemma LemmaMultiplyDivideLtAuto()\n    ensures forall a: int, b: int, c: int {:trigger a / b, b * c} :: 0 < b && a < b * c ==> a / b < c\n  {\n    forall a: int, b: int, c: int | 0 < b && a < b * c\n      ensures a / b < c\n    {\n      LemmaMultiplyDivideLt(a, b, c);\n    }\n  }\n\n  /* expresses the equality of giving fractions common denominators and then adding them together */\n  lemma LemmaHoistOverDenominator(x: int, j: int, d: nat)\n    requires 0 < d\n    ensures x / d + j == (x + j * d) / d\n  {\n    LemmaDivAuto(d);\n    LemmaMulInductionAuto(j, u => x / d  + u == (x + u * d) / d);\n  }\n\n  lemma LemmaHoistOverDenominatorAuto()\n    ensures forall x: int, j: int, d: nat {:trigger  x / d + j} :: 0 < d ==> x / d + j == (x + j * d) / d\n  {\n    forall x: int, j: int, d: nat | 0 < d\n      ensures x / d + j == (x + j * d) / d\n    {\n      LemmaHoistOverDenominator(x, j, d);\n    }\n  }\n\n  lemma LemmaPartBound1(a: int, b: int, c: int)\n    requires 0 <= a\n    requires 0 < b\n    requires 0 < c\n    ensures 0 < b * c\n    ensures (b * (a / b) % (b * c)) <= b * (c - 1)\n  {\n    LemmaMulStrictlyPositiveAuto();\n    calc {\n      b * (a / b) % (b * c);\n      { LemmaFundamentalDivMod(b * (a / b), b * c); }\n      b * (a / b) - (b * c) * ((b * (a / b)) / (b * c));\n      { LemmaMulIsAssociativeAuto(); }\n      b * (a / b) - b * (c * ((b * (a / b)) / (b * c)));\n      { LemmaMulIsDistributiveAuto(); }\n      b * ((a / b) - (c * ((b * (a / b)) / (b * c))));\n    }\n\n    calc ==> {\n      true;\n      { LemmaModPropertiesAuto(); }\n      b * (a / b) % (b * c) < b * c;\n      b * ((a / b) - (c * ((b * (a / b)) / (b * c)))) < b * c;\n      { LemmaMulIsCommutativeAuto(); LemmaMulStrictInequalityConverseAuto(); }\n      ((a / b) - (c * ((b * (a / b)) / (b * c)))) < c;\n      ((a / b) - (c * ((b * (a / b)) / (b * c)))) <= c - 1;\n      { LemmaMulIsCommutativeAuto(); LemmaMulInequalityAuto(); }\n      b * ((a / b) - (c * ((b * (a / b)) / (b * c)))) <= b * (c - 1);\n      b * (a / b) % (b * c) <= b * (c - 1);\n    }\n  }\n\n  lemma LemmaPartBound1Auto()\n    ensures forall a: int, b: int, c: int {:trigger b * (a / b) % (b * c)}\n              :: 0 <= a && 0 < b && 0 < c ==> 0 < b * c && (b * (a / b) % (b * c)) <= b * (c - 1)\n  {\n    forall a: int, b: int, c: int | 0 <= a && 0 < b && 0 < c\n      ensures 0 < b * c && (b * (a / b) % (b * c)) <= b * (c - 1)\n    {\n      LemmaPartBound1(a, b, c);\n    }\n  }\n\n\n  /*******************************************************************************\n   * Modulus:\n   *******************************************************************************/\n\n  /* the common syntax of the modulus operation results in the same remainder as recursively\n  calculating the modulus */\n  lemma LemmaModIsModRecursive(x: int, m: int)\n    requires m > 0\n    ensures ModRecursive(x, m) == x % m\n    decreases if x < 0 then -x + m else x\n  {\n    reveal ModRecursive();\n    if x < 0 {\n      calc {\n        ModRecursive(x, m);\n        ModRecursive(x + m, m);\n        { LemmaModIsModRecursive(x + m, m); }\n        (x + m) % m;\n        { LemmaAddModNoop(x, m, m); }\n        ((x % m) + (m % m)) % m;\n        { LemmaModBasicsAuto(); }\n        (x % m) % m;\n        { LemmaModBasicsAuto(); }\n        x % m;\n      }\n    } else if x < m {\n      LemmaSmallMod(x, m);\n    } else {\n      calc {\n        ModRecursive(x, m);\n        ModRecursive(x - m, m);\n        { LemmaModIsModRecursive(x - m, m); }\n        (x - m) % m;\n        { LemmaSubModNoop(x, m, m); }\n        ((x % m) - (m % m)) % m;\n        { LemmaModBasicsAuto(); }\n        (x % m) % m;\n        { LemmaModBasicsAuto(); }\n        x % m;\n      }\n    }\n  }\n\n  lemma LemmaModIsModRecursiveAuto()\n    ensures forall x: int, d: int {:trigger x % d}:: d > 0 ==> ModRecursive(x, d) == x % d\n  {\n    reveal ModRecursive();\n    forall x: int, d: int | d > 0\n      ensures ModRecursive(x, d) == x % d\n    {\n      LemmaModIsModRecursive(x, d);\n    }\n  }\n\n  /* proves basic properties of the modulus operation: any integer divided by itself does not have a\n  remainder; performing (x % m) % m gives the same result as simply perfoming x % m  */\n  lemma LemmaModBasicsAuto()\n    ensures forall m: int {:trigger m % m} :: m > 0 ==> m % m == 0\n    ensures forall x: int, m: int {:trigger (x % m) % m} :: m > 0 ==> (x % m) % m == x % m\n  {\n    forall m: int | m > 0\n      ensures m % m == 0\n    {\n      LemmaModAuto(m);\n    }\n    forall x: int, m: int | m > 0\n      ensures (x % m) % m == x % m\n    {\n      LemmaModAuto(m);\n    }\n  }\n\n  /* describes the properties of the modulus operation including those described in LemmaModBasicsAuto. \n  This lemma also states that the remainder of any division will be less than the divisor's value  */\n  lemma LemmaModPropertiesAuto()\n    ensures forall m: int {:trigger m % m} :: m > 0 ==> m % m == 0\n    ensures forall x: int, m: int {:trigger (x % m) % m} :: m > 0 ==> (x % m) % m == x % m\n    ensures forall x: int, m: int {:trigger x % m} :: m > 0 ==> 0 <= x % m < m\n  {\n    LemmaModBasicsAuto();\n\n    forall x: int, m: int | m > 0\n      ensures 0 <= x % m < m\n    {\n      LemmaModAuto(m);\n    }\n  }\n\n  /* the remainder of a natural number x divided by a natural number d will be less\n  than or equal to x */\n  lemma LemmaModDecreases(x: nat, m: nat)\n    requires 0 < m\n    ensures x % m <= x\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaModDecreasesAuto()\n    ensures forall x: nat, m: nat {:trigger x % m} :: 0 < m ==> x % m <= x\n  {\n    forall x: nat, m: nat | 0 < m\n      ensures x % m <= x\n    {\n      LemmaModDecreases(x, m);\n    }\n  }\n\n  /* if x % y is zero and x is greater than zero, x is greater than y. */\n  lemma LemmaModIsZero(x: nat, m: nat)\n    requires x > 0 && m > 0\n    requires x % m == 0\n    ensures x >= m\n  {\n    calc ==> {\n      x < m;\n      { LemmaSmallMod(x, m); }\n      x % m == x;\n      false;\n    }\n  }\n\n  lemma LemmaModIsZeroAuto()\n    ensures forall x: nat, m: nat {:trigger x % m} :: (x > 0 && m > 0\n                                                       && x % m == 0) ==> x >= m\n  {\n    forall x: nat, m: nat | x > 0 && m > 0 && x % m == 0\n      ensures x >= m\n    {\n      LemmaModIsZero(x, m);\n    }\n  }\n\n  /* a dividend that is any multiple of the divisor will result in a remainder of 0 */\n  lemma LemmaModMultiplesBasic(x: int, m: int)\n    requires m > 0\n    ensures (x * m) % m == 0\n  {\n    LemmaModAuto(m);\n    LemmaMulInductionAuto(x, u => (u * m) % m == 0);\n  }\n\n  lemma LemmaModMultiplesBasicAuto()\n    ensures forall x: int, m: int {:trigger (x * m) % m} :: m > 0 ==> (x * m) % m == 0\n  {\n    forall x: int, m: int | m > 0\n      ensures (x * m) % m == 0\n    {\n      LemmaModMultiplesBasic(x, m);\n    }\n  }\n\n  /* the remainder of adding the divisor m to the dividend b will be the same\n  as simply performing b % m */\n  lemma LemmaModAddMultiplesVanish(b: int, m: int)\n    requires 0 < m\n    ensures (m + b) % m == b % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaModAddMultiplesVanishAuto()\n    ensures forall b: int, m: int {:trigger b % m} :: 0 < m ==> (m + b) % m == b % m\n  {\n    forall b: int, m: int | 0 < m\n      ensures (m + b) % m == b % m\n    {\n      LemmaModAddMultiplesVanish(b, m);\n    }\n  }\n\n  /* the remainder of subtracting the divisor m from the dividend b will be the same\n  as simply performing b % m */\n  lemma LemmaModSubMultiplesVanish(b: int, m: int)\n    requires 0 < m\n    ensures (-m + b) % m == b % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaModSubMultiplesVanishAuto()\n    ensures forall b: int, m: int {:trigger b % m} :: 0 < m ==> (-m + b) % m == b % m\n  {\n    forall b: int, m: int | 0 < m\n      ensures (-m + b) % m == b % m\n    {\n      LemmaModSubMultiplesVanish(b, m);\n    }\n  }\n\n  /* the remainder of adding any multiple of the divisor m to the dividend b will be the same\n  as simply performing b % m */\n  lemma LemmaModMultiplesVanish(a: int, b: int, m: int)\n    decreases if a > 0 then a else -a\n    requires 0 < m\n    ensures (m * a + b) % m == b % m\n  {\n    LemmaModAuto(m);\n    LemmaMulInductionAuto(a, u => (m * u + b) % m == b % m);\n  }\n\n  lemma LemmaModMultiplesVanishAuto()\n    ensures forall a: int, b: int, m: int {:trigger (m * a + b) % m} :: 0 < m ==> (m * a + b) % m == b % m\n  {\n    forall a: int, b: int, m: int | 0 < m\n      ensures (m * a + b) % m == b % m\n    {\n      LemmaModMultiplesVanish(a, b, m);\n    }\n  }\n\n  /* proves equivalent forms of modulus subtraction */\n  lemma LemmaModSubtraction(x: nat, s: nat, d: nat)\n    requires 0 < d\n    requires 0 <= s <= x % d\n    ensures x % d - s % d == (x - s) % d\n  {\n    LemmaModAuto(d);\n  }\n\n  lemma LemmaModSubtractionAuto()\n    ensures forall x: nat, s: nat, d: nat {:trigger (x - s) % d}\n              :: 0 < d && 0 <= s <= x % d ==> x % d - s % d == (x - s) % d\n  {\n    forall x: nat, s: nat, d: nat | 0 < d && 0 <= s <= x % d\n      ensures x % d - s % d == (x - s) % d\n    {\n      LemmaModSubtraction(x, s, d);\n    }\n  }\n\n  /* describes expanded and succinct version of modulus operator in relation to addition (read \"ensures\") */\n  lemma LemmaAddModNoop(x: int, y: int, m: int)\n    requires 0 < m\n    ensures ((x % m) + (y % m)) % m == (x + y) % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaAddModNoopAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x + y) % m}\n              :: 0 < m ==> ((x % m) + (y % m)) % m == (x + y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures ((x % m) + (y % m)) % m == (x + y) % m\n    {\n      LemmaAddModNoop(x, y, m);\n    }\n  }\n\n  /* describes expanded and succinct version of modulus operator in relation to addition (read \"ensures\") */\n  lemma LemmaAddModNoopRight(x: int, y: int, m: int)\n    requires 0 < m\n    ensures (x + (y % m)) % m == (x + y) % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaAddModNoopRightAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x + y) % m}\n              :: 0 < m ==> (x + (y % m)) % m == (x + y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures (x + (y % m)) % m == (x + y) % m\n    {\n      LemmaAddModNoopRight(x, y, m);\n    }\n  }\n\n  /* describes expanded and succinct version of modulus operator in relation to subtraction (read \"ensures\") */\n  lemma LemmaSubModNoop(x: int, y: int, m: int)\n    requires 0 < m\n    ensures ((x % m) - (y % m)) % m == (x - y) % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaSubModNoopAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x - y) % m}\n              :: 0 < m ==> ((x % m) - (y % m)) % m == (x - y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures ((x % m) - (y % m)) % m == (x - y) % m\n    {\n      LemmaSubModNoop(x, y, m);\n    }\n  }\n\n  /* describes expanded and succinct version of modulus operator in relation to subtraction (read \"ensures\") */\n  lemma LemmaSubModNoopRight(x: int, y: int, m: int)\n    requires 0 < m\n    ensures (x - (y % m)) % m == (x - y) % m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaSubModNoopRightAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x - y) % m}\n              :: 0 < m ==> (x - (y % m)) % m == (x - y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures (x - (y % m)) % m == (x - y) % m\n    {\n      LemmaSubModNoopRight(x, y, m);\n    }\n  }\n\n  /* proves equivalent forms of modulus addition */\n  lemma LemmaModAdds(a: int, b: int, d: int)\n    requires 0 < d\n    ensures a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d)\n    ensures (a % d + b % d) < d ==> a % d + b % d == (a + b) % d\n  {\n    LemmaMulAuto();\n    LemmaDivAuto(d);\n  }\n\n  lemma LemmaModAddsAuto()\n    ensures forall a: int, b: int, d: int {:trigger (a + b) % d}\n              :: 0 < d ==> && a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d)\n                           && ((a % d + b % d) < d ==> a % d + b % d == (a + b) % d)\n  {\n    forall a: int, b: int, d: int | 0 < d\n      ensures && a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d)\n              && ((a % d + b % d) < d ==> a % d + b % d == (a + b) % d)\n    {\n      LemmaModAdds(a, b, d);\n    }\n  }\n\n  lemma {:vcs_split_on_every_assert} LemmaModNegNeg(x: int, d: int)\n    requires 0 < d\n    ensures x % d == (x * (1 - d)) % d\n  {\n    assert (x - x * d) % d == x % d\n    by {\n      LemmaModAuto(d);\n      var f := i => (x - i * d) % d == x % d;\n      assert  MulAuto() ==> && f(0)\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                            && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1));\n      LemmaMulInductionAuto(x, f);\n    }\n    LemmaMulAuto();\n  }\n\n  /* proves the validity of the quotient and remainder */\n  lemma {:timeLimitMultiplier 5} LemmaFundamentalDivModConverse(x: int, d: int, q: int, r: int)\n    requires d != 0\n    requires 0 <= r < d\n    requires x == q * d + r\n    ensures q == x / d\n    ensures r == x % d\n  {\n    LemmaDivAuto(d);\n    LemmaMulInductionAuto(q, u => u == (u * d + r) / d);\n    LemmaMulInductionAuto(q, u => r == (u * d + r) % d);\n  }\n\n  lemma {:timeLimitMultiplier 5} LemmaFundamentalDivModConverseAuto()\n    ensures forall x: int, d: int, q: int, r: int {:trigger q * d + r, x % d}\n              :: d != 0 && 0 <= r < d && x == q * d + r ==> q == x / d && r == x % d\n  {\n    forall x: int, d: int, q: int, r: int | d != 0 && 0 <= r < d && x == q * d + r\n      ensures q == x / d && r == x % d\n    {\n      LemmaFundamentalDivModConverse(x, d, q, r);\n    }\n  }\n\n\n  /* the remainder of any natural number x divided by a positive integer m is always less than m */\n  lemma LemmaModPosBound(x: int, m: int)\n    decreases x\n    requires 0 <= x\n    requires 0 < m\n    ensures  0 <= x % m < m\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaModPosBoundAuto()\n    ensures forall x: int, m: int {:trigger x % m} :: 0 <= x && 0 < m ==> 0 <= x % m < m\n  {\n    forall x: int, m: int | 0 <= x && 0 < m\n      ensures 0 <= x % m < m\n    {\n      LemmaModPosBound(x, m);\n    }\n  }\n\n  lemma LemmaMulModNoopLeft(x: int, y: int, m: int)\n    requires 0 < m\n    ensures (x % m) * y % m == x * y % m\n  {\n    LemmaModAuto(m);\n    LemmaMulInductionAuto(y, u => (x % m) * u % m == x * u % m);\n  }\n\n  lemma LemmaMulModNoopLeftAuto()\n    ensures forall x: int, y: int, m: int {:trigger x * y % m} :: 0 < m ==> (x % m) * y % m == x * y % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures (x % m) * y % m == x * y % m\n    {\n      LemmaMulModNoopLeft(x, y, m);\n    }\n  }\n\n  lemma LemmaMulModNoopRight(x: int, y: int, m: int)\n    requires 0 < m\n    ensures x * (y % m) % m == (x * y) % m\n  {\n    LemmaModAuto(m);\n    LemmaMulInductionAuto(x, u => u * (y % m) % m == (u * y) % m);\n  }\n\n  lemma LemmaMulModNoopRightAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x * y) % m}\n              :: 0 < m ==> x * (y % m) % m == (x * y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures x * (y % m) % m == (x * y) % m\n    {\n      LemmaMulModNoopRight(x, y, m);\n    }\n  }\n\n  /* combines previous no-op mod lemmas into a general, overarching lemma */\n  lemma LemmaMulModNoopGeneral(x: int, y: int, m: int)\n    requires 0 < m\n    ensures ((x % m) * y      ) % m == (x * y) % m\n    ensures ( x      * (y % m)) % m == (x * y) % m\n    ensures ((x % m) * (y % m)) % m == (x * y) % m\n  {\n    LemmaModPropertiesAuto();\n    LemmaMulModNoopLeft(x, y, m);\n    LemmaMulModNoopRight(x, y, m);\n    LemmaMulModNoopRight(x % m, y, m);\n  }\n\n  lemma LemmaMulModNoopGeneralAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x * y) % m}\n              :: 0 < m ==> ((x % m) * y) % m == (x * (y % m)) % m == ((x % m) * (y % m)) % m == (x * y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures ((x % m) * y) % m == (x * (y % m)) % m == ((x % m) * (y % m)) % m == (x * y) % m\n    {\n      LemmaMulModNoopGeneral(x, y, m);\n    }\n  }\n\n  lemma LemmaMulModNoop(x: int, y: int, m: int)\n    requires 0 < m\n    ensures (x % m) * (y % m) % m == (x * y) % m\n  {\n    LemmaMulModNoopGeneral(x, y, m);\n  }\n\n  lemma LemmaMulModNoopAuto()\n    ensures forall x: int, y: int, m: int {:trigger (x * y) % m}\n              :: 0 < m ==> (x % m) * (y % m) % m == (x * y) % m\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures (x % m) * (y % m) % m == (x * y) % m\n    {\n      LemmaMulModNoop(x, y, m);\n    }\n  }\n\n  /* proves modulus equivalence in two forms */\n  lemma LemmaModEquivalence(x: int, y: int, m: int)\n    requires 0 < m\n    ensures x % m == y % m <==> (x - y) % m == 0\n  {\n    LemmaModAuto(m);\n  }\n\n  lemma LemmaModEquivalenceAuto()\n    ensures forall x: int, y: int, m: int {:trigger  x % m , y % m}\n              :: 0 < m && x % m == y % m <==> 0 < m && (x - y) % m == 0\n  {\n    forall x: int, y: int, m: int | 0 < m\n      ensures x % m == y % m <==> 0 < m && (x - y) % m == 0\n    {\n      LemmaModEquivalence(x, y, m);\n    }\n  }\n\n  /* true if x%n and y%n are equal */\n  ghost predicate IsModEquivalent(x: int, y: int, m: int)\n    requires m > 0\n    ensures x % m == y % m <==> (x - y) % m == 0\n  {\n    LemmaModEquivalence(x, y, m);\n    (x - y) % m == 0 // same as x % n == y % n, but easier to do induction on x - y than x and y separately\n  }\n\n  /* if x % m == y % m, then (x * z) % m == (y * z) % m. */\n  lemma LemmaModMulEquivalent(x: int, y: int, z: int, m: int)\n    requires m > 0\n    requires IsModEquivalent(x, y, m)\n    ensures IsModEquivalent(x * z, y * z, m)\n  {\n    LemmaMulModNoopLeft(x, z, m);\n    LemmaMulModNoopLeft(y, z, m);\n  }\n\n  lemma LemmaModMulEquivalentAuto()\n    ensures forall x: int, y: int, z: int, m: int\n              {:trigger IsModEquivalent(x * z, y * z, m)}\n              :: m > 0 && IsModEquivalent(x, y, m) ==> IsModEquivalent(x * z, y * z, m)\n  {\n    forall x: int, y: int, z: int, m: int | m > 0 && IsModEquivalent(x, y, m)\n      ensures IsModEquivalent(x * z, y * z, m)\n    {\n      LemmaModMulEquivalent(x, y, z, m);\n    }\n  }\n\n  /* the remainder can increase with a larger divisor */\n  lemma LemmaModOrdering(x: int, k: int, d: int)\n    requires 1 < d\n    requires 0 < k\n    ensures 0 < d * k\n    ensures x % d <= x % (d * k)\n  {\n    LemmaMulStrictlyIncreases(d,k);\n    calc {\n      x % d + d * (x / d);\n      { LemmaFundamentalDivMod(x, d); }\n      x;\n      { LemmaFundamentalDivMod(x, d * k); }\n      x % (d * k) + (d * k) * (x / (d * k));\n      { LemmaMulIsAssociativeAuto(); }\n      x % (d * k) + d * (k * (x / (d * k)));\n    }\n    calc {\n      x % d;\n       { LemmaModPropertiesAuto(); }\n      (x % d) % d;\n       { LemmaModMultiplesVanish(x / d  - k * (x / (d * k)), x % d, d); }\n      (x % d + d * (x / d  - k * (x / (d * k)))) % d;\n       { LemmaMulIsDistributiveSubAuto(); }\n      (x % d + d * (x / d) - d * (k * (x / (d * k)))) % d;\n      (x % (d * k)) % d;\n    <= { LemmaModPropertiesAuto();\n         LemmaModDecreases(x % (d * k), d); }\n      x % (d * k);\n    }\n  }\n\n  lemma LemmaModOrderingAuto()\n    ensures forall x: int, k: int, d: int {:trigger x % (d * k)}\n              :: 1 < d && 0 < k ==> 0 < d * k && x % d <= x % (d * k)\n  {\n    forall x: int, k: int, d: int | 1 < d && 0 < k\n      ensures d * k > 0 && x % d <= x % (d * k)\n    {\n      LemmaModOrdering(x, k, d);\n    }\n  }\n\n  lemma LemmaModMod(x: int, a: int, b: int)\n    requires 0 < a\n    requires 0 < b\n    ensures 0 < a * b\n    ensures (x % (a * b)) % a == x % a\n  {\n    LemmaMulStrictlyPositiveAuto();\n    calc {\n      x;\n      { LemmaFundamentalDivMod(x, a * b); }\n      (a * b) * (x / (a * b)) + x % (a * b);\n      { LemmaMulIsAssociativeAuto(); }\n      a * (b * (x / (a * b))) + x % (a * b);\n      { LemmaFundamentalDivMod(x % (a * b), a); }\n      a * (b * (x / (a * b))) + a * (x % (a * b) / a) + (x % (a * b)) % a;\n      { LemmaMulIsDistributiveAuto(); }\n      a * (b * (x / (a * b)) + x % (a * b) / a) + (x % (a * b)) % a;\n    }\n    LemmaModPropertiesAuto();\n    LemmaMulIsCommutativeAuto();\n    LemmaFundamentalDivModConverse(x, a, b * (x / (a * b)) + x % (a * b) / a, (x % (a * b)) % a);\n  }\n\n  lemma LemmaModModAuto()\n    ensures forall x: int, a: int, b: int {:trigger a * b, x % a}\n              :: 0 < a && 0 < b ==> 0 < a * b && (x % (a * b)) % a == x % a\n  {\n    forall x: int, a: int, b: int | 0 < a && 0 < b\n      ensures 0 < a * b && (x % (a * b)) % a == x % a\n    {\n      LemmaModMod(x, a, b);\n    }\n  }\n\n  lemma LemmaPartBound2(x: int, y: int, z: int)\n    requires 0 <= x\n    requires 0 < y\n    requires 0 < z\n    ensures y * z > 0\n    ensures (x % y) % (y * z) < y\n  {\n    LemmaMulStrictlyPositiveAuto();\n    LemmaModPropertiesAuto();\n    assert x % y < y;\n    LemmaMulIncreasesAuto();\n    LemmaMulIsCommutativeAuto();\n    assert y <= y * z;\n    assert 0 <= x % y < y * z;\n    LemmaModPropertiesAuto();\n    LemmaSmallMod(x % y, y * z);\n    assert (x % y) % (y * z) == x % y;\n  }\n\n  lemma LemmaPartBound2Auto()\n    ensures forall x: int, y: int, z: int {:trigger y * z, x % y}\n              :: 0 <= x && 0 < y && 0 < z ==> y * z > 0 && (x % y) % (y * z) < y\n  {\n    forall x: int, y: int, z: int | 0 <= x && 0 < y && 0 < z\n      ensures y * z > 0 && (x % y) % (y * z) < y\n    {\n      LemmaPartBound2(x, y, z);\n    }\n  }\n\n  /* ensures the validity of an expanded form of the modulus operation,\n   as expressed in the pre and post conditions */\n  lemma LemmaModBreakdown(x: int, y: int, z: int)\n    requires 0 <= x\n    requires 0 < y\n    requires 0 < z\n    ensures y * z > 0\n    ensures x % (y * z) == y * ((x / y) % z) + x % y\n  {\n    LemmaMulStrictlyPositiveAuto();\n    LemmaDivPosIsPos(x, y);\n    assert 0 <= x / y;\n\n    calc {\n      (y * (x / y)) % (y * z) + (x % y) % (y * z);\n    <=    { LemmaPartBound1(x, y, z); }\n      y * (z - 1) + (x % y) % (y * z);\n    <    { LemmaPartBound2(x, y, z); }\n      y * (z - 1) + y;\n          { LemmaMulBasicsAuto(); }\n      y * (z - 1) + y * 1;\n          { LemmaMulIsDistributiveAuto(); }\n      y * (z - 1 + 1);\n      y * z;\n    }\n\n    calc {\n      x % (y * z);\n      { LemmaFundamentalDivMod(x, y); }\n      (y * (x / y) + x%  y) % (y * z);\n      {\n        LemmaModPropertiesAuto();\n        assert 0 <= x % y;\n        LemmaMulNonnegative(y, x / y);\n        assert (y * (x / y)) % (y * z) + (x % y) % (y * z) < y * z;\n        LemmaModAdds(y * (x / y), x % y, y * z);\n      }\n      (y * (x / y)) % (y * z) + (x % y) % (y * z);\n      {\n        LemmaModPropertiesAuto();\n        LemmaMulIncreases(z, y);\n        LemmaMulIsCommutativeAuto();\n        assert x % y < y <= y * z;\n        LemmaSmallMod(x % y, y * z);\n        assert (x % y) % (y * z) == x % y;\n      }\n      (y * (x / y)) % (y * z) + x % y;\n      { LemmaTruncateMiddle(x / y, y, z); }\n      y * ((x / y) % z) + x % y;\n    }\n  }\n\n  lemma LemmaModBreakdownAuto()\n    ensures forall x: int, y: int, z: int {:trigger x % (y * z)}\n              :: 0 <= x && 0 < y && 0 < z ==> y * z > 0 && x % (y * z) == y * ((x / y) % z) + x % y\n  {\n    forall x: int, y: int, z: int | 0 <= x && 0 < y && 0 < z\n      ensures y * z > 0 && x % (y * z) == y * ((x / y) % z) + x % y\n    {\n      LemmaModBreakdown(x, y, z);\n    }\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/NonlinearArithmetic/Power2.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* Every lemma comes in 2 forms: 'LemmaProperty' and 'LemmaPropertyAuto'. The\nformer takes arguments and may be more stable and less reliant on Z3\nheuristics. The latter includes automation and its use requires less effort */\n\ninclude \"Internals/GeneralInternals.dfy\"\ninclude \"Internals/MulInternals.dfy\"\ninclude \"Power.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.Power2 {\n  import opened GeneralInternals\n  import opened MulInternals\n  import opened Power\n\n  function {:opaque} Pow2(e: nat): nat\n    ensures Pow2(e) > 0\n  {\n    reveal Pow();\n    LemmaPowPositive(2, e);\n    Pow(2, e)\n  }\n\n  /* Pow2() is equivalent to Pow() with base 2. */\n  lemma LemmaPow2(e: nat)\n    ensures Pow2(e) == Pow(2, e)\n  {\n    reveal Pow();\n    reveal Pow2();\n\n    if e != 0 {\n      LemmaPow2(e - 1);\n    }\n  }\n\n  lemma LemmaPow2Auto()\n    ensures forall e: nat {:trigger Pow2(e)} :: Pow2(e) == Pow(2, e)\n  {\n    reveal Pow();\n    reveal Pow2();\n\n    forall e: nat {:trigger Pow2(e)}\n      ensures Pow2(e) == Pow(2, e)\n    {\n      LemmaPow2(e);\n    }\n  }\n\n  /* (2^e - 1) / 2 = 2^(e - 1) - 1 */\n  // keep\n  lemma LemmaPow2MaskDiv2(e: nat)\n    requires 0 < e\n    ensures (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1\n  {\n    LemmaPowAuto();\n    var f := e => 0 < e ==> (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1;\n    assert forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInductionAuto(e, f);\n  }\n\n  lemma LemmaPow2MaskDiv2Auto()\n    ensures forall e: nat {:trigger Pow2(e)} ::\n              0 < e ==> (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1\n  {\n    reveal Pow2();\n    forall e: nat {:trigger Pow2(e)} | 0 < e\n      ensures (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1\n    {\n      LemmaPow2MaskDiv2(e);\n    }\n  }\n\n  lemma Lemma2To64()\n    ensures Pow2(0) == 0x1\n    ensures Pow2(1) == 0x2\n    ensures Pow2(2) == 0x4\n    ensures Pow2(3) == 0x8\n    ensures Pow2(4) == 0x10\n    ensures Pow2(5) == 0x20\n    ensures Pow2(6) == 0x40\n    ensures Pow2(7) == 0x80\n    ensures Pow2(8) == 0x100\n    ensures Pow2(9) == 0x200\n    ensures Pow2(10) == 0x400\n    ensures Pow2(11) == 0x800\n    ensures Pow2(12) == 0x1000\n    ensures Pow2(13) == 0x2000\n    ensures Pow2(14) == 0x4000\n    ensures Pow2(15) == 0x8000\n    ensures Pow2(16) == 0x10000\n    ensures Pow2(17) == 0x20000\n    ensures Pow2(18) == 0x40000\n    ensures Pow2(19) == 0x80000\n    ensures Pow2(20) == 0x100000\n    ensures Pow2(21) == 0x200000\n    ensures Pow2(22) == 0x400000\n    ensures Pow2(23) == 0x800000\n    ensures Pow2(24) == 0x1000000\n    ensures Pow2(25) == 0x2000000\n    ensures Pow2(26) == 0x4000000\n    ensures Pow2(27) == 0x8000000\n    ensures Pow2(28) == 0x10000000\n    ensures Pow2(29) == 0x20000000\n    ensures Pow2(30) == 0x40000000\n    ensures Pow2(31) == 0x80000000\n    ensures Pow2(32) == 0x100000000\n    ensures Pow2(64) == 0x10000000000000000\n  {\n    reveal Pow2();\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/BinaryOperations.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/** Defines a number of (ghost) properties of binary operations */\nmodule {:options \"-functionSyntax:4\"} BinaryOperations\n{\n\n  ghost predicate IsAssociative<T(!new)>(bop: (T, T) -> T) {\n    forall x, y, z :: bop(bop(x, y), z) == bop(x, bop(y, z))\n  }\n\n  ghost predicate IsLeftUnital<T(!new)>(bop: (T, T) -> T, unit: T) {\n    forall x :: bop(unit, x) == x\n  }\n\n  ghost predicate IsRightUnital<T(!new)>(bop: (T, T) -> T, unit: T) {\n    forall x :: bop(x, unit) == x\n  }\n\n  ghost predicate IsUnital<T(!new)>(bop: (T, T) -> T, unit: T) {\n    && IsLeftUnital(bop, unit)\n    && IsRightUnital(bop, unit)\n  }\n\n  ghost predicate IsLeftInverse<T(!new)>(bop: (T, T) -> T, inverse: T --> T, unit: T) {\n    forall x | inverse.requires(x) :: bop(inverse(x), x) == unit\n  }\n\n  ghost predicate IsRightInverse<T(!new)>(bop: (T, T) -> T, inverse: T --> T, unit: T) {\n    forall x | inverse.requires(x) :: bop(x, inverse(x)) == unit\n  }\n\n  ghost predicate IsInverse<T(!new)>(bop: (T, T) -> T, inverse: T --> T, unit: T) {\n    && IsLeftInverse(bop, inverse, unit)\n    && IsRightInverse(bop, inverse, unit)\n  }\n\n  ghost predicate IsCommutative<T(!new)>(bop: (T, T) -> T) {\n    forall x, y :: bop(x, y) == bop(y, x)\n  }\n\n  ghost predicate IsRightDistributive<T(!new)>(bop1: (T, T) -> T, bop2: (T, T) -> T) {\n    forall x, y, z :: bop2(bop1(x, y), z) == bop1(bop2(x, z), bop2(y, z))\n  }\n\n  ghost predicate IsLeftDistributive<T(!new)>(bop1: (T, T) -> T, bop2: (T, T) -> T) {\n    forall x, y, z :: bop2(x, bop1(y, z)) == bop1(bop2(x, y), bop2(x, z))\n  }\n\n  ghost predicate IsDistributive<T(!new)>(bop1: (T, T) -> T, bop2: (T, T) -> T) {\n    && IsLeftDistributive(bop1, bop2)\n    && IsRightDistributive(bop1, bop2)\n  }\n\n  ghost predicate IsMonoid<T(!new)>(bop: (T, T) -> T, unit: T) {\n    && IsAssociative(bop)\n    && IsUnital(bop, unit)\n  }\n\n  datatype MonoidStructure<!T(!new)> = MonoidStructure(bop: (T, T) -> T, unit: T)\n  type Monoid<!T(!new)> = g: MonoidStructure | IsMonoid(g.bop, g.unit) witness *\n\n  ghost predicate IsGroup<T(!new)>(bop: (T, T) -> T, inverse: T --> T, unit: T) {\n    && IsMonoid(bop, unit)\n    && IsInverse(bop, inverse, unit)\n  }\n\n  datatype GroupStructure<!T(!new)> = GroupStructure(bop: (T, T) -> T, inverse: T -> T, unit: T)\n  type Group<!T(!new)> = g: GroupStructure | IsGroup(g.bop, g.inverse, g.unit) witness *\n\n  ghost predicate IsAbelianGroup<T(!new)>(bop: (T, T) -> T, inverse: T --> T, unit: T) {\n    && IsGroup(bop, inverse, unit)\n    && IsCommutative(bop)\n  }\n\n  type AbelianGroup<!T(!new)> = g: GroupStructure | IsAbelianGroup(g.bop, g.inverse, g.unit) witness *\n\n  ghost predicate IsRing<T(!new)>(add: (T, T) -> T, minus: T -> T, zero: T, mult: (T, T) -> T, one: T) {\n    && IsAbelianGroup(add, minus, zero)\n    && IsMonoid(mult, one)\n    && IsDistributive(add, mult)\n  }\n\n  datatype RingStructure<!T(!new)> = RingStructure(add: (T, T) -> T, minus: T -> T, zero: T, mult: (T, T) -> T, one: T)\n  type Ring<!T(!new)> = r: RingStructure | IsRing(r.add, r.minus, r.zero, r.mult, r.one) witness *\n\n  ghost predicate IsField<T(!new)>(add: (T, T) -> T, minus: T -> T, zero: T, mult: (T, T) -> T, div: T --> T, one: T)\n    requires forall t :: (t != zero) ==> div.requires(t)\n  {\n    && IsAbelianGroup(add, minus, zero)\n    && IsAbelianGroup(mult, div, one)\n    && IsLeftDistributive(add, mult)\n  }\n\n  datatype FieldStructure<!T(!new)> = FieldStructure(add: (T, T) -> T, minus: T -> T, zero: T, mult: (T, T) -> T, div: T --> T, one: T)\n  type FieldPre<!T(!new)> = f: FieldStructure | (forall t :: (t != f.zero) ==> f.div.requires(t)) witness *\n  type Field<!T(!new)> = f: FieldPre | IsField(f.add, f.minus, f.zero, f.mult, f.div, f.one) witness *\n\n  ghost predicate IsHomomorphism<S(!new),T>(bop1: (S, S) -> S, bop2: (T, T) -> T, f: S -> T) {\n    forall x, y :: f(bop1(x, y)) == bop2(f(x), f(y))\n  }\n\n  lemma MonoidInverseIsUnique<T(!new)>(m: Monoid<T>, inverse1: T -> T, inverse2: T -> T)\n    requires IsInverse(m.bop, inverse1, m.unit)\n    requires IsInverse(m.bop, inverse2, m.unit)\n    ensures forall x :: inverse1(x) == inverse2(x)\n  {\n    assert IsMonoid(m.bop, m.unit);\n    forall x ensures inverse1(x) == inverse2(x) {\n      calc {\n        inverse1(x);\n      == { assert IsRightUnital(m.bop, m.unit); }\n        m.bop(inverse1(x), m.unit);\n      == { assert IsRightInverse(m.bop, inverse2, m.unit); assert m.unit == m.bop(x, inverse2(x)); }\n        m.bop(inverse1(x), m.bop(x, inverse2(x)));\n      == { assert IsAssociative(m.bop); }\n        m.bop(m.bop(inverse1(x), x), inverse2(x));\n      == { assert IsLeftInverse(m.bop, inverse1, m.unit); }\n        m.bop(m.unit, inverse2(x));\n      == { assert IsLeftUnital(m.bop, m.unit); }\n        inverse2(x);\n      }\n    }\n  }\n\n  lemma UnitIsUnique<T(!new)>(bop: (T, T) -> T, unit1: T, unit2: T)\n    requires IsUnital(bop, unit1)\n    requires IsUnital(bop, unit2)\n    ensures unit1 == unit2\n  {\n    calc {\n      unit1;\n    == { assert IsRightUnital(bop, unit2); }\n      bop(unit1, unit2);\n    == { assert IsLeftUnital(bop, unit1); }\n      unit2;\n    }\n  }\n\n  lemma GroupUnitIsSelfInverse<T(!new)>(g: Group<T>)\n    ensures g.unit == g.inverse(g.unit)\n  {\n    calc {\n      g.unit;\n    == { assert IsLeftInverse(g.bop, g.inverse, g.unit); }\n      g.bop(g.inverse(g.unit), g.unit);\n    == { assert IsRightUnital(g.bop, g.unit); }\n      g.inverse(g.unit);\n    }\n  }\n\n  lemma GroupHomomorphismPreservesUnit<S(!new),T(!new)>(g1: Group<S>, g2: Group<T>, f: S -> T)\n    requires IsHomomorphism(g1.bop, g2.bop, f)\n    ensures f(g1.unit) == g2.unit\n  {\n    calc {\n      f(g1.unit);\n    == { assert IsRightUnital(g2.bop, g2.unit); }\n      g2.bop(f(g1.unit), g2.unit);\n    == { assert IsRightInverse(g2.bop, g2.inverse, g2.unit); }\n      g2.bop(f(g1.unit), g2.bop(f(g1.unit), g2.inverse(f(g1.unit))));\n    == { assert IsAssociative(g2.bop); }\n      g2.bop(g2.bop(f(g1.unit), f(g1.unit)), g2.inverse(f(g1.unit)));\n    == { assert IsHomomorphism(g1.bop, g2.bop, f); }\n      g2.bop(f(g1.bop(g1.unit, g1.unit)), g2.inverse(f(g1.unit)));\n    == { assert IsLeftUnital(g1.bop, g1.unit); }\n      g2.bop(f(g1.unit), g2.inverse(f(g1.unit)));\n    == { assert IsRightInverse(g2.bop, g2.inverse, g2.unit); }\n      g2.unit;\n    }\n  }\n\n  lemma GroupHomomorphismPreservesInverse<S(!new),T(!new)>(g1: Group<S>, g2: Group<T>, f: S -> T)\n    requires IsHomomorphism(g1.bop, g2.bop, f)\n    ensures forall x | g1.inverse.requires(x) :: f(g1.inverse(x)) == g2.inverse(f(x))\n  {\n    assert IsGroup(g1.bop, g1.inverse, g1.unit);\n    assert IsGroup(g2.bop, g2.inverse, g2.unit);\n    forall x | g1.inverse.requires(x) ensures f(g1.inverse(x)) == g2.inverse(f(x)) {\n      calc {\n        f(g1.inverse(x));\n      == { assert IsRightUnital(g2.bop, g2.unit); }\n        g2.bop(f(g1.inverse(x)), g2.unit);\n      == { assert IsRightInverse(g2.bop, g2.inverse, g2.unit); assert g2.unit == g2.bop(f(x), g2.inverse(f(x))); }\n        g2.bop(f(g1.inverse(x)), g2.bop(f(x), g2.inverse(f(x))));\n      == { assert IsAssociative(g2.bop); }\n        g2.bop(g2.bop(f(g1.inverse(x)), f(x)), g2.inverse(f(x)));\n      == { assert IsHomomorphism(g1.bop, g2.bop, f); assert g2.bop(f(g1.inverse(x)), f(x)) == f(g1.bop(g1.inverse(x), x)); }\n        g2.bop(f(g1.bop(g1.inverse(x), x)), g2.inverse(f(x)));\n      == { assert IsLeftInverse(g1.bop, g1.inverse, g1.unit); assert g1.bop(g1.inverse(x), x) == g1.unit; assert f(g1.bop(g1.inverse(x), x)) == f(g1.unit); }\n        g2.bop(f(g1.unit), g2.inverse(f(x)));\n      == { GroupHomomorphismPreservesUnit(g1, g2, f); assert f(g1.unit) == g2.unit; }\n        g2.bop(g2.unit, g2.inverse(f(x)));\n      == { assert IsLeftUnital(g2.bop, g2.unit); }\n        g2.inverse(f(x));\n      }\n    }\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/DafnyCore.dfy", "dafny": "// RUN: %verify \"%s\" > \"%t\"\n\ninclude \"./BoundedInts.dfy\"\ninclude \"./Wrappers.dfy\"\ninclude \"./Collections/Collections.dfy\"\ninclude \"./FileIO/FileIO.dfy\"\ninclude \"./Math.dfy\"\ninclude \"./NonlinearArithmetic/NonlinearArithmetic.dfy\"\ninclude \"./Relations.dfy\"\ninclude \"./Unicode/Unicode.dfy\"\ninclude \"./BinaryOperations.dfy\"\n\n\nmodule Dafny {\n\n}\n"}
{"file": "../libraries/src/dafny/FileIO/FileIO.dfy", "dafny": "/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\n// RUN: %verify \"%s\"\n\ninclude \"../Wrappers.dfy\"\n\n/**\n  * This module provides basic file I/O operations: reading and writing bytes from/to a file.\n  * The provided API is intentionally limited in scope and will be expanded later.\n  *\n  * Where the API accepts file paths as strings, there are some limitations.\n  * File paths containing only ASCII characters work identically across languages and platforms;\n  * non-ASCII Unicode codepoints may cause different language- or platform-specific behavior.\n  *\n  * File path symbols including . and .. are allowed.\n  */\nmodule {:options \"-functionSyntax:4\"} Dafny.FileIO {\n  import opened Wrappers\n\n  export provides ReadBytesFromFile, WriteBytesToFile, Wrappers\n\n  /*\n   * Public API\n   */\n\n  /**\n    * Attempts to read all bytes from the file at the given file path.\n    * If an error occurs, a `Result.Failure` value is returned containing an implementation-specific\n    * error message (which may also contain a stack trace).\n    *\n    * NOTE: See the module description for limitations on the path argument.\n    */\n  method ReadBytesFromFile(path: string) returns (res: Result<seq<bv8>, string>) {\n    var isError, bytesRead, errorMsg := INTERNAL_ReadBytesFromFile(path);\n    return if isError then Failure(errorMsg) else Success(bytesRead);\n  }\n\n  /**\n    * Attempts to write the given bytes to the file at the given file path,\n    * creating nonexistent parent directories as necessary.\n    * If an error occurs, a `Result.Failure` value is returned containing an implementation-specific\n    * error message (which may also contain a stack trace).\n    *\n    * NOTE: See the module description for limitations on the path argument.\n    */\n  method WriteBytesToFile(path: string, bytes: seq<bv8>) returns (res: Result<(), string>)\n  {\n    var isError, errorMsg := INTERNAL_WriteBytesToFile(path, bytes);\n    return if isError then Failure(errorMsg) else Success(());\n  }\n\n  /*\n   * Private API - these are intentionally not exported from the module and should not be used elsewhere\n   */\n\n  method\n    {:extern \"DafnyLibraries.FileIO\", \"INTERNAL_ReadBytesFromFile\"}\n  INTERNAL_ReadBytesFromFile(path: string)\n    returns (isError: bool, bytesRead: seq<bv8>, errorMsg: string)\n\n  method\n    {:extern \"DafnyLibraries.FileIO\", \"INTERNAL_WriteBytesToFile\"}\n  INTERNAL_WriteBytesToFile(path: string, bytes: seq<bv8>)\n    returns (isError: bool, errorMsg: string)\n}\n"}
{"file": "../libraries/src/dafny/Unicode/Utf8EncodingScheme.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../Collections/Seqs.dfy\"\ninclude \"../BoundedInts.dfy\"\n\ninclude \"Unicode.dfy\"\ninclude \"Utf8EncodingForm.dfy\"\n\n/**\n  * The Unicode encoding scheme that serializes a UTF-8 code unit sequence in exactly the same order as the code unit\n  * sequence itself.\n  *\n  * Because the UTF-8 encoding form deals in ordered byte sequences, the UTF-8 encoding scheme is trivial.\n  * The byte ordering is completely defined by the UTF-8 code unit sequence itself.\n  * We implement the encoding scheme here for completeness of the Unicode character encoding model,\n  * and to perform the (trivial) conversion between `uint8`/`byte` and `bv8` values.\n  *\n  * (Section 3.10 D95)\n  *\n  * TODO: this should refine an abstract UnicodeEncodingScheme module\n  * that states lemmas/conditions about Serialize and Deserialize\n  * which refining modules would prove about their own implementations.\n  * Proving those lemmas are easier to write using `calc`,\n  * but that runs into <https://github.com/dafny-lang/dafny/issues/1639>.\n  */\nmodule {:options \"-functionSyntax:4\"} Dafny.Utf8EncodingScheme {\n\n  import BoundedInts\n  import Collections.Seq\n  import Unicode\n  import Utf8EncodingForm\n\n  type byte = BoundedInts.uint8\n\n  /**\n    * Returns the byte serialization of the given code unit sequence.\n    */\n  function Serialize(s: Utf8EncodingForm.CodeUnitSeq): (b: seq<byte>)\n  {\n    Seq.Map(c => c as byte, s)\n  }\n\n  /**\n    * Returns the code unit sequence that serializes to the given byte sequence.\n    */\n  function Deserialize(b: seq<byte>): (s: Utf8EncodingForm.CodeUnitSeq)\n  {\n    Seq.Map(b => b as Utf8EncodingForm.CodeUnit, b)\n  }\n\n  /**\n    * Serializing a code unit sequence and then deserializing the result, yields the original code unit sequence.\n    */\n  lemma LemmaSerializeDeserialize(s: Utf8EncodingForm.CodeUnitSeq)\n    ensures Deserialize(Serialize(s)) == s\n  {}\n\n  /**\n    * Deserializing a byte sequence and then serializing the result, yields the original byte sequence.\n    */\n  lemma LemmaDeserializeSerialize(b: seq<byte>)\n    ensures Serialize(Deserialize(b)) == b\n  {\n    calc {\n      Serialize(Deserialize(b));\n    == // Definitions of Serialize, Deserialize\n      Seq.Map(c => c as byte, Seq.Map(b => b as Utf8EncodingForm.CodeUnit, b));\n    == // Compositionality of Map\n      Seq.Map(b => (b as Utf8EncodingForm.CodeUnit) as byte, b);\n    == // Simplify map\n      Seq.Map(b => b, b);\n    == // Identity function\n      b;\n    }\n  }\n}\n"}
{"file": "../libraries/src/dafny/Unicode/Utf8EncodingForm.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../Collections/Seqs.dfy\"\ninclude \"../Relations.dfy\"\n\ninclude \"Unicode.dfy\"\ninclude \"UnicodeEncodingForm.dfy\"\n\n/**\n  * The Unicode encoding form that assigns each Unicode scalar value to an unsigned byte sequence of one to four bytes\n  * in length, as specified in Table 3-6 and Table 3-7 of the Unicode Standard, Version 14.0.\n  */\nmodule {:options \"-functionSyntax:4\"} Dafny.Utf8EncodingForm refines UnicodeEncodingForm {\n  type CodeUnit = bv8\n\n  //\n  // Definitions of well-formedness.\n  //\n\n  function IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)\n  {\n    if |s| == 1 then (\n                       var b := IsWellFormedSingleCodeUnitSequence(s);\n                       assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);\n                       b\n                     )\n    else if |s| == 2 then (\n                            var b := IsWellFormedDoubleCodeUnitSequence(s);\n                            assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);\n                            b\n                          )\n    else if |s| == 3 then (\n                            var b := IsWellFormedTripleCodeUnitSequence(s);\n                            assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);\n                            b\n                          )\n    else if |s| == 4 then (\n                            var b := IsWellFormedQuadrupleCodeUnitSequence(s);\n                            assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);\n                            b\n                          )\n    else false\n  }\n\n  function IsWellFormedSingleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 1\n  {\n    var firstByte := s[0];\n    && 0x00 <= firstByte <= 0x7F\n  }\n\n  function IsWellFormedDoubleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 2\n    ensures b ==>\n              && !IsWellFormedSingleCodeUnitSequence(s[..1])\n  {\n    var firstByte := s[0];\n    var secondByte := s[1];\n    && 0xC2 <= firstByte <= 0xDF\n    && 0x80 <= secondByte <= 0xBF\n  }\n\n  function IsWellFormedTripleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 3\n    ensures b ==>\n              && !IsWellFormedSingleCodeUnitSequence(s[..1])\n              && !IsWellFormedDoubleCodeUnitSequence(s[..2])\n  {\n    var firstByte := s[0];\n    var secondByte := s[1];\n    var thirdByte := s[2];\n    && (\n         || (firstByte == 0xE0 && 0xA0 <= secondByte <= 0xBF)\n         || (0xE1 <= firstByte <= 0xEC && 0x80 <= secondByte <= 0xBF)\n         || (firstByte == 0xED && 0x80 <= secondByte <= 0x9F)\n         || (0xEE <= firstByte <= 0xEF && 0x80 <= secondByte <= 0xBF)\n       )\n    && 0x80 <= thirdByte <= 0xBF\n  }\n\n  function IsWellFormedQuadrupleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 4\n    ensures b ==>\n              && !IsWellFormedSingleCodeUnitSequence(s[..1])\n              && !IsWellFormedDoubleCodeUnitSequence(s[..2])\n              && !IsWellFormedTripleCodeUnitSequence(s[..3])\n  {\n    var firstByte := s[0];\n    var secondByte := s[1];\n    var thirdByte := s[2];\n    var fourthByte := s[3];\n    && (\n         || (firstByte == 0xF0 && 0x90 <= secondByte <= 0xBF)\n         || (0xF1 <= firstByte <= 0xF3 && 0x80 <= secondByte <= 0xBF)\n         || (firstByte == 0xF4 && 0x80 <= secondByte <= 0x8F)\n       )\n    && 0x80 <= thirdByte <= 0xBF\n    && 0x80 <= fourthByte <= 0xBF\n  }\n\n  function SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq):\n    (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)\n  {\n    if |s| >= 1 && IsWellFormedSingleCodeUnitSequence(s[..1]) then Some(s[..1])\n    else if |s| >= 2 && IsWellFormedDoubleCodeUnitSequence(s[..2]) then Some(s[..2])\n    else if |s| >= 3 && IsWellFormedTripleCodeUnitSequence(s[..3]) then Some(s[..3])\n    else if |s| >= 4 && IsWellFormedQuadrupleCodeUnitSequence(s[..4]) then Some(s[..4])\n    else None\n  }\n\n  //\n  // Encoding and decoding.\n  // See Table 3-6. UTF-8 Bit Distribution of the Unicode Standard 14.0.\n  //\n\n  function EncodeScalarValue(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n  {\n    if v <= 0x7F then EncodeScalarValueSingleByte(v)\n    else if v <= 0x7FF then EncodeScalarValueDoubleByte(v)\n    else if v <= 0xFFFF then EncodeScalarValueTripleByte(v)\n    else EncodeScalarValueQuadrupleByte(v)\n  }\n\n  function EncodeScalarValueSingleByte(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n    requires 0 <= v <= 0x7F\n    ensures |m| == 1\n    ensures IsWellFormedSingleCodeUnitSequence(m)\n  {\n    // v = 0000 0000 / 0xxx xxxx\n    var x := (v & 0x7F) as bv7;\n    // encoded = 0xxx xxxx\n    var firstByte := x as CodeUnit;\n    [firstByte]\n  }\n\n  function EncodeScalarValueDoubleByte(v: Unicode.ScalarValue): (s: CodeUnitSeq)\n    requires 0x80 <= v <= 0x7FF\n    ensures |s| == 2\n    ensures IsWellFormedDoubleCodeUnitSequence(s)\n  {\n    // v = 0000 0yyy / yyxx xxxx\n    var x := (v & 0x3F) as bv6;\n    var y := ((v & 0x7C0) >> 6) as bv5;\n    // encoded = 110y yyyy / 10xx xxxx\n    var firstByte := 0xC0 | y as CodeUnit;\n    var secondByte := 0x80 | x as CodeUnit;\n    [firstByte, secondByte]\n  }\n\n  function EncodeScalarValueTripleByte(v: Unicode.ScalarValue): (s: CodeUnitSeq)\n    requires 0x800 <= v <= 0xFFFF\n    ensures |s| == 3\n    ensures IsWellFormedTripleCodeUnitSequence(s)\n  {\n    // v = zzzz yyyy / yyxx xxxx\n    var x := (v & 0x3F) as bv6;\n    var y := ((v & 0xFC0) >> 6) as bv6;\n    var z := ((v & 0xF000) >> 12) as bv4;\n    // encoded = 1110 zzzz / 10yy yyyy / 10xx xxxx\n    var firstByte := 0xE0 | z as CodeUnit;\n    var secondByte := 0x80 | y as CodeUnit;\n    var thirdByte := 0x80 | x as CodeUnit;\n    [firstByte, secondByte, thirdByte]\n  }\n\n  function EncodeScalarValueQuadrupleByte(v: Unicode.ScalarValue): (s: CodeUnitSeq)\n    requires 0x10000 <= v <= 0x10FFFF\n    ensures |s| == 4\n    ensures IsWellFormedQuadrupleCodeUnitSequence(s)\n  {\n    // v = 000u uuuu / zzzz yyyy / yyxx xxxx\n    //        1 1122\n    assert v <= 0x1FFFFF;\n    var x := (v & 0x3F) as bv6;\n    var y := ((v & 0xFC0) >> 6) as bv6;\n    var z := ((v & 0xF000) >> 12) as bv4;\n    var u2 := ((v & 0x30000) >> 16) as bv2;\n    var u1 := ((v & 0x1C0000) >> 18) as bv3;\n\n    // encoded = 1111 0uuu / 10uu zzzz / 10yy yyyy / 10xx xxxx\n    //                 111     22\n    var firstByte := 0xF0 | u1 as CodeUnit;\n    var secondByte := 0x80 | ((u2 as CodeUnit) << 4) | z as CodeUnit;\n    var thirdByte := 0x80 | y as CodeUnit;\n    var fourthByte := 0x80 | x as CodeUnit;\n    [firstByte, secondByte, thirdByte, fourthByte]\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n  {\n    if |m| == 1 then DecodeMinimalWellFormedCodeUnitSubsequenceSingleByte(m)\n    else if |m| == 2 then DecodeMinimalWellFormedCodeUnitSubsequenceDoubleByte(m)\n    else if |m| == 3 then DecodeMinimalWellFormedCodeUnitSubsequenceTripleByte(m)\n    else assert |m| == 4; DecodeMinimalWellFormedCodeUnitSubsequenceQuadrupleByte(m)\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceSingleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 1\n    ensures 0 <= v <= 0x7F\n    ensures EncodeScalarValueSingleByte(v) == m\n  {\n    var firstByte := m[0];\n    var x := firstByte as bv7;\n    x as Unicode.ScalarValue\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceDoubleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 2\n    ensures 0x80 <= v <= 0x7FF\n    ensures EncodeScalarValueDoubleByte(v) == m\n  {\n    var firstByte := m[0];\n    var secondByte := m[1];\n    var y := (firstByte & 0x1F) as bv24;\n    var x := (secondByte & 0x3F) as bv24;\n    (y << 6) | x as Unicode.ScalarValue\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceTripleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 3\n    ensures 0x800 <= v <= 0xFFFF\n    ensures EncodeScalarValueTripleByte(v) == m\n  {\n    var firstByte := m[0];\n    var secondByte := m[1];\n    var thirdByte := m[2];\n    var z := (firstByte & 0xF) as bv24;\n    var y := (secondByte & 0x3F) as bv24;\n    var x := (thirdByte & 0x3F) as bv24;\n    assert {:split_here} true;\n    (z << 12) | (y << 6) | x as Unicode.ScalarValue\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceQuadrupleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 4\n    ensures 0x10000 <= v <= 0x10FFFF\n    ensures EncodeScalarValueQuadrupleByte(v) == m\n  {\n    var firstByte := m[0];\n    var secondByte := m[1];\n    var thirdByte := m[2];\n    var fourthByte := m[3];\n    var u1 := (firstByte & 0x7) as bv24;\n    var u2 := ((secondByte & 0x30) >> 4) as bv24;\n    var z := (secondByte & 0xF) as bv24;\n    var y := (thirdByte & 0x3F) as bv24;\n    var x := (fourthByte & 0x3F) as bv24;\n    assert {:split_here} true;\n    (u1 << 18) | (u2 << 16) | (z << 12) | (y << 6) | x as Unicode.ScalarValue\n  }\n}\n"}
{"file": "../libraries/src/dafny/Unicode/UnicodeEncodingForm.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../Wrappers.dfy\"\ninclude \"../Relations.dfy\"\ninclude \"../Collections/Seqs.dfy\"\n\ninclude \"Unicode.dfy\"\n\n/**\n  * A Unicode encoding form assigns each Unicode scalar value to a unique code unit sequence.\n  *\n  * A concrete `EncodingForm` MUST define the following:\n  *  - The type `CodeUnit`.\n  *  - The predicate `IsMinimalWellFormedCodeUnitSubsequence`, which defines the set of encodings of scalar values,\n  *    known as \"minimal well-formed code unit subsequences\".\n  *  - The function `SplitPrefixMinimalWellFormedCodeUnitSubsequence`, which defines the algorithm by which to parse\n  *    a minimal well-formed code unit subsequence from the beginning of a code unit sequence.\n  *  - The function `EncodeScalarValue`, which defines the mapping from scalar values to minimal well-formed code unit\n  *    subsequences.\n  *  - The function `DecodeMinimalWellFormedCodeUnitSubsequence`, which defines the mapping from minimal well-formed\n  *    code unit subsequences to scalar values.\n  */\nabstract module {:options \"-functionSyntax:4\"} Dafny.UnicodeEncodingForm {\n  import opened Wrappers\n\n  import Relations\n  import Collections.Seq\n  import Unicode\n\n  type CodeUnitSeq = seq<CodeUnit>\n  type WellFormedCodeUnitSeq = s: CodeUnitSeq\n    | IsWellFormedCodeUnitSequence(s)\n    witness []\n  type MinimalWellFormedCodeUnitSeq = s: CodeUnitSeq\n    | IsMinimalWellFormedCodeUnitSubsequence(s)\n    witness *\n\n  //\n  // Begin abstract items.\n  //\n\n  /**\n    * A code unit is the minimal bit combination that can represent a unit of encoded text for processing or\n    * interchange. (Section 3.9 D77.)\n    */\n  type CodeUnit\n\n  /**\n    * A well-formed Unicode code unit sequence that maps to a single Unicode scalar value.\n    * (Section 3.9 D85a.)\n    */\n  function IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)\n    ensures b ==>\n              && |s| > 0\n              && forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])\n    decreases |s|\n\n  /**\n    * Returns the shortest prefix of `s` that is a minimal well-formed code unit subsequence,\n    * or None if there is no such prefix.\n    */\n  function SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)\n    ensures |s| == 0 ==> maybePrefix.None?\n    ensures (exists i | 0 < i <= |s| :: IsMinimalWellFormedCodeUnitSubsequence(s[..i])) <==>\n            && maybePrefix.Some?\n    ensures maybePrefix.Some? ==>\n              && var prefix := maybePrefix.Extract();\n              && 0 < |prefix| <= |s|\n              && prefix == s[..|prefix|]\n              && forall i | 0 < i < |prefix| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])\n\n  /**\n    * Returns the minimal well-formed code unit subsequence that this encoding form assigns to the given scalar value.\n    * The Unicode standard requires that this is injective.\n    *\n    * TODO: enforce that implementations satisfy Functions.Injective\n    */\n  function EncodeScalarValue(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n\n  /**\n    * Returns the scalar value that this encoding form assigns to the given minimal well-formed code unit subsequence.\n    */\n  function DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    ensures EncodeScalarValue(v) == m\n\n  //\n  // End abstract items.\n  //\n\n  /**\n    * If `ms` is the concatenation of a minimal well-formed code unit subsequence `m` and a code unit sequence `s`,\n    * then the shortest minimal well-formed code unit subsequence prefix of `ms` is simply `m`.\n    */\n  lemma LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m: MinimalWellFormedCodeUnitSeq, s: CodeUnitSeq)\n    ensures SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + s) == Some(m)\n  {\n    var ms := m + s;\n    assert IsMinimalWellFormedCodeUnitSubsequence(ms[..|m|]);\n    var prefix := SplitPrefixMinimalWellFormedCodeUnitSubsequence(ms).Extract();\n    calc ==> {\n      IsMinimalWellFormedCodeUnitSubsequence(m);\n      |prefix| <= |m|;\n      prefix == ms[..|prefix|] == m[..|prefix|] == m;\n    }\n  }\n\n  /**\n    * Returns the unique partition of the given code unit sequence into minimal well-formed code unit subsequences,\n    * or None if no such partition exists.\n    */\n  function PartitionCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeParts: Option<seq<MinimalWellFormedCodeUnitSeq>>)\n    ensures maybeParts.Some? ==> Seq.Flatten(maybeParts.Extract()) == s\n    decreases |s|\n  {\n    if s == [] then Some([])\n    else\n      var maybePrefix := SplitPrefixMinimalWellFormedCodeUnitSubsequence(s);\n      if maybePrefix.None? then None\n      else\n        var prefix := maybePrefix.Extract();\n        // Recursing on subsequences leads to quadratic running time in most/all Dafny runtimes as of this writing.\n        // This definition (and others in the Unicode modules) emphasizes clarify and correctness,\n        // but should be supplemented with a by-method for improved performance,\n        // so long as Dafny runtimes' lack optimizations for subsequence recursion.\n        var restParts := PartitionCodeUnitSequenceChecked(s[|prefix|..]);\n        if restParts.Some? then Some([prefix] + restParts.Extract())\n        else None\n  }\n\n  /**\n    * Returns the unique partition of the given well-formed code unit sequence into minimal well-formed code unit\n    * subsequences.\n    */\n  function PartitionCodeUnitSequence(s: WellFormedCodeUnitSeq): (parts: seq<MinimalWellFormedCodeUnitSeq>)\n    ensures Seq.Flatten(parts) == s\n  {\n    PartitionCodeUnitSequenceChecked(s).Extract()\n  }\n\n  /**\n    * The partitioning of a minimal well-formed code unit subsequence is the singleton sequence\n    * containing exactly the minimal well-formed code unit subsequence.\n    */\n  lemma LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq)\n    ensures PartitionCodeUnitSequenceChecked(m) == Some([m])\n  {\n    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, []);\n    calc == {\n      Some(m);\n      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + []);\n      { assert m + [] == m; }\n      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m);\n    }\n    calc == {\n      PartitionCodeUnitSequenceChecked(m);\n      Some([m] + []);\n      { assert [m] + [] == [m]; }\n      Some([m]);\n    }\n  }\n\n  /**\n    * A code unit sequence is well-formed iff it can be partitioned into a sequence of minimal well-formed code unit subsequences.\n    */\n  function IsWellFormedCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n  {\n    PartitionCodeUnitSequenceChecked(s).Some?\n  }\n\n  /**\n    * A minimal well-formed code unit subsequence is a well-formed code unit sequence.\n    */\n  lemma LemmaMinimalWellFormedCodeUnitSubsequenceIsWellFormedSequence(m: MinimalWellFormedCodeUnitSeq)\n    ensures IsWellFormedCodeUnitSequence(m)\n  {\n    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);\n  }\n\n  /**\n    * The concatenation of a minimal well-formed code unit subsequence and a well-formed code unit sequence\n    * is itself a well-formed code unit sequence.\n    */\n  lemma LemmaPrependMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq, s: WellFormedCodeUnitSeq)\n    ensures IsWellFormedCodeUnitSequence(m + s)\n  {\n    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);\n    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, s);\n    assert PartitionCodeUnitSequenceChecked(m + s).Some?;\n  }\n\n  /**\n    * The concatenation of minimal well-formed code unit subsequences is itself a well-formed code unit sequence.\n    */\n  lemma LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms: seq<MinimalWellFormedCodeUnitSeq>)\n    ensures IsWellFormedCodeUnitSequence(Seq.Flatten(ms))\n  {\n    if |ms| == 0 {\n      assert IsWellFormedCodeUnitSequence(Seq.Flatten(ms));\n    }\n    else {\n      var head := ms[0];\n      var tail := ms[1..];\n      LemmaFlattenMinimalWellFormedCodeUnitSubsequences(tail);\n      var flatTail := Seq.Flatten(tail);\n      LemmaPrependMinimalWellFormedCodeUnitSubsequence(head, flatTail);\n      assert IsWellFormedCodeUnitSequence(head + flatTail);\n    }\n  }\n\n  /**\n    * The concatenation of well-formed code unit sequences is itself a well-formed code unit sequence.\n    */\n  lemma LemmaConcatWellFormedCodeUnitSubsequences(s: WellFormedCodeUnitSeq, t: WellFormedCodeUnitSeq)\n    ensures IsWellFormedCodeUnitSequence(s + t)\n  {\n    var partsS := PartitionCodeUnitSequence(s);\n    var partsT := PartitionCodeUnitSequence(t);\n    var partsST := partsS + partsT;\n    Seq.LemmaFlattenConcat(partsS, partsT);\n\n    assert s + t == Seq.Flatten(partsST);\n    assert forall part | part in partsST ::\n        && |part| > 0\n        && IsMinimalWellFormedCodeUnitSubsequence(part);\n    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(partsST);\n  }\n\n  /**\n    * Returns the well-formed Unicode string that is the encoding of the given scalar value sequence.\n    */\n  function EncodeScalarSequence(vs: seq<Unicode.ScalarValue>): (s: WellFormedCodeUnitSeq)\n  {\n    var ms := Seq.Map(EncodeScalarValue, vs);\n    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms);\n    Seq.Flatten(ms)\n  }\n\n  /**\n    * Returns the scalar value sequence encoded by the given well-formed Unicode string.\n    */\n  function DecodeCodeUnitSequence(s: WellFormedCodeUnitSeq): (vs: seq<Unicode.ScalarValue>)\n    ensures EncodeScalarSequence(vs) == s\n  {\n    var parts := PartitionCodeUnitSequence(s);\n    var vs := Seq.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);\n    calc == {\n      s;\n      Seq.Flatten(parts);\n      { assert parts == Seq.Map(EncodeScalarValue, vs); }\n      Seq.Flatten(Seq.Map(EncodeScalarValue, vs));\n      EncodeScalarSequence(vs);\n    }\n    vs\n  }\n\n  /**\n    * Returns the scalar value sequence encoded by the given code unit sequence, or None if the given Unicode string\n    * is not well-formed.\n    */\n  function DecodeCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeVs: Option<seq<Unicode.ScalarValue>>)\n    ensures IsWellFormedCodeUnitSequence(s) ==>\n              && maybeVs.Some?\n              && maybeVs.Extract() == DecodeCodeUnitSequence(s)\n    ensures !IsWellFormedCodeUnitSequence(s) ==> && maybeVs.None?\n  {\n    // IsWellFormedCodeUnitSequence and DecodeCodeUnitSequence each call PartitionCodeUnitSequence,\n    // so for efficiency we avoid recomputing the partition in the by-method.\n    if IsWellFormedCodeUnitSequence(s) then Some(DecodeCodeUnitSequence(s))\n    else None\n  }\n  by method {\n    var maybeParts := PartitionCodeUnitSequenceChecked(s);\n    if maybeParts.None? {\n      return None;\n    }\n    var parts := maybeParts.value;\n    var vs := Seq.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);\n    calc == {\n      s;\n      Seq.Flatten(parts);\n      { assert parts == Seq.Map(EncodeScalarValue, vs); }\n      Seq.Flatten(Seq.Map(EncodeScalarValue, vs));\n      EncodeScalarSequence(vs);\n    }\n    return Some(vs);\n  }\n}\n"}
{"file": "../libraries/src/dafny/Unicode/Unicode.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../Collections/Seqs.dfy\"\n\n// This module implements basic functionality of Unicode 14.0.\nmodule {:options \"-functionSyntax:4\"} Dafny.Unicode {\n\n  /**\n    * Any value in the Unicode codespace (a range of integers from 0 to 10FFFF_16). (Section 3.9 D9-D10)\n    */\n  type CodePoint = i: bv24 | 0 <= i <= 0x10FFFF\n\n  /**\n    * A Unicode code point in the range U+D800 to U+DBFF. (Section 3.8 D71)\n    */\n  type HighSurrogateCodePoint = p: CodePoint | HIGH_SURROGATE_MIN <= p <= HIGH_SURROGATE_MAX\n    witness HIGH_SURROGATE_MIN\n  const HIGH_SURROGATE_MIN: CodePoint := 0xD800\n  const HIGH_SURROGATE_MAX: CodePoint := 0xDBFF\n\n  /**\n    * A Unicode code point in the range U+DC00 to U+DFFF. (Section 3.8 D73)\n    */\n  type LowSurrogateCodePoint = p: CodePoint | LOW_SURROGATE_MIN <= p <= LOW_SURROGATE_MAX\n    witness LOW_SURROGATE_MIN\n  const LOW_SURROGATE_MIN: CodePoint := 0xDC00\n  const LOW_SURROGATE_MAX: CodePoint := 0xDFFF\n\n  /**\n    * Any Unicode code point except high-surrogate and low-surrogate code points. (Section 3.9 D76)\n    */\n  type ScalarValue = p: CodePoint |\n      && (p < HIGH_SURROGATE_MIN || p > HIGH_SURROGATE_MAX)\n      && (p < LOW_SURROGATE_MIN || p > LOW_SURROGATE_MAX)\n\n  const ASSIGNED_PLANES: set<bv8> := {\n    0,  // Basic Multilingual Plane\n    1,  // Supplementary Multilingual Plane\n    2,  // Supplementary Ideographic Plane\n    3,  // Tertiary Ideographic Plane\n    14, // Supplementary Special Purpose Plane\n    15, // Supplementary Private Use Area A\n    16  // Supplementary Private Use Area B\n  }\n\n  ghost predicate {:opaque} IsInAssignedPlane(i: CodePoint) {\n    var plane := (i >> 16) as bv8;\n    plane in ASSIGNED_PLANES\n  }\n\n  // These are actually supersets of the Unicode planes,\n  // since not all code points in a plane are assigned.\n  //\n  // TODO: check against the list of assigned code points, instead of only checking their plane\n  // (https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt)\n  type AssignedCodePoint = p: CodePoint | IsInAssignedPlane(p) witness *\n}\n"}
{"file": "../libraries/src/dafny/Unicode/Utf16EncodingForm.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../Collections/Seqs.dfy\"\ninclude \"../Relations.dfy\"\n\ninclude \"Unicode.dfy\"\ninclude \"UnicodeEncodingForm.dfy\"\n\n// Definition of the UTF-16 Unicode Encoding Form, as specified in Section 3.9 D91.\nmodule {:options \"-functionSyntax:4\"} Dafny.Utf16EncodingForm refines UnicodeEncodingForm {\n  type CodeUnit = bv16\n\n  //\n  // Definitions of well-formedness.\n  //\n\n  function IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)\n  {\n    if |s| == 1 then IsWellFormedSingleCodeUnitSequence(s)\n    else if |s| == 2 then (\n                            var b := IsWellFormedDoubleCodeUnitSequence(s);\n                            assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);\n                            b\n                          )\n    else false\n  }\n\n  function IsWellFormedSingleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 1\n  {\n    var firstWord := s[0];\n    || 0x0 <= firstWord <= 0xD7FF\n    || 0xE000 <= firstWord <= 0xFFFF\n  }\n\n  function IsWellFormedDoubleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 2\n    ensures b ==> !IsWellFormedSingleCodeUnitSequence(s[..1])\n  {\n    var firstWord := s[0];\n    var secondWord := s[1];\n    && 0xD800 <= firstWord <= 0xDBFF\n    && 0xDC00 <= secondWord <= 0xDFFF\n  }\n\n  function SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)\n    ensures |s| == 0 ==> maybePrefix.None?\n    ensures (exists i | 0 < i <= |s| :: IsMinimalWellFormedCodeUnitSubsequence(s[..i])) <==>\n            && maybePrefix.Some?\n    ensures maybePrefix.Some? ==>\n              && var prefix := maybePrefix.Extract();\n              && 0 < |prefix| <= |s|\n              && prefix == s[..|prefix|]\n              && IsMinimalWellFormedCodeUnitSubsequence(prefix)\n  {\n    if |s| >= 1 && IsWellFormedSingleCodeUnitSequence(s[..1]) then Some(s[..1])\n    else if |s| >= 2 && IsWellFormedDoubleCodeUnitSequence(s[..2]) then Some(s[..2])\n    else None\n  }\n\n  //\n  // Encoding and decoding.\n  // See Table 3-5. UTF-16 Bit Distribution.\n  //\n\n  function EncodeScalarValue(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n  {\n    if 0x0 <= v <= 0xD7FF || 0xE000 <= v <= 0xFFFF then EncodeScalarValueSingleWord(v)\n    else EncodeScalarValueDoubleWord(v)\n  }\n\n  function EncodeScalarValueSingleWord(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n    requires\n      || 0x0 <= v <= 0xD7FF\n      || 0xE000 <= v <= 0xFFFF\n    ensures |m| == 1\n    ensures IsWellFormedSingleCodeUnitSequence(m)\n  {\n    var firstWord := v as CodeUnit;\n    [firstWord]\n  }\n\n  function EncodeScalarValueDoubleWord(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n    requires 0x10000 <= v <= 0x10FFFF\n    ensures |m| == 2\n    ensures IsWellFormedDoubleCodeUnitSequence(m)\n  {\n    // v = 000u uuuu / xxxx xxxx / xxxx xxxx\n    //                 1111 1122   2222 2222\n    var x2 := (v & 0x3FF) as bv10;\n    var x1 := ((v & 0xFC00) >> 10) as bv6;\n    var u := ((v & 0x1F0000) >> 16) as bv5;\n    var w := (u - 1) as bv4;\n    // encoded = 1101 10ww / wwxx xxxx / 1101 11xx / xxxx xxxx\n    //                         11 1111          22   2222 2222\n    var firstWord := 0xD800 | ((w as CodeUnit) << 6) | x1 as CodeUnit;\n    var secondWord := 0xDC00 | x2 as CodeUnit;\n    [firstWord, secondWord]\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n  {\n    if |m| == 1 then DecodeMinimalWellFormedCodeUnitSubsequenceSingleWord(m)\n    else assert |m| == 2; DecodeMinimalWellFormedCodeUnitSubsequenceDoubleWord(m)\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceSingleWord(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 1\n    ensures\n      || 0x0 <= v <= 0xD7FF\n      || 0xE000 <= v <= 0xFFFF\n    ensures EncodeScalarValueSingleWord(v) == m\n  {\n    var firstWord := m[0];\n    var x := firstWord as bv16;\n    assert EncodeScalarValueSingleWord(x as Unicode.ScalarValue) == m;\n    x as Unicode.ScalarValue\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceDoubleWord(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 2\n    ensures 0x10000 <= v <= 0x10FFFF\n    ensures EncodeScalarValueDoubleWord(v) == m\n  {\n    var firstWord := m[0];\n    var secondWord := m[1];\n    var x2 := (secondWord & 0x3FF) as bv24;\n    var x1 := (firstWord & 0x3F) as bv24;\n    var w := ((firstWord & 0x3C0) >> 6) as bv24;\n    var u := (w + 1) as bv24;\n    var v := (u << 16) | (x1 << 10) | x2 as Unicode.ScalarValue;\n    assert {:split_here} true;\n    assert EncodeScalarValueDoubleWord(v) == m;\n    v\n  }\n}\n"}
{"file": "../libraries/src/dafny/Collections/Arrays.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../Wrappers.dfy\"\ninclude \"../Relations.dfy\"\ninclude \"Seqs.dfy\"\n\nmodule Dafny.Collections.Arrays {\n\n  import opened Wrappers\n  import opened Relations\n  import opened Seq\n\n  method BinarySearch<T>(a: array<T>, key: T, less: (T, T) -> bool) returns (r: Option<nat>)\n    requires SortedBy(a[..], (x, y) => less(x, y) || x == y)\n    requires StrictTotalOrdering(less)\n    ensures r.Some? ==> r.value < a.Length && a[r.value] == key\n    ensures r.None? ==> key !in a[..]\n  {\n    var lo, hi : nat := 0, a.Length;\n    while lo < hi\n      invariant 0 <= lo <= hi <= a.Length\n      invariant key !in a[..lo] && key !in a[hi..]\n      invariant a[..] == old(a[..])\n    {\n      var mid := (lo + hi) / 2;\n\n      if less(key, a[mid]) {\n        hi := mid;\n      } else if less(a[mid], key) {\n        lo:= mid + 1;\n      } else {\n        return Some(mid);\n      }\n    }\n\n    return None;\n  }\n}\n"}
{"file": "../libraries/src/dafny/Collections/Isets.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original Copyright under the following: \n *  Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../Relations.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.Collections.Isets {\n\n  import opened Relations\n\n  /* If all elements in iset x are in iset y, x is a subset of y. */\n  lemma LemmaSubset<T>(x: iset<T>, y: iset<T>)\n    requires forall e {:trigger e in y} :: e in x ==> e in y\n    ensures x <= y\n  {\n  }\n\n  /* Map an injective function to each element of an iset. */\n  ghost function {:opaque} Map<X(!new), Y>(xs: iset<X>, f: X-->Y): (ys: iset<Y>)\n    reads f.reads\n    requires forall x {:trigger f.requires(x)} :: f.requires(x)\n    requires Injective(f)\n    ensures forall x {:trigger f(x)} :: x in xs <==> f(x) in ys\n  {\n    var ys := iset x | x in xs :: f(x);\n    ys\n  }\n\n  /* Construct an iset using elements of another set for which a function\n  returns true. */\n  ghost function {:opaque} Filter<X(!new)>(xs: iset<X>, f: X~>bool): (ys: iset<X>)\n    reads f.reads\n    requires forall x {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)\n    ensures forall y {:trigger f(y)}{:trigger y in xs} :: y in ys <==> y in xs && f(y)\n  {\n    var ys := iset x | x in xs && f(x);\n    ys\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/Collections/Seqs.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original Copyright under the following: \n *  Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../Wrappers.dfy\"\ninclude \"../Math.dfy\"\ninclude \"../Relations.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.Collections.Seq {\n\n  import opened Wrappers\n  import opened Relations\n  import Math\n\n  /**********************************************************\n   *\n   *  Manipulating the End of a Sequence\n   *\n   ***********************************************************/\n\n  /* Returns the first element of a non-empty sequence. */\n  function First<T>(xs: seq<T>): T\n    requires |xs| > 0\n  {\n    xs[0]\n  }\n\n  /* Returns the subsequence of a non-empty sequence obtained by\n     dropping the first element. */\n  function DropFirst<T>(xs: seq<T>): seq<T>\n    requires |xs| > 0\n  {\n    xs[1..]\n  }\n\n  /* Returns the last element of a non-empty sequence. */\n  function Last<T>(xs: seq<T>): T\n    requires |xs| > 0;\n  {\n    xs[|xs|-1]\n  }\n\n  /* Returns the subsequence of a non-empty sequence obtained by\n     dropping the last element. */\n  function DropLast<T>(xs: seq<T>): seq<T>\n    requires |xs| > 0;\n  {\n    xs[..|xs|-1]\n  }\n\n  /* The concatenation of two subsequences of a non-empty sequence, the first obtained \n     from dropping the last element, the second consisting only of the last \n     element, is the original sequence. */\n  lemma LemmaLast<T>(xs: seq<T>)\n    requires |xs| > 0;\n    ensures DropLast(xs) + [Last(xs)] == xs;\n  {\n  }\n\n  /* The last element of two concatenated sequences, the second one being non-empty, will be the \n     last element of the latter sequence. */\n  lemma LemmaAppendLast<T>(xs: seq<T>, ys: seq<T>)\n    requires 0 < |ys|\n    ensures Last(xs + ys) == Last(ys)\n  {\n  }\n\n  /* The concatenation of sequences is associative. */\n  lemma LemmaConcatIsAssociative<T>(xs: seq<T>, ys: seq<T>, zs: seq<T>)\n    ensures xs + (ys + zs) == (xs + ys) + zs;\n  {\n  }\n\n  /**********************************************************\n   *\n   *  Manipulating the Content of a Sequence\n   *\n   ***********************************************************/\n\n  /* Is true if the sequence xs is a prefix of the sequence ys. */\n  ghost predicate IsPrefix<T>(xs: seq<T>, ys: seq<T>)\n    ensures IsPrefix(xs, ys) ==> (|xs| <= |ys| && xs == ys[..|xs|])\n  {\n    xs <= ys\n  }\n\n  /* Is true if the sequence xs is a suffix of the sequence ys. */\n  ghost predicate IsSuffix<T>(xs: seq<T>, ys: seq<T>)\n  {\n    && |xs| <= |ys|\n    && xs == ys[|ys|-|xs|..]\n  }\n\n  /* A sequence that is sliced at the pos-th element, concatenated \n     with that same sequence sliced from the pos-th element, is equal to the \n     original unsliced sequence. */\n  lemma LemmaSplitAt<T>(xs: seq<T>, pos: nat)\n    requires pos < |xs|;\n    ensures xs[..pos] + xs[pos..] == xs;\n  {\n  }\n\n  /* Any element in a slice is included in the original sequence. */\n  lemma LemmaElementFromSlice<T>(xs: seq<T>, xs':seq<T>, a: int, b: int, pos: nat)\n    requires 0 <= a <= b <= |xs|;\n    requires xs' == xs[a..b];\n    requires a <= pos < b;\n    ensures  pos - a < |xs'|;\n    ensures  xs'[pos-a] == xs[pos];\n  {\n  }\n\n  /* A slice (from s2..e2) of a slice (from s1..e1) of a sequence is equal to just a \n     slice (s1+s2..s1+e2) of the original sequence. */\n  lemma LemmaSliceOfSlice<T>(xs: seq<T>, s1: int, e1: int, s2: int, e2: int)\n    requires 0 <= s1 <= e1 <= |xs|;\n    requires 0 <= s2 <= e2 <= e1 - s1;\n    ensures  xs[s1..e1][s2..e2] == xs[s1+s2..s1+e2];\n  {\n    var r1 := xs[s1..e1];\n    var r2 := r1[s2..e2];\n    var r3 := xs[s1+s2..s1+e2];\n    assert |r2| == |r3|;\n    forall i {:trigger r2[i], r3[i]}| 0 <= i < |r2| ensures r2[i] == r3[i];\n    {\n    }\n  }\n\n  /* Converts a sequence to an array. */\n  method ToArray<T>(xs: seq<T>) returns (a: array<T>)\n    ensures fresh(a)\n    ensures a.Length == |xs|\n    ensures forall i :: 0 <= i < |xs| ==> a[i] == xs[i]\n  {\n    a := new T[|xs|](i requires 0 <= i < |xs| => xs[i]);\n  }\n\n  /* Converts a sequence to a set. */\n  function {:opaque} ToSet<T>(xs: seq<T>): set<T>\n  {\n    set x: T | x in xs\n  }\n\n  /* The cardinality of a set of elements is always less than or \n     equal to that of the full sequence of elements. */\n  lemma LemmaCardinalityOfSet<T>(xs: seq<T>)\n    ensures |ToSet(xs)| <= |xs|\n  {\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      assert ToSet(xs) == ToSet(DropLast(xs)) + {Last(xs)};\n      LemmaCardinalityOfSet(DropLast(xs));\n    }\n  }\n\n  /* A sequence is of length 0 if and only if its conversion to\n     a set results in the empty set. */\n  lemma LemmaCardinalityOfEmptySetIs0<T>(xs: seq<T>)\n    ensures |ToSet(xs)| == 0 <==> |xs| == 0\n  {\n    reveal ToSet();\n    if |xs| != 0 {\n      assert xs[0] in ToSet(xs);\n    }\n  }\n\n  /* Is true if there are no duplicate values in the sequence. */\n  ghost predicate {:opaque} HasNoDuplicates<T>(xs: seq<T>)\n  {\n    (forall i, j {:trigger xs[i], xs[j]}:: 0 <= i < |xs| && 0 <= j < |xs| && i != j ==> xs[i] != xs[j])\n  }\n\n  /* If sequences xs and ys don't have duplicates and there are no \n     elements in common between them, then the concatenated sequence xs + ys \n     will not contain duplicates either. */\n  lemma {:timeLimitMultiplier 3} LemmaNoDuplicatesInConcat<T>(xs: seq<T>, ys: seq<T>)\n    requires HasNoDuplicates(xs);\n    requires HasNoDuplicates(ys);\n    requires multiset(xs) !! multiset(ys);\n    ensures HasNoDuplicates(xs+ys);\n  {\n    reveal HasNoDuplicates();\n    var zs := xs + ys;\n    if |zs| > 1 {\n      assert forall i {:trigger zs[i]} :: 0 <= i < |xs| ==>\n                                            zs[i] in multiset(xs);\n      assert forall j {:trigger zs[j]} :: |xs| <= j < |zs| ==>\n                                            zs[j] in multiset(ys);\n      assert forall i, j {:trigger zs[i], zs[j]} :: i != j && 0 <= i < |xs| && |xs| <= j < |zs| ==>\n                                                      zs[i] != zs[j];\n    }\n  }\n\n  /* A sequence with no duplicates converts to a set of the same \n     cardinality. */\n  lemma LemmaCardinalityOfSetNoDuplicates<T>(xs: seq<T>)\n    requires HasNoDuplicates(xs)\n    ensures |ToSet(xs)| == |xs|\n  {\n    reveal HasNoDuplicates();\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      LemmaCardinalityOfSetNoDuplicates(DropLast(xs));\n      assert ToSet(xs) == ToSet(DropLast(xs)) + {Last(xs)};\n    }\n  }\n\n  /* A sequence with cardinality equal to its set has no duplicates. */\n  lemma LemmaNoDuplicatesCardinalityOfSet<T>(xs: seq<T>)\n    requires |ToSet(xs)| == |xs|\n    ensures HasNoDuplicates(xs)\n  {\n    reveal HasNoDuplicates();\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      assert xs == [First(xs)] + DropFirst(xs);\n      assert ToSet(xs) == {First(xs)} + ToSet(DropFirst(xs));\n      if First(xs) in DropFirst(xs) {\n        // If there is a duplicate, then we show that |ToSet(s)| == |s| cannot hold.\n        assert ToSet(xs) == ToSet(DropFirst(xs));\n        LemmaCardinalityOfSet(DropFirst(xs));\n        assert |ToSet(xs)| <= |DropFirst(xs)|;\n      } else {\n        assert |ToSet(xs)| == 1 + |ToSet(DropFirst(xs))|;\n        LemmaNoDuplicatesCardinalityOfSet(DropFirst(xs));\n      }\n    }\n  }\n\n  /* Given a sequence with no duplicates, each element occurs only \n     once in its conversion to a multiset. */\n  lemma LemmaMultisetHasNoDuplicates<T>(xs: seq<T>)\n    requires HasNoDuplicates(xs)\n    ensures forall x {:trigger multiset(xs)[x]} | x in multiset(xs):: multiset(xs)[x] == 1\n  {\n    if |xs| == 0 {\n    } else {\n      assert xs == DropLast(xs) + [Last(xs)];\n      assert Last(xs) !in DropLast(xs) by {\n        reveal HasNoDuplicates();\n      }\n      assert HasNoDuplicates(DropLast(xs)) by {\n        reveal HasNoDuplicates();\n      }\n      LemmaMultisetHasNoDuplicates(DropLast(xs));\n    }\n  }\n\n  /* For an element that occurs at least once in a sequence, the index of its\n     first occurrence is returned. */\n  function {:opaque} IndexOf<T(==)>(xs: seq<T>, v: T): (i: nat)\n    requires v in xs\n    ensures i < |xs| && xs[i] == v\n    ensures forall j {:trigger xs[j]} :: 0 <= j < i ==> xs[j] != v\n  {\n    if xs[0] == v then 0 else 1 + IndexOf(xs[1..], v)\n  }\n\n  /* Returns Some(i), if an element occurs at least once in a sequence, and i is \n     the index of its first occurrence. Otherwise the return is None. */\n  function {:opaque} IndexOfOption<T(==)>(xs: seq<T>, v: T): (o: Option<nat>)\n    ensures if o.Some? then o.value < |xs| && xs[o.value] == v &&\n                            forall j {:trigger xs[j]} :: 0 <= j < o.value ==> xs[j] != v\n            else v !in xs\n  {\n    if |xs| == 0 then None()\n    else\n    if xs[0] == v then Some(0)\n    else\n      var o' := IndexOfOption(xs[1..], v);\n      if o'.Some? then Some(o'.value + 1) else None()\n  }\n\n  /* For an element that occurs at least once in a sequence, the index of its\n     last occurrence is returned. */\n  function {:opaque} LastIndexOf<T(==)>(xs: seq<T>, v: T): (i: nat)\n    requires v in xs\n    ensures i < |xs| && xs[i] == v\n    ensures forall j {:trigger xs[j]} :: i < j < |xs| ==> xs[j] != v\n  {\n    if xs[|xs|-1] == v then |xs| - 1 else LastIndexOf(xs[..|xs|-1], v)\n  }\n\n  /* Returns Some(i), if an element occurs at least once in a sequence, and i is \n     the index of its last occurrence. Otherwise the return is None. */\n  function {:opaque} LastIndexOfOption<T(==)>(xs: seq<T>, v: T): (o: Option<nat>)\n    ensures if o.Some? then o.value < |xs| && xs[o.value] == v &&\n                            forall j {:trigger xs[j]} :: o.value < j < |xs| ==> xs[j] != v\n            else v !in xs\n  {\n    if |xs| == 0 then None()\n    else if xs[|xs|-1] == v then Some(|xs| - 1) else LastIndexOfOption(xs[..|xs|-1], v)\n  }\n\n  /* Returns a sequence without the element at a given position. */\n  function {:opaque} Remove<T>(xs: seq<T>, pos: nat): (ys: seq<T>)\n    requires pos < |xs|\n    ensures |ys| == |xs| - 1\n    ensures forall i {:trigger ys[i], xs[i]} | 0 <= i < pos :: ys[i] == xs[i]\n    ensures forall i {:trigger ys[i]} | pos <= i < |xs| - 1 :: ys[i] == xs[i+1]\n  {\n    xs[..pos] + xs[pos+1..]\n  }\n\n  /* If a given element occurs at least once in a sequence, the sequence without\n     its first occurrence is returned. Otherwise the same sequence is returned. */\n  function {:opaque} RemoveValue<T(==)>(xs: seq<T>, v: T): (ys: seq<T>)\n    ensures v !in xs ==> xs == ys\n    ensures v in xs ==> |multiset(ys)| == |multiset(xs)| - 1\n    ensures v in xs ==> multiset(ys)[v] == multiset(xs)[v] - 1\n    ensures HasNoDuplicates(xs) ==> HasNoDuplicates(ys) && ToSet(ys) == ToSet(xs) - {v}\n  {\n    reveal HasNoDuplicates();\n    reveal ToSet();\n    if v !in xs then xs\n    else\n      var i := IndexOf(xs, v);\n      assert xs == xs[..i] + [v] + xs[i+1..];\n      xs[..i] + xs[i+1..]\n  }\n\n  /* Inserts an element at a given position and returns the resulting (longer) sequence. */\n  function {:opaque} Insert<T>(xs: seq<T>, a: T, pos: nat): seq<T>\n    requires pos <= |xs|\n    ensures |Insert(xs, a, pos)| == |xs| + 1\n    ensures forall i {:trigger Insert(xs, a, pos)[i], xs[i]} :: 0 <= i < pos ==> Insert(xs, a, pos)[i] == xs[i]\n    ensures forall i {:trigger xs[i]} :: pos <= i < |xs| ==> Insert(xs, a, pos)[i+1] == xs[i]\n    ensures Insert(xs, a, pos)[pos] == a\n    ensures multiset(Insert(xs, a, pos)) == multiset(xs) + multiset{a}\n  {\n    assert xs == xs[..pos] + xs[pos..];\n    xs[..pos] + [a] + xs[pos..]\n  }\n\n  /* Returns the sequence that is in reverse order to a given sequence. */\n  function {:opaque} Reverse<T>(xs: seq<T>): (ys: seq<T>)\n    ensures |ys| == |xs|\n    ensures forall i {:trigger ys[i]}{:trigger xs[|xs| - i - 1]} :: 0 <= i < |xs| ==> ys[i] == xs[|xs| - i - 1]\n  {\n    if xs == [] then [] else [xs[|xs|-1]] + Reverse(xs[0 .. |xs|-1])\n  }\n\n  /* Returns a constant sequence of a given length. */\n  function {:opaque} Repeat<T>(v: T, length: nat): (xs: seq<T>)\n    ensures |xs| == length\n    ensures forall i: nat {:trigger xs[i]} | i < |xs| :: xs[i] == v\n  {\n    if length == 0 then\n      []\n    else\n      [v] + Repeat(v, length - 1)\n  }\n\n  /* Unzips a sequence that contains pairs into two separate sequences. */\n  function {:opaque} Unzip<A,B>(xs: seq<(A, B)>): (seq<A>, seq<B>)\n    ensures |Unzip(xs).0| == |Unzip(xs).1| == |xs|\n    ensures forall i {:trigger Unzip(xs).0[i]} {:trigger Unzip(xs).1[i]}\n              :: 0 <= i < |xs| ==> (Unzip(xs).0[i], Unzip(xs).1[i]) == xs[i]\n  {\n    if |xs| == 0 then ([], [])\n    else\n      var (a, b):= Unzip(DropLast(xs));\n      (a + [Last(xs).0], b + [Last(xs).1])\n  }\n\n  /* Zips two sequences of equal length into one sequence that consists of pairs. */\n  function {:opaque} Zip<A,B>(xs: seq<A>, ys: seq<B>): seq<(A, B)>\n    requires |xs| == |ys|\n    ensures |Zip(xs, ys)| == |xs|\n    ensures forall i {:trigger Zip(xs, ys)[i]}:: 0 <= i < |Zip(xs, ys)| ==> Zip(xs, ys)[i] == (xs[i], ys[i])\n    ensures Unzip(Zip(xs, ys)).0 == xs\n    ensures Unzip(Zip(xs, ys)).1 == ys\n  {\n    if |xs| == 0 then []\n    else Zip(DropLast(xs), DropLast(ys)) + [(Last(xs), Last(ys))]\n  }\n\n  /* Unzipping and zipping a sequence results in the original sequence */\n  lemma LemmaZipOfUnzip<A,B>(xs: seq<(A,B)>)\n    ensures Zip(Unzip(xs).0, Unzip(xs).1) == xs\n  {\n  }\n\n  /**********************************************************\n   *\n   *  Extrema in Sequences\n   *\n   ***********************************************************/\n\n  /* Returns the maximum integer value in a non-empty sequence of integers. */\n  function {:opaque} Max(xs: seq<int>): int\n    requires 0 < |xs|\n    ensures forall k {:trigger k in xs} :: k in xs ==> Max(xs) >= k\n    ensures Max(xs) in xs\n  {\n    assert xs == [xs[0]] + xs[1..];\n    if |xs| == 1 then xs[0] else Math.Max(xs[0], Max(xs[1..]))\n  }\n\n  /* The maximum of the concatenation of two non-empty sequences is greater than or \n     equal to the maxima of its two non-empty subsequences. */\n  lemma LemmaMaxOfConcat(xs: seq<int>, ys: seq<int>)\n    requires 0 < |xs| && 0 < |ys|\n    ensures Max(xs+ys) >= Max(xs)\n    ensures Max(xs+ys) >= Max(ys)\n    ensures forall i {:trigger i in [Max(xs + ys)]} :: i in xs + ys ==> Max(xs + ys) >= i\n  {\n    reveal Max();\n    if |xs| == 1 {\n    } else {\n      assert xs[1..] + ys == (xs + ys)[1..];\n      LemmaMaxOfConcat(xs[1..], ys);\n    }\n  }\n\n  /* Returns the minimum integer value in a non-empty sequence of integers. */\n  function {:opaque} Min(xs: seq<int>): int\n    requires 0 < |xs|\n    ensures forall k {:trigger k in xs} :: k in xs ==> Min(xs) <= k\n    ensures Min(xs) in xs\n  {\n    assert xs == [xs[0]] + xs[1..];\n    if |xs| == 1 then xs[0] else Math.Min(xs[0], Min(xs[1..]))\n  }\n\n  /* The minimum of the concatenation of two non-empty sequences is \n     less than or equal to the minima of its two non-empty subsequences. */\n  lemma LemmaMinOfConcat(xs: seq<int>, ys: seq<int>)\n    requires 0 < |xs| && 0 < |ys|\n    ensures Min(xs+ys) <= Min(xs)\n    ensures Min(xs+ys) <= Min(ys)\n    ensures forall i {:trigger i in xs + ys} :: i in xs + ys ==> Min(xs + ys) <= i\n  {\n    reveal Min();\n    if |xs| == 1 {\n    } else {\n      assert xs[1..] + ys == (xs + ys)[1..];\n      LemmaMinOfConcat(xs[1..], ys);\n    }\n  }\n\n  /* The maximum element in a non-empty sequence is greater than or equal to\n     the maxima of its non-empty subsequences. */\n  lemma LemmaSubseqMax(xs: seq<int>, from: nat, to: nat)\n    requires from < to <= |xs|\n    ensures Max(xs[from..to]) <= Max(xs)\n  {\n    var subseq := xs[from..to];\n    if Max(subseq) > Max(xs) {\n      var k :| 0 <= k < |subseq| && subseq[k] == Max(subseq);\n      assert xs[seq(|subseq|, i requires 0 <= i < |subseq| => i + from)[k]] in xs;\n      assert false;\n    }\n  }\n\n  /* The minimum element of a non-empty sequence is less than or equal \n     to the minima of its non-empty subsequences. */\n  lemma LemmaSubseqMin(xs: seq<int>, from: nat, to: nat)\n    requires from < to <= |xs|\n    ensures Min(xs[from..to]) >= Min(xs)\n  {\n    var subseq := xs[from..to];\n    if Min(subseq) < Min(xs) {\n      var k :| 0 <= k < |subseq| && subseq[k] == Min(subseq);\n      assert xs[seq(|subseq|, i requires 0 <= i < |subseq| => i + from)[k]] in xs;\n    }\n  }\n\n  /**********************************************************\n   *\n   *  Sequences of Sequences\n   *\n   ***********************************************************/\n\n  /* Flattens a sequence of sequences into a single sequence by concatenating \n     subsequences, starting from the first element. */\n  function Flatten<T>(xs: seq<seq<T>>): seq<T>\n    decreases |xs|\n  {\n    if |xs| == 0 then []\n    else xs[0] + Flatten(xs[1..])\n  }\n\n  /* Flattening sequences of sequences is distributive over concatenation. That is, concatenating\n     the flattening of two sequences of sequences is the same as flattening the \n     concatenation of two sequences of sequences. */\n  lemma LemmaFlattenConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)\n    ensures Flatten(xs + ys) == Flatten(xs) + Flatten(ys)\n  {\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      calc == {\n        Flatten(xs + ys);\n        { assert (xs + ys)[0] == xs[0];  assert (xs + ys)[1..] == xs[1..] + ys; }\n        xs[0] + Flatten(xs[1..] + ys);\n        xs[0] + Flatten(xs[1..]) + Flatten(ys);\n        Flatten(xs) + Flatten(ys);\n      }\n    }\n  }\n\n  /* Flattens a sequence of sequences into a single sequence by concatenating \n     subsequences in reverse order, i.e. starting from the last element. */\n  function FlattenReverse<T>(xs: seq<seq<T>>): seq<T>\n    decreases |xs|\n  {\n    if |xs| == 0 then []\n    else FlattenReverse(DropLast(xs)) + Last(xs)\n  }\n\n  /* Flattening sequences of sequences in reverse order is distributive over concatentation. \n     That is, concatenating the flattening of two sequences of sequences in reverse \n     order is the same as flattening the concatenation of two sequences of sequences\n     in reverse order. */\n  lemma LemmaFlattenReverseConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)\n    ensures FlattenReverse(xs + ys) == FlattenReverse(xs) + FlattenReverse(ys)\n  {\n    if |ys| == 0 {\n      assert FlattenReverse(ys) == [];\n      assert xs + ys == xs;\n    } else {\n      calc == {\n        FlattenReverse(xs + ys);\n        { assert Last(xs + ys) == Last(ys);  assert DropLast(xs + ys) == xs + DropLast(ys); }\n        FlattenReverse(xs + DropLast(ys)) + Last(ys);\n        FlattenReverse(xs) + FlattenReverse(DropLast(ys)) + Last(ys);\n        FlattenReverse(xs) + FlattenReverse(ys);\n      }\n    }\n  }\n\n  /* Flattening sequences of sequences in order (starting from the beginning)\n     and in reverse order (starting from the end) results in the same sequence. */\n  lemma LemmaFlattenAndFlattenReverseAreEquivalent<T>(xs: seq<seq<T>>)\n    ensures Flatten(xs) == FlattenReverse(xs)\n  {\n    if |xs| == 0 {\n    } else {\n      calc == {\n        FlattenReverse(xs);\n        FlattenReverse(DropLast(xs)) + Last(xs);\n        { LemmaFlattenAndFlattenReverseAreEquivalent(DropLast(xs)); }\n        Flatten(DropLast(xs)) + Last(xs);\n        Flatten(DropLast(xs)) + Flatten([Last(xs)]);\n        { LemmaFlattenConcat(DropLast(xs), [Last(xs)]);\n          assert xs == DropLast(xs) + [Last(xs)]; }\n        Flatten(xs);\n      }\n    }\n  }\n\n  /* The length of a flattened sequence of sequences xs is greater than or \n     equal to any of the lengths of the elements of xs.  */\n  lemma LemmaFlattenLengthGeSingleElementLength<T>(xs: seq<seq<T>>, i: int)\n    requires 0 <= i < |xs|\n    ensures |FlattenReverse(xs)| >= |xs[i]|\n  {\n    if i < |xs| - 1 {\n      LemmaFlattenLengthGeSingleElementLength(xs[..|xs|-1], i);\n    }\n  }\n\n  /* The length of a flattened sequence of sequences xs is less than or equal \n     to the length of xs multiplied by a number not smaller than the length of the \n     longest sequence in xs. */\n  lemma LemmaFlattenLengthLeMul<T>(xs: seq<seq<T>>, j: int)\n    requires forall i {:trigger xs[i]} | 0 <= i < |xs| :: |xs[i]| <= j\n    ensures |FlattenReverse(xs)| <= |xs| * j\n  {\n    if |xs| == 0 {\n    } else {\n      LemmaFlattenLengthLeMul(xs[..|xs|-1], j);\n      assert |FlattenReverse(xs[..|xs|-1])| <= (|xs|-1) * j;\n    }\n  }\n\n\n  /**********************************************************\n   *\n   *  Higher-Order Sequence Functions\n   *\n   ***********************************************************/\n\n  /* Returns the sequence one obtains by applying a function to every element \n     of a sequence. */\n  function {:opaque} Map<T,R>(f: (T ~> R), xs: seq<T>): (result: seq<R>)\n    requires forall i {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])\n    ensures |result| == |xs|\n    ensures forall i {:trigger result[i]}:: 0 <= i < |xs| ==> result[i] == f(xs[i]);\n    reads set i, o {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]):: o\n  {\n    if |xs| == 0 then []\n    else [f(xs[0])] + Map(f, xs[1..])\n  }\n\n  /* Applies a function to every element of a sequence, returning a Result value (which is a \n     failure-compatible type). Returns either a failure, or, if successful at every element, \n     the transformed sequence.  */\n  function {:opaque} MapWithResult<T, R, E>(f: (T ~> Result<R,E>), xs: seq<T>): (result: Result<seq<R>, E>)\n    requires forall i :: 0 <= i < |xs| ==> f.requires(xs[i])\n    ensures result.Success? ==>\n              && |result.value| == |xs|\n              && (forall i :: 0 <= i < |xs| ==>\n                                && f(xs[i]).Success?\n                                && result.value[i] == f(xs[i]).value)\n    reads set i, o | 0 <= i < |xs| && o in f.reads(xs[i]) :: o\n  {\n    if |xs| == 0 then Success([])\n    else\n      var head :- f(xs[0]);\n      var tail :- MapWithResult(f, xs[1..]);\n      Success([head] + tail)\n  }\n\n  /* Applying a function to a sequence  is distributive over concatenation. That is, concatenating \n     two sequences and then applying Map is the same as applying Map to each sequence separately, \n     and then concatenating the two resulting sequences. */\n  lemma {:opaque} LemmaMapDistributesOverConcat<T,R>(f: (T ~> R), xs: seq<T>, ys: seq<T>)\n    requires forall i {:trigger xs[i]}:: 0 <= i < |xs| ==> f.requires(xs[i])\n    requires forall j {:trigger ys[j]}:: 0 <= j < |ys| ==> f.requires(ys[j])\n    ensures Map(f, xs + ys) == Map(f, xs) + Map(f, ys)\n  {\n    reveal Map();\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      calc {\n        Map(f, xs + ys);\n        { assert (xs + ys)[0] == xs[0]; assert (xs + ys)[1..] == xs[1..] + ys; }\n        Map(f, [xs[0]]) + Map(f, xs[1..] + ys);\n        Map(f, [xs[0]]) + Map(f, xs[1..]) + Map(f, ys);\n        {assert [(xs + ys)[0]] + xs[1..] + ys == xs + ys;}\n        Map(f, xs) + Map(f, ys);\n      }\n    }\n  }\n\n  /* Returns the subsequence consisting of those elements of a sequence that satisfy a given \n     predicate. */\n  function {:opaque} Filter<T>(f: (T ~> bool), xs: seq<T>): (result: seq<T>)\n    requires forall i :: 0 <= i < |xs| ==> f.requires(xs[i])\n    ensures |result| <= |xs|\n    ensures forall i: nat {:trigger result[i]} :: i < |result| && f.requires(result[i]) ==> f(result[i])\n    reads set i, o | 0 <= i < |xs| && o in f.reads(xs[i]) :: o\n  {\n    if |xs| == 0 then []\n    else (if f(xs[0]) then [xs[0]] else []) + Filter(f, xs[1..])\n  }\n\n  /* Filtering a sequence is distributive over concatenation. That is, concatenating two sequences \n     and then using \"Filter\" is the same as using \"Filter\" on each sequence separately, and then \n     concatenating the two resulting sequences. */\n  lemma {:opaque} LemmaFilterDistributesOverConcat<T(!new)>(f: (T ~> bool), xs: seq<T>, ys: seq<T>)\n    requires forall i {:trigger xs[i]}:: 0 <= i < |xs| ==> f.requires(xs[i])\n    requires forall j {:trigger ys[j]}:: 0 <= j < |ys| ==> f.requires(ys[j])\n    ensures Filter(f, xs + ys) == Filter(f, xs) + Filter(f, ys)\n  {\n    reveal Filter();\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      calc {\n        Filter(f, xs + ys);\n        { assert {:split_here} (xs + ys)[0] == xs[0]; assert (xs + ys)[1..] == xs[1..] + ys; }\n        Filter(f, [xs[0]]) + Filter(f, xs[1..] + ys);\n        { assert Filter(f, xs[1..] + ys) == Filter(f, xs[1..]) + Filter(f, ys); }\n        Filter(f, [xs[0]]) + (Filter(f, xs[1..]) + Filter(f, ys));\n        { assert {:split_here} [(xs + ys)[0]] + (xs[1..] + ys) == xs + ys; }\n        Filter(f, xs) + Filter(f, ys);\n      }\n    }\n  }\n\n  /* Folds a sequence xs from the left (the beginning), by repeatedly acting on the accumulator\n     init via the function f. */\n  function {:opaque} FoldLeft<A,T>(f: (A, T) -> A, init: A, xs: seq<T>): A\n  {\n    if |xs| == 0 then init\n    else FoldLeft(f, f(init, xs[0]), xs[1..])\n  }\n\n  /* Folding to the left is distributive over concatenation. That is, concatenating two \n     sequences and then folding them to the left, is the same as folding to the left the \n     first sequence and using the result to fold to the left the second sequence. */\n  lemma {:opaque} LemmaFoldLeftDistributesOverConcat<A,T>(f: (A, T) -> A, init: A, xs: seq<T>, ys: seq<T>)\n    requires 0 <= |xs + ys|\n    ensures FoldLeft(f, init, xs + ys) == FoldLeft(f, FoldLeft(f, init, xs), ys)\n  {\n    reveal FoldLeft();\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      assert |xs| >= 1;\n      assert ([xs[0]] + xs[1..] + ys)[0] == xs[0];\n      calc {\n        FoldLeft(f, FoldLeft(f, init, xs), ys);\n        FoldLeft(f, FoldLeft(f, f(init, xs[0]), xs[1..]), ys);\n        { LemmaFoldLeftDistributesOverConcat(f, f(init, xs[0]), xs[1..], ys); }\n        FoldLeft(f, f(init, xs[0]), xs[1..] + ys);\n        { assert (xs + ys)[0] == xs[0];\n          assert (xs + ys)[1..] == xs[1..] + ys; }\n        FoldLeft(f, init, xs + ys);\n      }\n    }\n  }\n\n  /* Is true, if inv is an invariant under stp, which is a relational \n     version of the function f passed to fold. */\n  ghost predicate InvFoldLeft<A(!new),B(!new)>(inv: (B, seq<A>) -> bool,\n                                               stp: (B, A, B) -> bool)\n  {\n    forall x: A, xs: seq<A>, b: B, b': B ::\n      inv(b, [x] + xs) && stp(b, x, b') ==> inv(b', xs)\n  }\n\n  /* inv(b, xs) ==> inv(FoldLeft(f, b, xs), []). */\n  lemma LemmaInvFoldLeft<A,B>(inv: (B, seq<A>) -> bool,\n                              stp: (B, A, B) -> bool,\n                              f: (B, A) -> B,\n                              b: B,\n                              xs: seq<A>)\n    requires InvFoldLeft(inv, stp)\n    requires forall b, a :: stp(b, a, f(b, a))\n    requires inv(b, xs)\n    ensures inv(FoldLeft(f, b, xs), [])\n  {\n    reveal FoldLeft();\n    if xs == [] {\n    } else {\n      assert [xs[0]] + xs[1..] == xs;\n      LemmaInvFoldLeft(inv, stp, f, f(b, xs[0]), xs[1..]);\n    }\n  }\n\n  /* Folds a sequence xs from the right (the end), by acting on the accumulator init via the \n     function f. */\n  function {:opaque} FoldRight<A,T>(f: (T, A) -> A, xs: seq<T>, init: A): A\n  {\n    if |xs| == 0 then init\n    else f(xs[0], FoldRight(f, xs[1..], init))\n  }\n\n  /* Folding to the right is (contravariantly) distributive over concatenation. That is, concatenating\n     two sequences and then folding them to the right, is the same as folding to the right \n     the second sequence and using the result to fold to the right the first sequence. */\n  lemma {:opaque} LemmaFoldRightDistributesOverConcat<A,T>(f: (T, A) -> A, init: A, xs: seq<T>, ys: seq<T>)\n    requires 0 <= |xs + ys|\n    ensures FoldRight(f, xs + ys, init) == FoldRight(f, xs, FoldRight(f, ys, init))\n  {\n    reveal FoldRight();\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      calc {\n        FoldRight(f, xs, FoldRight(f, ys, init));\n        f(xs[0], FoldRight(f, xs[1..], FoldRight(f, ys, init)));\n        f(xs[0], FoldRight(f, xs[1..] + ys, init));\n        { assert (xs + ys)[0] == xs[0];\n          assert (xs +ys)[1..] == xs[1..] + ys; }\n        FoldRight(f, xs + ys, init);\n      }\n    }\n  }\n\n  /* Is true, if inv is an invariant under stp, which is a relational version\n     of the function f passed to fold. */\n  ghost predicate InvFoldRight<A(!new),B(!new)>(inv: (seq<A>, B) -> bool,\n                                                stp: (A, B, B) -> bool)\n  {\n    forall x: A, xs: seq<A>, b: B, b': B ::\n      inv(xs, b) && stp(x, b, b') ==> inv(([x] + xs), b')\n  }\n\n  /* inv([], b) ==> inv(xs, FoldRight(f, xs, b)) */\n  lemma LemmaInvFoldRight<A,B>(inv: (seq<A>, B) -> bool,\n                               stp: (A, B, B) -> bool,\n                               f: (A, B) -> B,\n                               b: B,\n                               xs: seq<A>)\n    requires InvFoldRight(inv, stp)\n    requires forall a, b :: stp(a, b, f(a, b))\n    requires inv([], b)\n    ensures inv(xs, FoldRight(f, xs, b))\n  {\n    reveal FoldRight();\n    if xs == [] {\n    } else {\n      assert [xs[0]] + xs[1..] == xs;\n    }\n  }\n\n\n  /**********************************************************\n   *\n   *  Sets to Ordered Sequences\n   *\n   ***********************************************************/\n\n  /* Converts a set to a sequence (ghost). */\n  ghost function SetToSeqSpec<T>(s: set<T>): (xs: seq<T>)\n    ensures multiset(s) == multiset(xs)\n  {\n    if s == {} then [] else var x :| x in s; [x] + SetToSeqSpec(s - {x})\n  }\n\n  /* Converts a set to a sequence (compiled). */\n  method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)\n    ensures multiset(s) == multiset(xs)\n  {\n    xs := [];\n    var left: set<T> := s;\n    while left != {}\n      invariant multiset(left) + multiset(xs) == multiset(s)\n    {\n      var x :| x in left;\n      left := left - {x};\n      xs := xs + [x];\n    }\n  }\n\n  /* Proves that any two sequences that are sorted by a total order and that have the same elements are equal. */\n  lemma SortedUnique<T>(xs: seq<T>, ys: seq<T>, R: (T, T) -> bool)\n    requires SortedBy(xs, R)\n    requires SortedBy(ys, R)\n    requires TotalOrdering(R)\n    requires multiset(xs) == multiset(ys)\n    ensures xs == ys\n  {\n    assert |xs| == |multiset(xs)| == |multiset(ys)| == |ys|;\n    if xs == [] || ys == [] {\n    } else {\n      assert xs == [xs[0]] + xs[1..];\n      assert ys == [ys[0]] + ys[1..];\n      assert multiset(xs[1..]) == multiset(xs) - multiset{xs[0]};\n      assert multiset(ys[1..]) == multiset(ys) - multiset{ys[0]};\n      assert multiset(xs[1..]) == multiset(ys[1..]);\n      SortedUnique(xs[1..], ys[1..], R);\n    }\n  }\n\n  /* Converts a set to a sequence that is ordered w.r.t. a given total order. */\n  function SetToSortedSeq<T>(s: set<T>, R: (T, T) -> bool): (xs: seq<T>)\n    requires TotalOrdering(R)\n    ensures multiset(s) == multiset(xs)\n    ensures SortedBy(xs, R)\n  {\n    MergeSortBy(SetToSeqSpec(s), R)\n  } by method {\n    xs := SetToSeq(s);\n    xs := MergeSortBy(xs, R);\n    SortedUnique(xs, SetToSortedSeq(s, R), R);\n  }\n\n\n  /****************************\n   **  Sorting sequences\n   ***************************** */\n\n  //Splits a sequence in two, sorts the two subsequences (recursively), and merges the two sorted sequences using `MergeSortedWith`\n  function MergeSortBy<T>(a: seq<T>, lessThanOrEq: (T, T) -> bool): (result :seq<T>)\n    requires TotalOrdering(lessThanOrEq)\n    ensures multiset(a) == multiset(result)\n    ensures SortedBy(result, lessThanOrEq)\n  {\n    if |a| <= 1 then\n      a\n    else\n      var splitIndex := |a| / 2;\n      var left, right := a[..splitIndex], a[splitIndex..];\n\n      assert a == left + right;\n\n      var leftSorted := MergeSortBy(left, lessThanOrEq);\n      var rightSorted := MergeSortBy(right, lessThanOrEq);\n\n      MergeSortedWith(leftSorted, rightSorted, lessThanOrEq)\n  }\n\n  ghost predicate SortedBy<T>(a: seq<T>, lessThan: (T, T) -> bool) {\n    forall i, j | 0 <= i < j < |a| :: lessThan(a[i], a[j])\n  }\n\n  /* An element in an ordered set is called minimal, if it is less than every element of the set. */\n  ghost predicate IsMinimum<T>(R: (T, T) -> bool, m: T, s: set<T>) {\n    m in s && forall y: T | y in s :: R(m, y)\n  }\n\n  /* Any totally ordered set contains a unique minimal element. */\n  lemma LemmaUniqueMinimum<T(!new)>(R: (T, T) -> bool, s: set<T>) returns (m: T)\n    requires |s| > 0 && TotalOrdering(R)\n    ensures IsMinimum(R, m, s) && (forall n: T | IsMinimum(R, n, s) :: m == n)\n  {\n    var x :| x in s;\n    if s == {x} {\n      m := x;\n    } else {\n      var m' := LemmaUniqueMinimum(R, s - {x});\n      if\n      case R(m', x) => m := m';\n      case R(x, m') => m := x;\n    }\n  }\n\n  lemma LemmaNewFirstElementStillSortedBy<T>(x: T, s: seq<T>, lessThan: (T, T) -> bool)\n    requires SortedBy(s, lessThan)\n    requires |s| == 0 || lessThan(x, s[0])\n    requires TotalOrdering(lessThan)\n    ensures SortedBy([x] + s, lessThan)\n  {}\n\n\n  // Helper function for MergeSortBy\n  function {:tailrecursion} MergeSortedWith<T>(left: seq<T>, right: seq<T>, lessThanOrEq: (T, T) -> bool) : (result :seq<T>)\n    requires SortedBy(left, lessThanOrEq)\n    requires SortedBy(right, lessThanOrEq)\n    requires TotalOrdering(lessThanOrEq)\n    ensures multiset(left + right) == multiset(result)\n    ensures SortedBy(result, lessThanOrEq)\n  {\n    if |left| == 0 then\n      right\n    else if |right| == 0 then\n      left\n    else if lessThanOrEq(left[0], right[0]) then\n      LemmaNewFirstElementStillSortedBy(left[0], MergeSortedWith(left[1..], right, lessThanOrEq), lessThanOrEq);\n      assert left == [left[0]] + left[1..];\n\n      [left[0]] + MergeSortedWith(left[1..], right, lessThanOrEq)\n\n    else\n      LemmaNewFirstElementStillSortedBy(right[0], MergeSortedWith(left, right[1..], lessThanOrEq), lessThanOrEq);\n      assert right == [right[0]] + right[1..];\n\n      [right[0]] + MergeSortedWith(left, right[1..], lessThanOrEq)\n  }\n}\n"}
{"file": "../libraries/src/dafny/Collections/LittleEndianNat.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) 2020 Secure Foundations Lab\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* Little endian interpretation of a sequence of numbers with a given base. The\nfirst element of a sequence is the least significant position; the last\nelement is the most significant position. */\n\ninclude \"../NonlinearArithmetic/DivMod.dfy\"\ninclude \"../NonlinearArithmetic/Multiply.dfy\"\ninclude \"../NonlinearArithmetic/Power.dfy\"\ninclude \"Seqs.dfy\"\n\nabstract module {:options \"-functionSyntax:4\"} Dafny.Collections.LittleEndianNat {\n\n  import opened DivMod\n  import opened Multiply\n  import opened Power\n  import opened Seq\n\n  function BASE(): nat\n    ensures BASE() > 1\n\n  type uint = i: int | 0 <= i < BASE()\n\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // ToNat definition and lemmas\n  //\n  //////////////////////////////////////////////////////////////////////////////\n\n  /* Converts a sequence to a nat beginning with the least significant position. */\n  function {:opaque} ToNatRight(xs: seq<uint>): nat\n  {\n    if |xs| == 0 then 0\n    else\n      LemmaMulNonnegativeAuto();\n      ToNatRight(DropFirst(xs)) * BASE() + First(xs)\n  }\n\n  /* Converts a sequence to a nat beginning with the most significant position. */\n  function {:opaque} ToNatLeft(xs: seq<uint>): nat\n  {\n    if |xs| == 0 then 0\n    else\n      LemmaPowPositiveAuto();\n      LemmaMulNonnegativeAuto();\n      ToNatLeft(DropLast(xs)) + Last(xs) * Pow(BASE(), |xs| - 1)\n  }\n\n  /* Given the same sequence, ToNatRight and ToNatLeft return the same nat. */\n  lemma {:vcs_split_on_every_assert} LemmaToNatLeftEqToNatRight(xs: seq<uint>)\n    ensures ToNatRight(xs) == ToNatLeft(xs)\n  {\n    reveal ToNatRight();\n    reveal ToNatLeft();\n    if xs == [] {\n    } else {\n      if DropLast(xs) == [] {\n        calc {\n          ToNatLeft(xs);\n          Last(xs) * Pow(BASE(), |xs| - 1);\n          { reveal Pow(); }\n          Last(xs);\n          First(xs);\n          { assert ToNatRight(DropFirst(xs)) == 0; }\n          ToNatRight(xs);\n        }\n      } else {\n        calc {\n          ToNatLeft(xs);\n          ToNatLeft(DropLast(xs)) + Last(xs) * Pow(BASE(), |xs| - 1);\n          { LemmaToNatLeftEqToNatRight(DropLast(xs)); }\n          ToNatRight(DropLast(xs)) + Last(xs) * Pow(BASE(), |xs| - 1);\n          ToNatRight(DropFirst(DropLast(xs))) * BASE() + First(xs) + Last(xs)\n          * Pow(BASE(), |xs| - 1);\n          { LemmaToNatLeftEqToNatRight(DropFirst(DropLast(xs))); }\n          ToNatLeft(DropFirst(DropLast(xs))) * BASE() + First(xs) + Last(xs)\n          * Pow(BASE(), |xs| - 1);\n          {\n            assert DropFirst(DropLast(xs)) == DropLast(DropFirst(xs));\n            reveal Pow();\n            LemmaMulProperties();\n          }\n          ToNatLeft(DropLast(DropFirst(xs))) * BASE() + First(xs) + Last(xs)\n          * Pow(BASE(), |xs| - 2) * BASE();\n          { LemmaMulIsDistributiveAddOtherWayAuto(); }\n          ToNatLeft(DropFirst(xs)) * BASE() + First(xs);\n          { LemmaToNatLeftEqToNatRight(DropFirst(xs)); }\n          ToNatRight(xs);\n        }\n      }\n    }\n  }\n\n  lemma LemmaToNatLeftEqToNatRightAuto()\n    ensures forall xs: seq<uint> :: ToNatRight(xs) == ToNatLeft(xs)\n  {\n    reveal ToNatRight();\n    reveal ToNatLeft();\n    forall xs: seq<uint>\n      ensures ToNatRight(xs) == ToNatLeft(xs)\n    {\n      LemmaToNatLeftEqToNatRight(xs);\n    }\n  }\n\n  /* The nat representation of a sequence of length 1 is its first (and only)\n  position. */\n  lemma LemmaSeqLen1(xs: seq<uint>)\n    requires |xs| == 1\n    ensures ToNatRight(xs) == First(xs)\n  {\n    reveal ToNatRight();\n  }\n\n  /* The nat representation of a sequence of length 2 is sum of its first\n  position and the product of its second position and BASE(). */\n  lemma LemmaSeqLen2(xs: seq<uint>)\n    requires |xs| == 2\n    ensures ToNatRight(xs) == First(xs) + xs[1] * BASE()\n  {\n    reveal ToNatRight();\n    LemmaSeqLen1(DropLast(xs));\n  }\n\n  /* Appending a zero does not change the nat representation of the sequence. */\n  lemma LemmaSeqAppendZero(xs: seq<uint>)\n    ensures ToNatRight(xs + [0]) == ToNatRight(xs)\n  {\n    reveal ToNatLeft();\n    LemmaToNatLeftEqToNatRightAuto();\n    calc {\n      ToNatRight(xs + [0]);\n      ToNatLeft(xs + [0]);\n      ToNatLeft(xs) + 0 * Pow(BASE(), |xs|);\n      { LemmaMulBasicsAuto(); }\n      ToNatLeft(xs);\n      ToNatRight(xs);\n    }\n  }\n\n  /* The nat representation of a sequence is bounded by BASE() to the power of\n  the sequence length. */\n  lemma LemmaSeqNatBound(xs: seq<uint>)\n    ensures ToNatRight(xs) < Pow(BASE(), |xs|)\n  {\n    reveal Pow();\n    if |xs| == 0 {\n      reveal ToNatRight();\n    } else {\n      var len' := |xs| - 1;\n      var pow := Pow(BASE(), len');\n      calc {\n        ToNatRight(xs);\n         { LemmaToNatLeftEqToNatRight(xs); }\n        ToNatLeft(xs);\n         { reveal ToNatLeft(); }\n        ToNatLeft(DropLast(xs)) + Last(xs) * pow;\n      <  {\n           LemmaToNatLeftEqToNatRight(DropLast(xs));\n           LemmaSeqNatBound(DropLast(xs));\n         }\n        pow + Last(xs) * pow;\n      <= {\n           LemmaPowPositiveAuto();\n           LemmaMulInequalityAuto();\n         }\n        pow + (BASE() - 1) * pow;\n         { LemmaMulIsDistributiveAuto(); }\n        Pow(BASE(), len' + 1);\n      }\n    }\n  }\n\n  /* The nat representation of a sequence can be calculated using the nat\n  representation of its prefix. */\n  lemma {:vcs_split_on_every_assert} LemmaSeqPrefix(xs: seq<uint>, i: nat)\n    requires 0 <= i <= |xs|\n    ensures ToNatRight(xs[..i]) + ToNatRight(xs[i..]) * Pow(BASE(), i) == ToNatRight(xs)\n  {\n    reveal ToNatRight();\n    reveal Pow();\n    if i == 1 {\n      assert ToNatRight(xs[..1]) == First(xs);\n    } else if i > 1 {\n      calc {\n        ToNatRight(xs[..i]) + ToNatRight(xs[i..]) * Pow(BASE(), i);\n        ToNatRight(DropFirst(xs[..i])) * BASE() + First(xs) + ToNatRight(xs[i..]) * Pow(BASE(), i);\n        {\n          assert DropFirst(xs[..i]) == DropFirst(xs)[..i-1];\n          LemmaMulProperties();\n        }\n        ToNatRight(DropFirst(xs)[..i-1]) * BASE() + First(xs) + (ToNatRight(xs[i..]) * Pow(BASE(), i - 1)) * BASE();\n        { LemmaMulIsDistributiveAddOtherWayAuto(); }\n        (ToNatRight(DropFirst(xs)[..i-1]) + ToNatRight(DropFirst(xs)[i-1..]) * Pow(BASE(), i - 1)) * BASE() + First(xs);\n        { LemmaSeqPrefix(DropFirst(xs), i - 1); }\n        ToNatRight(xs);\n      }\n    }\n  }\n\n  /* If there is an inequality between the most significant positions of two\n  sequences, then there is an inequality between the nat representations of\n  those sequences. Helper lemma for LemmaSeqNeq. */\n  lemma LemmaSeqMswInequality(xs: seq<uint>, ys: seq<uint>)\n    requires |xs| == |ys| > 0\n    requires Last(xs) < Last(ys)\n    ensures ToNatRight(xs) < ToNatRight(ys)\n  {\n    reveal ToNatLeft();\n    LemmaToNatLeftEqToNatRightAuto();\n    var len' := |xs| - 1;\n    calc {\n      ToNatRight(xs);\n      ToNatLeft(xs);\n    <  { LemmaSeqNatBound(DropLast(xs)); }\n      Pow(BASE(), len') + Last(xs) * Pow(BASE(), len');\n    == { LemmaMulIsDistributiveAuto(); }\n      (1 + Last(xs)) * Pow(BASE(), len');\n    <= { LemmaPowPositiveAuto(); LemmaMulInequalityAuto(); }\n      ToNatLeft(ys);\n      ToNatRight(ys);\n    }\n  }\n\n  /* Two sequences do not have the same nat representations if their prefixes\n  do not have the same nat representations. Helper lemma for LemmaSeqNeq. */\n  lemma LemmaSeqPrefixNeq(xs: seq<uint>, ys: seq<uint>, i: nat)\n    requires 0 <= i <= |xs| == |ys|\n    requires ToNatRight(xs[..i]) != ToNatRight(ys[..i])\n    ensures ToNatRight(xs) != ToNatRight(ys)\n    decreases |xs| - i\n  {\n    if i == |xs| {\n      assert xs[..i] == xs;\n      assert ys[..i] == ys;\n    } else {\n      if xs[i] == ys[i] {\n        reveal ToNatLeft();\n        assert DropLast(xs[..i+1]) == xs[..i];\n        assert DropLast(ys[..i+1]) == ys[..i];\n\n        LemmaToNatLeftEqToNatRightAuto();\n        assert ToNatRight(xs[..i+1]) == ToNatLeft(xs[..i+1]);\n      } else if xs[i] < ys[i] {\n        LemmaSeqMswInequality(xs[..i+1], ys[..i+1]);\n      } else {\n        LemmaSeqMswInequality(ys[..i+1], xs[..i+1]);\n      }\n      reveal ToNatRight();\n      LemmaSeqPrefixNeq(xs, ys, i + 1);\n    }\n  }\n\n  /* If two sequences of the same length are not equal, their nat\n  representations are not equal. */\n  lemma LemmaSeqNeq(xs: seq<uint>, ys: seq<uint>)\n    requires |xs| == |ys|\n    requires xs != ys\n    ensures ToNatRight(xs) != ToNatRight(ys)\n  {\n    ghost var i: nat, n: nat := 0, |xs|;\n\n    while i < n\n      invariant 0 <= i < n\n      invariant xs[..i] == ys[..i]\n    {\n      if xs[i] != ys[i] {\n        break;\n      }\n      i := i + 1;\n    }\n    assert ToNatLeft(xs[..i]) == ToNatLeft(ys[..i]);\n\n    reveal ToNatLeft();\n    assert xs[..i+1][..i] == xs[..i];\n    assert ys[..i+1][..i] == ys[..i];\n    LemmaPowPositiveAuto();\n    LemmaMulStrictInequalityAuto();\n    assert ToNatLeft(xs[..i+1]) != ToNatLeft(ys[..i+1]);\n    LemmaToNatLeftEqToNatRightAuto();\n\n    LemmaSeqPrefixNeq(xs, ys, i+1);\n  }\n\n  /* If the nat representations of two sequences of the same length are equal\n  to each other, the sequences are the same. */\n  lemma LemmaSeqEq(xs: seq<uint>, ys: seq<uint>)\n    requires |xs| == |ys|\n    requires ToNatRight(xs) == ToNatRight(ys)\n    ensures xs == ys\n  {\n    calc ==> {\n      xs != ys;\n      { LemmaSeqNeq(xs, ys); }\n      ToNatRight(xs) != ToNatRight(ys);\n      false;\n    }\n  }\n\n  /* The nat representation of a sequence and its least significant position are\n  congruent. */\n  lemma LemmaSeqLswModEquivalence(xs: seq<uint>)\n    requires |xs| >= 1;\n    ensures IsModEquivalent(ToNatRight(xs), First(xs), BASE());\n  {\n    if |xs| == 1 {\n      LemmaSeqLen1(xs);\n      LemmaModEquivalenceAuto();\n    } else {\n      assert IsModEquivalent(ToNatRight(xs), First(xs), BASE()) by {\n        reveal ToNatRight();\n        calc ==> {\n          true;\n          { LemmaModEquivalence(ToNatRight(xs), ToNatRight(DropFirst(xs)) * BASE() + First(xs), BASE()); }\n          IsModEquivalent(ToNatRight(xs), ToNatRight(DropFirst(xs)) * BASE() + First(xs), BASE());\n          { LemmaModMultiplesBasicAuto(); }\n          IsModEquivalent(ToNatRight(xs), First(xs), BASE());\n        }\n      }\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // FromNat definition and lemmas\n  //\n  //////////////////////////////////////////////////////////////////////////////\n\n  /* Converts a nat to a sequence. */\n  function {:opaque} FromNat(n: nat): (xs: seq<uint>)\n  {\n    if n == 0 then []\n    else\n      LemmaDivBasicsAuto();\n      LemmaDivDecreasesAuto();\n      [n % BASE()] + FromNat(n / BASE())\n  }\n\n  /* Ensures length of the sequence generated by FromNat is less than len.\n  Helper lemma for FromNatWithLen. */\n  lemma LemmaFromNatLen(n: nat, len: nat)\n    requires Pow(BASE(), len) > n\n    ensures |FromNat(n)| <= len\n  {\n    reveal FromNat();\n    if n == 0 {\n    } else {\n      calc {\n        |FromNat(n)|;\n      == { LemmaDivBasicsAuto(); }\n        1 + |FromNat(n / BASE())|;\n      <= {\n           LemmaMultiplyDivideLtAuto();\n           LemmaDivDecreasesAuto();\n           reveal Pow();\n           LemmaFromNatLen(n / BASE(), len - 1);\n         }\n        len;\n      }\n    }\n  }\n\n  /* If we start with a nat, convert it to a sequence, and convert it back, we\n  get the same nat we started with. */\n  lemma LemmaNatSeqNat(n: nat)\n    ensures ToNatRight(FromNat(n)) == n\n    decreases n\n  {\n    reveal ToNatRight();\n    reveal FromNat();\n    if n == 0 {\n    } else {\n      calc {\n        ToNatRight(FromNat(n));\n        { LemmaDivBasicsAuto(); }\n        ToNatRight([n % BASE()] + FromNat(n / BASE()));\n        n % BASE() + ToNatRight(FromNat(n / BASE())) * BASE();\n        {\n          LemmaDivDecreasesAuto();\n          LemmaNatSeqNat(n / BASE());\n        }\n        n % BASE() + n / BASE() * BASE();\n        { LemmaFundamentalDivMod(n, BASE()); }\n        n;\n      }\n    }\n  }\n\n  /* Extends a sequence to a specified length. */\n  function {:opaque} SeqExtend(xs: seq<uint>, n: nat): (ys: seq<uint>)\n    requires |xs| <= n\n    ensures |ys| == n\n    ensures ToNatRight(ys) == ToNatRight(xs)\n    decreases n - |xs|\n  {\n    if |xs| >= n then xs else LemmaSeqAppendZero(xs); SeqExtend(xs + [0], n)\n  }\n\n  /* Extends a sequence to a length that is a multiple of n. */\n  function {:opaque} SeqExtendMultiple(xs: seq<uint>, n: nat): (ys: seq<uint>)\n    requires n > 0\n    ensures |ys| % n == 0\n    ensures ToNatRight(ys) == ToNatRight(xs)\n  {\n    var newLen := |xs| + n - (|xs| % n);\n    LemmaSubModNoopRight(|xs| + n, |xs|, n);\n    LemmaModBasicsAuto();\n    assert newLen % n == 0;\n\n    LemmaSeqNatBound(xs);\n    LemmaPowIncreasesAuto();\n    SeqExtend(xs, newLen)\n  }\n\n  /* Converts a nat to a sequence of a specified length. */\n  function {:opaque} FromNatWithLen(n: nat, len: nat): (xs: seq<uint>)\n    requires Pow(BASE(), len) > n\n    ensures |xs| == len\n    ensures ToNatRight(xs) == n\n  {\n    LemmaFromNatLen(n, len);\n    LemmaNatSeqNat(n);\n    SeqExtend(FromNat(n), len)\n  }\n\n  /* If the nat representation of a sequence is zero, then the sequence is a\n  sequence of zeros. */\n  lemma LemmaSeqZero(xs: seq<uint>)\n    requires ToNatRight(xs) == 0\n    ensures forall i :: 0 <= i < |xs| ==> xs[i] == 0\n  {\n    reveal ToNatRight();\n    if |xs| == 0 {\n    } else {\n      LemmaMulNonnegativeAuto();\n      assert First(xs) == 0;\n\n      LemmaMulNonzeroAuto();\n      LemmaSeqZero(DropFirst(xs));\n    }\n  }\n\n  /* Generates a sequence of zeros of a specified length. */\n  function {:opaque} SeqZero(len: nat): (xs: seq<uint>)\n    ensures |xs| == len\n    ensures forall i :: 0 <= i < |xs| ==> xs[i] == 0\n    ensures ToNatRight(xs) == 0\n  {\n    LemmaPowPositive(BASE(), len);\n    var xs := FromNatWithLen(0, len);\n    LemmaSeqZero(xs);\n    xs\n  }\n\n  /* If we start with a sequence, convert it to a nat, and convert it back to a\n  sequence with the same length as the original sequence, we get the same\n  sequence we started with. */\n  lemma LemmaSeqNatSeq(xs: seq<uint>)\n    ensures Pow(BASE(), |xs|) > ToNatRight(xs)\n    ensures FromNatWithLen(ToNatRight(xs), |xs|) == xs\n  {\n    reveal FromNat();\n    reveal ToNatRight();\n    LemmaSeqNatBound(xs);\n    if |xs| > 0 {\n      calc {\n        FromNatWithLen(ToNatRight(xs), |xs|) != xs;\n        { LemmaSeqNeq(FromNatWithLen(ToNatRight(xs), |xs|), xs); }\n        ToNatRight(FromNatWithLen(ToNatRight(xs), |xs|)) != ToNatRight(xs);\n        ToNatRight(xs) != ToNatRight(xs);\n        false;\n      }\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // Addition and subtraction\n  //\n  //////////////////////////////////////////////////////////////////////////////\n\n  /* Adds two sequences. */\n  function {:opaque} SeqAdd(xs: seq<uint>, ys: seq<uint>): (seq<uint>, nat)\n    requires |xs| == |ys|\n    ensures var (zs, cout) := SeqAdd(xs, ys);\n            |zs| == |xs| && 0 <= cout <= 1\n    decreases xs\n  {\n    if |xs| == 0 then ([], 0)\n    else\n      var (zs', cin) := SeqAdd(DropLast(xs), DropLast(ys));\n      var sum: int := Last(xs) + Last(ys) + cin;\n      var (sum_out, cout) := if sum < BASE() then (sum, 0)\n                             else (sum - BASE(), 1);\n      (zs' + [sum_out], cout)\n  }\n\n  /* SeqAdd returns the same value as converting the sequences to nats, then\n  adding them. */\n  lemma {:vcs_split_on_every_assert} LemmaSeqAdd(xs: seq<uint>, ys: seq<uint>, zs: seq<uint>, cout: nat)\n    requires |xs| == |ys|\n    requires SeqAdd(xs, ys) == (zs, cout)\n    ensures ToNatRight(xs) + ToNatRight(ys) == ToNatRight(zs) + cout * Pow(BASE(), |xs|)\n  {\n    reveal SeqAdd();\n    if |xs| == 0 {\n      reveal ToNatRight();\n    } else {\n      var pow := Pow(BASE(), |xs| - 1);\n      var (zs', cin) := SeqAdd(DropLast(xs), DropLast(ys));\n      var sum: int := Last(xs) + Last(ys) + cin;\n      var z := if sum < BASE() then sum else sum - BASE();\n      assert sum == z + cout * BASE();\n\n      reveal ToNatLeft();\n      LemmaToNatLeftEqToNatRightAuto();\n      calc {\n        ToNatRight(zs);\n        ToNatLeft(zs);\n        ToNatLeft(zs') + z * pow;\n        { LemmaSeqAdd(DropLast(xs), DropLast(ys), zs', cin); }\n        ToNatLeft(DropLast(xs)) + ToNatLeft(DropLast(ys)) - cin * pow + z * pow;\n        {\n          LemmaMulEquality(sum, z + cout * BASE(), pow);\n          assert sum * pow == (z + cout * BASE()) * pow;\n          LemmaMulIsDistributiveAuto();\n        }\n        ToNatLeft(xs) + ToNatLeft(ys) - cout * BASE() * pow;\n        {\n          LemmaMulIsAssociative(cout, BASE(), pow);\n          reveal Pow();\n        }\n        ToNatLeft(xs) + ToNatLeft(ys) - cout * Pow(BASE(), |xs|);\n        ToNatRight(xs) + ToNatRight(ys) - cout * Pow(BASE(), |xs|);\n      }\n    }\n  }\n\n  /* Subtracts two sequences. */\n  function {:opaque} SeqSub(xs: seq<uint>, ys: seq<uint>): (seq<uint>, nat)\n    requires |xs| == |ys|\n    ensures var (zs, cout) := SeqSub(xs, ys);\n            |zs| == |xs| && 0 <= cout <= 1\n    decreases xs\n  {\n    if |xs| == 0 then ([], 0)\n    else\n      var (zs, cin) := SeqSub(DropLast(xs), DropLast(ys));\n      var (diff_out, cout) := if Last(xs) >= Last(ys) + cin\n                              then (Last(xs) - Last(ys) - cin, 0)\n                              else (BASE() + Last(xs) - Last(ys) - cin, 1);\n      (zs + [diff_out], cout)\n  }\n\n  /* SeqSub returns the same value as converting the sequences to nats, then\n  subtracting them. */\n  lemma {:vcs_split_on_every_assert} LemmaSeqSub(xs: seq<uint>, ys: seq<uint>, zs: seq<uint>, cout: nat)\n    requires |xs| == |ys|\n    requires SeqSub(xs, ys) == (zs, cout)\n    ensures ToNatRight(xs) - ToNatRight(ys) + cout * Pow(BASE(), |xs|) == ToNatRight(zs)\n  {\n    reveal SeqSub();\n    if |xs| == 0 {\n      reveal ToNatRight();\n    } else {\n      var pow := Pow(BASE(), |xs| - 1);\n      var (zs', cin) := SeqSub(DropLast(xs), DropLast(ys));\n      var z := if Last(xs) >= Last(ys) + cin\n      then Last(xs) - Last(ys) - cin\n      else BASE() + Last(xs) - Last(ys) - cin;\n      assert cout * BASE() + Last(xs) - cin - Last(ys) == z;\n\n      reveal ToNatLeft();\n      LemmaToNatLeftEqToNatRightAuto();\n      calc {\n        ToNatRight(zs);\n        ToNatLeft(zs);\n        ToNatLeft(zs') + z * pow;\n        { LemmaSeqSub(DropLast(xs), DropLast(ys), zs', cin); }\n        ToNatLeft(DropLast(xs)) - ToNatLeft(DropLast(ys)) + cin * pow + z * pow;\n        {\n          LemmaMulEquality(cout * BASE() + Last(xs) - cin - Last(ys), z, pow);\n          assert pow * (cout * BASE() + Last(xs) - cin - Last(ys)) == pow * z;\n          LemmaMulIsDistributiveAuto();\n        }\n        ToNatLeft(xs) - ToNatLeft(ys) + cout * BASE() * pow;\n        {\n          LemmaMulIsAssociative(cout, BASE(), pow);\n          reveal Pow();\n        }\n        ToNatLeft(xs) - ToNatLeft(ys) + cout * Pow(BASE(), |xs|);\n        ToNatRight(xs) - ToNatRight(ys) + cout * Pow(BASE(), |xs|);\n      }\n    }\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/Collections/Imaps.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../Wrappers.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.Collections.Imaps {\n  import opened Wrappers\n\n  function Get<X, Y>(m: imap<X, Y>, x: X): Option<Y>\n  {\n    if x in m then Some(m[x]) else None\n  }\n\n  /* Remove all key-value pairs corresponding to the iset of keys provided. */\n  ghost function {:opaque} RemoveKeys<X, Y>(m: imap<X, Y>, xs: iset<X>): (m': imap<X, Y>)\n    ensures forall x {:trigger m'[x]} :: x in m && x !in xs ==> x in m' && m'[x] == m[x]\n    ensures forall x {:trigger x in m'} :: x in m' ==> x in m && x !in xs\n    ensures m'.Keys == m.Keys - xs\n  {\n    imap x | x in m && x !in xs :: m[x]\n  }\n\n  /* Remove a key-value pair. Returns unmodified imap if key is not found. */\n  ghost function {:opaque} RemoveKey<X, Y>(m: imap<X, Y>, x: X): (m': imap<X, Y>)\n    ensures m' == RemoveKeys(m, iset{x})\n    ensures forall x' {:trigger m'[x']} :: x' in m' ==> m'[x'] == m[x']\n  {\n    imap i | i in m && i != x :: m[i]\n  }\n\n  /* Keep all key-value pairs corresponding to the iset of keys provided. */\n  ghost function {:opaque} Restrict<X, Y>(m: imap<X, Y>, xs: iset<X>): (m': imap<X, Y>)\n    ensures m' == RemoveKeys(m, m.Keys - xs)\n  {\n    imap x | x in xs && x in m :: m[x]\n  }\n\n  /* True iff x maps to the same value or does not exist in m and m'. */\n  ghost predicate EqualOnKey<X, Y>(m: imap<X, Y>, m': imap<X, Y>, x: X)\n  {\n    (x !in m && x !in m') || (x in m && x in m' && m[x] == m'[x])\n  }\n\n  /* True iff m is a subset of m'. */\n  ghost predicate IsSubset<X, Y>(m: imap<X, Y>, m': imap<X, Y>)\n  {\n    && m.Keys <= m'.Keys\n    && forall x {:trigger EqualOnKey(m, m', x)}{:trigger x in m} :: x in m ==> EqualOnKey(m, m', x)\n  }\n\n  /* Union of two imaps. Does not require disjoint domains; on the intersection,\n  values from the second imap are chosen. */\n  ghost function {:opaque} Union<X, Y>(m: imap<X, Y>, m': imap<X, Y>): (r: imap<X, Y>)\n    ensures r.Keys == m.Keys + m'.Keys\n    ensures forall x {:trigger r[x]} :: x in m' ==> r[x] == m'[x]\n    ensures forall x {:trigger r[x]} :: x in m && x !in m' ==> r[x] == m[x]\n  {\n    m + m'\n  }\n\n  /* True iff an imap is injective. */\n  ghost predicate {:opaque} Injective<X, Y>(m: imap<X, Y>)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x != x' && x in m && x' in m ==> m[x] != m[x']\n  }\n\n  /* Swaps imap keys and values. Values are not required to be unique; no\n  promises on which key is chosen on the intersection. */\n  ghost function {:opaque} Invert<X, Y>(m: imap<X, Y>): imap<Y, X>\n  {\n    imap y | y in m.Values :: var x :| x in m.Keys && m[x] == y; x\n  }\n\n  /* Inverted maps are injective. */\n  lemma LemmaInvertIsInjective<X, Y>(m: imap<X, Y>)\n    ensures Injective(Invert(m))\n  {\n    reveal Injective();\n    reveal Invert();\n  }\n\n  /* True iff an imap contains all valid keys. */\n  ghost predicate {:opaque} Total<X(!new), Y>(m: imap<X, Y>)\n  {\n    forall i {:trigger m[i]}{:trigger i in m} :: i in m\n  }\n\n  /* True iff an imap is monotonic. */\n  ghost predicate {:opaque} Monotonic(m: imap<int, int>)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x in m && x' in m && x <= x' ==> m[x] <= m[x']\n  }\n\n  /* True iff an imap is monotonic. Only considers keys greater than or\n  equal to start. */\n  ghost predicate {:opaque} MonotonicFrom(m: imap<int, int>, start: int)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x in m && x' in m && start <= x <= x' ==> m[x] <= m[x']\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/Collections/Collections.dfy", "dafny": "// RUN: %verify \"%s\" > \"%t\"\n\nmodule Collections {\n\n}\n"}
{"file": "../libraries/src/dafny/Collections/Maps.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../Wrappers.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.Collections.Maps {\n  import opened Wrappers\n\n  function Get<X, Y>(m: map<X, Y>, x: X): Option<Y>\n  {\n    if x in m then Some(m[x]) else None\n  }\n\n  function {:opaque} ToImap<X, Y>(m: map<X, Y>): (m': imap<X, Y>)\n    ensures forall x {:trigger m'[x]} :: x in m ==> x in m' && m'[x] == m[x]\n    ensures forall x {:trigger x in m'} :: x in m' ==> x in m\n  {\n    imap x | x in m :: m[x]\n  }\n\n  /* Remove all key-value pairs corresponding to the set of keys provided. */\n  function {:opaque} RemoveKeys<X, Y>(m: map<X, Y>, xs: set<X>): (m': map<X, Y>)\n    ensures forall x {:trigger m'[x]} :: x in m && x !in xs ==> x in m' && m'[x] == m[x]\n    ensures forall x {:trigger x in m'} :: x in m' ==> x in m && x !in xs\n    ensures m'.Keys == m.Keys - xs\n  {\n    m - xs\n  }\n\n  /* Remove a key-value pair. Returns unmodified map if key is not found. */\n  function {:opaque} Remove<X, Y>(m: map<X, Y>, x: X): (m': map<X, Y>)\n    ensures m' == RemoveKeys(m, {x})\n    ensures |m'.Keys| <= |m.Keys|\n    ensures x in m ==> |m'| == |m| - 1\n    ensures x !in m ==> |m'| == |m|\n  {\n    var m' := map x' | x' in m && x' != x :: m[x'];\n    assert m'.Keys == m.Keys - {x};\n    m'\n  }\n\n  /* Keep all key-value pairs corresponding to the set of keys provided. */\n  function {:opaque} Restrict<X, Y>(m: map<X, Y>, xs: set<X>): (m': map<X, Y>)\n    ensures m' == RemoveKeys(m, m.Keys - xs)\n  {\n    map x | x in xs && x in m :: m[x]\n  }\n\n  /* True iff x maps to the same value or does not exist in m and m'. */\n  ghost predicate EqualOnKey<X, Y>(m: map<X, Y>, m': map<X, Y>, x: X)\n  {\n    (x !in m && x !in m') || (x in m && x in m' && m[x] == m'[x])\n  }\n\n  /* True iff m is a subset of m'. */\n  ghost predicate IsSubset<X, Y>(m: map<X, Y>, m': map<X, Y>)\n  {\n    && m.Keys <= m'.Keys\n    && forall x {:trigger EqualOnKey(m, m', x)}{:trigger x in m} :: x in m ==> EqualOnKey(m, m', x)\n  }\n\n  /* Union of two maps. Does not require disjoint domains; on the intersection,\n  values from the second map are chosen. */\n  function {:opaque} Union<X, Y>(m: map<X, Y>, m': map<X, Y>): (r: map<X, Y>)\n    ensures r.Keys == m.Keys + m'.Keys\n    ensures forall x {:trigger r[x]} :: x in m' ==> r[x] == m'[x]\n    ensures forall x {:trigger r[x]} :: x in m && x !in m' ==> r[x] == m[x]\n  {\n    m + m'\n  }\n\n  /* The size of the disjoint union is equal to the sum of individual map\n  sizes. */\n  lemma LemmaDisjointUnionSize<X, Y>(m: map<X, Y>, m': map<X, Y>)\n    requires m.Keys !! m'.Keys\n    ensures |Union(m, m')| == |m| + |m'|\n  {\n    var u := Union(m, m');\n    assert |u.Keys| == |m.Keys| + |m'.Keys|;\n  }\n\n  /* True iff a map is injective. */\n  ghost predicate {:opaque} Injective<X, Y>(m: map<X, Y>)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x != x' && x in m && x' in m ==> m[x] != m[x']\n  }\n\n  /* Swaps map keys and values. Values are not required to be unique; no\n  promises on which key is chosen on the intersection. */\n  ghost function {:opaque} Invert<X, Y>(m: map<X, Y>): map<Y, X>\n  {\n    map y | y in m.Values :: var x :| x in m.Keys && m[x] == y; x\n  }\n\n  /* Inverted maps are injective. */\n  lemma LemmaInvertIsInjective<X, Y>(m: map<X, Y>)\n    ensures Injective(Invert(m))\n  {\n    reveal Injective();\n    reveal Invert();\n  }\n\n  /* True iff a map contains all valid keys. */\n  ghost predicate {:opaque} Total<X(!new), Y>(m: map<X, Y>)\n  {\n    forall i {:trigger m[i]}{:trigger i in m} :: i in m\n  }\n\n  /* True iff a map is monotonic. */\n  ghost predicate {:opaque} Monotonic(m: map<int, int>)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x in m && x' in m && x <= x' ==> m[x] <= m[x']\n  }\n\n  /* True iff a map is monotonic. Only considers keys greater than or\n  equal to start. */\n  ghost predicate {:opaque} MonotonicFrom(m: map<int, int>, start: int)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x in m && x' in m && start <= x <= x' ==> m[x] <= m[x']\n  }\n\n}\n"}
{"file": "../libraries/src/dafny/Collections/Sets.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original Copyright under the following: \n *  Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../Relations.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Dafny.Collections.Sets {\n\n  import opened Relations\n\n  /* If all elements in set x are in set y, x is a subset of y. */\n  lemma LemmaSubset<T>(x: set<T>, y: set<T>)\n    requires forall e {:trigger e in y} :: e in x ==> e in y\n    ensures x <= y\n  {\n  }\n\n  /* If x is a subset of y, then the size of x is less than or equal to the\n  size of y. */\n  lemma LemmaSubsetSize<T>(x: set<T>, y: set<T>)\n    ensures x < y ==> |x| < |y|\n    ensures x <= y ==> |x| <= |y|\n  {\n    if x != {} {\n      var e :| e in x;\n      LemmaSubsetSize(x - {e}, y - {e});\n    }\n  }\n\n  /* If x is a subset of y and the size of x is equal to the size of y, x is\n  equal to y. */\n  lemma LemmaSubsetEquality<T>(x: set<T>, y: set<T>)\n    requires x <= y\n    requires |x| == |y|\n    ensures x == y\n    decreases x, y\n  {\n    if x == {} {\n    } else {\n      var e :| e in x;\n      LemmaSubsetEquality(x - {e}, y - {e});\n    }\n  }\n\n  /* A singleton set has a size of 1. */\n  lemma LemmaSingletonSize<T>(x: set<T>, e: T)\n    requires x == {e}\n    ensures |x| == 1\n  {\n  }\n\n  /* Elements in a singleton set are equal to each other. */\n  lemma LemmaSingletonEquality<T>(x: set<T>, a: T, b: T)\n    requires |x| == 1\n    requires a in x\n    requires b in x\n    ensures a == b\n  {\n    if a != b {\n      assert {a} < x;\n      LemmaSubsetSize({a}, x);\n      assert |{a}| < |x|;\n      assert |x| > 1;\n      assert false;\n    }\n  }\n\n  /* A singleton set has at least one element and any two elements are equal. */\n  ghost predicate IsSingleton<T>(s: set<T>) {\n    && (exists x :: x in s)\n    && (forall x, y | x in s && y in s :: x == y)\n  }\n\n  /* A set has exactly one element, if and only if, it has at least one element and any two elements are equal. */\n  lemma LemmaIsSingleton<T>(s: set<T>)\n    ensures |s| == 1 <==> IsSingleton(s)\n  {\n    if |s| == 1 {\n      forall x, y | x in s && y in s ensures x == y {\n        LemmaSingletonEquality(s, x, y);\n      }\n    }\n    if IsSingleton(s) {\n      var x :| x in s;\n      assert s == {x};\n      assert |s| == 1;\n    }\n  }\n\n  /* Non-deterministically extracts an element from a set that contains at least one element. */\n  ghost function ExtractFromNonEmptySet<T>(s: set<T>): (x: T)\n    requires |s| != 0\n    ensures x in s\n  {\n    var x :| x in s;\n    x\n  }\n\n  /* Deterministically extracts the unique element from a singleton set. In contrast to \n     `ExtractFromNonEmptySet`, this implementation compiles, as the uniqueness of the element \n     being picked can be proven. */\n  function ExtractFromSingleton<T>(s: set<T>): (x: T)\n    requires |s| == 1\n    ensures s == {x}\n  {\n    LemmaIsSingleton(s);\n    var x :| x in s;\n    x\n  }\n\n  /* If an injective function is applied to each element of a set to construct\n  another set, the two sets have the same size.  */\n  lemma LemmaMapSize<X(!new), Y>(xs: set<X>, ys: set<Y>, f: X-->Y)\n    requires forall x {:trigger f.requires(x)} :: f.requires(x)\n    requires Injective(f)\n    requires forall x {:trigger f(x)} :: x in xs <==> f(x) in ys\n    requires forall y {:trigger y in ys} :: y in ys ==> exists x :: x in xs && y == f(x)\n    ensures |xs| == |ys|\n  {\n    if xs != {} {\n      var x :| x in xs;\n      var xs' := xs - {x};\n      var ys' := ys - {f(x)};\n      LemmaMapSize(xs', ys', f);\n    }\n  }\n\n  /* Map an injective function to each element of a set. */\n  function {:opaque} Map<X(!new), Y>(xs: set<X>, f: X-->Y): (ys: set<Y>)\n    reads f.reads\n    requires forall x {:trigger f.requires(x)} :: f.requires(x)\n    requires Injective(f)\n    ensures forall x {:trigger f(x)} :: x in xs <==> f(x) in ys\n    ensures |xs| == |ys|\n  {\n    var ys := set x | x in xs :: f(x);\n    LemmaMapSize(xs, ys, f);\n    ys\n  }\n\n  /* If a set ys is constructed using elements of another set xs for which a\n  function returns true, the size of ys is less than or equal to the size of\n  xs. */\n  lemma LemmaFilterSize<X>(xs: set<X>, ys: set<X>, f: X~>bool)\n    requires forall x {:trigger f.requires(x)}{:trigger x in xs} :: x in xs ==> f.requires(x)\n    requires forall y {:trigger f(y)}{:trigger y in xs} :: y in ys ==> y in xs && f(y)\n    ensures |ys| <= |xs|\n    decreases xs, ys\n  {\n    if ys != {} {\n      var y :| y in ys;\n      var xs' := xs - {y};\n      var ys' := ys - {y};\n      LemmaFilterSize(xs', ys', f);\n    }\n  }\n\n  /* Construct a set using elements of another set for which a function returns\n  true. */\n  function {:opaque} Filter<X(!new)>(xs: set<X>, f: X~>bool): (ys: set<X>)\n    reads f.reads\n    requires forall x {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)\n    ensures forall y {:trigger f(y)}{:trigger y in xs} :: y in ys <==> y in xs && f(y)\n    ensures |ys| <= |xs|\n  {\n    var ys := set x | x in xs && f(x);\n    LemmaFilterSize(xs, ys, f);\n    ys\n  }\n\n  /* The size of a union of two sets is greater than or equal to the size of\n  either individual set. */\n  lemma LemmaUnionSize<X>(xs: set<X>, ys: set<X>)\n    ensures |xs + ys| >= |xs|\n    ensures |xs + ys| >= |ys|\n  {\n    if ys == {} {\n    } else {\n      var y :| y in ys;\n      if y in xs {\n        var xr := xs - {y};\n        var yr := ys - {y};\n        assert xr + yr == xs + ys - {y};\n        LemmaUnionSize(xr, yr);\n      } else {\n        var yr := ys - {y};\n        assert xs + yr == xs + ys - {y};\n        LemmaUnionSize(xs, yr);\n      }\n    }\n  }\n\n  /* Construct a set with all integers in the range [a, b). */\n  function {:opaque} SetRange(a: int, b: int): (s: set<int>)\n    requires a <= b\n    ensures forall i {:trigger i in s} :: a <= i < b <==> i in s\n    ensures |s| == b - a\n    decreases b - a\n  {\n    if a == b then {} else {a} + SetRange(a + 1, b)\n  }\n\n  /* Construct a set with all integers in the range [0, n). */\n  function {:opaque} SetRangeZeroBound(n: int): (s: set<int>)\n    requires n >= 0\n    ensures forall i {:trigger i in s} :: 0 <= i < n <==> i in s\n    ensures |s| == n\n  {\n    SetRange(0, n)\n  }\n\n  /* If a set solely contains integers in the range [a, b), then its size is\n  bounded by b - a. */\n  lemma LemmaBoundedSetSize(x: set<int>, a: int, b: int)\n    requires forall i {:trigger i in x} :: i in x ==> a <= i < b\n    requires a <= b\n    ensures |x| <= b - a\n  {\n    var range := SetRange(a, b);\n    forall e {:trigger e in range}{:trigger e in x} | e in x\n      ensures e in range;\n    {\n    }\n    assert x <= range;\n    LemmaSubsetSize(x, range);\n  }\n\n  /** In a pre-ordered set, a greatest element is necessarily maximal. */\n  lemma LemmaGreatestImpliesMaximal<T(!new)>(R: (T, T) -> bool, max: T, s: set<T>)\n    requires PreOrdering(R)\n    ensures IsGreatest(R, max, s) ==> IsMaximal(R, max, s)\n  {\n  }\n\n  /** In a pre-ordered set, a least element is necessarily minimal. */\n  lemma LemmaLeastImpliesMinimal<T(!new)>(R: (T, T) -> bool, min: T, s: set<T>)\n    requires PreOrdering(R)\n    ensures IsLeast(R, min, s) ==> IsMinimal(R, min, s)\n  {\n  }\n\n  /** In a totally-ordered set, an element is maximal if and only if it is a greatest element. */\n  lemma LemmaMaximalEquivalentGreatest<T(!new)>(R: (T, T) -> bool, max: T, s: set<T>)\n    requires TotalOrdering(R)\n    ensures IsGreatest(R, max, s) <==> IsMaximal(R, max, s)\n  {\n  }\n\n  /** In a totally-ordered set, an element is minimal if and only if it is a least element. */\n  lemma LemmaMinimalEquivalentLeast<T(!new)>(R: (T, T) -> bool, min: T, s: set<T>)\n    requires TotalOrdering(R)\n    ensures IsLeast(R, min, s) <==> IsMinimal(R, min, s)\n  {\n  }\n\n  /** In a partially-ordered set, there exists at most one least element. */\n  lemma LemmaLeastIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)\n    requires PartialOrdering(R)\n    ensures forall min, min' | IsLeast(R, min, s) && IsLeast(R, min', s) :: min == min'\n  {}\n\n  /** In a partially-ordered set, there exists at most one greatest element. */\n  lemma LemmaGreatestIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)\n    requires PartialOrdering(R)\n    ensures forall max, max' | IsGreatest(R, max, s) && IsGreatest(R, max', s) :: max == max'\n  {}\n\n  /** In a totally-ordered set, there exists at most one minimal element. */\n  lemma LemmaMinimalIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)\n    requires TotalOrdering(R)\n    ensures forall min, min' | IsMinimal(R, min, s) && IsMinimal(R, min', s) :: min == min'\n  {}\n\n  /** In a totally-ordered set, there exists at most one maximal element. */\n  lemma LemmaMaximalIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)\n    requires TotalOrdering(R)\n    ensures forall max, max' | IsMaximal(R, max, s) && IsMaximal(R, max', s) :: max == max'\n  {}\n\n  /** Any totally-ordered set contains a unique minimal (equivalently, least) element. */\n  lemma LemmaFindUniqueMinimal<T(!new)>(R: (T, T) -> bool, s: set<T>) returns (min: T)\n    requires |s| > 0 && TotalOrdering(R)\n    ensures IsMinimal(R, min, s) && (forall min': T | IsMinimal(R, min', s) :: min == min')\n  {\n    var x :| x in s;\n    if s == {x} {\n      min := x;\n    } else {\n      var min' := LemmaFindUniqueMinimal(R, s - {x});\n      if\n      case R(min', x) => min := min';\n      case R(x, min') => min := x;\n    }\n  }\n\n  /** Any totally ordered set contains a unique maximal (equivalently, greatest) element. */\n  lemma LemmaFindUniqueMaximal<T(!new)>(R: (T, T) -> bool, s: set<T>) returns (max: T)\n    requires |s| > 0 && TotalOrdering(R)\n    ensures IsMaximal(R, max, s) && (forall max': T | IsMaximal(R, max', s) :: max == max')\n  {\n    var x :| x in s;\n    if s == {x} {\n      max := x;\n    } else {\n      var max' := LemmaFindUniqueMaximal(R, s - {x});\n      if\n      case R(max', x) => max := x;\n      case R(x, max') => max := max';\n    }\n  }\n}\n"}
{"file": "../libraries/src/dafny/Collections/LittleEndianNatConversions.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../NonlinearArithmetic/DivMod.dfy\"\ninclude \"../NonlinearArithmetic/Multiply.dfy\"\ninclude \"../NonlinearArithmetic/Power.dfy\"\ninclude \"Seqs.dfy\"\ninclude \"LittleEndianNat.dfy\"\n\n/* Sequence with smaller base. */\nabstract module {:options \"-functionSyntax:4\"} Dafny.Collections.SmallSeq refines LittleEndianNat {\n\n  function BITS(): nat\n    ensures BITS() > 1\n\n  function BASE(): nat\n  {\n    LemmaPowPositive(2, BITS() - 1);\n    LemmaPowStrictlyIncreases(2, BITS() - 1, BITS());\n    Pow(2, BITS())\n  }\n\n}\n\n/* Sequence with larger base. */\nabstract module {:options \"-functionSyntax:4\"} Dafny.Collections.LargeSeq refines LittleEndianNat {\n\n  import Small : SmallSeq\n\n  function BITS(): nat\n    ensures BITS() > Small.BITS() && BITS() % Small.BITS() == 0\n\n  function BASE(): nat\n  {\n    LemmaPowPositive(2, BITS() - 1);\n    LemmaPowStrictlyIncreases(2, BITS() - 1, BITS());\n    Pow(2, BITS())\n  }\n\n}\n\nabstract module {:options \"-functionSyntax:4\"} Dafny.Collections.LittleEndianNatConversions {\n\n  import opened DivMod\n  import opened Multiply\n  import opened Power\n  import opened Seq\n\n  import opened Large : LargeSeq\n\n  /* Small.BASE() to the power of E is Large.BASE(). */\n  function E(): (E: nat)\n    ensures Pow(Small.BASE(), E) == Large.BASE()\n    ensures E > 0\n  {\n    LemmaDivBasicsAuto();\n    assert forall x :: x != 0 ==> 0 / x == 0;\n    LemmaPowMultipliesAuto();\n    LemmaFundamentalDivMod(Large.BITS(), Small.BITS());\n    assert Large.BITS() == Small.BITS() * (Large.BITS() / Small.BITS()) + (Large.BITS() % Small.BITS());\n    assert (Large.BITS() / Small.BITS()) != 0;\n    Large.BITS() / Small.BITS()\n  }\n\n  /* Converts a sequence from Large.BASE() to Small.BASE(). */\n  function {:opaque} ToSmall(xs: seq<Large.uint>): (ys: seq<Small.uint>)\n    ensures |ys| == |xs| * E()\n  {\n    if |xs| == 0 then []\n    else\n      LemmaMulIsDistributiveAddOtherWay(E(), 1, |xs| - 1);\n      Small.FromNatWithLen(First(xs), E()) + ToSmall(DropFirst(xs))\n  }\n\n  /* Converts a sequence from Small.BASE() to Large.BASE(). */\n  function {:opaque} ToLarge(xs: seq<Small.uint>): (ys: seq<Large.uint>)\n    requires |xs| % E() == 0\n    ensures |ys| == |xs| / E()\n  {\n    if |xs| == 0 then LemmaDivBasicsAuto(); []\n    else\n      LemmaModIsZero(|xs|, E());\n      assert |xs| >= E();\n\n      Small.LemmaSeqNatBound(xs[..E()]);\n      LemmaModSubMultiplesVanishAuto();\n      LemmaDivMinusOne(|xs|, E());\n      [Small.ToNatRight(xs[..E()]) as Large.uint] + ToLarge(xs[E()..])\n  }\n\n  /* Sequence conversion from Large.BASE() to Small.BASE() does not\n  change its nat representation. */\n  lemma LemmaToSmall(xs: seq<Large.uint>)\n    ensures Small.ToNatRight(ToSmall(xs)) == Large.ToNatRight(xs)\n  {\n    reveal Small.ToNatRight();\n    reveal Large.ToNatRight();\n    reveal ToSmall();\n    if |xs| == 0 {\n    } else {\n      calc {\n        Small.ToNatRight(ToSmall(xs));\n        Small.ToNatRight(Small.FromNatWithLen(First(xs), E()) + ToSmall(DropFirst(xs)));\n        {\n          Small.LemmaSeqPrefix(Small.FromNatWithLen(First(xs), E()) + ToSmall(DropFirst(xs)), E());\n          LemmaToSmall(DropFirst(xs));\n        }\n        First(xs) + Large.ToNatRight(DropFirst(xs)) * Pow(Small.BASE(), E());\n        { assert Pow(Small.BASE(), E()) == Large.BASE(); }\n        Large.ToNatRight(xs);\n      }\n    }\n  }\n\n  /* Sequence conversion from Small.BASE() to Large.BASE() does not\n  change its nat representation. */\n  lemma LemmaToLarge(xs: seq<Small.uint>)\n    requires |xs| % E() == 0\n    ensures Large.ToNatRight(ToLarge(xs)) == Small.ToNatRight(xs)\n  {\n    reveal Large.ToNatRight();\n    reveal Small.ToNatRight();\n    reveal ToLarge();\n    if |xs| == 0 {\n    } else {\n      calc {\n        Large.ToNatRight(ToLarge(xs));\n        {\n          LemmaModIsZero(|xs|, E());\n          LemmaModSubMultiplesVanishAuto();\n          Small.LemmaSeqNatBound(xs[..E()]);\n        }\n        Large.ToNatRight([Small.ToNatRight(xs[..E()]) as Large.uint] + ToLarge(xs[E()..]));\n        { LemmaToLarge(xs[E()..]); }\n        Small.ToNatRight(xs[..E()]) + Small.ToNatRight(xs[E()..]) * Pow(Small.BASE(), E());\n        { Small.LemmaSeqPrefix(xs, E()); }\n        Small.ToNatRight(xs);\n      }\n    }\n  }\n\n  /* ToSmall is injective. */\n  lemma LemmaToSmallIsInjective(xs: seq<Large.uint>, ys: seq<Large.uint>)\n    requires ToSmall(xs) == ToSmall(ys)\n    requires |xs| == |ys|\n    ensures xs == ys\n  {\n    LemmaToSmall(xs);\n    LemmaToSmall(ys);\n    assert Large.ToNatRight(xs) == Large.ToNatRight(ys);\n    Large.LemmaSeqEq(xs, ys);\n  }\n\n  /* ToLarge is injective. */\n  lemma LemmaToLargeIsInjective(xs: seq<Small.uint>, ys: seq<Small.uint>)\n    requires |xs| % E() == |ys| % E() == 0\n    requires ToLarge(xs) == ToLarge(ys)\n    requires |xs| == |ys|\n    ensures xs == ys\n  {\n    LemmaToLarge(xs);\n    LemmaToLarge(ys);\n    assert Small.ToNatRight(xs) == Small.ToNatRight(ys);\n    Small.LemmaSeqEq(xs, ys);\n  }\n\n  /* If we start with a Small sequence, convert it to a Large sequence,\n  and convert it back, we get the same sequence we started with. */\n  lemma LemmaSmallLargeSmall(xs: seq<Small.uint>)\n    requires |xs| % E() == 0\n    ensures ToSmall(ToLarge(xs)) == xs\n  {\n    reveal ToSmall();\n    reveal ToLarge();\n    if |xs| == 0 {\n    } else {\n      calc {\n        ToSmall(ToLarge(xs));\n        {\n          LemmaModIsZero(|xs|, E());\n          Small.LemmaSeqNatBound(xs[..E()]);\n          LemmaModSubMultiplesVanishAuto();\n        }\n        ToSmall([Small.ToNatRight(xs[..E()]) as Large.uint] + ToLarge(xs[E()..]));\n        Small.FromNatWithLen(Small.ToNatRight(xs[..E()]), E()) + ToSmall(ToLarge(xs[E()..]));\n        {\n          Small.LemmaSeqNatSeq(xs[..E()]);\n          LemmaSmallLargeSmall(xs[E()..]);\n        }\n        xs;\n      }\n    }\n  }\n\n  /* If we start with a Large sequence, convert it to a Sequence sequence,\n  and convert it back, we get the same sequence we started with. */\n  lemma LemmaLargeSmallLarge(xs: seq<Large.uint>)\n    ensures |ToSmall(xs)| % E() == 0\n    ensures ToLarge(ToSmall(xs)) == xs\n  {\n    reveal ToSmall();\n    reveal ToLarge();\n    LemmaModMultiplesBasicAuto();\n    if |xs| == 0 {\n    } else {\n      calc {\n        ToLarge(ToSmall(xs));\n        ToLarge(Small.FromNatWithLen(First(xs), E()) + ToSmall(DropFirst(xs)));\n        [Small.ToNatRight(Small.FromNatWithLen(First(xs), E())) as Large.uint] + ToLarge(ToSmall(DropFirst(xs)));\n        [First(xs)] + ToLarge(ToSmall(DropFirst(xs)));\n        { LemmaLargeSmallLarge(DropFirst(xs)); }\n        [First(xs)] + DropFirst(xs);\n        xs;\n      }\n    }\n  }\n\n}\n\n/* Conversions between sequences of uint8 and uint16. */\nmodule {:options \"-functionSyntax:4\"} Dafny.Collections.Uint8_16 refines LittleEndianNatConversions {\n\n  module Uint8Seq refines SmallSeq {\n    function BITS(): nat { 8 }\n  }\n\n  module Uint16Seq refines LargeSeq {\n    import Small = Uint8Seq\n    function BITS(): nat { 16 }\n  }\n\n  import opened Large = Uint16Seq\n  import Small = Large.Small\n\n}\n\n/* Conversions between sequences of uint8 and uint32. */\nmodule {:options \"-functionSyntax:4\"} Dafny.Collections.Uint8_32 refines LittleEndianNatConversions {\n\n  module Uint8Seq refines SmallSeq {\n    function BITS(): nat { 8 }\n  }\n\n  module Uint32Seq refines LargeSeq {\n    import Small = Uint8Seq\n    function BITS(): nat { 32 }\n  }\n\n  import opened Large = Uint32Seq\n  import Small = Large.Small\n\n}\n\n/* Conversions between sequences of uint8 and uint64. */\nmodule {:options \"-functionSyntax:4\"} Dafny.Collections.Uint8_64 refines LittleEndianNatConversions {\n\n  module Uint8Seq refines SmallSeq {\n    function BITS(): nat { 8 }\n  }\n\n  module Uint64Seq refines LargeSeq {\n    import Small = Uint8Seq\n    function BITS(): nat { 64 }\n  }\n\n  import opened Large = Uint64Seq\n  import Small = Large.Small\n\n}\n\n/* Conversions between sequences of uint16 and uint32. */\nmodule {:options \"-functionSyntax:4\"} Dafny.Collections.Uint16_32 refines LittleEndianNatConversions {\n\n  module Uint16Seq refines SmallSeq {\n    function BITS(): nat { 16 }\n  }\n\n  module Uint32Seq refines LargeSeq {\n    import Small = Uint16Seq\n    function BITS(): nat { 32 }\n  }\n\n  import opened Large = Uint32Seq\n  import Small = Large.Small\n\n}\n\n/* Conversions between sequences of uint32 and uint64. */\nmodule {:options \"-functionSyntax:4\"} Dafny.Collections.Uint32_64 refines LittleEndianNatConversions {\n\n  module Uint32Seq refines SmallSeq {\n    function BITS(): nat { 32 }\n  }\n\n  module Uint64Seq refines LargeSeq {\n    import Small = Uint32Seq\n    function BITS(): nat { 64 }\n  }\n\n  import opened Large = Uint64Seq\n  import Small = Large.Small\n\n}\n"}
{"file": "../libraries/src/dafny/BoundedInts.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/** Defines symbolic names for various powers of 2 and newtypes for various common\n    restricted-range int types. */\nmodule {:options \"-functionSyntax:4\"} Dafny.BoundedInts {\n  const TWO_TO_THE_0:   int := 1\n\n  const TWO_TO_THE_1:   int := 2\n  const TWO_TO_THE_2:   int := 4\n  const TWO_TO_THE_4:   int := 16\n  const TWO_TO_THE_5:   int := 32\n  const TWO_TO_THE_7:   int := 0x80\n  const TWO_TO_THE_8:   int := 0x100\n  const TWO_TO_THE_15:  int := 0x8000\n  const TWO_TO_THE_16:  int := 0x1_0000\n  const TWO_TO_THE_24:  int := 0x100_0000\n  const TWO_TO_THE_31:  int := 0x8000_0000\n  const TWO_TO_THE_32:  int := 0x1_00000000\n  const TWO_TO_THE_40:  int := 0x100_00000000\n  const TWO_TO_THE_48:  int := 0x10000_00000000\n  const TWO_TO_THE_56:  int := 0x1000000_00000000\n  const TWO_TO_THE_63:  int := 0x80000000_00000000\n  const TWO_TO_THE_64:  int := 0x1_00000000_00000000\n  const TWO_TO_THE_127: int := 0x80000000_00000000_00000000_00000000\n  const TWO_TO_THE_128: int := 0x1_00000000_00000000_00000000_00000000\n  const TWO_TO_THE_256: int := 0x1_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000\n  const TWO_TO_THE_512: int :=\n    0x1_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000;\n\n  newtype uint8 = x: int   | 0 <= x < TWO_TO_THE_8\n  newtype uint16 = x: int  | 0 <= x < TWO_TO_THE_16\n  newtype uint32 = x: int  | 0 <= x < TWO_TO_THE_32\n  newtype uint64 = x: int  | 0 <= x < TWO_TO_THE_64\n  newtype uint128 = x: int | 0 <= x < TWO_TO_THE_128\n\n  newtype int8 = x: int    | -TWO_TO_THE_7 <= x < TWO_TO_THE_7\n  newtype int16 = x: int   | -TWO_TO_THE_15 <= x < TWO_TO_THE_15\n  newtype int32 = x: int   | -TWO_TO_THE_31 <= x < TWO_TO_THE_31\n  newtype int64 = x: int   | -TWO_TO_THE_63 <= x < TWO_TO_THE_63\n  newtype int128 = x: int  | -TWO_TO_THE_127 <= x < TWO_TO_THE_127\n\n  newtype nat8 = x: int    | 0 <= x < TWO_TO_THE_7\n  newtype nat16 = x: int   | 0 <= x < TWO_TO_THE_15\n  newtype nat32 = x: int   | 0 <= x < TWO_TO_THE_31\n  newtype nat64 = x: int   | 0 <= x < TWO_TO_THE_63\n  newtype nat128 = x: int  | 0 <= x < TWO_TO_THE_127\n\n}\n"}
{"file": "../libraries/src/dafny/Relations.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/** Various properties of mathematical Relations (see also BinaryOperations) */\nmodule {:options \"-functionSyntax:4\"} Dafny.Relations {\n\n  ghost predicate Injective<X(!new), Y>(f: X-->Y)\n    reads f.reads\n    requires forall x :: f.requires(x)\n  {\n    forall x1, x2 :: f(x1) == f(x2) ==> x1 == x2\n  }\n\n  ghost predicate Commutative<T(!new),U(!new)>(f: (T,T)->U)\n    reads f.reads\n    requires forall x,y :: f.requires(x,y) && f.requires(y,x)\n  {\n    forall x,y :: f(x,y) == f(y,x)\n  }\n\n  ghost predicate Associative<T(!new)>(f: (T,T)->T)\n    reads f.reads\n    requires forall x, y, z :: f.requires(x,y) && f.requires(y,z) && f.requires(x,z)\n  {\n    forall x, y, z: T :: f(x,f(y,z)) == f(f(x,y),z)\n  }\n\n  ghost predicate Reflexive<T(!new)>(R: (T, T) -> bool) {\n    forall x :: R(x, x)\n  }\n\n  ghost predicate Irreflexive<T(!new)>(R: (T, T) -> bool) {\n    forall x :: !R(x, x)\n  }\n\n  ghost predicate AntiSymmetric<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) && R(y, x) ==> x == y\n  }\n\n  ghost predicate Asymmetric<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) ==> !R(y, x)\n  }\n\n  ghost predicate Symmetric<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) <==> R(y, x)\n  }\n\n  ghost predicate Connected<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: x != y ==> R(x, y) || R(y, x)\n  }\n\n  ghost predicate StronglyConnected<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) || R(y, x)\n  }\n\n  ghost predicate Transitive<T(!new)>(R: (T, T) -> bool) {\n    forall x, y, z :: R(x, y) && R(y, z) ==> R(x, z)\n  }\n\n  ghost predicate TotalOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && AntiSymmetric(R)\n    && Transitive(R)\n    && StronglyConnected(R)\n  }\n\n  ghost predicate StrictTotalOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Irreflexive(R)\n    && AntiSymmetric(R)\n    && Transitive(R)\n    && Connected(R)\n  }\n\n  ghost predicate PreOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && Transitive(R)\n  }\n\n  ghost predicate PartialOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && Transitive(R)\n    && AntiSymmetric(R)\n  }\n\n  ghost predicate EquivalenceRelation<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && Symmetric(R)\n    && Transitive(R)\n  }\n\n  /** An element in an ordered set is called a least element (or a minimum), if it is less than \n      every other element of the set. */\n  ghost predicate IsLeast<T>(R: (T, T) -> bool, min: T, s: set<T>) {\n    min in s && forall x | x in s :: R(min, x)\n  }\n\n  /** An element in an ordered set is called a minimal element, if no other element is less than it. */\n  ghost predicate IsMinimal<T>(R: (T, T) -> bool, min: T, s: set<T>) {\n    min in s && forall x | x in s && R(x, min) :: R(min, x)\n  }\n\n  /** An element in an ordered set is called a greatest element (or a maximum), if it is greater than \n      every other element of the set. */\n  ghost predicate IsGreatest<T>(R: (T, T) -> bool, max: T, s: set<T>) {\n    max in s && forall x | x in s :: R(x, max)\n  }\n\n  /** An element in an ordered set is called a maximal element, if no other element is greater than it. */\n  ghost predicate IsMaximal<T>(R: (T, T) -> bool, max: T, s: set<T>) {\n    max in s && forall x | x in s && R(max, x) :: R(x, max)\n  }\n}\n"}
{"file": "../libraries/src/dafny/Math.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/** Defines various integer-math functions */\nmodule {:options \"-functionSyntax:4\"} Dafny.Math {\n\n  /** Minimum of two integers  */\n  function Min(a: int, b: int): int\n  {\n    if a < b\n    then a\n    else b\n  }\n\n  /** Minimum of three integers  */\n  function Min3(a: int, b: int, c: int): int\n  {\n    Min(a, Min(b, c))\n  }\n\n  /** Maximum of two integers  */\n  function Max(a: int, b: int): int\n  {\n    if a < b\n    then b\n    else a\n  }\n\n  /** Maximum of three integers  */\n  function Max3(a: int, b: int, c: int): int\n  {\n    Max(a, Max(b, c))\n  }\n\n  /** Integer absolute value */\n  function Abs(a: int): int\n  {\n    if a < 0\n    then -a\n    else a\n  }\n}\n"}
{"file": "../libraries/src/dafny/Wrappers.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/** This module provides various kinds of failure-compatible datatypes, including Option.\n- Option<R> (Some or None) with a type parameter R that is the type of the Some value\n- Outcome<E> (Pass or Fail) with a type parameter E that is the type of a failure value\n- Result<R,E> which has both a value type and a failure type\nAll three of these may be used with `:-` as Dafny failure-compatible types\n\nThe module also defines two forms of `Need`, that check the truth of a predicate and\nreturn a failure value if false.\n */\nmodule {:options \"--function-syntax:4\"} Dafny.Wrappers {\n\n  /** This datatype is the conventional Some/None datatype that is often used\n      in place of a reference or null.\n   */\n  datatype Option<+T> = None | Some(value: T) {\n\n    /** True if is None */\n    predicate IsFailure() {\n      None?\n    }\n\n    /** Converts a None result to an Option value with a different value type. */\n    function PropagateFailure<U>(): Option<U>\n      requires None?\n    {\n      None\n    }\n\n    /** Returns the value encapsulated in Some */\n    function Extract(): T\n      requires Some?\n    {\n      value\n    }\n\n    /** Returns the value encapsulated in Some or a default value if None */\n    function GetOr(default: T): T {\n      match this\n      case Some(v) => v\n      case None() => default\n    }\n\n    /** Converts the datatype value to a Result value (with the given error value) */\n    function ToResult<E>(error: E): Result<T, E> {\n      match this\n      case Some(v) => Success(v)\n      case None() => Failure(error)\n    }\n\n    /** Converts the datatype value to an Outcome value (with the given error value) */\n    function ToOutcome<E>(error: E): Outcome<E> {\n      match this\n      case Some(v) => Pass\n      case None() => Fail(error)\n    }\n\n    /** Applies the given function to convert the Option to something else  */\n    function Map<FC>(rewrap: Option<T> -> FC): FC\n    {\n      rewrap(this)\n    }\n  }\n\n  /** A Success/Failure failure-compatible datatype that carries either a success value or an error value */\n  datatype Result<+R, +E> = | Success(value: R) | Failure(error: E) {\n\n    /** True if is Failure */\n    predicate IsFailure() {\n      Failure?\n    }\n\n    /** Converts a Failure value to an alternate Result that has a different value type but the same error type */\n    function PropagateFailure<U>(): (r: Result<U, E>)\n      requires Failure?\n    {\n      Failure(this.error)\n    }\n\n    /** Returns the value encapsulated in Success */\n    function Extract(): R\n      requires Success?\n    {\n      value\n    }\n\n    /** Returns the value encapsulated in Success or a default value if Failure */\n    function GetOr(default: R): R\n    {\n      match this\n      case Success(s) => s\n      case Failure(e) => default\n    }\n\n    /** Converts the Result to an Option */\n    function ToOption(): Option<R>\n    {\n      match this\n      case Success(s) => Some(s)\n      case Failure(e) => None()\n    }\n\n    /** Converts the Result to an Outcome */\n    function ToOutcome(): Outcome<E>\n    {\n      match this\n      case Success(s) => Pass\n      case Failure(e) => Fail(e)\n    }\n\n    /** Applies the given function to convert the Result to something else */\n    function Map<FC>(rewrap: Result<R,E> -> FC): FC\n    {\n      rewrap(this)\n    }\n\n    /** Applies the given function to convert the Result to something else with the same Success type */\n    function MapFailure<NewE>(reWrap: E -> NewE): Result<R, NewE>\n    {\n      match this\n      case Success(s) => Success(s)\n      case Failure(e) => Failure(reWrap(e))\n    }\n  }\n\n  /** A Pass/Fail failure-compatible datatype that carries an error value, but is not 'value-carrying' */\n  datatype Outcome<+E> = Pass | Fail(error: E) {\n\n    predicate IsFailure() {\n      Fail?\n    }\n\n\n    function PropagateFailure(): Outcome<E>\n      requires Fail?\n    {\n      this\n    }\n    // Note: no Extract method, intentionally\n\n    /** Converts to an Option */\n    function ToOption<R>(r: R): Option<R>\n    {\n      match this\n      case Pass => Some(r)\n      case Fail(e) => None()\n    }\n\n    /** Converts to a Result */\n    function ToResult<R>(r: R): Result<R,E>\n    {\n      match this\n      case Pass => Success(r)\n      case Fail(e) => Failure(e)\n    }\n\n    /** Applies the given function to convert to something else */\n    function Map<FC>(rewrap: Outcome<E> -> FC): FC\n    {\n      rewrap(this)\n    }\n\n    /** Converts to a Result with a different error type */\n    function MapFailure<T,NewE>(rewrap: E-> NewE, default: T): Result<T, NewE>\n    {\n      match this\n      case Pass => Success(default)\n      case Fail(e) => Failure(rewrap(e))\n    }\n\n    /** A helper function to ensure a requirement is true at runtime,\n       returning an Outcome<>. Example:\n      `:- Need(5 == |mySet|, \"The set MUST have 5 elements.\")`\n    */\n    static function Need(condition: bool, error: E): (result: Outcome<E>)\n    {\n      if condition then Pass else Fail(error)\n    }\n  }\n\n  // A special case of Outcome that is just used for Need below, and\n  // returns a Result<>\n  datatype OutcomeResult<+E> = Pass' | Fail'(error: E) {\n    predicate IsFailure() {\n      Fail'?\n    }\n    function PropagateFailure<U>(): Result<U,E>\n      requires IsFailure()\n    {\n      Failure(this.error)\n    }\n  }\n\n  /** A helper function to ensure a requirement is true at runtime.\n      Example: `:- Need(5 == |mySet|, \"The set MUST have 5 elements.\")`\n  */\n  function Need<E>(condition: bool, error: E): (result: OutcomeResult<E>)\n  {\n    if condition then Pass' else Fail'(error)\n  }\n\n  /** In verification, this method functions as an `assert` of the given condition;\n      at run-time functions as an `expect`. The arguments may not be ghost.\n   */\n  method Expect(condition: bool, message: string)\n    requires condition\n  {\n    expect condition, message;\n  }\n}\n"}
{"file": "../libraries/src/Functions.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original Copyright under the following: \n *  Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\nmodule {:options \"-functionSyntax:4\"} Functions {\n  ghost predicate Injective<X(!new), Y>(f: X-->Y)\n    reads f.reads\n    requires forall x :: f.requires(x)\n  {\n    forall x1, x2 :: f(x1) == f(x2) ==> x1 == x2\n  }\n\n}\n"}
{"file": "../libraries/src/Unicode/Utf8EncodingScheme.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../Collections/Sequences/Seq.dfy\"\ninclude \"../BoundedInts.dfy\"\n\ninclude \"Unicode.dfy\"\ninclude \"Utf8EncodingForm.dfy\"\n\n/**\n  * The Unicode encoding scheme that serializes a UTF-8 code unit sequence in exactly the same order as the code unit\n  * sequence itself.\n  *\n  * Because the UTF-8 encoding form deals in ordered byte sequences, the UTF-8 encoding scheme is trivial.\n  * The byte ordering is completely defined by the UTF-8 code unit sequence itself.\n  * We implement the encoding scheme here for completeness of the Unicode character encoding model,\n  * and to perform the (trivial) conversion between `uint8`/`byte` and `bv8` values.\n  *\n  * (Section 3.10 D95)\n  *\n  * TODO: this should refine an abstract UnicodeEncodingScheme module\n  * that states lemmas/conditions about Serialize and Deserialize\n  * which refining modules would prove about their own implementations.\n  * Proving those lemmas are easier to write using `calc`,\n  * but that runs into <https://github.com/dafny-lang/dafny/issues/1639>.\n  */\nmodule {:options \"-functionSyntax:4\"} Utf8EncodingScheme {\n  import opened Wrappers\n\n  import BoundedInts\n  import Seq\n  import Unicode\n  import Utf8EncodingForm\n\n  type byte = BoundedInts.uint8\n\n  /**\n    * Returns the byte serialization of the given code unit sequence.\n    */\n  function Serialize(s: Utf8EncodingForm.CodeUnitSeq): (b: seq<byte>)\n  {\n    Seq.Map(c => c as byte, s)\n  }\n\n  /**\n    * Returns the code unit sequence that serializes to the given byte sequence.\n    */\n  function Deserialize(b: seq<byte>): (s: Utf8EncodingForm.CodeUnitSeq)\n  {\n    Seq.Map(b => b as Utf8EncodingForm.CodeUnit, b)\n  }\n\n  /**\n    * Serializing a code unit sequence and then deserializing the result, yields the original code unit sequence.\n    */\n  lemma LemmaSerializeDeserialize(s: Utf8EncodingForm.CodeUnitSeq)\n    ensures Deserialize(Serialize(s)) == s\n  {}\n\n  /**\n    * Deserializing a byte sequence and then serializing the result, yields the original byte sequence.\n    */\n  lemma LemmaDeserializeSerialize(b: seq<byte>)\n    ensures Serialize(Deserialize(b)) == b\n  {\n    calc {\n      Serialize(Deserialize(b));\n    == // Definitions of Serialize, Deserialize\n      Seq.Map(c => c as byte, Seq.Map(b => b as Utf8EncodingForm.CodeUnit, b));\n    == // Compositionality of Map\n      Seq.Map(b => (b as Utf8EncodingForm.CodeUnit) as byte, b);\n    == // Simplify map\n      Seq.Map(b => b, b);\n    == // Identity function\n      b;\n    }\n  }\n}\n"}
{"file": "../libraries/src/Unicode/Utf8EncodingForm.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../Collections/Sequences/Seq.dfy\"\ninclude \"../Functions.dfy\"\n\ninclude \"Unicode.dfy\"\ninclude \"UnicodeEncodingForm.dfy\"\n\n/**\n  * The Unicode encoding form that assigns each Unicode scalar value to an unsigned byte sequence of one to four bytes\n  * in length, as specified in Table 3-6 and Table 3-7.\n  */\nmodule {:options \"-functionSyntax:4\"} Utf8EncodingForm refines UnicodeEncodingForm {\n  type CodeUnit = bv8\n\n  //\n  // Definitions of well-formedness.\n  //\n\n  function IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)\n  {\n    if |s| == 1 then (\n                       var b := IsWellFormedSingleCodeUnitSequence(s);\n                       assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);\n                       b\n                     )\n    else if |s| == 2 then (\n                            var b := IsWellFormedDoubleCodeUnitSequence(s);\n                            assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);\n                            b\n                          )\n    else if |s| == 3 then (\n                            var b := IsWellFormedTripleCodeUnitSequence(s);\n                            assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);\n                            b\n                          )\n    else if |s| == 4 then (\n                            var b := IsWellFormedQuadrupleCodeUnitSequence(s);\n                            assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);\n                            b\n                          )\n    else false\n  }\n\n  function IsWellFormedSingleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 1\n  {\n    var firstByte := s[0];\n    && 0x00 <= firstByte <= 0x7F\n  }\n\n  function IsWellFormedDoubleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 2\n    ensures b ==>\n              && !IsWellFormedSingleCodeUnitSequence(s[..1])\n  {\n    var firstByte := s[0];\n    var secondByte := s[1];\n    && 0xC2 <= firstByte <= 0xDF\n    && 0x80 <= secondByte <= 0xBF\n  }\n\n  function IsWellFormedTripleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 3\n    ensures b ==>\n              && !IsWellFormedSingleCodeUnitSequence(s[..1])\n              && !IsWellFormedDoubleCodeUnitSequence(s[..2])\n  {\n    var firstByte := s[0];\n    var secondByte := s[1];\n    var thirdByte := s[2];\n    && (\n         || (firstByte == 0xE0 && 0xA0 <= secondByte <= 0xBF)\n         || (0xE1 <= firstByte <= 0xEC && 0x80 <= secondByte <= 0xBF)\n         || (firstByte == 0xED && 0x80 <= secondByte <= 0x9F)\n         || (0xEE <= firstByte <= 0xEF && 0x80 <= secondByte <= 0xBF)\n       )\n    && 0x80 <= thirdByte <= 0xBF\n  }\n\n  function IsWellFormedQuadrupleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 4\n    ensures b ==>\n              && !IsWellFormedSingleCodeUnitSequence(s[..1])\n              && !IsWellFormedDoubleCodeUnitSequence(s[..2])\n              && !IsWellFormedTripleCodeUnitSequence(s[..3])\n  {\n    var firstByte := s[0];\n    var secondByte := s[1];\n    var thirdByte := s[2];\n    var fourthByte := s[3];\n    && (\n         || (firstByte == 0xF0 && 0x90 <= secondByte <= 0xBF)\n         || (0xF1 <= firstByte <= 0xF3 && 0x80 <= secondByte <= 0xBF)\n         || (firstByte == 0xF4 && 0x80 <= secondByte <= 0x8F)\n       )\n    && 0x80 <= thirdByte <= 0xBF\n    && 0x80 <= fourthByte <= 0xBF\n  }\n\n  function SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq):\n    (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)\n  {\n    if |s| >= 1 && IsWellFormedSingleCodeUnitSequence(s[..1]) then Some(s[..1])\n    else if |s| >= 2 && IsWellFormedDoubleCodeUnitSequence(s[..2]) then Some(s[..2])\n    else if |s| >= 3 && IsWellFormedTripleCodeUnitSequence(s[..3]) then Some(s[..3])\n    else if |s| >= 4 && IsWellFormedQuadrupleCodeUnitSequence(s[..4]) then Some(s[..4])\n    else None\n  }\n\n  //\n  // Encoding and decoding.\n  // See Table 3-6. UTF-8 Bit Distribution of the Unicode Standard 14.0.\n  //\n\n  function EncodeScalarValue(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n  {\n    if v <= 0x7F then EncodeScalarValueSingleByte(v)\n    else if v <= 0x7FF then EncodeScalarValueDoubleByte(v)\n    else if v <= 0xFFFF then EncodeScalarValueTripleByte(v)\n    else EncodeScalarValueQuadrupleByte(v)\n  }\n\n  function EncodeScalarValueSingleByte(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n    requires 0 <= v <= 0x7F\n    ensures |m| == 1\n    ensures IsWellFormedSingleCodeUnitSequence(m)\n  {\n    // v = 0000 0000 / 0xxx xxxx\n    var x := (v & 0x7F) as bv7;\n    // encoded = 0xxx xxxx\n    var firstByte := x as CodeUnit;\n    [firstByte]\n  }\n\n  function EncodeScalarValueDoubleByte(v: Unicode.ScalarValue): (s: CodeUnitSeq)\n    requires 0x80 <= v <= 0x7FF\n    ensures |s| == 2\n    ensures IsWellFormedDoubleCodeUnitSequence(s)\n  {\n    // v = 0000 0yyy / yyxx xxxx\n    var x := (v & 0x3F) as bv6;\n    var y := ((v & 0x7C0) >> 6) as bv5;\n    // encoded = 110y yyyy / 10xx xxxx\n    var firstByte := 0xC0 | y as CodeUnit;\n    var secondByte := 0x80 | x as CodeUnit;\n    [firstByte, secondByte]\n  }\n\n  function EncodeScalarValueTripleByte(v: Unicode.ScalarValue): (s: CodeUnitSeq)\n    requires 0x800 <= v <= 0xFFFF\n    ensures |s| == 3\n    ensures IsWellFormedTripleCodeUnitSequence(s)\n  {\n    // v = zzzz yyyy / yyxx xxxx\n    var x := (v & 0x3F) as bv6;\n    var y := ((v & 0xFC0) >> 6) as bv6;\n    var z := ((v & 0xF000) >> 12) as bv4;\n    // encoded = 1110 zzzz / 10yy yyyy / 10xx xxxx\n    var firstByte := 0xE0 | z as CodeUnit;\n    var secondByte := 0x80 | y as CodeUnit;\n    var thirdByte := 0x80 | x as CodeUnit;\n    [firstByte, secondByte, thirdByte]\n  }\n\n  function EncodeScalarValueQuadrupleByte(v: Unicode.ScalarValue): (s: CodeUnitSeq)\n    requires 0x10000 <= v <= 0x10FFFF\n    ensures |s| == 4\n    ensures IsWellFormedQuadrupleCodeUnitSequence(s)\n  {\n    // v = 000u uuuu / zzzz yyyy / yyxx xxxx\n    //        1 1122\n    assert v <= 0x1FFFFF;\n    var x := (v & 0x3F) as bv6;\n    var y := ((v & 0xFC0) >> 6) as bv6;\n    var z := ((v & 0xF000) >> 12) as bv4;\n    var u2 := ((v & 0x30000) >> 16) as bv2;\n    var u1 := ((v & 0x1C0000) >> 18) as bv3;\n\n    // encoded = 1111 0uuu / 10uu zzzz / 10yy yyyy / 10xx xxxx\n    //                 111     22\n    var firstByte := 0xF0 | u1 as CodeUnit;\n    var secondByte := 0x80 | ((u2 as CodeUnit) << 4) | z as CodeUnit;\n    var thirdByte := 0x80 | y as CodeUnit;\n    var fourthByte := 0x80 | x as CodeUnit;\n    [firstByte, secondByte, thirdByte, fourthByte]\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n  {\n    if |m| == 1 then DecodeMinimalWellFormedCodeUnitSubsequenceSingleByte(m)\n    else if |m| == 2 then DecodeMinimalWellFormedCodeUnitSubsequenceDoubleByte(m)\n    else if |m| == 3 then DecodeMinimalWellFormedCodeUnitSubsequenceTripleByte(m)\n    else assert |m| == 4; DecodeMinimalWellFormedCodeUnitSubsequenceQuadrupleByte(m)\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceSingleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 1\n    ensures 0 <= v <= 0x7F\n    ensures EncodeScalarValueSingleByte(v) == m\n  {\n    var firstByte := m[0];\n    var x := firstByte as bv7;\n    x as Unicode.ScalarValue\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceDoubleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 2\n    ensures 0x80 <= v <= 0x7FF\n    ensures EncodeScalarValueDoubleByte(v) == m\n  {\n    var firstByte := m[0];\n    var secondByte := m[1];\n    var y := (firstByte & 0x1F) as bv24;\n    var x := (secondByte & 0x3F) as bv24;\n    (y << 6) | x as Unicode.ScalarValue\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceTripleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 3\n    ensures 0x800 <= v <= 0xFFFF\n    ensures EncodeScalarValueTripleByte(v) == m\n  {\n    var firstByte := m[0];\n    var secondByte := m[1];\n    var thirdByte := m[2];\n    var z := (firstByte & 0xF) as bv24;\n    var y := (secondByte & 0x3F) as bv24;\n    var x := (thirdByte & 0x3F) as bv24;\n    assert {:split_here} true;\n    (z << 12) | (y << 6) | x as Unicode.ScalarValue\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceQuadrupleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 4\n    ensures 0x10000 <= v <= 0x10FFFF\n    ensures EncodeScalarValueQuadrupleByte(v) == m\n  {\n    var firstByte := m[0];\n    var secondByte := m[1];\n    var thirdByte := m[2];\n    var fourthByte := m[3];\n    var u1 := (firstByte & 0x7) as bv24;\n    var u2 := ((secondByte & 0x30) >> 4) as bv24;\n    var z := (secondByte & 0xF) as bv24;\n    var y := (thirdByte & 0x3F) as bv24;\n    var x := (fourthByte & 0x3F) as bv24;\n    assert {:split_here} true;\n    (u1 << 18) | (u2 << 16) | (z << 12) | (y << 6) | x as Unicode.ScalarValue\n  }\n}\n"}
{"file": "../libraries/src/Unicode/UnicodeEncodingForm.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../Wrappers.dfy\"\ninclude \"../Functions.dfy\"\ninclude \"../Collections/Sequences/Seq.dfy\"\n\ninclude \"Unicode.dfy\"\n\n/**\n  * A Unicode encoding form assigns each Unicode scalar value to a unique code unit sequence.\n  *\n  * A concrete `EncodingForm` MUST define the following:\n  *  - The type `CodeUnit`.\n  *  - The predicate `IsMinimalWellFormedCodeUnitSubsequence`, which defines the set of encodings of scalar values,\n  *    known as \"minimal well-formed code unit subsequences\".\n  *  - The function `SplitPrefixMinimalWellFormedCodeUnitSubsequence`, which defines the algorithm by which to parse\n  *    a minimal well-formed code unit subsequence from the beginning of a code unit sequence.\n  *  - The function `EncodeScalarValue`, which defines the mapping from scalar values to minimal well-formed code unit\n  *    subsequences.\n  *  - The function `DecodeMinimalWellFormedCodeUnitSubsequence`, which defines the mapping from minimal well-formed\n  *    code unit subsequences to scalar values.\n  */\nabstract module {:options \"-functionSyntax:4\"} UnicodeEncodingForm {\n  import opened Wrappers\n\n  import Functions\n  import Seq\n  import Unicode\n\n  type CodeUnitSeq = seq<CodeUnit>\n  type WellFormedCodeUnitSeq = s: CodeUnitSeq\n    | IsWellFormedCodeUnitSequence(s)\n    witness []\n  type MinimalWellFormedCodeUnitSeq = s: CodeUnitSeq\n    | IsMinimalWellFormedCodeUnitSubsequence(s)\n    witness *\n\n  //\n  // Begin abstract items.\n  //\n\n  /**\n    * A code unit is the minimal bit combination that can represent a unit of encoded text for processing or\n    * interchange. (Section 3.9 D77.)\n    */\n  type CodeUnit\n\n  /**\n    * A well-formed Unicode code unit sequence that maps to a single Unicode scalar value.\n    * (Section 3.9 D85a.)\n    */\n  function IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)\n    ensures b ==>\n              && |s| > 0\n              && forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])\n    decreases |s|\n\n  /**\n    * Returns the shortest prefix of `s` that is a minimal well-formed code unit subsequence,\n    * or None if there is no such prefix.\n    */\n  function SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)\n    ensures |s| == 0 ==> maybePrefix.None?\n    ensures (exists i | 0 < i <= |s| :: IsMinimalWellFormedCodeUnitSubsequence(s[..i])) <==>\n            && maybePrefix.Some?\n    ensures maybePrefix.Some? ==>\n              && var prefix := maybePrefix.Extract();\n              && 0 < |prefix| <= |s|\n              && prefix == s[..|prefix|]\n              && forall i | 0 < i < |prefix| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])\n\n  /**\n    * Returns the minimal well-formed code unit subsequence that this encoding form assigns to the given scalar value.\n    * The Unicode standard requires that this is injective.\n    *\n    * TODO: enforce that implementations satisfy Functions.Injective\n    */\n  function EncodeScalarValue(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n\n  /**\n    * Returns the scalar value that this encoding form assigns to the given minimal well-formed code unit subsequence.\n    */\n  function DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    ensures EncodeScalarValue(v) == m\n\n  //\n  // End abstract items.\n  //\n\n  /**\n    * If `ms` is the concatenation of a minimal well-formed code unit subsequence `m` and a code unit sequence `s`,\n    * then the shortest minimal well-formed code unit subsequence prefix of `ms` is simply `m`.\n    */\n  lemma LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m: MinimalWellFormedCodeUnitSeq, s: CodeUnitSeq)\n    ensures SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + s) == Some(m)\n  {\n    var ms := m + s;\n    assert IsMinimalWellFormedCodeUnitSubsequence(ms[..|m|]);\n    var prefix := SplitPrefixMinimalWellFormedCodeUnitSubsequence(ms).Extract();\n    calc ==> {\n      IsMinimalWellFormedCodeUnitSubsequence(m);\n      |prefix| <= |m|;\n      prefix == ms[..|prefix|] == m[..|prefix|] == m;\n    }\n  }\n\n  /**\n    * Returns the unique partition of the given code unit sequence into minimal well-formed code unit subsequences,\n    * or None if no such partition exists.\n    */\n  function PartitionCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeParts: Option<seq<MinimalWellFormedCodeUnitSeq>>)\n    ensures maybeParts.Some? ==> Seq.Flatten(maybeParts.Extract()) == s\n    decreases |s|\n  {\n    if s == [] then Some([])\n    else\n      var prefix :- SplitPrefixMinimalWellFormedCodeUnitSubsequence(s);\n      // Recursing/iterating on subsequences leads to quadratic running time in most/all Dafny runtimes as of this writing.\n      // This definition (and others in the Unicode modules) emphasizes clarity and correctness,\n      // and while the by-method implementation avoids stack overflows due to non-tail-recursive recursion,\n      // it doesn't yet avoid the subsequences.\n      // The best solution would be to ensure all Dafny runtimes implement subsequences as an O(1)\n      // operation, so this implementation would become linear.\n      var restParts :- PartitionCodeUnitSequenceChecked(s[|prefix|..]);\n      Some([prefix] + restParts)\n  } by method {\n    if s == [] {\n      return Some([]);\n    }\n    var result: seq<MinimalWellFormedCodeUnitSeq> := [];\n    var rest := s;\n    while |rest| > 0\n      invariant PartitionCodeUnitSequenceChecked(s).Some?\n           <==> PartitionCodeUnitSequenceChecked(rest).Some?\n      invariant\n        PartitionCodeUnitSequenceChecked(s).Some? ==>\n          && PartitionCodeUnitSequenceChecked(s).value\n             == result + PartitionCodeUnitSequenceChecked(rest).value\n    {\n      var prefix :- SplitPrefixMinimalWellFormedCodeUnitSubsequence(rest);\n      result := result + [prefix];\n      rest := rest[|prefix|..];\n    }\n    assert result + [] == result;\n    return Some(result);\n  }\n\n  /**\n    * Returns the unique partition of the given well-formed code unit sequence into minimal well-formed code unit\n    * subsequences.\n    */\n  function PartitionCodeUnitSequence(s: WellFormedCodeUnitSeq): (parts: seq<MinimalWellFormedCodeUnitSeq>)\n    ensures Seq.Flatten(parts) == s\n  {\n    PartitionCodeUnitSequenceChecked(s).Extract()\n  }\n\n  /**\n    * The partitioning of a minimal well-formed code unit subsequence is the singleton sequence\n    * containing exactly the minimal well-formed code unit subsequence.\n    */\n  lemma LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq)\n    ensures PartitionCodeUnitSequenceChecked(m) == Some([m])\n  {\n    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, []);\n    calc == {\n      Some(m);\n      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + []);\n      { assert m + [] == m; }\n      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m);\n    }\n    calc == {\n      PartitionCodeUnitSequenceChecked(m);\n      Some([m] + []);\n      { assert [m] + [] == [m]; }\n      Some([m]);\n    }\n  }\n\n  /**\n    * A code unit sequence is well-formed iff it can be partitioned into a sequence of minimal well-formed code unit subsequences.\n    */\n  function IsWellFormedCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n  {\n    PartitionCodeUnitSequenceChecked(s).Some?\n  }\n\n  /**\n    * A minimal well-formed code unit subsequence is a well-formed code unit sequence.\n    */\n  lemma LemmaMinimalWellFormedCodeUnitSubsequenceIsWellFormedSequence(m: MinimalWellFormedCodeUnitSeq)\n    ensures IsWellFormedCodeUnitSequence(m)\n  {\n    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);\n  }\n\n  /**\n    * The concatenation of a minimal well-formed code unit subsequence and a well-formed code unit sequence\n    * is itself a well-formed code unit sequence.\n    */\n  lemma LemmaPrependMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq, s: WellFormedCodeUnitSeq)\n    ensures IsWellFormedCodeUnitSequence(m + s)\n  {\n    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);\n    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, s);\n    assert PartitionCodeUnitSequenceChecked(m + s).Some?;\n  }\n\n  /**\n    * The concatenation of minimal well-formed code unit subsequences is itself a well-formed code unit sequence.\n    */\n  lemma LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms: seq<MinimalWellFormedCodeUnitSeq>)\n    ensures IsWellFormedCodeUnitSequence(Seq.Flatten(ms))\n  {\n    if |ms| == 0 {\n      assert IsWellFormedCodeUnitSequence(Seq.Flatten(ms));\n    }\n    else {\n      var head := ms[0];\n      var tail := ms[1..];\n      LemmaFlattenMinimalWellFormedCodeUnitSubsequences(tail);\n      var flatTail := Seq.Flatten(tail);\n      LemmaPrependMinimalWellFormedCodeUnitSubsequence(head, flatTail);\n      assert IsWellFormedCodeUnitSequence(head + flatTail);\n    }\n  }\n\n  /**\n    * The concatenation of well-formed code unit sequences is itself a well-formed code unit sequence.\n    */\n  lemma LemmaConcatWellFormedCodeUnitSubsequences(s: WellFormedCodeUnitSeq, t: WellFormedCodeUnitSeq)\n    ensures IsWellFormedCodeUnitSequence(s + t)\n  {\n    var partsS := PartitionCodeUnitSequence(s);\n    var partsT := PartitionCodeUnitSequence(t);\n    var partsST := partsS + partsT;\n    Seq.LemmaFlattenConcat(partsS, partsT);\n\n    assert s + t == Seq.Flatten(partsST);\n    assert forall part | part in partsST ::\n        && |part| > 0\n        && IsMinimalWellFormedCodeUnitSubsequence(part);\n    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(partsST);\n  }\n\n  /**\n    * Returns the well-formed Unicode string that is the encoding of the given scalar value sequence.\n    */\n  function EncodeScalarSequence(vs: seq<Unicode.ScalarValue>): (s: WellFormedCodeUnitSeq)\n  {\n    var ms := Seq.Map(EncodeScalarValue, vs);\n    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms);\n    Seq.Flatten(ms)\n  }\n  by method {\n    // Optimize to to avoid allocating the intermediate unflattened sequence.\n    // We can't quite use Seq.FlatMap easily because we need to prove the result\n    // is not just a seq<CodeUnit> but a WellFormedCodeUnitSeq.\n    // TODO: We can be even more efficient by using a JSON.Utils.Vectors.Vector instead.\n    s := [];\n    ghost var unflattened: seq<MinimalWellFormedCodeUnitSeq> := [];\n    for i := |vs| downto 0\n      invariant unflattened == Seq.Map(EncodeScalarValue, vs[i..])\n      invariant s == Seq.Flatten(unflattened)\n    {\n      var next: MinimalWellFormedCodeUnitSeq := EncodeScalarValue(vs[i]);\n      unflattened := [next] + unflattened;\n      LemmaPrependMinimalWellFormedCodeUnitSubsequence(next, s);\n      s := next + s;\n    }\n  }\n\n  /**\n    * Returns the scalar value sequence encoded by the given well-formed Unicode string.\n    */\n  function DecodeCodeUnitSequence(s: WellFormedCodeUnitSeq): (vs: seq<Unicode.ScalarValue>)\n    ensures EncodeScalarSequence(vs) == s\n  {\n    var parts := PartitionCodeUnitSequence(s);\n    var vs := Seq.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);\n    calc == {\n      s;\n      Seq.Flatten(parts);\n      { assert parts == Seq.Map(EncodeScalarValue, vs); }\n      Seq.Flatten(Seq.Map(EncodeScalarValue, vs));\n      EncodeScalarSequence(vs);\n    }\n    vs\n  }\n\n  /**\n    * Returns the scalar value sequence encoded by the given code unit sequence, or None if the given Unicode string\n    * is not well-formed.\n    */\n  function DecodeCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeVs: Option<seq<Unicode.ScalarValue>>)\n    ensures IsWellFormedCodeUnitSequence(s) ==>\n              && maybeVs.Some?\n              && maybeVs.Extract() == DecodeCodeUnitSequence(s)\n    ensures !IsWellFormedCodeUnitSequence(s) ==> && maybeVs.None?\n  {\n    // IsWellFormedCodeUnitSequence and DecodeCodeUnitSequence each call PartitionCodeUnitSequence,\n    // so for efficiency we avoid recomputing the partition in the by-method.\n    if IsWellFormedCodeUnitSequence(s) then Some(DecodeCodeUnitSequence(s))\n    else None\n  }\n  by method {\n    var maybeParts := PartitionCodeUnitSequenceChecked(s);\n    if maybeParts.None? {\n      return None;\n    }\n    var parts := maybeParts.value;\n    var vs := Seq.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);\n    calc == {\n      s;\n      Seq.Flatten(parts);\n      { assert parts == Seq.Map(EncodeScalarValue, vs); }\n      Seq.Flatten(Seq.Map(EncodeScalarValue, vs));\n      EncodeScalarSequence(vs);\n    }\n    return Some(vs);\n  }\n}\n"}
{"file": "../libraries/src/Unicode/Unicode.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../Wrappers.dfy\"\ninclude \"../Collections/Sequences/Seq.dfy\"\n\n// This module implements basic functionality of Unicode 14.0.\nmodule {:options \"-functionSyntax:4\"} Unicode {\n  import opened Wrappers\n\n  import Seq\n\n  /**\n    * Any value in the Unicode codespace (a range of integers from 0 to 10FFFF_16). (Section 3.9 D9-D10)\n    */\n  type CodePoint = i: bv24 | 0 <= i <= 0x10FFFF\n\n  /**\n    * A Unicode code point in the range U+D800 to U+DBFF. (Section 3.8 D71)\n    */\n  type HighSurrogateCodePoint = p: CodePoint | HIGH_SURROGATE_MIN <= p <= HIGH_SURROGATE_MAX\n    witness HIGH_SURROGATE_MIN\n  const HIGH_SURROGATE_MIN: CodePoint := 0xD800\n  const HIGH_SURROGATE_MAX: CodePoint := 0xDBFF\n\n  /**\n    * A Unicode code point in the range U+DC00 to U+DFFF. (Section 3.8 D73)\n    */\n  type LowSurrogateCodePoint = p: CodePoint | LOW_SURROGATE_MIN <= p <= LOW_SURROGATE_MAX\n    witness LOW_SURROGATE_MIN\n  const LOW_SURROGATE_MIN: CodePoint := 0xDC00\n  const LOW_SURROGATE_MAX: CodePoint := 0xDFFF\n\n  /**\n    * Any Unicode code point except high-surrogate and low-surrogate code points. (Section 3.9 D76)\n    */\n  type ScalarValue = p: CodePoint |\n      && (p < HIGH_SURROGATE_MIN || p > HIGH_SURROGATE_MAX)\n      && (p < LOW_SURROGATE_MIN || p > LOW_SURROGATE_MAX)\n\n  const ASSIGNED_PLANES: set<bv8> := {\n    0,  // Basic Multilingual Plane\n    1,  // Supplementary Multilingual Plane\n    2,  // Supplementary Ideographic Plane\n    3,  // Tertiary Ideographic Plane\n    14, // Supplementary Special Purpose Plane\n    15, // Supplementary Private Use Area A\n    16  // Supplementary Private Use Area B\n  }\n\n  ghost predicate {:opaque} IsInAssignedPlane(i: CodePoint) {\n    var plane := (i >> 16) as bv8;\n    plane in ASSIGNED_PLANES\n  }\n\n  // These are actually supersets of the Unicode planes,\n  // since not all code points in a plane are assigned.\n  //\n  // TODO: check against the list of assigned code points, instead of only checking their plane\n  // (https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt)\n  type AssignedCodePoint = p: CodePoint | IsInAssignedPlane(p) witness *\n}\n"}
{"file": "../libraries/src/Unicode/UnicodeStringsWithUnicodeChar.dfy", "dafny": "// RUN: %verify --unicode-char:true %s\n\n///  Converting between strings and UTF-8/UTF-16\n/// =============================================\n///\n/// Implementation of `AbstractUnicodeStrings` for `--unicode-char:true`.\n/// See `UnicodeStrings.dfy` for details.\n\ninclude \"UnicodeStrings.dfy\"\ninclude \"../Wrappers.dfy\"\ninclude \"../Collections/Sequences/Seq.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} UnicodeStrings refines AbstractUnicodeStrings {\n\n  import Unicode\n  import Utf8EncodingForm\n  import Utf16EncodingForm\n\n  lemma {:vcs_split_on_every_assert} CharIsUnicodeScalarValue(c: char)\n    ensures\n      && var asBits := c as bv24;\n      && asBits <= 0x10_FFFF\n      && (0 <= asBits < Unicode.HIGH_SURROGATE_MIN || Unicode.LOW_SURROGATE_MAX < asBits)\n  {\n    assert c as int < 0x11_0000;\n    // This seems to be just too expensive to verify for such a wide bit-vector type,\n    // but is clearly true given the above.\n    assume {:axiom} c as bv24 < 0x11_0000 as bv24;\n    var asBits := c as int as bv24;\n    assert (asBits < Unicode.HIGH_SURROGATE_MIN || asBits > Unicode.LOW_SURROGATE_MAX);\n    assert asBits <= 0x10_FFFF;\n  }\n\n  lemma UnicodeScalarValueIsChar(sv: Unicode.ScalarValue)\n    ensures\n      && var asInt := sv as int;\n      && (0 <= asInt < 0xD800 || 0xE000 <= asInt < 0x11_0000)\n  {\n    var asInt := sv as int;\n    assert (asInt < 0xD800 || asInt > 0xDFFF);\n    assert (asInt < 0xDBFF || asInt > 0xDC00);\n  }\n\n  function CharAsUnicodeScalarValue(c: char): Unicode.ScalarValue {\n    CharIsUnicodeScalarValue(c);\n    c as Unicode.ScalarValue\n  }\n\n  function CharFromUnicodeScalarValue(sv: Unicode.ScalarValue): char {\n    UnicodeScalarValueIsChar(sv);\n    // TODO: Can we avoid the extra cast to int?\n    sv as int as char\n  }\n\n  function ToUTF8Checked(s: string): Option<seq<uint8>>\n    ensures ToUTF8Checked(s).Some?\n  {\n    var asCodeUnits := Seq.Map(CharAsUnicodeScalarValue, s);\n    var asUtf8CodeUnits := Utf8EncodingForm.EncodeScalarSequence(asCodeUnits);\n    var asBytes := Seq.Map(cu => cu as uint8, asUtf8CodeUnits);\n    Some(asBytes)\n  }\n\n  function FromUTF8Checked(bs: seq<uint8>): Option<string> {\n    var asCodeUnits := Seq.Map(c => c as Utf8EncodingForm.CodeUnit, bs);\n    var utf32 :- Utf8EncodingForm.DecodeCodeUnitSequenceChecked(asCodeUnits);\n    var asChars := Seq.Map(CharFromUnicodeScalarValue, utf32);\n    Some(asChars)\n  }\n\n  function ToUTF16Checked(s: string): Option<seq<uint16>>\n    ensures ToUTF16Checked(s).Some?\n  {\n    var asCodeUnits := Seq.Map(CharAsUnicodeScalarValue, s);\n    var asUtf16CodeUnits := Utf16EncodingForm.EncodeScalarSequence(asCodeUnits);\n    var asBytes := Seq.Map(cu => cu as uint16, asUtf16CodeUnits);\n    Some(asBytes)\n  }\n\n  function FromUTF16Checked(bs: seq<uint16>): Option<string> {\n    var asCodeUnits := Seq.Map(c => c as Utf16EncodingForm.CodeUnit, bs);\n    var utf32 :- Utf16EncodingForm.DecodeCodeUnitSequenceChecked(asCodeUnits);\n    var asChars := Seq.Map(CharFromUnicodeScalarValue, utf32);\n    Some(asChars)\n  }\n}\n"}
{"file": "../libraries/src/Unicode/Utf16EncodingForm.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\ninclude \"../Collections/Sequences/Seq.dfy\"\ninclude \"../Functions.dfy\"\n\ninclude \"Unicode.dfy\"\ninclude \"UnicodeEncodingForm.dfy\"\n\n// Definition of the UTF-16 Unicode Encoding Form, as specified in Section 3.9 D91.\nmodule {:options \"-functionSyntax:4\"} Utf16EncodingForm refines UnicodeEncodingForm {\n  type CodeUnit = bv16\n\n  //\n  // Definitions of well-formedness.\n  //\n\n  function IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)\n  {\n    if |s| == 1 then IsWellFormedSingleCodeUnitSequence(s)\n    else if |s| == 2 then (\n                            var b := IsWellFormedDoubleCodeUnitSequence(s);\n                            assert b ==> forall i | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);\n                            b\n                          )\n    else false\n  }\n\n  function IsWellFormedSingleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 1\n  {\n    var firstWord := s[0];\n    || 0x0 <= firstWord <= 0xD7FF\n    || 0xE000 <= firstWord <= 0xFFFF\n  }\n\n  function IsWellFormedDoubleCodeUnitSequence(s: CodeUnitSeq): (b: bool)\n    requires |s| == 2\n    ensures b ==> !IsWellFormedSingleCodeUnitSequence(s[..1])\n  {\n    var firstWord := s[0];\n    var secondWord := s[1];\n    && 0xD800 <= firstWord <= 0xDBFF\n    && 0xDC00 <= secondWord <= 0xDFFF\n  }\n\n  function SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)\n    ensures |s| == 0 ==> maybePrefix.None?\n    ensures (exists i | 0 < i <= |s| :: IsMinimalWellFormedCodeUnitSubsequence(s[..i])) <==>\n            && maybePrefix.Some?\n    ensures maybePrefix.Some? ==>\n              && var prefix := maybePrefix.Extract();\n              && 0 < |prefix| <= |s|\n              && prefix == s[..|prefix|]\n              && IsMinimalWellFormedCodeUnitSubsequence(prefix)\n  {\n    if |s| >= 1 && IsWellFormedSingleCodeUnitSequence(s[..1]) then Some(s[..1])\n    else if |s| >= 2 && IsWellFormedDoubleCodeUnitSequence(s[..2]) then Some(s[..2])\n    else None\n  }\n\n  //\n  // Encoding and decoding.\n  // See Table 3-5. UTF-16 Bit Distribution.\n  //\n\n  function EncodeScalarValue(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n  {\n    if 0x0 <= v <= 0xD7FF || 0xE000 <= v <= 0xFFFF then EncodeScalarValueSingleWord(v)\n    else EncodeScalarValueDoubleWord(v)\n  }\n\n  function EncodeScalarValueSingleWord(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n    requires\n      || 0x0 <= v <= 0xD7FF\n      || 0xE000 <= v <= 0xFFFF\n    ensures |m| == 1\n    ensures IsWellFormedSingleCodeUnitSequence(m)\n  {\n    var firstWord := v as CodeUnit;\n    [firstWord]\n  }\n\n  function EncodeScalarValueDoubleWord(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)\n    requires 0x10000 <= v <= 0x10FFFF\n    ensures |m| == 2\n    ensures IsWellFormedDoubleCodeUnitSequence(m)\n  {\n    // v = 000u uuuu / xxxx xxxx / xxxx xxxx\n    //                 1111 1122   2222 2222\n    var x2 := (v & 0x3FF) as bv10;\n    var x1 := ((v & 0xFC00) >> 10) as bv6;\n    var u := ((v & 0x1F0000) >> 16) as bv5;\n    var w := (u - 1) as bv4;\n    // encoded = 1101 10ww / wwxx xxxx / 1101 11xx / xxxx xxxx\n    //                         11 1111          22   2222 2222\n    var firstWord := 0xD800 | ((w as CodeUnit) << 6) | x1 as CodeUnit;\n    var secondWord := 0xDC00 | x2 as CodeUnit;\n    [firstWord, secondWord]\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n  {\n    if |m| == 1 then DecodeMinimalWellFormedCodeUnitSubsequenceSingleWord(m)\n    else assert |m| == 2; DecodeMinimalWellFormedCodeUnitSubsequenceDoubleWord(m)\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceSingleWord(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 1\n    ensures\n      || 0x0 <= v <= 0xD7FF\n      || 0xE000 <= v <= 0xFFFF\n    ensures EncodeScalarValueSingleWord(v) == m\n  {\n    var firstWord := m[0];\n    var x := firstWord as bv16;\n    assert EncodeScalarValueSingleWord(x as Unicode.ScalarValue) == m;\n    x as Unicode.ScalarValue\n  }\n\n  function DecodeMinimalWellFormedCodeUnitSubsequenceDoubleWord(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)\n    requires |m| == 2\n    ensures 0x10000 <= v <= 0x10FFFF\n    ensures EncodeScalarValueDoubleWord(v) == m\n  {\n    var firstWord := m[0];\n    var secondWord := m[1];\n    var x2 := (secondWord & 0x3FF) as bv24;\n    var x1 := (firstWord & 0x3F) as bv24;\n    var w := ((firstWord & 0x3C0) >> 6) as bv24;\n    var u := (w + 1) as bv24;\n    var v := (u << 16) | (x1 << 10) | x2 as Unicode.ScalarValue;\n    assert {:split_here} true;\n    assert EncodeScalarValueDoubleWord(v) == m;\n    v\n  }\n}\n"}
{"file": "../libraries/src/Unicode/UnicodeStrings.dfy", "dafny": "// RUN: %verify %s\n\n///  Converting between strings and UTF-8/UTF-16\n/// =============================================\n///\n/// This abstract module defines an interface for converting\n/// between the Dafny `string` type and sequences of UTF-8 and UTF-16\n/// codepoints, where codepoints are represents as bounded ints\n/// (`uint8` and `uint16`).\n///\n/// Because the `--unicode-char` option changes the meaning of the `char`\n/// type and hence the `string` type, there are two different concrete\n/// implementations in separate files.\n/// Only include the one that matches your value of that option!\n///\n/// If you also want to maintain code that works for either mode,\n/// you have two options:\n///\n/// 1. Implement your logic in an abstract module as well that\n///    imports this one, and define two different refining modules\n///    that import the appropriate UnicodeStrings module.\n/// 2. Do not `include` any of these three files in your source code,\n///    instead passing the appropriate file to Dafny when verifying and building,\n///    so that references to `UnicodeStrings` can be resolved.\n///    See the JSON modules as an example.\n///\n/// Option 2. avoids needing to write boilerplate refining modules,\n/// but is less IDE-friendly until we have better project configuration support.\n\ninclude \"../BoundedInts.dfy\"\ninclude \"../Wrappers.dfy\"\ninclude \"../Collections/Sequences/Seq.dfy\"\ninclude \"Utf8EncodingForm.dfy\"\ninclude \"Utf16EncodingForm.dfy\"\n\nabstract module {:options \"-functionSyntax:4\"} AbstractUnicodeStrings {\n\n  import Seq\n\n  import opened Wrappers\n  import opened BoundedInts\n\n  function ToUTF8Checked(s: string): Option<seq<uint8>>\n\n  function ASCIIToUTF8(s: string): seq<uint8>\n    requires forall i | 0 <= i < |s| :: 0 <= s[i] as int < 128\n  {\n    Seq.Map(c requires 0 <= c as int < 128 => c as uint8, s)\n  }\n\n  function FromUTF8Checked(bs: seq<uint8>): Option<string>\n\n  function ToUTF16Checked(s: string): Option<seq<uint16>>\n\n  function ASCIIToUTF16(s: string): seq<uint16>\n    requires forall i | 0 <= i < |s| :: 0 <= s[i] as int < 128\n  {\n    Seq.Map(c requires 0 <= c as int < 128 => c as uint16, s)\n  }\n\n  function FromUTF16Checked(bs: seq<uint16>): Option<string>\n}\n"}
{"file": "../libraries/src/Unicode/UnicodeStringsWithoutUnicodeChar.dfy", "dafny": "// RUN: %verify --unicode-char:false %s\n\n///  Converting between strings and UTF-8/UTF-16\n/// =============================================\n///\n/// Implementation of `AbstractUnicodeStrings` for `--unicode-char:false`.\n/// See `UnicodeStrings.dfy` for details.\n\ninclude \"UnicodeStrings.dfy\"\ninclude \"../Wrappers.dfy\"\ninclude \"../Collections/Sequences/Seq.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} UnicodeStrings refines AbstractUnicodeStrings {\n\n  import Unicode\n  import Utf8EncodingForm\n  import Utf16EncodingForm\n\n  predicate IsWellFormedString(s: string)\n    ensures |s| == 0 ==> IsWellFormedString(s)\n  {\n    Utf16EncodingForm.IsWellFormedCodeUnitSequence(Seq.Map(c => c as Utf16EncodingForm.CodeUnit, s))\n  }\n\n  function ToUTF8Checked(s: string): Option<seq<uint8>> {\n    var asCodeUnits := Seq.Map(c => c as Utf16EncodingForm.CodeUnit, s);\n    var utf32 :- Utf16EncodingForm.DecodeCodeUnitSequenceChecked(asCodeUnits);\n    var asUtf8CodeUnits := Utf8EncodingForm.EncodeScalarSequence(utf32);\n    Some(Seq.Map(c => c as byte, asUtf8CodeUnits))\n  }\n\n  function {:vcs_split_on_every_assert} FromUTF8Checked(bs: seq<uint8>): Option<string> {\n    var asCodeUnits := Seq.Map(c => c as Utf8EncodingForm.CodeUnit, bs);\n    var utf32 :- Utf8EncodingForm.DecodeCodeUnitSequenceChecked(asCodeUnits);\n    var asUtf16CodeUnits := Utf16EncodingForm.EncodeScalarSequence(utf32);\n    Some(Seq.Map(cu => cu as char, asUtf16CodeUnits))\n  }\n\n  function ToUTF16Checked(s: string): Option<seq<uint16>> {\n    if Utf16EncodingForm.IsWellFormedCodeUnitSequence(Seq.Map(c => c as Utf16EncodingForm.CodeUnit, s)) then\n      Some(Seq.Map(c => c as uint16, s))\n    else\n      None\n  }\n\n  function FromUTF16Checked(bs: seq<uint16>): Option<string> {\n    if Utf16EncodingForm.IsWellFormedCodeUnitSequence(Seq.Map(c => c as Utf16EncodingForm.CodeUnit, bs)) then\n      Some(Seq.Map(c => c as char, bs))\n    else\n      None\n  }\n}\n"}
{"file": "../libraries/src/Collections/Arrays/BinarySearch.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../Wrappers.dfy\"\ninclude \"../../Relations.dfy\"\n\nmodule BinarySearch {\n  import opened Wrappers\n  import opened Relations\n\n  method BinarySearch<T>(a: array<T>, key: T, less: (T, T) -> bool) returns (r: Option<nat>)\n    requires SortedBy(a[..], (x, y) => less(x, y) || x == y)\n    requires StrictTotalOrdering(less)\n    ensures r.Some? ==> r.value < a.Length && a[r.value] == key\n    ensures r.None? ==> key !in a[..]\n  {\n    var lo, hi : nat := 0, a.Length;\n    while lo < hi\n      invariant 0 <= lo <= hi <= a.Length\n      invariant key !in a[..lo] && key !in a[hi..]\n      invariant a[..] == old(a[..])\n    {\n      var mid := (lo + hi) / 2;\n\n      if less(key, a[mid]) {\n        hi := mid;\n      } else if less(a[mid], key) {\n        lo:= mid + 1;\n      } else {\n        return Some(mid);\n      }\n    }\n\n    return None;\n  }\n}\n"}
{"file": "../libraries/src/Collections/Sequences/Seq.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original Copyright under the following: \n *  Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../Wrappers.dfy\"\ninclude \"../../Math.dfy\"\ninclude \"MergeSort.dfy\"\ninclude \"../../Relations.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Seq {\n\n  import opened Wrappers\n  import opened MergeSort\n  import opened Relations\n  import Math\n\n  /**********************************************************\n   *\n   *  Manipulating the End of a Sequence\n   *\n   ***********************************************************/\n\n  /* Returns the first element of a non-empty sequence. */\n  function First<T>(xs: seq<T>): T\n    requires |xs| > 0\n  {\n    xs[0]\n  }\n\n  /* Returns the subsequence of a non-empty sequence obtained by\n     dropping the first element. */\n  function DropFirst<T>(xs: seq<T>): seq<T>\n    requires |xs| > 0\n  {\n    xs[1..]\n  }\n\n  /* Returns the last element of a non-empty sequence. */\n  function Last<T>(xs: seq<T>): T\n    requires |xs| > 0;\n  {\n    xs[|xs|-1]\n  }\n\n  /* Returns the subsequence of a non-empty sequence obtained by\n     dropping the last element. */\n  function DropLast<T>(xs: seq<T>): seq<T>\n    requires |xs| > 0;\n  {\n    xs[..|xs|-1]\n  }\n\n  /* The concatenation of two subsequences of a non-empty sequence, the first obtained \n     from dropping the last element, the second consisting only of the last \n     element, is the original sequence. */\n  lemma LemmaLast<T>(xs: seq<T>)\n    requires |xs| > 0;\n    ensures DropLast(xs) + [Last(xs)] == xs;\n  {\n  }\n\n  /* The last element of two concatenated sequences, the second one being non-empty, will be the \n     last element of the latter sequence. */\n  lemma LemmaAppendLast<T>(xs: seq<T>, ys: seq<T>)\n    requires 0 < |ys|\n    ensures Last(xs + ys) == Last(ys)\n  {\n  }\n\n  /* The concatenation of sequences is associative. */\n  lemma LemmaConcatIsAssociative<T>(xs: seq<T>, ys: seq<T>, zs: seq<T>)\n    ensures xs + (ys + zs) == (xs + ys) + zs;\n  {\n  }\n\n  /**********************************************************\n   *\n   *  Manipulating the Content of a Sequence\n   *\n   ***********************************************************/\n\n  /* If a predicate is true at every index of a sequence,\n     it is true for every member of the sequence as a collection.\n     Useful for converting quantifiers between the two forms\n     to satisfy a precondition in the latter form. */\n  lemma IndexingImpliesMembership<T>(p: T -> bool, xs: seq<T>)\n    requires forall i | 0 <= i < |xs| :: p(xs[i])\n    ensures forall t | t in xs :: p(t)\n  {\n  }\n\n  /* If a predicate is true for every member of a sequence as a collection,\n     it is true at every index of the sequence.\n     Useful for converting quantifiers between the two forms\n     to satisfy a precondition in the latter form. */\n  lemma MembershipImpliesIndexing<T>(p: T -> bool, xs: seq<T>)\n    requires forall t | t in xs :: p(t)\n    ensures forall i | 0 <= i < |xs| :: p(xs[i])\n  {\n  }\n\n  /* Is true if the sequence xs is a prefix of the sequence ys. */\n  ghost predicate IsPrefix<T>(xs: seq<T>, ys: seq<T>)\n    ensures IsPrefix(xs, ys) ==> (|xs| <= |ys| && xs == ys[..|xs|])\n  {\n    xs <= ys\n  }\n\n  /* Is true if the sequence xs is a suffix of the sequence ys. */\n  ghost predicate IsSuffix<T>(xs: seq<T>, ys: seq<T>)\n  {\n    && |xs| <= |ys|\n    && xs == ys[|ys|-|xs|..]\n  }\n\n  /* A sequence that is sliced at the pos-th element, concatenated \n     with that same sequence sliced from the pos-th element, is equal to the \n     original unsliced sequence. */\n  lemma LemmaSplitAt<T>(xs: seq<T>, pos: nat)\n    requires pos < |xs|;\n    ensures xs[..pos] + xs[pos..] == xs;\n  {\n  }\n\n  /* Any element in a slice is included in the original sequence. */\n  lemma LemmaElementFromSlice<T>(xs: seq<T>, xs':seq<T>, a: int, b: int, pos: nat)\n    requires 0 <= a <= b <= |xs|;\n    requires xs' == xs[a..b];\n    requires a <= pos < b;\n    ensures  pos - a < |xs'|;\n    ensures  xs'[pos-a] == xs[pos];\n  {\n  }\n\n  /* A slice (from s2..e2) of a slice (from s1..e1) of a sequence is equal to just a \n     slice (s1+s2..s1+e2) of the original sequence. */\n  lemma LemmaSliceOfSlice<T>(xs: seq<T>, s1: int, e1: int, s2: int, e2: int)\n    requires 0 <= s1 <= e1 <= |xs|;\n    requires 0 <= s2 <= e2 <= e1 - s1;\n    ensures  xs[s1..e1][s2..e2] == xs[s1+s2..s1+e2];\n  {\n    var r1 := xs[s1..e1];\n    var r2 := r1[s2..e2];\n    var r3 := xs[s1+s2..s1+e2];\n    assert |r2| == |r3|;\n    forall i {:trigger r2[i], r3[i]}| 0 <= i < |r2| ensures r2[i] == r3[i];\n    {\n    }\n  }\n\n  /* Converts a sequence to an array. */\n  method ToArray<T>(xs: seq<T>) returns (a: array<T>)\n    ensures fresh(a)\n    ensures a.Length == |xs|\n    ensures forall i :: 0 <= i < |xs| ==> a[i] == xs[i]\n  {\n    a := new T[|xs|](i requires 0 <= i < |xs| => xs[i]);\n  }\n\n  /* Converts a sequence to a set. */\n  function {:opaque} ToSet<T>(xs: seq<T>): set<T>\n  {\n    set x: T | x in xs\n  }\n\n  /* The cardinality of a set of elements is always less than or \n     equal to that of the full sequence of elements. */\n  lemma LemmaCardinalityOfSet<T>(xs: seq<T>)\n    ensures |ToSet(xs)| <= |xs|\n  {\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      assert ToSet(xs) == ToSet(DropLast(xs)) + {Last(xs)};\n      LemmaCardinalityOfSet(DropLast(xs));\n    }\n  }\n\n  /* A sequence is of length 0 if and only if its conversion to\n     a set results in the empty set. */\n  lemma LemmaCardinalityOfEmptySetIs0<T>(xs: seq<T>)\n    ensures |ToSet(xs)| == 0 <==> |xs| == 0\n  {\n    reveal ToSet();\n    if |xs| != 0 {\n      assert xs[0] in ToSet(xs);\n    }\n  }\n\n  /* Is true if there are no duplicate values in the sequence. */\n  ghost predicate {:opaque} HasNoDuplicates<T>(xs: seq<T>)\n  {\n    forall i, j :: 0 <= i < |xs| && 0 <= j < |xs| && i != j ==> xs[i] != xs[j]\n  }\n\n  /* If sequences xs and ys don't have duplicates and there are no \n     elements in common between them, then the concatenated sequence xs + ys \n     will not contain duplicates either. */\n  lemma {:timeLimitMultiplier 3} LemmaNoDuplicatesInConcat<T>(xs: seq<T>, ys: seq<T>)\n    requires HasNoDuplicates(xs);\n    requires HasNoDuplicates(ys);\n    requires multiset(xs) !! multiset(ys);\n    ensures HasNoDuplicates(xs+ys);\n  {\n    reveal HasNoDuplicates();\n    var zs := xs + ys;\n    if |zs| > 1 {\n      assert forall i :: 0 <= i < |xs| ==> zs[i] in multiset(xs);\n      assert forall j :: |xs| <= j < |zs| ==> zs[j] in multiset(ys);\n      assert forall i, j :: i != j && 0 <= i < |xs| && |xs| <= j < |zs| ==> zs[i] != zs[j];\n    }\n  }\n\n  /* A sequence with no duplicates converts to a set of the same \n     cardinality. */\n  lemma LemmaCardinalityOfSetNoDuplicates<T>(xs: seq<T>)\n    requires HasNoDuplicates(xs)\n    ensures |ToSet(xs)| == |xs|\n  {\n    reveal HasNoDuplicates();\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      LemmaCardinalityOfSetNoDuplicates(DropLast(xs));\n      assert ToSet(xs) == ToSet(DropLast(xs)) + {Last(xs)};\n    }\n  }\n\n  /* A sequence with cardinality equal to its set has no duplicates. */\n  lemma LemmaNoDuplicatesCardinalityOfSet<T>(xs: seq<T>)\n    requires |ToSet(xs)| == |xs|\n    ensures HasNoDuplicates(xs)\n  {\n    reveal HasNoDuplicates();\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      assert xs == [First(xs)] + DropFirst(xs);\n      assert ToSet(xs) == {First(xs)} + ToSet(DropFirst(xs));\n      if First(xs) in DropFirst(xs) {\n        // If there is a duplicate, then we show that |ToSet(s)| == |s| cannot hold.\n        assert ToSet(xs) == ToSet(DropFirst(xs));\n        LemmaCardinalityOfSet(DropFirst(xs));\n        assert |ToSet(xs)| <= |DropFirst(xs)|;\n      } else {\n        assert |ToSet(xs)| == 1 + |ToSet(DropFirst(xs))|;\n        LemmaNoDuplicatesCardinalityOfSet(DropFirst(xs));\n      }\n    }\n  }\n\n  /* Given a sequence with no duplicates, each element occurs only \n     once in its conversion to a multiset. */\n  lemma LemmaMultisetHasNoDuplicates<T>(xs: seq<T>)\n    requires HasNoDuplicates(xs)\n    ensures forall x | x in multiset(xs) :: multiset(xs)[x] == 1\n  {\n    if |xs| == 0 {\n    } else {\n      assert xs == DropLast(xs) + [Last(xs)];\n      assert Last(xs) !in DropLast(xs) by {\n        reveal HasNoDuplicates();\n      }\n      assert HasNoDuplicates(DropLast(xs)) by {\n        reveal HasNoDuplicates();\n      }\n      LemmaMultisetHasNoDuplicates(DropLast(xs));\n    }\n  }\n\n  /* For an element that occurs at least once in a sequence, the index of its\n     first occurrence is returned. */\n  function {:opaque} IndexOf<T(==)>(xs: seq<T>, v: T): (i: nat)\n    requires v in xs\n    ensures i < |xs| && xs[i] == v\n    ensures forall j :: 0 <= j < i ==> xs[j] != v\n  {\n    if xs[0] == v then 0 else 1 + IndexOf(xs[1..], v)\n  }\n\n  /* Returns Some(i), if an element occurs at least once in a sequence, and i is \n     the index of its first occurrence. Otherwise the return is None. */\n  function {:opaque} IndexOfOption<T(==)>(xs: seq<T>, v: T): (o: Option<nat>)\n    ensures if o.Some? then o.value < |xs| && xs[o.value] == v &&\n                            forall j :: 0 <= j < o.value ==> xs[j] != v\n            else v !in xs\n  {\n    if |xs| == 0 then None()\n    else\n    if xs[0] == v then Some(0)\n    else\n      var o' := IndexOfOption(xs[1..], v);\n      if o'.Some? then Some(o'.value + 1) else None()\n  }\n\n  /* For an element that occurs at least once in a sequence, the index of its\n     last occurrence is returned. */\n  function {:opaque} LastIndexOf<T(==)>(xs: seq<T>, v: T): (i: nat)\n    requires v in xs\n    ensures i < |xs| && xs[i] == v\n    ensures forall j :: i < j < |xs| ==> xs[j] != v\n  {\n    if xs[|xs|-1] == v then |xs| - 1 else LastIndexOf(xs[..|xs|-1], v)\n  }\n\n  /* Returns Some(i), if an element occurs at least once in a sequence, and i is \n     the index of its last occurrence. Otherwise the return is None. */\n  function {:opaque} LastIndexOfOption<T(==)>(xs: seq<T>, v: T): (o: Option<nat>)\n    ensures if o.Some? then o.value < |xs| && xs[o.value] == v &&\n                            forall j :: o.value < j < |xs| ==> xs[j] != v\n            else v !in xs\n  {\n    if |xs| == 0 then None()\n    else if xs[|xs|-1] == v then Some(|xs| - 1) else LastIndexOfOption(xs[..|xs|-1], v)\n  }\n\n  /* Returns a sequence without the element at a given position. */\n  function {:opaque} Remove<T>(xs: seq<T>, pos: nat): (ys: seq<T>)\n    requires pos < |xs|\n    ensures |ys| == |xs| - 1\n    ensures forall i {:trigger ys[i], xs[i]} | 0 <= i < pos :: ys[i] == xs[i]\n    ensures forall i {:trigger ys[i]} | pos <= i < |xs| - 1 :: ys[i] == xs[i+1]\n  {\n    xs[..pos] + xs[pos+1..]\n  }\n\n  /* If a given element occurs at least once in a sequence, the sequence without\n     its first occurrence is returned. Otherwise the same sequence is returned. */\n  function {:opaque} RemoveValue<T(==)>(xs: seq<T>, v: T): (ys: seq<T>)\n    ensures v !in xs ==> xs == ys\n    ensures v in xs ==> |multiset(ys)| == |multiset(xs)| - 1\n    ensures v in xs ==> multiset(ys)[v] == multiset(xs)[v] - 1\n    ensures HasNoDuplicates(xs) ==> HasNoDuplicates(ys) && ToSet(ys) == ToSet(xs) - {v}\n  {\n    reveal HasNoDuplicates();\n    reveal ToSet();\n    if v !in xs then xs\n    else\n      var i := IndexOf(xs, v);\n      assert xs == xs[..i] + [v] + xs[i+1..];\n      xs[..i] + xs[i+1..]\n  }\n\n  /* Inserts an element at a given position and returns the resulting (longer) sequence. */\n  function {:opaque} Insert<T>(xs: seq<T>, a: T, pos: nat): seq<T>\n    requires pos <= |xs|\n    ensures |Insert(xs, a, pos)| == |xs| + 1\n    ensures forall i {:trigger Insert(xs, a, pos)[i], xs[i]} :: 0 <= i < pos ==> Insert(xs, a, pos)[i] == xs[i]\n    ensures forall i {:trigger xs[i]} :: pos <= i < |xs| ==> Insert(xs, a, pos)[i+1] == xs[i]\n    ensures Insert(xs, a, pos)[pos] == a\n    ensures multiset(Insert(xs, a, pos)) == multiset(xs) + multiset{a}\n  {\n    assert xs == xs[..pos] + xs[pos..];\n    xs[..pos] + [a] + xs[pos..]\n  }\n\n  /* Returns the sequence that is in reverse order to a given sequence. */\n  function {:opaque} Reverse<T>(xs: seq<T>): (ys: seq<T>)\n    ensures |ys| == |xs|\n    ensures forall i {:trigger ys[i]}{:trigger xs[|xs| - i - 1]} :: 0 <= i < |xs| ==> ys[i] == xs[|xs| - i - 1]\n  {\n    if xs == [] then [] else [xs[|xs|-1]] + Reverse(xs[0 .. |xs|-1])\n  }\n\n  /* Returns a constant sequence of a given length. */\n  function {:opaque} Repeat<T>(v: T, length: nat): (xs: seq<T>)\n    ensures |xs| == length\n    ensures forall i: nat | i < |xs| :: xs[i] == v\n  {\n    if length == 0 then\n      []\n    else\n      [v] + Repeat(v, length - 1)\n  }\n\n  /* Unzips a sequence that contains pairs into two separate sequences. */\n  function {:opaque} Unzip<A,B>(xs: seq<(A, B)>): (seq<A>, seq<B>)\n    ensures |Unzip(xs).0| == |Unzip(xs).1| == |xs|\n    ensures forall i {:trigger Unzip(xs).0[i]} {:trigger Unzip(xs).1[i]}\n              :: 0 <= i < |xs| ==> (Unzip(xs).0[i], Unzip(xs).1[i]) == xs[i]\n  {\n    if |xs| == 0 then ([], [])\n    else\n      var (a, b):= Unzip(DropLast(xs));\n      (a + [Last(xs).0], b + [Last(xs).1])\n  }\n\n  /* Zips two sequences of equal length into one sequence that consists of pairs. */\n  function {:opaque} Zip<A,B>(xs: seq<A>, ys: seq<B>): seq<(A, B)>\n    requires |xs| == |ys|\n    ensures |Zip(xs, ys)| == |xs|\n    ensures forall i {:trigger Zip(xs, ys)[i]} :: 0 <= i < |Zip(xs, ys)| ==> Zip(xs, ys)[i] == (xs[i], ys[i])\n    ensures Unzip(Zip(xs, ys)).0 == xs\n    ensures Unzip(Zip(xs, ys)).1 == ys\n  {\n    if |xs| == 0 then []\n    else Zip(DropLast(xs), DropLast(ys)) + [(Last(xs), Last(ys))]\n  }\n\n  /* Unzipping and zipping a sequence results in the original sequence */\n  lemma LemmaZipOfUnzip<A,B>(xs: seq<(A,B)>)\n    ensures Zip(Unzip(xs).0, Unzip(xs).1) == xs\n  {\n  }\n\n  /**********************************************************\n   *\n   *  Extrema in Sequences\n   *\n   ***********************************************************/\n\n  /* Returns the maximum integer value in a non-empty sequence of integers. */\n  function {:opaque} Max(xs: seq<int>): int\n    requires 0 < |xs|\n    ensures forall k :: k in xs ==> Max(xs) >= k\n    ensures Max(xs) in xs\n  {\n    assert xs == [xs[0]] + xs[1..];\n    if |xs| == 1 then xs[0] else Math.Max(xs[0], Max(xs[1..]))\n  }\n\n  /* The maximum of the concatenation of two non-empty sequences is greater than or \n     equal to the maxima of its two non-empty subsequences. */\n  lemma LemmaMaxOfConcat(xs: seq<int>, ys: seq<int>)\n    requires 0 < |xs| && 0 < |ys|\n    ensures Max(xs+ys) >= Max(xs)\n    ensures Max(xs+ys) >= Max(ys)\n    ensures forall i {:trigger i in [Max(xs + ys)]} :: i in xs + ys ==> Max(xs + ys) >= i\n  {\n    reveal Max();\n    if |xs| == 1 {\n    } else {\n      assert xs[1..] + ys == (xs + ys)[1..];\n      LemmaMaxOfConcat(xs[1..], ys);\n    }\n  }\n\n  /* Returns the minimum integer value in a non-empty sequence of integers. */\n  function {:opaque} Min(xs: seq<int>): int\n    requires 0 < |xs|\n    ensures forall k :: k in xs ==> Min(xs) <= k\n    ensures Min(xs) in xs\n  {\n    assert xs == [xs[0]] + xs[1..];\n    if |xs| == 1 then xs[0] else Math.Min(xs[0], Min(xs[1..]))\n  }\n\n  /* The minimum of the concatenation of two non-empty sequences is \n     less than or equal to the minima of its two non-empty subsequences. */\n  lemma LemmaMinOfConcat(xs: seq<int>, ys: seq<int>)\n    requires 0 < |xs| && 0 < |ys|\n    ensures Min(xs+ys) <= Min(xs)\n    ensures Min(xs+ys) <= Min(ys)\n    ensures forall i :: i in xs + ys ==> Min(xs + ys) <= i\n  {\n    reveal Min();\n    if |xs| == 1 {\n    } else {\n      assert xs[1..] + ys == (xs + ys)[1..];\n      LemmaMinOfConcat(xs[1..], ys);\n    }\n  }\n\n  /* The maximum element in a non-empty sequence is greater than or equal to\n     the maxima of its non-empty subsequences. */\n  lemma LemmaSubseqMax(xs: seq<int>, from: nat, to: nat)\n    requires from < to <= |xs|\n    ensures Max(xs[from..to]) <= Max(xs)\n  {\n    var subseq := xs[from..to];\n    if Max(subseq) > Max(xs) {\n      var k :| 0 <= k < |subseq| && subseq[k] == Max(subseq);\n      assert xs[seq(|subseq|, i requires 0 <= i < |subseq| => i + from)[k]] in xs;\n      assert false;\n    }\n  }\n\n  /* The minimum element of a non-empty sequence is less than or equal \n     to the minima of its non-empty subsequences. */\n  lemma LemmaSubseqMin(xs: seq<int>, from: nat, to: nat)\n    requires from < to <= |xs|\n    ensures Min(xs[from..to]) >= Min(xs)\n  {\n    var subseq := xs[from..to];\n    if Min(subseq) < Min(xs) {\n      var k :| 0 <= k < |subseq| && subseq[k] == Min(subseq);\n      assert xs[seq(|subseq|, i requires 0 <= i < |subseq| => i + from)[k]] in xs;\n    }\n  }\n\n  /**********************************************************\n   *\n   *  Sequences of Sequences\n   *\n   ***********************************************************/\n\n  /* Flattens a sequence of sequences into a single sequence by concatenating \n     subsequences, starting from the first element. */\n  function Flatten<T>(xs: seq<seq<T>>): seq<T>\n    decreases |xs|\n  {\n    if |xs| == 0 then []\n    else xs[0] + Flatten(xs[1..])\n  }\n\n  /* Flattening sequences of sequences is distributive over concatenation. That is, concatenating\n     the flattening of two sequences of sequences is the same as flattening the \n     concatenation of two sequences of sequences. */\n  lemma LemmaFlattenConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)\n    ensures Flatten(xs + ys) == Flatten(xs) + Flatten(ys)\n  {\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      calc == {\n        Flatten(xs + ys);\n        { assert (xs + ys)[0] == xs[0];  assert (xs + ys)[1..] == xs[1..] + ys; }\n        xs[0] + Flatten(xs[1..] + ys);\n        xs[0] + Flatten(xs[1..]) + Flatten(ys);\n        Flatten(xs) + Flatten(ys);\n      }\n    }\n  }\n\n  /* Flattens a sequence of sequences into a single sequence by concatenating \n     subsequences in reverse order, i.e. starting from the last element. */\n  function FlattenReverse<T>(xs: seq<seq<T>>): seq<T>\n    decreases |xs|\n  {\n    if |xs| == 0 then []\n    else FlattenReverse(DropLast(xs)) + Last(xs)\n  }\n\n  /* Flattening sequences of sequences in reverse order is distributive over concatentation. \n     That is, concatenating the flattening of two sequences of sequences in reverse \n     order is the same as flattening the concatenation of two sequences of sequences\n     in reverse order. */\n  lemma LemmaFlattenReverseConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)\n    ensures FlattenReverse(xs + ys) == FlattenReverse(xs) + FlattenReverse(ys)\n  {\n    if |ys| == 0 {\n      assert FlattenReverse(ys) == [];\n      assert xs + ys == xs;\n    } else {\n      calc == {\n        FlattenReverse(xs + ys);\n        { assert Last(xs + ys) == Last(ys);  assert DropLast(xs + ys) == xs + DropLast(ys); }\n        FlattenReverse(xs + DropLast(ys)) + Last(ys);\n        FlattenReverse(xs) + FlattenReverse(DropLast(ys)) + Last(ys);\n        FlattenReverse(xs) + FlattenReverse(ys);\n      }\n    }\n  }\n\n  /* Flattening sequences of sequences in order (starting from the beginning)\n     and in reverse order (starting from the end) results in the same sequence. */\n  lemma LemmaFlattenAndFlattenReverseAreEquivalent<T>(xs: seq<seq<T>>)\n    ensures Flatten(xs) == FlattenReverse(xs)\n  {\n    if |xs| == 0 {\n    } else {\n      calc == {\n        FlattenReverse(xs);\n        FlattenReverse(DropLast(xs)) + Last(xs);\n        { LemmaFlattenAndFlattenReverseAreEquivalent(DropLast(xs)); }\n        Flatten(DropLast(xs)) + Last(xs);\n        Flatten(DropLast(xs)) + Flatten([Last(xs)]);\n        { LemmaFlattenConcat(DropLast(xs), [Last(xs)]);\n          assert xs == DropLast(xs) + [Last(xs)]; }\n        Flatten(xs);\n      }\n    }\n  }\n\n  /* The length of a flattened sequence of sequences xs is greater than or \n     equal to any of the lengths of the elements of xs.  */\n  lemma LemmaFlattenLengthGeSingleElementLength<T>(xs: seq<seq<T>>, i: int)\n    requires 0 <= i < |xs|\n    ensures |FlattenReverse(xs)| >= |xs[i]|\n  {\n    if i < |xs| - 1 {\n      LemmaFlattenLengthGeSingleElementLength(xs[..|xs|-1], i);\n    }\n  }\n\n  /* The length of a flattened sequence of sequences xs is less than or equal \n     to the length of xs multiplied by a number not smaller than the length of the \n     longest sequence in xs. */\n  lemma LemmaFlattenLengthLeMul<T>(xs: seq<seq<T>>, j: int)\n    requires forall i | 0 <= i < |xs| :: |xs[i]| <= j\n    ensures |FlattenReverse(xs)| <= |xs| * j\n  {\n    if |xs| == 0 {\n    } else {\n      LemmaFlattenLengthLeMul(xs[..|xs|-1], j);\n      assert |FlattenReverse(xs[..|xs|-1])| <= (|xs|-1) * j;\n    }\n  }\n\n\n  /**********************************************************\n   *\n   *  Higher-Order Sequence Functions\n   *\n   ***********************************************************/\n\n  /* Returns the sequence one obtains by applying a function to every element \n     of a sequence. */\n  function {:opaque} Map<T,R>(f: (T ~> R), xs: seq<T>): (result: seq<R>)\n    requires forall i :: 0 <= i < |xs| ==> f.requires(xs[i])\n    ensures |result| == |xs|\n    ensures forall i {:trigger result[i]} :: 0 <= i < |xs| ==> result[i] == f(xs[i]);\n    reads set i, o | 0 <= i < |xs| && o in f.reads(xs[i]) :: o\n  {\n    // This uses a sequence comprehension because it will usually be\n    // more efficient when compiled, allocating the storage for |xs| elements\n    // once instead of creating a chain of |xs| single element concatenations.\n    seq(|xs|, i requires 0 <= i < |xs| && f.requires(xs[i])\n                reads set i,o | 0 <= i < |xs| && o in f.reads(xs[i]) :: o\n    => f(xs[i]))\n  }\n\n  /* Applies a function to every element of a sequence, returning a Result value (which is a \n     failure-compatible type). Returns either a failure, or, if successful at every element, \n     the transformed sequence.  */\n  function {:opaque} MapWithResult<T, R, E>(f: (T ~> Result<R,E>), xs: seq<T>): (result: Result<seq<R>, E>)\n    requires forall i :: 0 <= i < |xs| ==> f.requires(xs[i])\n    ensures result.Success? ==>\n              && |result.value| == |xs|\n              && (forall i :: 0 <= i < |xs| ==>\n                                && f(xs[i]).Success?\n                                && result.value[i] == f(xs[i]).value)\n    reads set i, o | 0 <= i < |xs| && o in f.reads(xs[i]) :: o\n  {\n    if |xs| == 0 then Success([])\n    else\n      var head :- f(xs[0]);\n      var tail :- MapWithResult(f, xs[1..]);\n      Success([head] + tail)\n  }\n\n  /* Applying a function to a sequence  is distributive over concatenation. That is, concatenating \n     two sequences and then applying Map is the same as applying Map to each sequence separately, \n     and then concatenating the two resulting sequences. */\n  lemma {:opaque} LemmaMapDistributesOverConcat<T,R>(f: (T ~> R), xs: seq<T>, ys: seq<T>)\n    requires forall i :: 0 <= i < |xs| ==> f.requires(xs[i])\n    requires forall j :: 0 <= j < |ys| ==> f.requires(ys[j])\n    ensures Map(f, xs + ys) == Map(f, xs) + Map(f, ys)\n  {\n    reveal Map();\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      calc {\n        Map(f, xs + ys);\n        { assert (xs + ys)[0] == xs[0]; assert (xs + ys)[1..] == xs[1..] + ys; }\n        Map(f, [xs[0]]) + Map(f, xs[1..] + ys);\n        Map(f, [xs[0]]) + Map(f, xs[1..]) + Map(f, ys);\n        {assert [(xs + ys)[0]] + xs[1..] + ys == xs + ys;}\n        Map(f, xs) + Map(f, ys);\n      }\n    }\n  }\n\n  /* Returns the subsequence consisting of those elements of a sequence that satisfy a given \n     predicate. */\n  function {:opaque} Filter<T>(f: (T ~> bool), xs: seq<T>): (result: seq<T>)\n    requires forall i :: 0 <= i < |xs| ==> f.requires(xs[i])\n    ensures |result| <= |xs|\n    ensures forall i: nat :: i < |result| && f.requires(result[i]) ==> f(result[i])\n    reads set i, o | 0 <= i < |xs| && o in f.reads(xs[i]) :: o\n  {\n    if |xs| == 0 then []\n    else (if f(xs[0]) then [xs[0]] else []) + Filter(f, xs[1..])\n  }\n\n  /* Filtering a sequence is distributive over concatenation. That is, concatenating two sequences \n     and then using \"Filter\" is the same as using \"Filter\" on each sequence separately, and then \n     concatenating the two resulting sequences. */\n  lemma {:opaque} LemmaFilterDistributesOverConcat<T>(f: (T ~> bool), xs: seq<T>, ys: seq<T>)\n    requires forall i :: 0 <= i < |xs| ==> f.requires(xs[i])\n    requires forall j :: 0 <= j < |ys| ==> f.requires(ys[j])\n    ensures Filter(f, xs + ys) == Filter(f, xs) + Filter(f, ys)\n  {\n    reveal Filter();\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      calc {\n        Filter(f, xs + ys);\n        { assert {:split_here} (xs + ys)[0] == xs[0]; assert (xs + ys)[1..] == xs[1..] + ys; }\n        Filter(f, [xs[0]]) + Filter(f, xs[1..] + ys);\n        { assert Filter(f, xs[1..] + ys) == Filter(f, xs[1..]) + Filter(f, ys); }\n        Filter(f, [xs[0]]) + (Filter(f, xs[1..]) + Filter(f, ys));\n        { assert {:split_here} [(xs + ys)[0]] + (xs[1..] + ys) == xs + ys; }\n        Filter(f, xs) + Filter(f, ys);\n      }\n    }\n  }\n\n  /* Folds a sequence xs from the left (the beginning), by repeatedly acting on the accumulator\n     init via the function f. */\n  function {:opaque} FoldLeft<A,T>(f: (A, T) -> A, init: A, xs: seq<T>): A\n  {\n    if |xs| == 0 then init\n    else FoldLeft(f, f(init, xs[0]), xs[1..])\n  }\n\n  /* Folding to the left is distributive over concatenation. That is, concatenating two \n     sequences and then folding them to the left, is the same as folding to the left the \n     first sequence and using the result to fold to the left the second sequence. */\n  lemma {:opaque} LemmaFoldLeftDistributesOverConcat<A,T>(f: (A, T) -> A, init: A, xs: seq<T>, ys: seq<T>)\n    requires 0 <= |xs + ys|\n    ensures FoldLeft(f, init, xs + ys) == FoldLeft(f, FoldLeft(f, init, xs), ys)\n  {\n    reveal FoldLeft();\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      assert |xs| >= 1;\n      assert ([xs[0]] + xs[1..] + ys)[0] == xs[0];\n      calc {\n        FoldLeft(f, FoldLeft(f, init, xs), ys);\n        FoldLeft(f, FoldLeft(f, f(init, xs[0]), xs[1..]), ys);\n        { LemmaFoldLeftDistributesOverConcat(f, f(init, xs[0]), xs[1..], ys); }\n        FoldLeft(f, f(init, xs[0]), xs[1..] + ys);\n        { assert (xs + ys)[0] == xs[0];\n          assert (xs + ys)[1..] == xs[1..] + ys; }\n        FoldLeft(f, init, xs + ys);\n      }\n    }\n  }\n\n  /* Is true, if inv is an invariant under stp, which is a relational \n     version of the function f passed to fold. */\n  ghost predicate InvFoldLeft<A(!new),B(!new)>(inv: (B, seq<A>) -> bool,\n                                               stp: (B, A, B) -> bool)\n  {\n    forall x: A, xs: seq<A>, b: B, b': B ::\n      inv(b, [x] + xs) && stp(b, x, b') ==> inv(b', xs)\n  }\n\n  /* inv(b, xs) ==> inv(FoldLeft(f, b, xs), []). */\n  lemma LemmaInvFoldLeft<A,B>(inv: (B, seq<A>) -> bool,\n                              stp: (B, A, B) -> bool,\n                              f: (B, A) -> B,\n                              b: B,\n                              xs: seq<A>)\n    requires InvFoldLeft(inv, stp)\n    requires forall b, a :: stp(b, a, f(b, a))\n    requires inv(b, xs)\n    ensures inv(FoldLeft(f, b, xs), [])\n  {\n    reveal FoldLeft();\n    if xs == [] {\n    } else {\n      assert [xs[0]] + xs[1..] == xs;\n      LemmaInvFoldLeft(inv, stp, f, f(b, xs[0]), xs[1..]);\n    }\n  }\n\n  /* Folds a sequence xs from the right (the end), by acting on the accumulator init via the \n     function f. */\n  function {:opaque} FoldRight<A,T>(f: (T, A) -> A, xs: seq<T>, init: A): A\n  {\n    if |xs| == 0 then init\n    else f(xs[0], FoldRight(f, xs[1..], init))\n  }\n\n  /* Folding to the right is (contravariantly) distributive over concatenation. That is, concatenating\n     two sequences and then folding them to the right, is the same as folding to the right \n     the second sequence and using the result to fold to the right the first sequence. */\n  lemma {:opaque} LemmaFoldRightDistributesOverConcat<A,T>(f: (T, A) -> A, init: A, xs: seq<T>, ys: seq<T>)\n    requires 0 <= |xs + ys|\n    ensures FoldRight(f, xs + ys, init) == FoldRight(f, xs, FoldRight(f, ys, init))\n  {\n    reveal FoldRight();\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      calc {\n        FoldRight(f, xs, FoldRight(f, ys, init));\n        f(xs[0], FoldRight(f, xs[1..], FoldRight(f, ys, init)));\n        f(xs[0], FoldRight(f, xs[1..] + ys, init));\n        { assert (xs + ys)[0] == xs[0];\n          assert (xs +ys)[1..] == xs[1..] + ys; }\n        FoldRight(f, xs + ys, init);\n      }\n    }\n  }\n\n  /* Is true, if inv is an invariant under stp, which is a relational version\n     of the function f passed to fold. */\n  ghost predicate InvFoldRight<A(!new),B(!new)>(inv: (seq<A>, B) -> bool,\n                                                stp: (A, B, B) -> bool)\n  {\n    forall x: A, xs: seq<A>, b: B, b': B ::\n      inv(xs, b) && stp(x, b, b') ==> inv(([x] + xs), b')\n  }\n\n  /* inv([], b) ==> inv(xs, FoldRight(f, xs, b)) */\n  lemma LemmaInvFoldRight<A,B>(inv: (seq<A>, B) -> bool,\n                               stp: (A, B, B) -> bool,\n                               f: (A, B) -> B,\n                               b: B,\n                               xs: seq<A>)\n    requires InvFoldRight(inv, stp)\n    requires forall a, b :: stp(a, b, f(a, b))\n    requires inv([], b)\n    ensures inv(xs, FoldRight(f, xs, b))\n  {\n    reveal FoldRight();\n    if xs == [] {\n    } else {\n      assert [xs[0]] + xs[1..] == xs;\n    }\n  }\n\n  /* Optimized implementation of Flatten(Map(f, xs)). */\n  function FlatMap<T,R>(f: (T ~> seq<R>), xs: seq<T>): (result: seq<R>)\n    requires forall i :: 0 <= i < |xs| ==> f.requires(xs[i])\n    reads set i, o | 0 <= i < |xs| && o in f.reads(xs[i]) :: o\n  {\n    Flatten(Map(f, xs))\n  }\n  by method {\n    result := [];\n    ghost var unflattened: seq<seq<R>> := [];\n    for i := |xs| downto 0\n      invariant unflattened == Map(f, xs[i..])\n      invariant result == Flatten(unflattened)\n    {\n      var next := f(xs[i]);\n      unflattened := [next] + unflattened;\n      result := next + result;\n    }\n  }\n\n  /**********************************************************\n   *\n   *  Sets to Ordered Sequences\n   *\n   ***********************************************************/\n\n  /* Converts a set to a sequence (ghost). */\n  ghost function SetToSeqSpec<T>(s: set<T>): (xs: seq<T>)\n    ensures multiset(s) == multiset(xs)\n  {\n    if s == {} then [] else var x :| x in s; [x] + SetToSeqSpec(s - {x})\n  }\n\n  /* Converts a set to a sequence (compiled). */\n  method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)\n    ensures multiset(s) == multiset(xs)\n  {\n    xs := [];\n    var left: set<T> := s;\n    while left != {}\n      invariant multiset(left) + multiset(xs) == multiset(s)\n    {\n      var x :| x in left;\n      left := left - {x};\n      xs := xs + [x];\n    }\n  }\n\n  /* Proves that any two sequences that are sorted by a total order and that have the same elements are equal. */\n  lemma SortedUnique<T>(xs: seq<T>, ys: seq<T>, R: (T, T) -> bool)\n    requires SortedBy(xs, R)\n    requires SortedBy(ys, R)\n    requires TotalOrdering(R)\n    requires multiset(xs) == multiset(ys)\n    ensures xs == ys\n  {\n    assert |xs| == |multiset(xs)| == |multiset(ys)| == |ys|;\n    if xs == [] || ys == [] {\n    } else {\n      assert xs == [xs[0]] + xs[1..];\n      assert ys == [ys[0]] + ys[1..];\n      assert multiset(xs[1..]) == multiset(xs) - multiset{xs[0]};\n      assert multiset(ys[1..]) == multiset(ys) - multiset{ys[0]};\n      assert multiset(xs[1..]) == multiset(ys[1..]);\n      SortedUnique(xs[1..], ys[1..], R);\n    }\n  }\n\n  /* Converts a set to a sequence that is ordered w.r.t. a given total order. */\n  function SetToSortedSeq<T>(s: set<T>, R: (T, T) -> bool): (xs: seq<T>)\n    requires TotalOrdering(R)\n    ensures multiset(s) == multiset(xs)\n    ensures SortedBy(xs, R)\n  {\n    MergeSortBy(SetToSeqSpec(s), R)\n  } by method {\n    xs := SetToSeq(s);\n    xs := MergeSortBy(xs, R);\n    SortedUnique(xs, SetToSortedSeq(s, R), R);\n  }\n}\n"}
{"file": "../libraries/src/Collections/Sequences/MergeSort.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../Relations.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Seq.MergeSort {\n\n  import opened Relations\n\n  //Splits a sequence in two, sorts the two subsequences using itself, and merge the two sorted sequences using `MergeSortedWith`\n  function MergeSortBy<T>(a: seq<T>, lessThanOrEq: (T, T) -> bool): (result :seq<T>)\n    requires TotalOrdering(lessThanOrEq)\n    ensures multiset(a) == multiset(result)\n    ensures SortedBy(result, lessThanOrEq)\n  {\n    if |a| <= 1 then\n      a\n    else\n      var splitIndex := |a| / 2;\n      var left, right := a[..splitIndex], a[splitIndex..];\n\n      assert a == left + right;\n\n      var leftSorted := MergeSortBy(left, lessThanOrEq);\n      var rightSorted := MergeSortBy(right, lessThanOrEq);\n\n      MergeSortedWith(leftSorted, rightSorted, lessThanOrEq)\n  }\n\n  function {:tailrecursion} MergeSortedWith<T>(left: seq<T>, right: seq<T>, lessThanOrEq: (T, T) -> bool) : (result :seq<T>)\n    requires SortedBy(left, lessThanOrEq)\n    requires SortedBy(right, lessThanOrEq)\n    requires TotalOrdering(lessThanOrEq)\n    ensures multiset(left + right) == multiset(result)\n    ensures SortedBy(result, lessThanOrEq)\n  {\n    if |left| == 0 then\n      right\n    else if |right| == 0 then\n      left\n    else if lessThanOrEq(left[0], right[0]) then\n      LemmaNewFirstElementStillSortedBy(left[0], MergeSortedWith(left[1..], right, lessThanOrEq), lessThanOrEq);\n      assert left == [left[0]] + left[1..];\n\n      [left[0]] + MergeSortedWith(left[1..], right, lessThanOrEq)\n\n    else\n      LemmaNewFirstElementStillSortedBy(right[0], MergeSortedWith(left, right[1..], lessThanOrEq), lessThanOrEq);\n      assert right == [right[0]] + right[1..];\n\n      [right[0]] + MergeSortedWith(left, right[1..], lessThanOrEq)\n  }\n}\n"}
{"file": "../libraries/src/Collections/Sequences/LittleEndianNat.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright (c) 2020 Secure Foundations Lab\n *  SPDX-License-Identifier: MIT\n *  \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\n/* Little endian interpretation of a sequence of numbers with a given base. The\nfirst element of a sequence is the least significant position; the last\nelement is the most significant position. */\n\ninclude \"../../NonlinearArithmetic/DivMod.dfy\"\ninclude \"../../NonlinearArithmetic/Mul.dfy\"\ninclude \"../../NonlinearArithmetic/Power.dfy\"\ninclude \"Seq.dfy\"\n\nabstract module {:options \"-functionSyntax:4\"} LittleEndianNat {\n\n  import opened DivMod\n  import opened Mul\n  import opened Power\n  import opened Seq\n\n  function BASE(): nat\n    ensures BASE() > 1\n\n  type uint = i: int | 0 <= i < BASE()\n\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // ToNat definition and lemmas\n  //\n  //////////////////////////////////////////////////////////////////////////////\n\n  /* Converts a sequence to a nat beginning with the least significant position. */\n  function {:opaque} ToNatRight(xs: seq<uint>): nat\n  {\n    if |xs| == 0 then 0\n    else\n      LemmaMulNonnegativeAuto();\n      ToNatRight(DropFirst(xs)) * BASE() + First(xs)\n  }\n\n  /* Converts a sequence to a nat beginning with the most significant position. */\n  function {:opaque} ToNatLeft(xs: seq<uint>): nat\n  {\n    if |xs| == 0 then 0\n    else\n      LemmaPowPositiveAuto();\n      LemmaMulNonnegativeAuto();\n      ToNatLeft(DropLast(xs)) + Last(xs) * Pow(BASE(), |xs| - 1)\n  }\n\n  /* Given the same sequence, ToNatRight and ToNatLeft return the same nat. */\n  lemma {:vcs_split_on_every_assert} LemmaToNatLeftEqToNatRight(xs: seq<uint>)\n    ensures ToNatRight(xs) == ToNatLeft(xs)\n  {\n    reveal ToNatRight();\n    reveal ToNatLeft();\n    if xs == [] {\n    } else {\n      if DropLast(xs) == [] {\n        calc {\n          ToNatLeft(xs);\n          Last(xs) * Pow(BASE(), |xs| - 1);\n          { reveal Pow(); }\n          Last(xs);\n          First(xs);\n          { assert ToNatRight(DropFirst(xs)) == 0; }\n          ToNatRight(xs);\n        }\n      } else {\n        calc {\n          ToNatLeft(xs);\n          ToNatLeft(DropLast(xs)) + Last(xs) * Pow(BASE(), |xs| - 1);\n          { LemmaToNatLeftEqToNatRight(DropLast(xs)); }\n          ToNatRight(DropLast(xs)) + Last(xs) * Pow(BASE(), |xs| - 1);\n          ToNatRight(DropFirst(DropLast(xs))) * BASE() + First(xs) + Last(xs)\n          * Pow(BASE(), |xs| - 1);\n          { LemmaToNatLeftEqToNatRight(DropFirst(DropLast(xs))); }\n          ToNatLeft(DropFirst(DropLast(xs))) * BASE() + First(xs) + Last(xs)\n          * Pow(BASE(), |xs| - 1);\n          {\n            assert DropFirst(DropLast(xs)) == DropLast(DropFirst(xs));\n            reveal Pow();\n            LemmaMulProperties();\n          }\n          ToNatLeft(DropLast(DropFirst(xs))) * BASE() + First(xs) + Last(xs)\n          * Pow(BASE(), |xs| - 2) * BASE();\n          { LemmaMulIsDistributiveAddOtherWayAuto(); }\n          ToNatLeft(DropFirst(xs)) * BASE() + First(xs);\n          { LemmaToNatLeftEqToNatRight(DropFirst(xs)); }\n          ToNatRight(xs);\n        }\n      }\n    }\n  }\n\n  lemma LemmaToNatLeftEqToNatRightAuto()\n    ensures forall xs: seq<uint> :: ToNatRight(xs) == ToNatLeft(xs)\n  {\n    reveal ToNatRight();\n    reveal ToNatLeft();\n    forall xs: seq<uint>\n      ensures ToNatRight(xs) == ToNatLeft(xs)\n    {\n      LemmaToNatLeftEqToNatRight(xs);\n    }\n  }\n\n  /* The nat representation of a sequence of length 1 is its first (and only)\n  position. */\n  lemma LemmaSeqLen1(xs: seq<uint>)\n    requires |xs| == 1\n    ensures ToNatRight(xs) == First(xs)\n  {\n    reveal ToNatRight();\n  }\n\n  /* The nat representation of a sequence of length 2 is sum of its first\n  position and the product of its second position and BASE(). */\n  lemma LemmaSeqLen2(xs: seq<uint>)\n    requires |xs| == 2\n    ensures ToNatRight(xs) == First(xs) + xs[1] * BASE()\n  {\n    reveal ToNatRight();\n    LemmaSeqLen1(DropLast(xs));\n  }\n\n  /* Appending a zero does not change the nat representation of the sequence. */\n  lemma LemmaSeqAppendZero(xs: seq<uint>)\n    ensures ToNatRight(xs + [0]) == ToNatRight(xs)\n  {\n    reveal ToNatLeft();\n    LemmaToNatLeftEqToNatRightAuto();\n    calc {\n      ToNatRight(xs + [0]);\n      ToNatLeft(xs + [0]);\n      ToNatLeft(xs) + 0 * Pow(BASE(), |xs|);\n      { LemmaMulBasicsAuto(); }\n      ToNatLeft(xs);\n      ToNatRight(xs);\n    }\n  }\n\n  /* The nat representation of a sequence is bounded by BASE() to the power of\n  the sequence length. */\n  lemma LemmaSeqNatBound(xs: seq<uint>)\n    ensures ToNatRight(xs) < Pow(BASE(), |xs|)\n  {\n    reveal Pow();\n    if |xs| == 0 {\n      reveal ToNatRight();\n    } else {\n      var len' := |xs| - 1;\n      var pow := Pow(BASE(), len');\n      calc {\n        ToNatRight(xs);\n         { LemmaToNatLeftEqToNatRight(xs); }\n        ToNatLeft(xs);\n         { reveal ToNatLeft(); }\n        ToNatLeft(DropLast(xs)) + Last(xs) * pow;\n      <  {\n           LemmaToNatLeftEqToNatRight(DropLast(xs));\n           LemmaSeqNatBound(DropLast(xs));\n         }\n        pow + Last(xs) * pow;\n      <= {\n           LemmaPowPositiveAuto();\n           LemmaMulInequalityAuto();\n         }\n        pow + (BASE() - 1) * pow;\n         { LemmaMulIsDistributiveAuto(); }\n        Pow(BASE(), len' + 1);\n      }\n    }\n  }\n\n  /* The nat representation of a sequence can be calculated using the nat\n  representation of its prefix. */\n  lemma {:vcs_split_on_every_assert} LemmaSeqPrefix(xs: seq<uint>, i: nat)\n    requires 0 <= i <= |xs|\n    ensures ToNatRight(xs[..i]) + ToNatRight(xs[i..]) * Pow(BASE(), i) == ToNatRight(xs)\n  {\n    reveal ToNatRight();\n    reveal Pow();\n    if i == 1 {\n      assert ToNatRight(xs[..1]) == First(xs);\n    } else if i > 1 {\n      calc {\n        ToNatRight(xs[..i]) + ToNatRight(xs[i..]) * Pow(BASE(), i);\n        ToNatRight(DropFirst(xs[..i])) * BASE() + First(xs) + ToNatRight(xs[i..]) * Pow(BASE(), i);\n        {\n          assert DropFirst(xs[..i]) == DropFirst(xs)[..i-1];\n          LemmaMulProperties();\n        }\n        ToNatRight(DropFirst(xs)[..i-1]) * BASE() + First(xs) + (ToNatRight(xs[i..]) * Pow(BASE(), i - 1)) * BASE();\n        { LemmaMulIsDistributiveAddOtherWayAuto(); }\n        (ToNatRight(DropFirst(xs)[..i-1]) + ToNatRight(DropFirst(xs)[i-1..]) * Pow(BASE(), i - 1)) * BASE() + First(xs);\n        { LemmaSeqPrefix(DropFirst(xs), i - 1); }\n        ToNatRight(xs);\n      }\n    }\n  }\n\n  /* If there is an inequality between the most significant positions of two\n  sequences, then there is an inequality between the nat representations of\n  those sequences. Helper lemma for LemmaSeqNeq. */\n  lemma LemmaSeqMswInequality(xs: seq<uint>, ys: seq<uint>)\n    requires |xs| == |ys| > 0\n    requires Last(xs) < Last(ys)\n    ensures ToNatRight(xs) < ToNatRight(ys)\n  {\n    reveal ToNatLeft();\n    LemmaToNatLeftEqToNatRightAuto();\n    var len' := |xs| - 1;\n    calc {\n      ToNatRight(xs);\n      ToNatLeft(xs);\n    <  { LemmaSeqNatBound(DropLast(xs)); }\n      Pow(BASE(), len') + Last(xs) * Pow(BASE(), len');\n    == { LemmaMulIsDistributiveAuto(); }\n      (1 + Last(xs)) * Pow(BASE(), len');\n    <= { LemmaPowPositiveAuto(); LemmaMulInequalityAuto(); }\n      ToNatLeft(ys);\n      ToNatRight(ys);\n    }\n  }\n\n  /* Two sequences do not have the same nat representations if their prefixes\n  do not have the same nat representations. Helper lemma for LemmaSeqNeq. */\n  lemma LemmaSeqPrefixNeq(xs: seq<uint>, ys: seq<uint>, i: nat)\n    requires 0 <= i <= |xs| == |ys|\n    requires ToNatRight(xs[..i]) != ToNatRight(ys[..i])\n    ensures ToNatRight(xs) != ToNatRight(ys)\n    decreases |xs| - i\n  {\n    if i == |xs| {\n      assert xs[..i] == xs;\n      assert ys[..i] == ys;\n    } else {\n      if xs[i] == ys[i] {\n        reveal ToNatLeft();\n        assert DropLast(xs[..i+1]) == xs[..i];\n        assert DropLast(ys[..i+1]) == ys[..i];\n\n        LemmaToNatLeftEqToNatRightAuto();\n        assert ToNatRight(xs[..i+1]) == ToNatLeft(xs[..i+1]);\n      } else if xs[i] < ys[i] {\n        LemmaSeqMswInequality(xs[..i+1], ys[..i+1]);\n      } else {\n        LemmaSeqMswInequality(ys[..i+1], xs[..i+1]);\n      }\n      reveal ToNatRight();\n      LemmaSeqPrefixNeq(xs, ys, i + 1);\n    }\n  }\n\n  /* If two sequences of the same length are not equal, their nat\n  representations are not equal. */\n  lemma LemmaSeqNeq(xs: seq<uint>, ys: seq<uint>)\n    requires |xs| == |ys|\n    requires xs != ys\n    ensures ToNatRight(xs) != ToNatRight(ys)\n  {\n    ghost var i: nat, n: nat := 0, |xs|;\n\n    while i < n\n      invariant 0 <= i < n\n      invariant xs[..i] == ys[..i]\n    {\n      if xs[i] != ys[i] {\n        break;\n      }\n      i := i + 1;\n    }\n    assert ToNatLeft(xs[..i]) == ToNatLeft(ys[..i]);\n\n    reveal ToNatLeft();\n    assert xs[..i+1][..i] == xs[..i];\n    assert ys[..i+1][..i] == ys[..i];\n    LemmaPowPositiveAuto();\n    LemmaMulStrictInequalityAuto();\n    assert ToNatLeft(xs[..i+1]) != ToNatLeft(ys[..i+1]);\n    LemmaToNatLeftEqToNatRightAuto();\n\n    LemmaSeqPrefixNeq(xs, ys, i+1);\n  }\n\n  /* If the nat representations of two sequences of the same length are equal\n  to each other, the sequences are the same. */\n  lemma LemmaSeqEq(xs: seq<uint>, ys: seq<uint>)\n    requires |xs| == |ys|\n    requires ToNatRight(xs) == ToNatRight(ys)\n    ensures xs == ys\n  {\n    calc ==> {\n      xs != ys;\n      { LemmaSeqNeq(xs, ys); }\n      ToNatRight(xs) != ToNatRight(ys);\n      false;\n    }\n  }\n\n  /* The nat representation of a sequence and its least significant position are\n  congruent. */\n  lemma LemmaSeqLswModEquivalence(xs: seq<uint>)\n    requires |xs| >= 1;\n    ensures IsModEquivalent(ToNatRight(xs), First(xs), BASE());\n  {\n    if |xs| == 1 {\n      LemmaSeqLen1(xs);\n      LemmaModEquivalenceAuto();\n    } else {\n      assert IsModEquivalent(ToNatRight(xs), First(xs), BASE()) by {\n        reveal ToNatRight();\n        calc ==> {\n          true;\n          { LemmaModEquivalence(ToNatRight(xs), ToNatRight(DropFirst(xs)) * BASE() + First(xs), BASE()); }\n          IsModEquivalent(ToNatRight(xs), ToNatRight(DropFirst(xs)) * BASE() + First(xs), BASE());\n          { LemmaModMultiplesBasicAuto(); }\n          IsModEquivalent(ToNatRight(xs), First(xs), BASE());\n        }\n      }\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // FromNat definition and lemmas\n  //\n  //////////////////////////////////////////////////////////////////////////////\n\n  /* Converts a nat to a sequence. */\n  function {:opaque} FromNat(n: nat): (xs: seq<uint>)\n  {\n    if n == 0 then []\n    else\n      LemmaDivBasicsAuto();\n      LemmaDivDecreasesAuto();\n      [n % BASE()] + FromNat(n / BASE())\n  }\n\n  /* Ensures length of the sequence generated by FromNat is less than len.\n  Helper lemma for FromNatWithLen. */\n  lemma LemmaFromNatLen(n: nat, len: nat)\n    requires Pow(BASE(), len) > n\n    ensures |FromNat(n)| <= len\n  {\n    reveal FromNat();\n    if n == 0 {\n    } else {\n      calc {\n        |FromNat(n)|;\n      == { LemmaDivBasicsAuto(); }\n        1 + |FromNat(n / BASE())|;\n      <= {\n           LemmaMultiplyDivideLtAuto();\n           LemmaDivDecreasesAuto();\n           reveal Pow();\n           LemmaFromNatLen(n / BASE(), len - 1);\n         }\n        len;\n      }\n    }\n  }\n\n  /* If we start with a nat, convert it to a sequence, and convert it back, we\n  get the same nat we started with. */\n  lemma LemmaNatSeqNat(n: nat)\n    ensures ToNatRight(FromNat(n)) == n\n    decreases n\n  {\n    reveal ToNatRight();\n    reveal FromNat();\n    if n == 0 {\n    } else {\n      calc {\n        ToNatRight(FromNat(n));\n        { LemmaDivBasicsAuto(); }\n        ToNatRight([n % BASE()] + FromNat(n / BASE()));\n        n % BASE() + ToNatRight(FromNat(n / BASE())) * BASE();\n        {\n          LemmaDivDecreasesAuto();\n          LemmaNatSeqNat(n / BASE());\n        }\n        n % BASE() + n / BASE() * BASE();\n        { LemmaFundamentalDivMod(n, BASE()); }\n        n;\n      }\n    }\n  }\n\n  /* Extends a sequence to a specified length. */\n  function {:opaque} SeqExtend(xs: seq<uint>, n: nat): (ys: seq<uint>)\n    requires |xs| <= n\n    ensures |ys| == n\n    ensures ToNatRight(ys) == ToNatRight(xs)\n    decreases n - |xs|\n  {\n    if |xs| >= n then xs else LemmaSeqAppendZero(xs); SeqExtend(xs + [0], n)\n  }\n\n  /* Extends a sequence to a length that is a multiple of n. */\n  function {:opaque} SeqExtendMultiple(xs: seq<uint>, n: nat): (ys: seq<uint>)\n    requires n > 0\n    ensures |ys| % n == 0\n    ensures ToNatRight(ys) == ToNatRight(xs)\n  {\n    var newLen := |xs| + n - (|xs| % n);\n    LemmaSubModNoopRight(|xs| + n, |xs|, n);\n    LemmaModBasicsAuto();\n    assert newLen % n == 0;\n\n    LemmaSeqNatBound(xs);\n    LemmaPowIncreasesAuto();\n    SeqExtend(xs, newLen)\n  }\n\n  /* Converts a nat to a sequence of a specified length. */\n  function {:opaque} FromNatWithLen(n: nat, len: nat): (xs: seq<uint>)\n    requires Pow(BASE(), len) > n\n    ensures |xs| == len\n    ensures ToNatRight(xs) == n\n  {\n    LemmaFromNatLen(n, len);\n    LemmaNatSeqNat(n);\n    SeqExtend(FromNat(n), len)\n  }\n\n  /* If the nat representation of a sequence is zero, then the sequence is a\n  sequence of zeros. */\n  lemma LemmaSeqZero(xs: seq<uint>)\n    requires ToNatRight(xs) == 0\n    ensures forall i :: 0 <= i < |xs| ==> xs[i] == 0\n  {\n    reveal ToNatRight();\n    if |xs| == 0 {\n    } else {\n      LemmaMulNonnegativeAuto();\n      assert First(xs) == 0;\n\n      LemmaMulNonzeroAuto();\n      LemmaSeqZero(DropFirst(xs));\n    }\n  }\n\n  /* Generates a sequence of zeros of a specified length. */\n  function {:opaque} SeqZero(len: nat): (xs: seq<uint>)\n    ensures |xs| == len\n    ensures forall i :: 0 <= i < |xs| ==> xs[i] == 0\n    ensures ToNatRight(xs) == 0\n  {\n    LemmaPowPositive(BASE(), len);\n    var xs := FromNatWithLen(0, len);\n    LemmaSeqZero(xs);\n    xs\n  }\n\n  /* If we start with a sequence, convert it to a nat, and convert it back to a\n  sequence with the same length as the original sequence, we get the same\n  sequence we started with. */\n  lemma LemmaSeqNatSeq(xs: seq<uint>)\n    ensures Pow(BASE(), |xs|) > ToNatRight(xs)\n    ensures FromNatWithLen(ToNatRight(xs), |xs|) == xs\n  {\n    reveal FromNat();\n    reveal ToNatRight();\n    LemmaSeqNatBound(xs);\n    if |xs| > 0 {\n      calc {\n        FromNatWithLen(ToNatRight(xs), |xs|) != xs;\n        { LemmaSeqNeq(FromNatWithLen(ToNatRight(xs), |xs|), xs); }\n        ToNatRight(FromNatWithLen(ToNatRight(xs), |xs|)) != ToNatRight(xs);\n        ToNatRight(xs) != ToNatRight(xs);\n        false;\n      }\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // Addition and subtraction\n  //\n  //////////////////////////////////////////////////////////////////////////////\n\n  /* Adds two sequences. */\n  function {:opaque} SeqAdd(xs: seq<uint>, ys: seq<uint>): (seq<uint>, nat)\n    requires |xs| == |ys|\n    ensures var (zs, cout) := SeqAdd(xs, ys);\n            |zs| == |xs| && 0 <= cout <= 1\n    decreases xs\n  {\n    if |xs| == 0 then ([], 0)\n    else\n      var (zs', cin) := SeqAdd(DropLast(xs), DropLast(ys));\n      var sum: int := Last(xs) + Last(ys) + cin;\n      var (sum_out, cout) := if sum < BASE() then (sum, 0)\n                             else (sum - BASE(), 1);\n      (zs' + [sum_out], cout)\n  }\n\n  /* SeqAdd returns the same value as converting the sequences to nats, then\n  adding them. */\n  lemma {:vcs_split_on_every_assert} LemmaSeqAdd(xs: seq<uint>, ys: seq<uint>, zs: seq<uint>, cout: nat)\n    requires |xs| == |ys|\n    requires SeqAdd(xs, ys) == (zs, cout)\n    ensures ToNatRight(xs) + ToNatRight(ys) == ToNatRight(zs) + cout * Pow(BASE(), |xs|)\n  {\n    reveal SeqAdd();\n    if |xs| == 0 {\n      reveal ToNatRight();\n    } else {\n      var pow := Pow(BASE(), |xs| - 1);\n      var (zs', cin) := SeqAdd(DropLast(xs), DropLast(ys));\n      var sum: int := Last(xs) + Last(ys) + cin;\n      var z := if sum < BASE() then sum else sum - BASE();\n      assert sum == z + cout * BASE();\n\n      reveal ToNatLeft();\n      LemmaToNatLeftEqToNatRightAuto();\n      calc {\n        ToNatRight(zs);\n        ToNatLeft(zs);\n        ToNatLeft(zs') + z * pow;\n        { LemmaSeqAdd(DropLast(xs), DropLast(ys), zs', cin); }\n        ToNatLeft(DropLast(xs)) + ToNatLeft(DropLast(ys)) - cin * pow + z * pow;\n        {\n          LemmaMulEquality(sum, z + cout * BASE(), pow);\n          assert sum * pow == (z + cout * BASE()) * pow;\n          LemmaMulIsDistributiveAuto();\n        }\n        ToNatLeft(xs) + ToNatLeft(ys) - cout * BASE() * pow;\n        {\n          LemmaMulIsAssociative(cout, BASE(), pow);\n          reveal Pow();\n        }\n        ToNatLeft(xs) + ToNatLeft(ys) - cout * Pow(BASE(), |xs|);\n        ToNatRight(xs) + ToNatRight(ys) - cout * Pow(BASE(), |xs|);\n      }\n    }\n  }\n\n  /* Subtracts two sequences. */\n  function {:opaque} SeqSub(xs: seq<uint>, ys: seq<uint>): (seq<uint>, nat)\n    requires |xs| == |ys|\n    ensures var (zs, cout) := SeqSub(xs, ys);\n            |zs| == |xs| && 0 <= cout <= 1\n    decreases xs\n  {\n    if |xs| == 0 then ([], 0)\n    else\n      var (zs, cin) := SeqSub(DropLast(xs), DropLast(ys));\n      var (diff_out, cout) := if Last(xs) >= Last(ys) + cin\n                              then (Last(xs) - Last(ys) - cin, 0)\n                              else (BASE() + Last(xs) - Last(ys) - cin, 1);\n      (zs + [diff_out], cout)\n  }\n\n  /* SeqSub returns the same value as converting the sequences to nats, then\n  subtracting them. */\n  lemma {:vcs_split_on_every_assert} LemmaSeqSub(xs: seq<uint>, ys: seq<uint>, zs: seq<uint>, cout: nat)\n    requires |xs| == |ys|\n    requires SeqSub(xs, ys) == (zs, cout)\n    ensures ToNatRight(xs) - ToNatRight(ys) + cout * Pow(BASE(), |xs|) == ToNatRight(zs)\n  {\n    reveal SeqSub();\n    if |xs| == 0 {\n      reveal ToNatRight();\n    } else {\n      var pow := Pow(BASE(), |xs| - 1);\n      var (zs', cin) := SeqSub(DropLast(xs), DropLast(ys));\n      var z := if Last(xs) >= Last(ys) + cin\n      then Last(xs) - Last(ys) - cin\n      else BASE() + Last(xs) - Last(ys) - cin;\n      assert cout * BASE() + Last(xs) - cin - Last(ys) == z;\n\n      reveal ToNatLeft();\n      LemmaToNatLeftEqToNatRightAuto();\n      calc {\n        ToNatRight(zs);\n        ToNatLeft(zs);\n        ToNatLeft(zs') + z * pow;\n        { LemmaSeqSub(DropLast(xs), DropLast(ys), zs', cin); }\n        ToNatLeft(DropLast(xs)) - ToNatLeft(DropLast(ys)) + cin * pow + z * pow;\n        {\n          LemmaMulEquality(cout * BASE() + Last(xs) - cin - Last(ys), z, pow);\n          assert pow * (cout * BASE() + Last(xs) - cin - Last(ys)) == pow * z;\n          LemmaMulIsDistributiveAuto();\n        }\n        ToNatLeft(xs) - ToNatLeft(ys) + cout * BASE() * pow;\n        {\n          LemmaMulIsAssociative(cout, BASE(), pow);\n          reveal Pow();\n        }\n        ToNatLeft(xs) - ToNatLeft(ys) + cout * Pow(BASE(), |xs|);\n        ToNatRight(xs) - ToNatRight(ys) + cout * Pow(BASE(), |xs|);\n      }\n    }\n  }\n\n}\n"}
{"file": "../libraries/src/Collections/Sequences/LittleEndianNatConversions.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../NonlinearArithmetic/DivMod.dfy\"\ninclude \"../../NonlinearArithmetic/Mul.dfy\"\ninclude \"../../NonlinearArithmetic/Power.dfy\"\ninclude \"Seq.dfy\"\ninclude \"LittleEndianNat.dfy\"\n\n/* Sequence with smaller base. */\nabstract module {:options \"-functionSyntax:4\"} SmallSeq refines LittleEndianNat {\n\n  function BITS(): nat\n    ensures BITS() > 1\n\n  function BASE(): nat\n  {\n    LemmaPowPositive(2, BITS() - 1);\n    LemmaPowStrictlyIncreases(2, BITS() - 1, BITS());\n    Pow(2, BITS())\n  }\n\n}\n\n/* Sequence with larger base. */\nabstract module {:options \"-functionSyntax:4\"} LargeSeq refines LittleEndianNat {\n\n  import Small : SmallSeq\n\n  function BITS(): nat\n    ensures BITS() > Small.BITS() && BITS() % Small.BITS() == 0\n\n  function BASE(): nat\n  {\n    LemmaPowPositive(2, BITS() - 1);\n    LemmaPowStrictlyIncreases(2, BITS() - 1, BITS());\n    Pow(2, BITS())\n  }\n\n}\n\nabstract module {:options \"-functionSyntax:4\"} LittleEndianNatConversions {\n\n  import opened DivMod\n  import opened Mul\n  import opened Power\n  import opened Seq\n\n  import opened Large : LargeSeq\n\n  /* Small.BASE() to the power of E is Large.BASE(). */\n  function E(): (E: nat)\n    ensures Pow(Small.BASE(), E) == Large.BASE()\n    ensures E > 0\n  {\n    LemmaDivBasicsAuto();\n    assert forall x :: x != 0 ==> 0 / x == 0;\n    LemmaPowMultipliesAuto();\n    LemmaFundamentalDivMod(Large.BITS(), Small.BITS());\n    assert Large.BITS() == Small.BITS() * (Large.BITS() / Small.BITS()) + (Large.BITS() % Small.BITS());\n    assert (Large.BITS() / Small.BITS()) != 0;\n    Large.BITS() / Small.BITS()\n  }\n\n  /* Converts a sequence from Large.BASE() to Small.BASE(). */\n  function {:opaque} ToSmall(xs: seq<Large.uint>): (ys: seq<Small.uint>)\n    ensures |ys| == |xs| * E()\n  {\n    if |xs| == 0 then []\n    else\n      LemmaMulIsDistributiveAddOtherWay(E(), 1, |xs| - 1);\n      Small.FromNatWithLen(First(xs), E()) + ToSmall(DropFirst(xs))\n  }\n\n  /* Converts a sequence from Small.BASE() to Large.BASE(). */\n  function {:opaque} ToLarge(xs: seq<Small.uint>): (ys: seq<Large.uint>)\n    requires |xs| % E() == 0\n    ensures |ys| == |xs| / E()\n  {\n    if |xs| == 0 then LemmaDivBasicsAuto(); []\n    else\n      LemmaModIsZero(|xs|, E());\n      assert |xs| >= E();\n\n      Small.LemmaSeqNatBound(xs[..E()]);\n      LemmaModSubMultiplesVanishAuto();\n      LemmaDivMinusOne(|xs|, E());\n      [Small.ToNatRight(xs[..E()]) as Large.uint] + ToLarge(xs[E()..])\n  }\n\n  /* Sequence conversion from Large.BASE() to Small.BASE() does not\n  change its nat representation. */\n  lemma LemmaToSmall(xs: seq<Large.uint>)\n    ensures Small.ToNatRight(ToSmall(xs)) == Large.ToNatRight(xs)\n  {\n    reveal Small.ToNatRight();\n    reveal Large.ToNatRight();\n    reveal ToSmall();\n    if |xs| == 0 {\n    } else {\n      calc {\n        Small.ToNatRight(ToSmall(xs));\n        Small.ToNatRight(Small.FromNatWithLen(First(xs), E()) + ToSmall(DropFirst(xs)));\n        {\n          Small.LemmaSeqPrefix(Small.FromNatWithLen(First(xs), E()) + ToSmall(DropFirst(xs)), E());\n          LemmaToSmall(DropFirst(xs));\n        }\n        First(xs) + Large.ToNatRight(DropFirst(xs)) * Pow(Small.BASE(), E());\n        { assert Pow(Small.BASE(), E()) == Large.BASE(); }\n        Large.ToNatRight(xs);\n      }\n    }\n  }\n\n  /* Sequence conversion from Small.BASE() to Large.BASE() does not\n  change its nat representation. */\n  lemma LemmaToLarge(xs: seq<Small.uint>)\n    requires |xs| % E() == 0\n    ensures Large.ToNatRight(ToLarge(xs)) == Small.ToNatRight(xs)\n  {\n    reveal Large.ToNatRight();\n    reveal Small.ToNatRight();\n    reveal ToLarge();\n    if |xs| == 0 {\n    } else {\n      calc {\n        Large.ToNatRight(ToLarge(xs));\n        {\n          LemmaModIsZero(|xs|, E());\n          LemmaModSubMultiplesVanishAuto();\n          Small.LemmaSeqNatBound(xs[..E()]);\n        }\n        Large.ToNatRight([Small.ToNatRight(xs[..E()]) as Large.uint] + ToLarge(xs[E()..]));\n        { LemmaToLarge(xs[E()..]); }\n        Small.ToNatRight(xs[..E()]) + Small.ToNatRight(xs[E()..]) * Pow(Small.BASE(), E());\n        { Small.LemmaSeqPrefix(xs, E()); }\n        Small.ToNatRight(xs);\n      }\n    }\n  }\n\n  /* ToSmall is injective. */\n  lemma LemmaToSmallIsInjective(xs: seq<Large.uint>, ys: seq<Large.uint>)\n    requires ToSmall(xs) == ToSmall(ys)\n    requires |xs| == |ys|\n    ensures xs == ys\n  {\n    LemmaToSmall(xs);\n    LemmaToSmall(ys);\n    assert Large.ToNatRight(xs) == Large.ToNatRight(ys);\n    Large.LemmaSeqEq(xs, ys);\n  }\n\n  /* ToLarge is injective. */\n  lemma LemmaToLargeIsInjective(xs: seq<Small.uint>, ys: seq<Small.uint>)\n    requires |xs| % E() == |ys| % E() == 0\n    requires ToLarge(xs) == ToLarge(ys)\n    requires |xs| == |ys|\n    ensures xs == ys\n  {\n    LemmaToLarge(xs);\n    LemmaToLarge(ys);\n    assert Small.ToNatRight(xs) == Small.ToNatRight(ys);\n    Small.LemmaSeqEq(xs, ys);\n  }\n\n  /* If we start with a Small sequence, convert it to a Large sequence,\n  and convert it back, we get the same sequence we started with. */\n  lemma LemmaSmallLargeSmall(xs: seq<Small.uint>)\n    requires |xs| % E() == 0\n    ensures ToSmall(ToLarge(xs)) == xs\n  {\n    reveal ToSmall();\n    reveal ToLarge();\n    if |xs| == 0 {\n    } else {\n      calc {\n        ToSmall(ToLarge(xs));\n        {\n          LemmaModIsZero(|xs|, E());\n          Small.LemmaSeqNatBound(xs[..E()]);\n          LemmaModSubMultiplesVanishAuto();\n        }\n        ToSmall([Small.ToNatRight(xs[..E()]) as Large.uint] + ToLarge(xs[E()..]));\n        Small.FromNatWithLen(Small.ToNatRight(xs[..E()]), E()) + ToSmall(ToLarge(xs[E()..]));\n        {\n          Small.LemmaSeqNatSeq(xs[..E()]);\n          LemmaSmallLargeSmall(xs[E()..]);\n        }\n        xs;\n      }\n    }\n  }\n\n  /* If we start with a Large sequence, convert it to a Sequence sequence,\n  and convert it back, we get the same sequence we started with. */\n  lemma LemmaLargeSmallLarge(xs: seq<Large.uint>)\n    ensures |ToSmall(xs)| % E() == 0\n    ensures ToLarge(ToSmall(xs)) == xs\n  {\n    reveal ToSmall();\n    reveal ToLarge();\n    LemmaModMultiplesBasicAuto();\n    if |xs| == 0 {\n    } else {\n      calc {\n        ToLarge(ToSmall(xs));\n        ToLarge(Small.FromNatWithLen(First(xs), E()) + ToSmall(DropFirst(xs)));\n        [Small.ToNatRight(Small.FromNatWithLen(First(xs), E())) as Large.uint] + ToLarge(ToSmall(DropFirst(xs)));\n        [First(xs)] + ToLarge(ToSmall(DropFirst(xs)));\n        { LemmaLargeSmallLarge(DropFirst(xs)); }\n        [First(xs)] + DropFirst(xs);\n        xs;\n      }\n    }\n  }\n\n}\n\n/* Conversions between sequences of uint8 and uint16. */\nmodule {:options \"-functionSyntax:4\"} Uint8_16 refines LittleEndianNatConversions {\n\n  module Uint8Seq refines SmallSeq {\n    function BITS(): nat { 8 }\n  }\n\n  module Uint16Seq refines LargeSeq {\n    import Small = Uint8Seq\n    function BITS(): nat { 16 }\n  }\n\n  import opened Large = Uint16Seq\n  import Small = Large.Small\n\n}\n\n/* Conversions between sequences of uint8 and uint32. */\nmodule {:options \"-functionSyntax:4\"} Uint8_32 refines LittleEndianNatConversions {\n\n  module Uint8Seq refines SmallSeq {\n    function BITS(): nat { 8 }\n  }\n\n  module Uint32Seq refines LargeSeq {\n    import Small = Uint8Seq\n    function BITS(): nat { 32 }\n  }\n\n  import opened Large = Uint32Seq\n  import Small = Large.Small\n\n}\n\n/* Conversions between sequences of uint8 and uint64. */\nmodule {:options \"-functionSyntax:4\"} Uint8_64 refines LittleEndianNatConversions {\n\n  module Uint8Seq refines SmallSeq {\n    function BITS(): nat { 8 }\n  }\n\n  module Uint64Seq refines LargeSeq {\n    import Small = Uint8Seq\n    function BITS(): nat { 64 }\n  }\n\n  import opened Large = Uint64Seq\n  import Small = Large.Small\n\n}\n\n/* Conversions between sequences of uint16 and uint32. */\nmodule {:options \"-functionSyntax:4\"} Uint16_32 refines LittleEndianNatConversions {\n\n  module Uint16Seq refines SmallSeq {\n    function BITS(): nat { 16 }\n  }\n\n  module Uint32Seq refines LargeSeq {\n    import Small = Uint16Seq\n    function BITS(): nat { 32 }\n  }\n\n  import opened Large = Uint32Seq\n  import Small = Large.Small\n\n}\n\n/* Conversions between sequences of uint32 and uint64. */\nmodule {:options \"-functionSyntax:4\"} Uint32_64 refines LittleEndianNatConversions {\n\n  module Uint32Seq refines SmallSeq {\n    function BITS(): nat { 32 }\n  }\n\n  module Uint64Seq refines LargeSeq {\n    import Small = Uint32Seq\n    function BITS(): nat { 64 }\n  }\n\n  import opened Large = Uint64Seq\n  import Small = Large.Small\n\n}\n"}
{"file": "../libraries/src/Collections/Sets/Isets.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original Copyright under the following: \n *  Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../Functions.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Isets {\n\n  import opened Functions\n\n  /* If all elements in iset x are in iset y, x is a subset of y. */\n  lemma LemmaSubset<T>(x: iset<T>, y: iset<T>)\n    requires forall e {:trigger e in y} :: e in x ==> e in y\n    ensures x <= y\n  {\n  }\n\n  /* Map an injective function to each element of an iset. */\n  ghost function {:opaque} Map<X(!new), Y>(xs: iset<X>, f: X-->Y): (ys: iset<Y>)\n    reads f.reads\n    requires forall x {:trigger f.requires(x)} :: f.requires(x)\n    requires Injective(f)\n    ensures forall x {:trigger f(x)} :: x in xs <==> f(x) in ys\n  {\n    var ys := iset x | x in xs :: f(x);\n    ys\n  }\n\n  /* Construct an iset using elements of another set for which a function\n  returns true. */\n  ghost function {:opaque} Filter<X(!new)>(xs: iset<X>, f: X~>bool): (ys: iset<X>)\n    reads f.reads\n    requires forall x {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)\n    ensures forall y {:trigger f(y)}{:trigger y in xs} :: y in ys <==> y in xs && f(y)\n  {\n    var ys := iset x | x in xs && f(x);\n    ys\n  }\n\n}\n"}
{"file": "../libraries/src/Collections/Sets/Sets.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original Copyright under the following: \n *  Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Copyright (c) Microsoft Corporation\n *  SPDX-License-Identifier: MIT \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../Functions.dfy\"\ninclude \"../../Relations.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Sets {\n\n  import opened Functions\n  import opened Relations\n\n  /* If all elements in set x are in set y, x is a subset of y. */\n  lemma LemmaSubset<T>(x: set<T>, y: set<T>)\n    requires forall e {:trigger e in y} :: e in x ==> e in y\n    ensures x <= y\n  {\n  }\n\n  /* If x is a subset of y, then the size of x is less than or equal to the\n  size of y. */\n  lemma LemmaSubsetSize<T>(x: set<T>, y: set<T>)\n    ensures x < y ==> |x| < |y|\n    ensures x <= y ==> |x| <= |y|\n  {\n    if x != {} {\n      var e :| e in x;\n      LemmaSubsetSize(x - {e}, y - {e});\n    }\n  }\n\n  /* If x is a subset of y and the size of x is equal to the size of y, x is\n  equal to y. */\n  lemma LemmaSubsetEquality<T>(x: set<T>, y: set<T>)\n    requires x <= y\n    requires |x| == |y|\n    ensures x == y\n    decreases x, y\n  {\n    if x == {} {\n    } else {\n      var e :| e in x;\n      LemmaSubsetEquality(x - {e}, y - {e});\n    }\n  }\n\n  /* A singleton set has a size of 1. */\n  lemma LemmaSingletonSize<T>(x: set<T>, e: T)\n    requires x == {e}\n    ensures |x| == 1\n  {\n  }\n\n  /* Elements in a singleton set are equal to each other. */\n  lemma LemmaSingletonEquality<T>(x: set<T>, a: T, b: T)\n    requires |x| == 1\n    requires a in x\n    requires b in x\n    ensures a == b\n  {\n    if a != b {\n      assert {a} < x;\n      LemmaSubsetSize({a}, x);\n      assert |{a}| < |x|;\n      assert |x| > 1;\n      assert false;\n    }\n  }\n\n  /* A singleton set has at least one element and any two elements are equal. */\n  ghost predicate IsSingleton<T>(s: set<T>) {\n    && (exists x :: x in s)\n    && (forall x, y | x in s && y in s :: x == y)\n  }\n\n  /* A set has exactly one element, if and only if, it has at least one element and any two elements are equal. */\n  lemma LemmaIsSingleton<T>(s: set<T>)\n    ensures |s| == 1 <==> IsSingleton(s)\n  {\n    if |s| == 1 {\n      forall x, y | x in s && y in s ensures x == y {\n        LemmaSingletonEquality(s, x, y);\n      }\n    }\n    if IsSingleton(s) {\n      var x :| x in s;\n      assert s == {x};\n      assert |s| == 1;\n    }\n  }\n\n  /* Non-deterministically extracts an element from a set that contains at least one element. */\n  ghost function ExtractFromNonEmptySet<T>(s: set<T>): (x: T)\n    requires |s| != 0\n    ensures x in s\n  {\n    var x :| x in s;\n    x\n  }\n\n  /* Deterministically extracts the unique element from a singleton set. In contrast to \n     `ExtractFromNonEmptySet`, this implementation compiles, as the uniqueness of the element \n     being picked can be proven. */\n  function ExtractFromSingleton<T>(s: set<T>): (x: T)\n    requires |s| == 1\n    ensures s == {x}\n  {\n    LemmaIsSingleton(s);\n    var x :| x in s;\n    x\n  }\n\n  /* If an injective function is applied to each element of a set to construct\n  another set, the two sets have the same size. */\n  lemma LemmaMapSize<X(!new), Y>(xs: set<X>, ys: set<Y>, f: X-->Y)\n    requires forall x {:trigger f.requires(x)} :: f.requires(x)\n    requires Injective(f)\n    requires forall x {:trigger f(x)} :: x in xs <==> f(x) in ys\n    requires forall y {:trigger y in ys} :: y in ys ==> exists x :: x in xs && y == f(x)\n    ensures |xs| == |ys|\n  {\n    if xs != {} {\n      var x :| x in xs;\n      var xs' := xs - {x};\n      var ys' := ys - {f(x)};\n      LemmaMapSize(xs', ys', f);\n    }\n  }\n\n  /* Map an injective function to each element of a set. */\n  function {:opaque} Map<X(!new), Y>(xs: set<X>, f: X-->Y): (ys: set<Y>)\n    reads f.reads\n    requires forall x {:trigger f.requires(x)} :: f.requires(x)\n    requires Injective(f)\n    ensures forall x {:trigger f(x)} :: x in xs <==> f(x) in ys\n    ensures |xs| == |ys|\n  {\n    var ys := set x | x in xs :: f(x);\n    LemmaMapSize(xs, ys, f);\n    ys\n  }\n\n  /* If a set ys is constructed using elements of another set xs for which a\n  function returns true, the size of ys is less than or equal to the size of\n  xs. */\n  lemma LemmaFilterSize<X>(xs: set<X>, ys: set<X>, f: X~>bool)\n    requires forall x {:trigger f.requires(x)}{:trigger x in xs} :: x in xs ==> f.requires(x)\n    requires forall y {:trigger f(y)}{:trigger y in xs} :: y in ys ==> y in xs && f(y)\n    ensures |ys| <= |xs|\n    decreases xs, ys\n  {\n    if ys != {} {\n      var y :| y in ys;\n      var xs' := xs - {y};\n      var ys' := ys - {y};\n      LemmaFilterSize(xs', ys', f);\n    }\n  }\n\n  /* Construct a set using elements of another set for which a function returns\n  true. */\n  function {:opaque} Filter<X(!new)>(xs: set<X>, f: X~>bool): (ys: set<X>)\n    reads f.reads\n    requires forall x {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)\n    ensures forall y {:trigger f(y)}{:trigger y in xs} :: y in ys <==> y in xs && f(y)\n    ensures |ys| <= |xs|\n  {\n    var ys := set x | x in xs && f(x);\n    LemmaFilterSize(xs, ys, f);\n    ys\n  }\n\n  /* The size of a union of two sets is greater than or equal to the size of\n  either individual set. */\n  lemma LemmaUnionSize<X>(xs: set<X>, ys: set<X>)\n    ensures |xs + ys| >= |xs|\n    ensures |xs + ys| >= |ys|\n  {\n    if ys == {} {\n    } else {\n      var y :| y in ys;\n      if y in xs {\n        var xr := xs - {y};\n        var yr := ys - {y};\n        assert xr + yr == xs + ys - {y};\n        LemmaUnionSize(xr, yr);\n      } else {\n        var yr := ys - {y};\n        assert xs + yr == xs + ys - {y};\n        LemmaUnionSize(xs, yr);\n      }\n    }\n  }\n\n  /* Construct a set with all integers in the range [a, b). */\n  function {:opaque} SetRange(a: int, b: int): (s: set<int>)\n    requires a <= b\n    ensures forall i {:trigger i in s} :: a <= i < b <==> i in s\n    ensures |s| == b - a\n    decreases b - a\n  {\n    if a == b then {} else {a} + SetRange(a + 1, b)\n  }\n\n  /* Construct a set with all integers in the range [0, n). */\n  function {:opaque} SetRangeZeroBound(n: int): (s: set<int>)\n    requires n >= 0\n    ensures forall i {:trigger i in s} :: 0 <= i < n <==> i in s\n    ensures |s| == n\n  {\n    SetRange(0, n)\n  }\n\n  /* If a set solely contains integers in the range [a, b), then its size is\n  bounded by b - a. */\n  lemma LemmaBoundedSetSize(x: set<int>, a: int, b: int)\n    requires forall i {:trigger i in x} :: i in x ==> a <= i < b\n    requires a <= b\n    ensures |x| <= b - a\n  {\n    var range := SetRange(a, b);\n    forall e {:trigger e in range}{:trigger e in x} | e in x\n      ensures e in range;\n    {\n    }\n    assert x <= range;\n    LemmaSubsetSize(x, range);\n  }\n\n  /** In a pre-ordered set, a greatest element is necessarily maximal. */\n  lemma LemmaGreatestImpliesMaximal<T(!new)>(R: (T, T) -> bool, max: T, s: set<T>)\n    requires PreOrdering(R)\n    ensures IsGreatest(R, max, s) ==> IsMaximal(R, max, s)\n  {\n  }\n\n  /** In a pre-ordered set, a least element is necessarily minimal. */\n  lemma LemmaLeastImpliesMinimal<T(!new)>(R: (T, T) -> bool, min: T, s: set<T>)\n    requires PreOrdering(R)\n    ensures IsLeast(R, min, s) ==> IsMinimal(R, min, s)\n  {\n  }\n\n  /** In a totally-ordered set, an element is maximal if and only if it is a greatest element. */\n  lemma LemmaMaximalEquivalentGreatest<T(!new)>(R: (T, T) -> bool, max: T, s: set<T>)\n    requires TotalOrdering(R)\n    ensures IsGreatest(R, max, s) <==> IsMaximal(R, max, s)\n  {\n  }\n\n  /** In a totally-ordered set, an element is minimal if and only if it is a least element. */\n  lemma LemmaMinimalEquivalentLeast<T(!new)>(R: (T, T) -> bool, min: T, s: set<T>)\n    requires TotalOrdering(R)\n    ensures IsLeast(R, min, s) <==> IsMinimal(R, min, s)\n  {\n  }\n\n  /** In a partially-ordered set, there exists at most one least element. */\n  lemma LemmaLeastIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)\n    requires PartialOrdering(R)\n    ensures forall min, min' | IsLeast(R, min, s) && IsLeast(R, min', s) :: min == min'\n  {}\n\n  /** In a partially-ordered set, there exists at most one greatest element. */\n  lemma LemmaGreatestIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)\n    requires PartialOrdering(R)\n    ensures forall max, max' | IsGreatest(R, max, s) && IsGreatest(R, max', s) :: max == max'\n  {}\n\n  /** In a totally-ordered set, there exists at most one minimal element. */\n  lemma LemmaMinimalIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)\n    requires TotalOrdering(R)\n    ensures forall min, min' | IsMinimal(R, min, s) && IsMinimal(R, min', s) :: min == min'\n  {}\n\n  /** In a totally-ordered set, there exists at most one maximal element. */\n  lemma LemmaMaximalIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)\n    requires TotalOrdering(R)\n    ensures forall max, max' | IsMaximal(R, max, s) && IsMaximal(R, max', s) :: max == max'\n  {}\n\n  /** Any totally-ordered set contains a unique minimal (equivalently, least) element. */\n  lemma LemmaFindUniqueMinimal<T(!new)>(R: (T, T) -> bool, s: set<T>) returns (min: T)\n    requires |s| > 0 && TotalOrdering(R)\n    ensures IsMinimal(R, min, s) && (forall min': T | IsMinimal(R, min', s) :: min == min')\n  {\n    var x :| x in s;\n    if s == {x} {\n      min := x;\n    } else {\n      var min' := LemmaFindUniqueMinimal(R, s - {x});\n      if\n      case R(min', x) => min := min';\n      case R(x, min') => min := x;\n    }\n  }\n\n  /** Any totally ordered set contains a unique maximal (equivalently, greatest) element. */\n  lemma LemmaFindUniqueMaximal<T(!new)>(R: (T, T) -> bool, s: set<T>) returns (max: T)\n    requires |s| > 0 && TotalOrdering(R)\n    ensures IsMaximal(R, max, s) && (forall max': T | IsMaximal(R, max', s) :: max == max')\n  {\n    var x :| x in s;\n    if s == {x} {\n      max := x;\n    } else {\n      var max' := LemmaFindUniqueMaximal(R, s - {x});\n      if\n      case R(max', x) => max := x;\n      case R(x, max') => max := max';\n    }\n  }\n}\n"}
{"file": "../libraries/src/Collections/Maps/Imaps.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../Wrappers.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Imaps {\n  import opened Wrappers\n\n  function Get<X, Y>(m: imap<X, Y>, x: X): Option<Y>\n  {\n    if x in m then Some(m[x]) else None\n  }\n\n  /* Remove all key-value pairs corresponding to the iset of keys provided. */\n  ghost function {:opaque} RemoveKeys<X, Y>(m: imap<X, Y>, xs: iset<X>): (m': imap<X, Y>)\n    ensures forall x {:trigger m'[x]} :: x in m && x !in xs ==> x in m' && m'[x] == m[x]\n    ensures forall x {:trigger x in m'} :: x in m' ==> x in m && x !in xs\n    ensures m'.Keys == m.Keys - xs\n  {\n    imap x | x in m && x !in xs :: m[x]\n  }\n\n  /* Remove a key-value pair. Returns unmodified imap if key is not found. */\n  ghost function {:opaque} RemoveKey<X, Y>(m: imap<X, Y>, x: X): (m': imap<X, Y>)\n    ensures m' == RemoveKeys(m, iset{x})\n    ensures forall x' {:trigger m'[x']} :: x' in m' ==> m'[x'] == m[x']\n  {\n    imap i | i in m && i != x :: m[i]\n  }\n\n  /* Keep all key-value pairs corresponding to the iset of keys provided. */\n  ghost function {:opaque} Restrict<X, Y>(m: imap<X, Y>, xs: iset<X>): (m': imap<X, Y>)\n    ensures m' == RemoveKeys(m, m.Keys - xs)\n  {\n    imap x | x in xs && x in m :: m[x]\n  }\n\n  /* True iff x maps to the same value or does not exist in m and m'. */\n  ghost predicate EqualOnKey<X, Y>(m: imap<X, Y>, m': imap<X, Y>, x: X)\n  {\n    (x !in m && x !in m') || (x in m && x in m' && m[x] == m'[x])\n  }\n\n  /* True iff m is a subset of m'. */\n  ghost predicate IsSubset<X, Y>(m: imap<X, Y>, m': imap<X, Y>)\n  {\n    && m.Keys <= m'.Keys\n    && forall x {:trigger EqualOnKey(m, m', x)}{:trigger x in m} :: x in m ==> EqualOnKey(m, m', x)\n  }\n\n  /* Union of two imaps. Does not require disjoint domains; on the intersection,\n  values from the second imap are chosen. */\n  ghost function {:opaque} Union<X, Y>(m: imap<X, Y>, m': imap<X, Y>): (r: imap<X, Y>)\n    ensures r.Keys == m.Keys + m'.Keys\n    ensures forall x {:trigger r[x]} :: x in m' ==> r[x] == m'[x]\n    ensures forall x {:trigger r[x]} :: x in m && x !in m' ==> r[x] == m[x]\n  {\n    m + m'\n  }\n\n  /* True iff an imap is injective. */\n  ghost predicate {:opaque} Injective<X, Y>(m: imap<X, Y>)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x != x' && x in m && x' in m ==> m[x] != m[x']\n  }\n\n  /* Swaps imap keys and values. Values are not required to be unique; no\n  promises on which key is chosen on the intersection. */\n  ghost function {:opaque} Invert<X, Y>(m: imap<X, Y>): imap<Y, X>\n  {\n    imap y | y in m.Values :: var x :| x in m.Keys && m[x] == y; x\n  }\n\n  /* Inverted maps are injective. */\n  lemma LemmaInvertIsInjective<X, Y>(m: imap<X, Y>)\n    ensures Injective(Invert(m))\n  {\n    reveal Injective();\n    reveal Invert();\n  }\n\n  /* True iff an imap contains all valid keys. */\n  ghost predicate {:opaque} Total<X(!new), Y>(m: imap<X, Y>)\n  {\n    forall i {:trigger m[i]}{:trigger i in m} :: i in m\n  }\n\n  /* True iff an imap is monotonic. */\n  ghost predicate {:opaque} Monotonic(m: imap<int, int>)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x in m && x' in m && x <= x' ==> m[x] <= m[x']\n  }\n\n  /* True iff an imap is monotonic. Only considers keys greater than or\n  equal to start. */\n  ghost predicate {:opaque} MonotonicFrom(m: imap<int, int>, start: int)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x in m && x' in m && start <= x <= x' ==> m[x] <= m[x']\n  }\n\n}\n"}
{"file": "../libraries/src/Collections/Maps/Maps.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Original: Copyright 2018-2021 VMware, Inc., Microsoft Inc., Carnegie Mellon University, \n *  ETH Zurich, and University of Washington\n *  SPDX-License-Identifier: BSD-2-Clause \n * \n *  Modifications and Extensions: Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\ninclude \"../../Wrappers.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} Maps {\n  import opened Wrappers\n\n  function Get<X, Y>(m: map<X, Y>, x: X): Option<Y>\n  {\n    if x in m then Some(m[x]) else None\n  }\n\n  function {:opaque} ToImap<X, Y>(m: map<X, Y>): (m': imap<X, Y>)\n    ensures forall x {:trigger m'[x]} :: x in m ==> x in m' && m'[x] == m[x]\n    ensures forall x {:trigger x in m'} :: x in m' ==> x in m\n  {\n    imap x | x in m :: m[x]\n  }\n\n  /* Remove all key-value pairs corresponding to the set of keys provided. */\n  function {:opaque} RemoveKeys<X, Y>(m: map<X, Y>, xs: set<X>): (m': map<X, Y>)\n    ensures forall x {:trigger m'[x]} :: x in m && x !in xs ==> x in m' && m'[x] == m[x]\n    ensures forall x {:trigger x in m'} :: x in m' ==> x in m && x !in xs\n    ensures m'.Keys == m.Keys - xs\n  {\n    m - xs\n  }\n\n  /* Remove a key-value pair. Returns unmodified map if key is not found. */\n  function {:opaque} Remove<X, Y>(m: map<X, Y>, x: X): (m': map<X, Y>)\n    ensures m' == RemoveKeys(m, {x})\n    ensures |m'.Keys| <= |m.Keys|\n    ensures x in m ==> |m'| == |m| - 1\n    ensures x !in m ==> |m'| == |m|\n  {\n    var m' := map x' | x' in m && x' != x :: m[x'];\n    assert m'.Keys == m.Keys - {x};\n    m'\n  }\n\n  /* Keep all key-value pairs corresponding to the set of keys provided. */\n  function {:opaque} Restrict<X, Y>(m: map<X, Y>, xs: set<X>): (m': map<X, Y>)\n    ensures m' == RemoveKeys(m, m.Keys - xs)\n  {\n    map x | x in xs && x in m :: m[x]\n  }\n\n  /* True iff x maps to the same value or does not exist in m and m'. */\n  ghost predicate EqualOnKey<X, Y>(m: map<X, Y>, m': map<X, Y>, x: X)\n  {\n    (x !in m && x !in m') || (x in m && x in m' && m[x] == m'[x])\n  }\n\n  /* True iff m is a subset of m'. */\n  ghost predicate IsSubset<X, Y>(m: map<X, Y>, m': map<X, Y>)\n  {\n    && m.Keys <= m'.Keys\n    && forall x {:trigger EqualOnKey(m, m', x)}{:trigger x in m} :: x in m ==> EqualOnKey(m, m', x)\n  }\n\n  /* Union of two maps. Does not require disjoint domains; on the intersection,\n  values from the second map are chosen. */\n  function {:opaque} Union<X, Y>(m: map<X, Y>, m': map<X, Y>): (r: map<X, Y>)\n    ensures r.Keys == m.Keys + m'.Keys\n    ensures forall x {:trigger r[x]} :: x in m' ==> r[x] == m'[x]\n    ensures forall x {:trigger r[x]} :: x in m && x !in m' ==> r[x] == m[x]\n  {\n    m + m'\n  }\n\n  /* The size of the disjoint union is equal to the sum of individual map\n  sizes. */\n  lemma LemmaDisjointUnionSize<X, Y>(m: map<X, Y>, m': map<X, Y>)\n    requires m.Keys !! m'.Keys\n    ensures |Union(m, m')| == |m| + |m'|\n  {\n    var u := Union(m, m');\n    assert |u.Keys| == |m.Keys| + |m'.Keys|;\n  }\n\n  /* True iff a map is injective. */\n  ghost predicate {:opaque} Injective<X, Y>(m: map<X, Y>)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x != x' && x in m && x' in m ==> m[x] != m[x']\n  }\n\n  /* Swaps map keys and values. Values are not required to be unique; no\n  promises on which key is chosen on the intersection. */\n  ghost function {:opaque} Invert<X, Y>(m: map<X, Y>): map<Y, X>\n  {\n    map y | y in m.Values :: var x :| x in m.Keys && m[x] == y; x\n  }\n\n  /* Inverted maps are injective. */\n  lemma LemmaInvertIsInjective<X, Y>(m: map<X, Y>)\n    ensures Injective(Invert(m))\n  {\n    reveal Injective();\n    reveal Invert();\n  }\n\n  /* True iff a map contains all valid keys. */\n  ghost predicate {:opaque} Total<X(!new), Y>(m: map<X, Y>)\n  {\n    forall i {:trigger m[i]}{:trigger i in m} :: i in m\n  }\n\n  /* True iff a map is monotonic. */\n  ghost predicate {:opaque} Monotonic(m: map<int, int>)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x in m && x' in m && x <= x' ==> m[x] <= m[x']\n  }\n\n  /* True iff a map is monotonic. Only considers keys greater than or\n  equal to start. */\n  ghost predicate {:opaque} MonotonicFrom(m: map<int, int>, start: int)\n  {\n    forall x, x' {:trigger m[x], m[x']} :: x in m && x' in m && start <= x <= x' ==> m[x] <= m[x']\n  }\n\n}\n"}
{"file": "../libraries/src/MutableMap/MutableMap.dfy", "dafny": "/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT\n *******************************************************************************/\n\n// RUN: %verify \"%s\"\n\ninclude \"../../src/Wrappers.dfy\"\n\n/**\n  *  Implements mutable maps by interfacing with external code, e.g. \"MutableMap.java\".\n  */\n\nmodule {:extern \"DafnyLibraries\"} {:options \"-functionSyntax:4\"} DafnyLibraries {\n  import opened Wrappers\n\n  /**\n    *  NOTE: Only here because of #2500; once resolved import \"../../examples/MutableMap/\n    *  MutableMapTrait.dfy\".\n    */\n  trait {:termination false} MutableMapTrait<K(==),V(==)> {\n    function content(): map<K, V>\n      reads this\n\n    method Put(k: K, v: V)\n      modifies this\n      ensures this.content() == old(this.content())[k := v]\n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values + {v}\n      ensures k !in old(this.content()).Keys ==> this.content().Values == old(this.content()).Values + {v}\n\n    function Keys(): (keys: set<K>)\n      reads this\n      ensures keys == this.content().Keys\n\n    predicate HasKey(k: K)\n      reads this\n      ensures HasKey(k) <==> k in this.content().Keys\n\n    function Values(): (values: set<V>)\n      reads this\n      ensures values == this.content().Values\n\n    function Items(): (items: set<(K,V)>)\n      reads this\n      ensures items == this.content().Items\n      ensures items == set k | k in this.content().Keys :: (k, this.content()[k])\n\n    function Select(k: K): (v: V)\n      reads this\n      requires this.HasKey(k)\n      ensures v in this.content().Values\n      ensures this.content()[k] == v\n\n    method Remove(k: K)\n      modifies this\n      ensures this.content() == old(this.content()) - {k}\n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values\n\n    function Size(): (size: int)\n      reads this\n      ensures size == |this.content().Items|\n  }\n\n  class {:extern} MutableMap<K(==),V(==)> extends MutableMapTrait<K,V> {\n    constructor {:extern} ()\n      ensures this.content() == map[]\n\n    function {:extern} content(): map<K, V>\n      reads this\n\n    method {:extern} Put(k: K, v: V)\n      modifies this\n      ensures this.content() == old(this.content())[k := v]\n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values + {v}\n      ensures k !in old(this.content()).Keys ==> this.content().Values == old(this.content()).Values + {v}\n\n    function {:extern} Keys(): (keys: set<K>)\n      reads this\n      ensures keys == this.content().Keys\n\n    predicate {:extern} HasKey(k: K)\n      reads this\n      ensures HasKey(k) <==> k in this.content().Keys\n\n    function {:extern} Values(): (values: set<V>)\n      reads this\n      ensures values == this.content().Values\n\n    function {:extern} Items(): (items: set<(K,V)>)\n      reads this\n      ensures items == this.content().Items\n      ensures items == set k | k in this.content().Keys :: (k, this.content()[k])\n\n    function {:extern} Select(k: K): (v: V)\n      reads this\n      requires this.HasKey(k)\n      ensures v in this.content().Values\n      ensures this.content()[k] == v\n\n    function SelectOpt(k: K): (o: Option<V>)\n      reads this\n      ensures o.Some? ==> (this.HasKey(k) && o.value in this.content().Values && this.content()[k] == o.value)\n      ensures o.None? ==> !this.HasKey(k)\n    {\n      if this.HasKey(k) then\n        Some(this.Select(k))\n      else\n        None\n    }\n\n    method {:extern} Remove(k: K)\n      modifies this\n      ensures this.content() == old(this.content()) - {k}\n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values\n\n    function {:extern} Size(): (size: int)\n      reads this\n      ensures size == |this.content().Items|\n  }\n}\n"}
{"file": "../libraries/src/BoundedInts.dfy", "dafny": "// RUN: %verify \"%s\"\n\nmodule {:options \"-functionSyntax:4\"} BoundedInts {\n  const TWO_TO_THE_0:   int := 1\n  const TWO_TO_THE_1:   int := 2\n  const TWO_TO_THE_2:   int := 4\n  const TWO_TO_THE_4:   int := 16\n  const TWO_TO_THE_5:   int := 32\n  const TWO_TO_THE_8:   int := 0x100\n  const TWO_TO_THE_16:  int := 0x10000\n  const TWO_TO_THE_24:  int := 0x1000000\n  const TWO_TO_THE_32:  int := 0x1_00000000\n  const TWO_TO_THE_40:  int := 0x100_00000000\n  const TWO_TO_THE_48:  int := 0x10000_00000000\n  const TWO_TO_THE_56:  int := 0x1000000_00000000\n  const TWO_TO_THE_64:  int := 0x1_00000000_00000000\n  const TWO_TO_THE_128: int := 0x1_00000000_00000000_00000000_00000000\n  const TWO_TO_THE_256: int := 0x1_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000\n  const TWO_TO_THE_512: int :=\n    0x1_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000;\n\n  newtype uint8  = x: int | 0 <= x < TWO_TO_THE_8\n  newtype uint16 = x: int | 0 <= x < TWO_TO_THE_16\n  newtype uint32 = x: int | 0 <= x < TWO_TO_THE_32\n  newtype uint64 = x: int | 0 <= x < TWO_TO_THE_64\n\n  newtype int8  = x: int  | -0x80 <= x < 0x80\n  newtype int16 = x: int  | -0x8000 <= x < 0x8000\n  newtype int32 = x: int  | -0x8000_0000 <= x < 0x8000_0000\n  newtype int64 = x: int  | -0x8000_0000_0000_0000 <= x < 0x8000_0000_0000_0000\n\n  newtype nat8 = x: int   | 0 <= x < 0x80\n  newtype nat16 = x: int  | 0 <= x < 0x8000\n  newtype nat32 = x: int  | 0 <= x < 0x8000_0000\n  newtype nat64 = x: int  | 0 <= x < 0x8000_0000_0000_0000\n\n  const UINT8_MAX:  uint8  := 0xFF\n  const UINT16_MAX: uint16 := 0xFFFF\n  const UINT32_MAX: uint32 := 0xFFFF_FFFF\n  const UINT64_MAX: uint64 := 0xFFFF_FFFF_FFFF_FFFF\n\n  const INT8_MIN:  int8  := -0x80\n  const INT8_MAX:  int8  :=  0x7F\n  const INT16_MIN: int16 := -0x8000\n  const INT16_MAX: int16 :=  0x7FFF\n  const INT32_MIN: int32 := -0x8000_0000\n  const INT32_MAX: int32 :=  0x7FFFFFFF\n  const INT64_MIN: int64 := -0x8000_0000_0000_0000\n  const INT64_MAX: int64 :=  0x7FFFFFFF_FFFFFFFF\n\n  const NAT8_MAX:  nat8  := 0x7F\n  const NAT16_MAX: nat16 := 0x7FFF\n  const NAT32_MAX: nat32 := 0x7FFFFFFF\n  const NAT64_MAX: nat64 := 0x7FFFFFFF_FFFFFFFF\n\n  type byte = uint8\n  type bytes = seq<byte>\n  newtype opt_byte = c: int | -1 <= c < TWO_TO_THE_8\n}\n"}
{"file": "../libraries/src/JSON/Spec.dfy", "dafny": "// RUN: %verify \"%s\" --unicode-char:false ../Unicode/UnicodeStringsWithoutUnicodeChar.dfy\n// RUN: %verify \"%s\" --unicode-char:true ../Unicode/UnicodeStringsWithUnicodeChar.dfy\n\n/// ================================================\n///  Serialization from Values.JSON to bytes (Spec)\n/// ================================================\n///\n/// This is the high-level spec.  For the implementation, see\n/// ``JSON.Serializer.dfy``.\n\ninclude \"../BoundedInts.dfy\"\ninclude \"../NonlinearArithmetic/Logarithm.dfy\"\ninclude \"../Collections/Sequences/Seq.dfy\"\n/// include one of these two files externally as well:\n/// \"../Unicode/UnicodeStringsWithoutUnicodeChar.dfy\"\n/// \"../Unicode/UnicodeStringsWithUnicodeChar.dfy\"\n\ninclude \"Values.dfy\"\ninclude \"Errors.dfy\"\ninclude \"Utils/Str.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Spec {\n  import opened BoundedInts\n\n  import opened Utils.Str\n  import opened Values\n  import opened Wrappers\n  import opened Errors\n  import opened UnicodeStrings\n  import opened Logarithm\n\n  import Seq\n\n  type bytes = seq<uint8>\n  type Result<+T> = SerializationResult<T>\n\n  function EscapeUnicode(c: uint16): seq<uint16> {\n    var sStr := Str.OfNat(c as nat, 16);\n    Seq.MembershipImpliesIndexing(c => 0 <= c as int < 128, sStr);\n    var s := ASCIIToUTF16(sStr);\n    assert |s| <= 4 by {\n      assert c as nat <= 0xFFFF;\n      assert Log(16, c as nat) <= Log(16, 0xFFFF) by {\n        LemmaLogIsOrdered(16, c as nat, 0xFFFF);\n      }\n      assert Log(16, 0xFFFF) == 3 by { reveal Log(); }\n    }\n    s + seq(4 - |s|, _ => ' ' as uint16)\n  }\n\n  function Escape(str: seq<uint16>, start: nat := 0): seq<uint16>\n    decreases |str| - start\n  {\n    if start >= |str| then []\n    else\n      (match str[start]\n       case 0x22 => ASCIIToUTF16(\"\\\\\\\"\") // quotation mark\n       case 0x5C => ASCIIToUTF16(\"\\\\\\\\\")  // reverse solidus\n       case 0x08 => ASCIIToUTF16(\"\\\\b\")  // backspace\n       case 0x0C => ASCIIToUTF16(\"\\\\f\")  // form feed\n       case 0x0A => ASCIIToUTF16(\"\\\\n\")  // line feed\n       case 0x0D => ASCIIToUTF16(\"\\\\r\")  // carriage return\n       case 0x09 => ASCIIToUTF16(\"\\\\t\")  // tab\n       case c =>\n      if c < 0x001F then ASCIIToUTF16(\"\\\\u\") + EscapeUnicode(c)\n      else [str[start]])\n      + Escape(str, start + 1)\n  }\n\n  function EscapeToUTF8(str: string, start: nat := 0): Result<bytes> {\n    var utf16 :- ToUTF16Checked(str).ToResult'(SerializationError.InvalidUnicode);\n    var escaped := Escape(utf16);\n    var utf32 :- FromUTF16Checked(escaped).ToResult'(SerializationError.InvalidUnicode);\n    ToUTF8Checked(utf32).ToResult'(SerializationError.InvalidUnicode)\n  }\n\n  // Can fail due to invalid UTF-16 sequences in a string when --unicode-char is off\n  function String(str: string): Result<bytes> {\n    var inBytes :- EscapeToUTF8(str);\n    Success(ASCIIToUTF8(\"\\\"\") + inBytes + ASCIIToUTF8(\"\\\"\"))\n  }\n\n  lemma OfIntOnlyASCII(n: int)\n    ensures\n      && var s := Str.OfInt(n);\n      && forall i | 0 <= i < |s| :: 0 <= s[i] as int < 128\n  {\n    var s := Str.OfInt(n);\n    forall i | 0 <= i < |s| ensures 0 <= s[i] as int < 128 {\n      if i == 0 {\n      } else {\n        var isHexDigit := c => c in HEX_DIGITS;\n        assert CharStrConversion.NumberStr(s, '-', isHexDigit);\n        assert isHexDigit(s[i]);\n      }\n    }\n  }\n\n  function IntToBytes(n: int): bytes {\n    var s := Str.OfInt(n);\n    OfIntOnlyASCII(n);\n    ASCIIToUTF8(s)\n  }\n\n  function Number(dec: Decimal): Result<bytes> {\n    Success(IntToBytes(dec.n) +\n            (if dec.e10 == 0 then []\n            else ASCIIToUTF8(\"e\") + IntToBytes(dec.e10)))\n  }\n\n  function KeyValue(kv: (string, JSON)): Result<bytes> {\n    var key :- String(kv.0);\n    var value :- JSON(kv.1);\n    Success(key + ASCIIToUTF8(\":\") + value)\n  }\n\n  function Join(sep: bytes, items: seq<Result<bytes>>): Result<bytes> {\n    if |items| == 0 then\n      Success([])\n    else\n      var first :- items[0];\n      if |items| == 1 then\n        Success(first)\n      else\n        var rest :- Join(sep, items[1..]);\n        Success(first + sep + rest)\n  }\n\n  function Object(obj: seq<(string, JSON)>): Result<bytes> {\n    var middle :- Join(ASCIIToUTF8(\",\"), seq(|obj|, i requires 0 <= i < |obj| => KeyValue(obj[i])));\n    Success(ASCIIToUTF8(\"{\") + middle + ASCIIToUTF8(\"}\"))\n  }\n\n  function Array(arr: seq<JSON>): Result<bytes> {\n    var middle :- Join(ASCIIToUTF8(\",\"), seq(|arr|, i requires 0 <= i < |arr| => JSON(arr[i])));\n    Success(ASCIIToUTF8(\"[\") + middle + ASCIIToUTF8(\"]\"))\n  }\n\n  function JSON(js: JSON): Result<bytes> {\n    match js\n    case Null => Success(ASCIIToUTF8(\"null\"))\n    case Bool(b) => Success(if b then ASCIIToUTF8(\"true\") else ASCIIToUTF8(\"false\"))\n    case String(str) => String(str)\n    case Number(dec) => Number(dec)\n    case Object(obj) => Object(obj)\n    case Array(arr) => Array(arr)\n  }\n}\n"}
{"file": "../libraries/src/JSON/ZeroCopy/API.dfy", "dafny": "// RUN: %verify \"%s\" --unicode-char:false ../../Unicode/UnicodeStringsWithoutUnicodeChar.dfy\n// RUN: %verify \"%s\" --unicode-char:true ../../Unicode/UnicodeStringsWithUnicodeChar.dfy\n\ninclude \"../Grammar.dfy\"\ninclude \"../ConcreteSyntax.Spec.dfy\"\ninclude \"Serializer.dfy\"\ninclude \"Deserializer.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.ZeroCopy.API {\n  import opened BoundedInts\n  import opened Wrappers\n\n  import opened Errors\n  import Grammar\n  import ConcreteSyntax.Spec\n  import Serializer\n  import Deserializer\n\n  function {:opaque} Serialize(js: Grammar.JSON) : (bs: SerializationResult<seq<byte>>)\n    ensures bs == Success(Spec.JSON(js))\n  {\n    Success(Serializer.Text(js).Bytes())\n  }\n\n  method SerializeAlloc(js: Grammar.JSON) returns (bs: SerializationResult<array<byte>>)\n    ensures bs.Success? ==> fresh(bs.value)\n    ensures bs.Success? ==> bs.value[..] == Spec.JSON(js)\n  {\n    bs := Serializer.Serialize(js);\n  }\n\n  method SerializeInto(js: Grammar.JSON, bs: array<byte>) returns (len: SerializationResult<uint32>)\n    modifies bs\n    ensures len.Success? ==> len.value as int <= bs.Length\n    ensures len.Success? ==> bs[..len.value] == Spec.JSON(js)\n    ensures len.Success? ==> bs[len.value..] == old(bs[len.value..])\n    ensures len.Failure? ==> unchanged(bs)\n  {\n    len := Serializer.SerializeTo(js, bs);\n  }\n\n  function {:opaque} Deserialize(bs: seq<byte>) : (js: DeserializationResult<Grammar.JSON>)\n    ensures js.Success? ==> bs == Spec.JSON(js.value)\n  {\n    Deserializer.API.OfBytes(bs)\n  }\n}\n"}
{"file": "../libraries/src/JSON/ZeroCopy/Serializer.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"../Utils/Seq.dfy\"\ninclude \"../Errors.dfy\"\ninclude \"../ConcreteSyntax.Spec.dfy\"\ninclude \"../ConcreteSyntax.SpecProperties.dfy\"\ninclude \"../Utils/Views.Writers.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.ZeroCopy.Serializer {\n  import opened BoundedInts\n  import opened Wrappers\n\n  import opened Seq = Utils.Seq\n  import opened Errors\n  import ConcreteSyntax.Spec\n  import ConcreteSyntax.SpecProperties\n  import opened Grammar\n  import opened Utils.Views.Writers\n  import opened Vs = Utils.Views.Core // DISCUSS: Module naming convention?\n\n  method Serialize(js: JSON) returns (rbs: SerializationResult<array<byte>>)\n    ensures rbs.Success? ==> fresh(rbs.value)\n    ensures rbs.Success? ==> rbs.value[..] == Spec.JSON(js)\n  {\n    var writer := Text(js);\n    :- Need(writer.Unsaturated?, OutOfMemory);\n    var bs := writer.ToArray();\n    return Success(bs);\n  }\n\n  method SerializeTo(js: JSON, dest: array<byte>) returns (len: SerializationResult<uint32>)\n    modifies dest\n    ensures len.Success? ==> len.value as int <= dest.Length\n    ensures len.Success? ==> dest[..len.value] == Spec.JSON(js)\n    ensures len.Success? ==> dest[len.value..] == old(dest[len.value..])\n    ensures len.Failure? ==> unchanged(dest)\n  {\n    var writer := Text(js);\n    :- Need(writer.Unsaturated?, OutOfMemory);\n    :- Need(writer.length as int <= dest.Length, OutOfMemory);\n    writer.CopyTo(dest);\n    return Success(writer.length);\n  }\n\n  function {:opaque} Text(js: JSON) : (wr: Writer)\n    ensures wr.Bytes() == Spec.JSON(js)\n  {\n    JSON(js)\n  }\n\n  function {:opaque} JSON(js: JSON, writer: Writer := Writer.Empty) : (wr: Writer)\n    ensures wr.Bytes() == writer.Bytes() + Spec.JSON(js)\n  {\n    Seq.Assoc2(writer.Bytes(),js.before.Bytes(), Spec.Value(js.t), js.after.Bytes());\n    writer\n    .Append(js.before)\n    .Then(wr => Value(js.t, wr))\n    .Append(js.after)\n  }\n\n  function {:opaque} {:vcs_split_on_every_assert} Value(v: Value, writer: Writer) : (wr: Writer)\n    decreases v, 4\n    ensures wr.Bytes() == writer.Bytes() + Spec.Value(v)\n  {\n    match v\n    case Null(n) => writer.Append(n)\n    case Bool(b) => var wr := writer.Append(b); wr\n    case String(str) => var wr := String(str, writer); wr\n    case Number(num) => assert Grammar.Number(num) == v by { Spec.UnfoldValueNumber(v); }  var wr := Number(num, writer); wr\n    case Object(obj) => assert Grammar.Object(obj) == v; assert Spec.Value(v) == Spec.Value(Grammar.Object(obj)) == Spec.Object(obj); var wr := Object(obj, writer); wr\n    case Array(arr) => assert Grammar.Array(arr) == v; assert Spec.Value(v) == Spec.Array(arr); var wr := Array(arr, writer); assert wr.Bytes() == writer.Bytes() + Spec.Value(v); wr\n  }\n\n  function {:opaque} String(str: jstring, writer: Writer) : (wr: Writer)\n    decreases str, 0\n    ensures wr.Bytes() == writer.Bytes() + Spec.String(str)\n  {\n    writer\n    .Append(str.lq)\n    .Append(str.contents)\n    .Append(str.rq)\n  }\n\n  function {:opaque} {:vcs_split_on_every_assert} Number(num: jnumber, writer: Writer) : (wr: Writer)\n    decreases num, 0\n    ensures wr.Bytes() == writer.Bytes() + Spec.Number(num)\n  {\n    var wr := writer.Append(num.minus).Append(num.num);\n\n    var wr := if num.frac.NonEmpty? then\n                wr.Append(num.frac.t.period).Append(num.frac.t.num)\n              else wr;\n    assert wr.Bytes() == writer.Bytes() + Spec.View(num.minus) + Spec.View(num.num) + Spec.Maybe(num.frac, Spec.Frac) by {\n      assert num.frac.Empty? ==> wr.Bytes() == writer.Bytes() + Spec.View(num.minus) + Spec.View(num.num) + [];\n    }\n\n    var wr := if num.exp.NonEmpty? then\n                wr.Append(num.exp.t.e).Append(num.exp.t.sign).Append(num.exp.t.num)\n              else wr;\n    assert wr.Bytes() == writer.Bytes() + Spec.View(num.minus) + Spec.View(num.num) + Spec.Maybe(num.frac, Spec.Frac) + Spec.Maybe(num.exp, Spec.Exp) by {\n      if num.exp.NonEmpty? {} else {\n        assert wr.Bytes() == writer.Bytes() + Spec.View(num.minus) + Spec.View(num.num) + Spec.Maybe(num.frac, Spec.Frac) + [];\n      }\n    }\n    wr\n  }\n\n  // DISCUSS: Can't be opaque, due to the lambda\n  function StructuralView(st: Structural<View>, writer: Writer) : (wr: Writer)\n    ensures wr.Bytes() == writer.Bytes() + Spec.Structural(st, Spec.View)\n  {\n    writer.Append(st.before).Append(st.t).Append(st.after)\n  }\n\n  lemma StructuralViewEns(st: Structural<View>, writer: Writer)\n    ensures StructuralView(st, writer).Bytes() == writer.Bytes() + Spec.Structural(st, Spec.View)\n  {}\n\n  lemma {:axiom} Assume(b: bool) ensures b\n\n  // FIXME refactor below to merge\n\n  lemma BracketedToObject(obj: jobject)\n    ensures Spec.Bracketed(obj, Spec.Member) == Spec.Object(obj)\n  {\n    var rMember := (d: jmember) requires d < obj => Spec.Member(d);\n    assert Spec.Bracketed(obj, Spec.Member) == Spec.Bracketed(obj, rMember) by {\n      // We call ``ConcatBytes`` with ``Spec.Member``, whereas the spec calls it\n      // with ``(d: jmember) requires d in obj.data => Spec.Member(d)``.  That's\n      // why we need an explicit cast, which is performed by the lemma below.\n      assert SpecProperties.Bracketed_Morphism_Requires(obj, Spec.Member, rMember);\n      SpecProperties.Bracketed_Morphism(obj, Spec.Member, rMember);\n    }\n    calc {\n      Spec.Bracketed(obj, Spec.Member);\n      Spec.Bracketed(obj, rMember);\n      Spec.Object(obj);\n    }\n  }\n\n  function {:opaque} Object(obj: jobject, writer: Writer) : (wr: Writer)\n    decreases obj, 3\n    ensures wr.Bytes() == writer.Bytes() + Spec.Object(obj)\n  {\n    var wr := StructuralView(obj.l, writer);\n    StructuralViewEns(obj.l, writer);\n    var wr := Members(obj, wr);\n    var wr := StructuralView(obj.r, wr);\n    Seq.Assoc2(writer.Bytes(), Spec.Structural<View>(obj.l, Spec.View), Spec.ConcatBytes(obj.data, Spec.Member), Spec.Structural<View>(obj.r, Spec.View));\n    assert wr.Bytes() == writer.Bytes() + Spec.Bracketed(obj, Spec.Member);\n    assert Spec.Bracketed(obj, Spec.Member) == Spec.Object(obj) by { BracketedToObject(obj); }\n    wr\n  }\n\n  lemma BracketedToArray(arr: jarray)\n    ensures Spec.Bracketed(arr, Spec.Item) == Spec.Array(arr)\n  {\n    var rItem := (d: jitem) requires d < arr => Spec.Item(d);\n    assert Spec.Bracketed(arr, Spec.Item) == Spec.Bracketed(arr, rItem) by {\n      assert SpecProperties.Bracketed_Morphism_Requires(arr, Spec.Item, rItem);\n      SpecProperties.Bracketed_Morphism(arr, Spec.Item, rItem);\n    }\n    calc {\n      Spec.Bracketed(arr, Spec.Item);\n      Spec.Bracketed(arr, rItem);\n      Spec.Array(arr);\n    }\n  }\n\n  function {:opaque} Array(arr: jarray, writer: Writer) : (wr: Writer)\n    decreases arr, 3\n    ensures wr.Bytes() == writer.Bytes() + Spec.Array(arr)\n  {\n    var wr := StructuralView(arr.l, writer);\n    StructuralViewEns(arr.l, writer);\n    var wr := Items(arr, wr);\n    var wr := StructuralView(arr.r, wr);\n    Seq.Assoc2(writer.Bytes(), Spec.Structural<View>(arr.l, Spec.View), Spec.ConcatBytes(arr.data, Spec.Item), Spec.Structural<View>(arr.r, Spec.View));\n    assert wr.Bytes() == writer.Bytes() + Spec.Bracketed(arr, Spec.Item);\n    assert Spec.Bracketed(arr, Spec.Item) == Spec.Array(arr) by { BracketedToArray(arr); }\n    wr\n  }\n\n  function {:opaque} Members(obj: jobject, writer: Writer) : (wr: Writer)\n    decreases obj, 2\n    ensures wr.Bytes() == writer.Bytes() + Spec.ConcatBytes(obj.data, Spec.Member)\n  {\n    MembersSpec(obj, obj.data, writer)\n  } by method {\n    wr := MembersImpl(obj, writer);\n    Assume(false); // BUG(https://github.com/dafny-lang/dafny/issues/2180)\n  }\n\n  function {:opaque} Items(arr: jarray, writer: Writer) : (wr: Writer)\n    decreases arr, 2\n    ensures wr.Bytes() == writer.Bytes() + Spec.ConcatBytes(arr.data, Spec.Item)\n  {\n    ItemsSpec(arr, arr.data, writer)\n  } by method {\n    wr := ItemsImpl(arr, writer);\n    Assume(false); // BUG(https://github.com/dafny-lang/dafny/issues/2180)\n  }\n\n  ghost function MembersSpec(obj: jobject, members: seq<jmember>, writer: Writer) : (wr: Writer)\n    requires forall j | 0 <= j < |members| :: members[j] < obj\n    decreases obj, 1, members\n    ensures wr.Bytes() == writer.Bytes() + Spec.ConcatBytes(members, Spec.Member)\n  { // TR elimination doesn't work for mutually recursive methods, so this\n    // function is only used as a spec for Members.\n    if members == [] then writer\n    else\n      var butLast, last := members[..|members|-1], members[|members|-1];\n      assert members == butLast + [last];\n      var wr := MembersSpec(obj, butLast, writer);\n      var wr := Member(obj, last, wr);\n      assert wr.Bytes() == writer.Bytes() + (Spec.ConcatBytes(butLast, Spec.Member) + Spec.ConcatBytes([last], Spec.Member)) by {\n        Seq.Assoc(writer.Bytes(), Spec.ConcatBytes(butLast, Spec.Member), Spec.ConcatBytes([last], Spec.Member));\n      }\n      SpecProperties.ConcatBytes_Linear(butLast, [last], Spec.Member);\n      wr\n  } // No by method block here, because the loop invariant in the method version\n    // needs to call MembersSpec and the termination checker gets confused by\n    // that.  Instead, see Members above. // DISCUSS\n\n  // DISCUSS: Is there a way to avoid passing the ghost `v` around while\n  // maintaining the termination argument?  Maybe the lambda for elements will be enough?\n\n  ghost function SequenceSpec<T>(v: Value, items: seq<T>,\n                                 spec: T -> bytes, impl: (Value, T, Writer) --> Writer,\n                                 writer: Writer)\n    : (wr: Writer)\n    requires forall item, wr | item in items :: impl.requires(v, item, wr)\n    requires forall item, wr | item in items :: impl(v, item, wr).Bytes() == wr.Bytes() + spec(item)\n    decreases v, 1, items\n    ensures wr.Bytes() == writer.Bytes() + Spec.ConcatBytes(items, spec)\n  { // TR elimination doesn't work for mutually recursive methods, so this\n    // function is only used as a spec for Items.\n    if items == [] then writer\n    else\n      var writer := SequenceSpec(v, items[..|items|-1], spec, impl, writer);\n      assert items == items[..|items|-1] + [items[|items|-1]];\n      SpecProperties.ConcatBytes_Linear(items[..|items|-1], [items[|items|-1]], spec);\n      impl(v, items[|items|-1], writer)\n  } // No by method block here, because the loop invariant in the method version\n    // needs to call `SequenceSpec` and the termination checker gets confused by\n    // that.  Instead, see `Sequence`Items above. // DISCUSS\n\n\n  ghost function ItemsSpec(arr: jarray, items: seq<jitem>, writer: Writer) : (wr: Writer)\n    requires forall j | 0 <= j < |items| :: items[j] < arr\n    decreases arr, 1, items\n    ensures wr.Bytes() == writer.Bytes() + Spec.ConcatBytes(items, Spec.Item)\n  { // TR elimination doesn't work for mutually recursive methods, so this\n    // function is only used as a spec for Items.\n    if items == [] then writer\n    else\n      var butLast, last := items[..|items|-1], items[|items|-1];\n      assert items == butLast + [last];\n      var wr := ItemsSpec(arr, butLast, writer);\n      var wr := Item(arr, last, wr);\n      assert wr.Bytes() == writer.Bytes() + (Spec.ConcatBytes(butLast, Spec.Item) + Spec.ConcatBytes([last], Spec.Item)) by {\n        Seq.Assoc(writer.Bytes(), Spec.ConcatBytes(butLast, Spec.Item), Spec.ConcatBytes([last], Spec.Item));\n      }\n      SpecProperties.ConcatBytes_Linear(butLast, [last], Spec.Item);\n      wr\n  } // No by method block here, because the loop invariant in the method version\n    // needs to call ItemsSpec and the termination checker gets confused by\n    // that.  Instead, see Items above. // DISCUSS\n\n  method MembersImpl(obj: jobject, writer: Writer) returns (wr: Writer)\n    decreases obj, 1\n    ensures wr == MembersSpec(obj, obj.data, writer);\n  {\n    wr := writer;\n    var members := obj.data;\n    assert wr == MembersSpec(obj, members[..0], writer);\n    for i := 0 to |members| // FIXME uint32\n      invariant wr == MembersSpec(obj, members[..i], writer)\n    {\n      assert members[..i+1][..i] == members[..i];\n      wr := Member(obj, members[i], wr);\n    }\n    assert members[..|members|] == members;\n    assert wr == MembersSpec(obj, members, writer);\n  }\n\n  method {:vcs_split_on_every_assert} ItemsImpl(arr: jarray, writer: Writer) returns (wr: Writer)\n    decreases arr, 1\n    ensures wr == ItemsSpec(arr, arr.data, writer);\n  {\n    wr := writer;\n    var items := arr.data;\n    assert wr == ItemsSpec(arr, items[..0], writer);\n    for i := 0 to |items| // FIXME uint32\n      invariant wr == ItemsSpec(arr, items[..i], writer)\n    {\n      assert items[..i+1][..i] == items[..i] by {\n        AboutList(items, i, i+1);\n      }\n      wr := Item(arr, items[i], wr);\n    }\n    assert items[..|items|] == items;\n  }\n\n  lemma AboutList<T>(xs: seq<T>, i: nat, j: nat)\n    requires i < j <= |xs|\n    ensures xs[..j][..i] == xs[..i]\n  {}\n\n  function {:opaque} Member(ghost obj: jobject, m: jmember, writer: Writer) : (wr: Writer)\n    requires m < obj\n    decreases obj, 0\n    ensures wr.Bytes() == writer.Bytes() + Spec.Member(m)\n  {\n    var wr := String(m.t.k, writer);\n    var wr := StructuralView(m.t.colon, wr);\n    var wr := Value(m.t.v, wr);\n    assert wr.Bytes() == writer.Bytes() + (Spec.String(m.t.k) + Spec.Structural<View>(m.t.colon, Spec.View) + Spec.Value(m.t.v)) by {\n      Seq.Assoc2( writer.Bytes(), Spec.String(m.t.k), Spec.Structural<View>(m.t.colon, Spec.View), Spec.Value(m.t.v));\n    }\n    var wr := if m.suffix.Empty? then wr else StructuralView(m.suffix.t, wr);\n    assert wr.Bytes() == writer.Bytes() + Spec.KeyValue(m.t) + Spec.CommaSuffix(m.suffix) by {\n      if m.suffix.Empty? {\n        Neutral(Spec.KeyValue(m.t));\n        Seq.Assoc'(writer.Bytes(), Spec.KeyValue(m.t), []);\n      }\n      else {\n        assert Spec.StructuralView(m.suffix.t) == Spec.CommaSuffix(m.suffix);\n      }\n    }\n    assert wr.Bytes() == writer.Bytes() + (Spec.KeyValue(m.t) + Spec.CommaSuffix(m.suffix)) by {\n      Seq.Assoc(writer.Bytes(), Spec.KeyValue(m.t), Spec.CommaSuffix(m.suffix));\n    }\n    wr\n  }\n\n  function {:opaque} Item(ghost arr: jarray, m: jitem, writer: Writer) : (wr: Writer)\n    requires m < arr\n    decreases arr, 0\n    ensures wr.Bytes() == writer.Bytes() + Spec.Item(m)\n  {\n    var wr := Value(m.t, writer);\n    var wr := if m.suffix.Empty? then wr else StructuralView(m.suffix.t, wr);\n    assert wr.Bytes() == writer.Bytes() + (Spec.Value(m.t) + Spec.CommaSuffix(m.suffix)) by {\n      Seq.Assoc(writer.Bytes(), Spec.Value(m.t), Spec.CommaSuffix(m.suffix));\n    }\n    wr\n  }\n}\n"}
{"file": "../libraries/src/JSON/ZeroCopy/Deserializer.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"../Utils/Seq.dfy\"\ninclude \"../Errors.dfy\"\ninclude \"../Grammar.dfy\"\ninclude \"../ConcreteSyntax.Spec.dfy\"\ninclude \"../ConcreteSyntax.SpecProperties.dfy\"\ninclude \"../Utils/Parsers.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.ZeroCopy.Deserializer {\n  module Core {\n    import opened BoundedInts\n    import opened Wrappers\n\n    import ConcreteSyntax.Spec\n    import Vs = Utils.Views.Core\n    import opened Utils.Cursors\n    import opened Utils.Parsers\n    import opened Grammar\n    import Errors\n    import opened Seq = Utils.Seq\n\n\n    type JSONError = Errors.DeserializationError\n    type Error = CursorError<JSONError>\n    type ParseResult<+T> = SplitResult<T, JSONError>\n    type Parser<!T> = Parsers.Parser<T, JSONError>\n    type SubParser<!T> = Parsers.SubParser<T, JSONError>\n\n    // BUG(https://github.com/dafny-lang/dafny/issues/2179)\n    const SpecView := (v: Vs.View) => Spec.View(v);\n\n    function {:opaque} Get(cs: FreshCursor, err: JSONError): (pr: ParseResult<jchar>)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, SpecView)\n    {\n      var cs :- cs.Get(err);\n      Success(cs.Split())\n    }\n\n    function {:opaque} WS(cs: FreshCursor): (sp: Split<jblanks>)\n      ensures sp.SplitFrom?(cs, SpecView)\n      ensures sp.cs.SuffixOf?(cs)\n      ensures !cs.BOF? ==> sp.cs.StrictSuffixOf?(cs)\n      ensures cs.EOF? ==> sp.cs.SuffixOf?(cs.Suffix())\n    {\n      cs.SkipWhile(Blank?).Split()\n    } by method {\n      reveal WS();\n      var point' := cs.point;\n      var end := cs.end;\n      while point' < end && Blank?(cs.s[point'])\n        invariant cs.(point := point').Valid?\n        invariant cs.(point := point').SkipWhile(Blank?) == cs.SkipWhile(Blank?)\n      {\n        point' := point' + 1;\n      }\n      return Cursor(cs.s, cs.beg, point', cs.end).Split();\n    }\n\n    function {:opaque} {:vcs_split_on_every_assert} Structural<T>(cs: FreshCursor, parser: Parser<T>)\n      : (pr: ParseResult<Structural<T>>)\n      requires forall cs :: parser.fn.requires(cs)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, st => Spec.Structural(st, parser.spec))\n    {\n      var SP(before, cs) := WS(cs);\n      var SP(val, cs) :- parser.fn(cs);\n      var SP(after, cs) := WS(cs);\n      Success(SP(Grammar.Structural(before, val, after), cs))\n    }\n\n    type jopt = v: Vs.View | v.Length() <= 1 witness Vs.View.OfBytes([])\n\n    function TryStructural(cs: FreshCursor)\n      : (sp: Split<Structural<jopt>>)\n      ensures sp.SplitFrom?(cs, st => Spec.Structural(st, SpecView))\n    {\n      var SP(before, cs) := WS(cs);\n      var SP(val, cs) := cs.SkipByte().Split();\n      var SP(after, cs) := WS(cs);\n      SP(Grammar.Structural(before, val, after), cs)\n    }\n\n    ghost predicate ValueParserValid(sp: SubParser<Value>) {\n      forall t :: sp.spec(t) == Spec.Value(t)\n    }\n\n    type ValueParser = sp: SubParser<Value> | ValueParserValid(sp) witness *\n  }\n  type Error = Core.Error\n\n  abstract module SequenceParams {\n    import opened BoundedInts\n\n    import opened Grammar\n    import opened Utils.Cursors\n    import opened Core\n\n    const OPEN: byte\n    const CLOSE: byte\n\n    type TElement\n\n    ghost function ElementSpec(t: TElement): bytes\n\n    function Element(cs: FreshCursor, json: ValueParser)\n      : (pr: ParseResult<TElement>)\n      requires cs.StrictlySplitFrom?(json.cs)\n      decreases cs.Length()\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, ElementSpec)\n  }\n\n  abstract module Sequences {\n    import opened Wrappers\n    import opened BoundedInts\n    import opened Params: SequenceParams\n\n    import ConcreteSyntax.SpecProperties\n    import opened Vs = Utils.Views.Core\n    import opened Grammar\n    import opened Utils.Cursors\n    import Utils.Parsers\n    import opened Core\n\n    const SEPARATOR: byte := ',' as byte\n\n    type jopen = v: Vs.View | v.Byte?(OPEN) witness Vs.View.OfBytes([OPEN])\n    type jclose = v: Vs.View | v.Byte?(CLOSE) witness Vs.View.OfBytes([CLOSE])\n    type TBracketed = Bracketed<jopen, TElement, jcomma, jclose>\n    type TSuffixedElement = Suffixed<TElement, jcomma>\n\n    const SpecViewClose: jclose -> bytes := SpecView;\n    const SpecViewOpen: jopen -> bytes := SpecView;\n\n    ghost function SuffixedElementSpec(e: TSuffixedElement): bytes {\n      ElementSpec(e.t) + Spec.CommaSuffix(e.suffix)\n    }\n\n    ghost function BracketedSpec(ts: TBracketed): bytes {\n      Spec.Bracketed(ts, SuffixedElementSpec)\n    }\n\n    ghost function SuffixedElementsSpec(ts: seq<TSuffixedElement>): bytes {\n      Spec.ConcatBytes(ts, SuffixedElementSpec)\n    }\n\n    function {:opaque} Open(cs: FreshCursor)\n      : (pr: ParseResult<jopen>)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, SpecViewOpen)\n    {\n      var cs :- cs.AssertByte(OPEN);\n      Success(cs.Split())\n    }\n\n    function {:opaque} Close(cs: FreshCursor)\n      : (pr: ParseResult<jclose>)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, SpecViewClose)\n    {\n      var cs :- cs.AssertByte(CLOSE);\n      Success(cs.Split())\n    }\n\n    function {:opaque} BracketedFromParts(ghost cs: Cursor,\n                                          open: Split<Structural<jopen>>,\n                                          elems: Split<seq<TSuffixedElement>>,\n                                          close: Split<Structural<jclose>>)\n      : (sp: Split<TBracketed>)\n      requires Grammar.NoTrailingSuffix(elems.t)\n      requires open.StrictlySplitFrom?(cs, c => Spec.Structural(c, SpecView))\n      requires elems.SplitFrom?(open.cs, SuffixedElementsSpec)\n      requires close.StrictlySplitFrom?(elems.cs, c => Spec.Structural(c, SpecView))\n      ensures sp.StrictlySplitFrom?(cs, BracketedSpec)\n    {\n      var sp := SP(Grammar.Bracketed(open.t, elems.t, close.t), close.cs);\n      calc {\n        cs.Bytes();\n        Spec.Structural(open.t, SpecView) + open.cs.Bytes();\n        { assert open.cs.Bytes() == SuffixedElementsSpec(elems.t) + elems.cs.Bytes(); }\n        Spec.Structural(open.t, SpecView) + (SuffixedElementsSpec(elems.t) + elems.cs.Bytes());\n        { Seq.Assoc'(Spec.Structural(open.t, SpecView), SuffixedElementsSpec(elems.t), elems.cs.Bytes()); }\n        Spec.Structural(open.t, SpecView) + SuffixedElementsSpec(elems.t) + elems.cs.Bytes();\n        { assert elems.cs.Bytes() == Spec.Structural(close.t, SpecView) + close.cs.Bytes(); }\n        Spec.Structural(open.t, SpecView) + SuffixedElementsSpec(elems.t) + (Spec.Structural(close.t, SpecView) + close.cs.Bytes());\n        { Seq.Assoc'(Spec.Structural(open.t, SpecView) + SuffixedElementsSpec(elems.t), Spec.Structural(close.t, SpecView), close.cs.Bytes()); }\n        Spec.Structural(open.t, SpecView) + SuffixedElementsSpec(elems.t) + Spec.Structural(close.t, SpecView) + close.cs.Bytes();\n        Spec.Bracketed(sp.t, SuffixedElementSpec) + close.cs.Bytes();\n      }\n      assert sp.StrictlySplitFrom?(cs, BracketedSpec);\n      sp\n    }\n\n    function {:opaque} AppendWithSuffix(ghost cs0: FreshCursor,\n                                        ghost json: ValueParser,\n                                        elems: Split<seq<TSuffixedElement>>,\n                                        elem: Split<TElement>,\n                                        sep: Split<Structural<jcomma>>)\n      : (elems': Split<seq<TSuffixedElement>>)\n      requires elems.cs.StrictlySplitFrom?(json.cs)\n      requires elems.SplitFrom?(cs0, SuffixedElementsSpec)\n      requires elem.StrictlySplitFrom?(elems.cs, ElementSpec)\n      requires sep.StrictlySplitFrom?(elem.cs, c => Spec.Structural(c, SpecView))\n      requires forall e | e in elems.t :: e.suffix.NonEmpty?\n      ensures elems'.StrictlySplitFrom?(cs0, SuffixedElementsSpec)\n      ensures forall e | e in elems'.t :: e.suffix.NonEmpty?\n      ensures elems'.cs.Length() < elems.cs.Length()\n      ensures elems'.cs.StrictlySplitFrom?(json.cs)\n      ensures elems'.SplitFrom?(cs0, SuffixedElementsSpec)\n    {\n      var suffixed := Suffixed(elem.t, NonEmpty(sep.t));\n      var elems' := SP(elems.t + [suffixed], sep.cs); // DISCUSS: Moving this down doubles the verification time\n\n      assert cs0.Bytes() == SuffixedElementsSpec(elems'.t) + sep.cs.Bytes() by {\n        assert {:focus} cs0.Bytes() == SuffixedElementsSpec(elems.t) + (ElementSpec(suffixed.t) + Spec.CommaSuffix(suffixed.suffix)) + sep.cs.Bytes() by {\n          assert cs0.Bytes() == SuffixedElementsSpec(elems.t) + ElementSpec(suffixed.t) + Spec.CommaSuffix(suffixed.suffix) + sep.cs.Bytes() by {\n            assert cs0.Bytes() == SuffixedElementsSpec(elems.t) + elems.cs.Bytes();\n            assert elems.cs.Bytes() == ElementSpec(suffixed.t) + elem.cs.Bytes();\n            assert elem.cs.Bytes() == Spec.CommaSuffix(suffixed.suffix) + sep.cs.Bytes();\n            Seq.Assoc'(SuffixedElementsSpec(elems.t), ElementSpec(suffixed.t), elem.cs.Bytes());\n            Seq.Assoc'(SuffixedElementsSpec(elems.t) + ElementSpec(suffixed.t), Spec.CommaSuffix(suffixed.suffix), sep.cs.Bytes());\n          }\n          Seq.Assoc(SuffixedElementsSpec(elems.t), ElementSpec(suffixed.t), Spec.CommaSuffix(suffixed.suffix));\n        }\n        assert SuffixedElementsSpec(elems.t) + (ElementSpec(suffixed.t) + Spec.CommaSuffix(suffixed.suffix)) + sep.cs.Bytes() == SuffixedElementsSpec(elems'.t) + sep.cs.Bytes() by {\n          assert SuffixedElementsSpec(elems.t) + SuffixedElementSpec(suffixed) == SuffixedElementsSpec(elems.t + [suffixed]) by {\n            SpecProperties.ConcatBytes_Linear(elems.t, [suffixed], SuffixedElementSpec);\n            assert Spec.ConcatBytes(elems.t, SuffixedElementSpec) + Spec.ConcatBytes([suffixed], SuffixedElementSpec) ==  Spec.ConcatBytes(elems.t + [suffixed], SuffixedElementSpec);\n          }\n        }\n      }\n      assert elems'.StrictlySplitFrom?(cs0, SuffixedElementsSpec);\n      assert forall e | e in elems'.t :: e.suffix.NonEmpty? by { assert elems'.t == elems.t + [suffixed]; }\n      assert {:split_here} elems'.cs.Length() < elems.cs.Length();\n      assert elems'.SplitFrom?(cs0, SuffixedElementsSpec) by {\n        assert elems'.BytesSplitFrom?(cs0, SuffixedElementsSpec) by {\n          assert elems'.StrictlySplitFrom?(cs0, SuffixedElementsSpec);\n        }\n        assert elems'.cs.SplitFrom?(cs0) by {\n          assert elems'.cs.StrictlySplitFrom?(cs0) by {\n            assert elems'.StrictlySplitFrom?(cs0, SuffixedElementsSpec);\n          }\n        }\n      }\n      elems'\n    }\n\n    function {:vcs_split_on_every_assert} {:opaque} AppendLast(ghost cs0: FreshCursor,\n                                                               ghost json: ValueParser,\n                                                               elems: Split<seq<TSuffixedElement>>,\n                                                               elem: Split<TElement>,\n                                                               sep: Split<Structural<jclose>>)\n      : (elems': Split<seq<TSuffixedElement>>)\n      requires elems.cs.StrictlySplitFrom?(json.cs)\n      requires elems.SplitFrom?(cs0, SuffixedElementsSpec)\n      requires elem.StrictlySplitFrom?(elems.cs, ElementSpec)\n      requires sep.StrictlySplitFrom?(elem.cs, c => Spec.Structural(c, SpecView))\n      requires forall e | e in elems.t :: e.suffix.NonEmpty?\n      ensures elems'.StrictlySplitFrom?(cs0, SuffixedElementsSpec)\n      ensures NoTrailingSuffix(elems'.t)\n      ensures elems'.cs.Length() < elems.cs.Length()\n      ensures elems'.cs.StrictlySplitFrom?(json.cs)\n      ensures sep.StrictlySplitFrom?(elems'.cs, c => Spec.Structural(c, SpecView))\n    {\n      var suffixed := Suffixed(elem.t, Empty());\n      var elems' := SP(elems.t + [suffixed], elem.cs);\n\n      assert cs0.Bytes() == SuffixedElementsSpec(elems'.t) + elem.cs.Bytes() by {\n        assert cs0.Bytes() == SuffixedElementsSpec(elems.t) + ElementSpec(suffixed.t) + elem.cs.Bytes() by {\n          assert elem.t == suffixed.t;\n        }\n        assert SuffixedElementsSpec(elems.t) + ElementSpec(suffixed.t) + elem.cs.Bytes() == SuffixedElementsSpec(elems'.t) + elem.cs.Bytes() by {\n          assert SuffixedElementsSpec(elems.t) + SuffixedElementSpec(suffixed) == SuffixedElementsSpec(elems.t + [suffixed]) by {\n            SpecProperties.ConcatBytes_Linear(elems.t, [suffixed], SuffixedElementSpec);\n            assert Spec.ConcatBytes(elems.t, SuffixedElementSpec) + Spec.ConcatBytes([suffixed], SuffixedElementSpec) ==  Spec.ConcatBytes(elems.t + [suffixed], SuffixedElementSpec);\n          }\n        }\n      }\n\n      assert elems'.StrictlySplitFrom?(cs0, SuffixedElementsSpec);\n      elems'\n    }\n\n    lemma AboutTryStructural(cs: FreshCursor)\n      ensures\n        var sp := Core.TryStructural(cs);\n        var s0 := sp.t.t.Peek();\n        && ((!cs.BOF? || !cs.EOF?) && (s0 == SEPARATOR as opt_byte) ==> (var sp: Split<Structural<jcomma>> := sp; sp.cs.StrictSuffixOf?(cs)))\n        && ((s0 == SEPARATOR as opt_byte) ==> var sp: Split<Structural<jcomma>> := sp; sp.SplitFrom?(cs, st => Spec.Structural(st, SpecView)))\n        && ((!cs.BOF? || !cs.EOF?) && (s0 == CLOSE as opt_byte) ==> (var sp: Split<Structural<jclose>> := sp; sp.cs.StrictSuffixOf?(cs)))\n        && ((s0 == CLOSE as opt_byte) ==> var sp: Split<Structural<jclose>> := sp; sp.SplitFrom?(cs, st => Spec.Structural(st, SpecView)))\n    {}\n\n    lemma {:vcs_split_on_every_assert} AboutLists<T>(xs: seq<T>, i: uint32)\n      requires 0 <= (i as int) < |xs|\n      ensures xs[(i as int)..(i as int)+1] == [xs[i as int]]\n    {}\n\n    // The implementation and proof of this function is more painful than\n    // expected due to the tail recursion.\n    function {:vcs_split_on_every_assert} {:opaque} {:tailrecursion} Elements(\n      ghost cs0: FreshCursor,\n      json: ValueParser,\n      open: Split<Structural<jopen>>,\n      elems: Split<seq<TSuffixedElement>>\n    ) // DISCUSS: Why is this function reverified once per instantiation of the module?\n      : (pr: ParseResult<TBracketed>)\n      requires open.StrictlySplitFrom?(cs0, c => Spec.Structural(c, SpecView))\n      requires elems.cs.StrictlySplitFrom?(json.cs)\n      requires elems.SplitFrom?(open.cs, SuffixedElementsSpec)\n      requires forall e | e in elems.t :: e.suffix.NonEmpty?\n      decreases elems.cs.Length()\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs0, BracketedSpec)\n    {\n      var elem :- Element(elems.cs, json);\n      if elem.cs.EOF? then\n        Failure(EOF)\n      else\n        AboutTryStructural(elem.cs);\n        var sep := Core.TryStructural(elem.cs);\n        var s0 := sep.t.t.Peek();\n        if s0 == SEPARATOR as opt_byte && sep.t.t.Length() == 1 then\n          assert sep.t.t.Char?(',') by {\n            calc {\n              sep.t.t.Char?(',');\n              sep.t.t.Byte?(',' as byte);\n              sep.t.t.Byte?(SEPARATOR);\n              sep.t.t.Bytes() == [SEPARATOR];\n              sep.t.t.s[(sep.t.t.beg as int)..(sep.t.t.end as int)] == [SEPARATOR];\n              { assert (sep.t.t.beg as int) + 1 == (sep.t.t.end as int) by { assert sep.t.t.Length() == 1; } }\n              sep.t.t.s[(sep.t.t.beg as int)..(sep.t.t.beg as int) + 1] == [SEPARATOR];\n              { assert sep.t.t.s[(sep.t.t.beg as int)..(sep.t.t.beg as int) + 1] == [sep.t.t.s[sep.t.t.beg as int]] by { AboutLists(sep.t.t.s, sep.t.t.beg); } }\n              [sep.t.t.s[sep.t.t.beg as int]] == [SEPARATOR];\n              sep.t.t.s[sep.t.t.beg as int] as opt_byte == SEPARATOR as opt_byte;\n              sep.t.t.At(0) as opt_byte == SEPARATOR as opt_byte;\n              (s0 == SEPARATOR as opt_byte);\n              true;\n            }\n          }\n          var sep: Split<Structural<jcomma>> := sep;\n          assert AppendWithSuffix.requires(open.cs, json, elems, elem, sep) by {\n            assert {:focus} elems.cs.StrictlySplitFrom?(json.cs);\n            assert elems.SplitFrom?(open.cs, SuffixedElementsSpec);\n            assert elem.StrictlySplitFrom?(elems.cs, ElementSpec);\n            assert sep.StrictlySplitFrom?(elem.cs, c => Spec.Structural(c, SpecView)) by {\n              assert sep.BytesSplitFrom?(elem.cs, c => Spec.Structural(c, SpecView)) by {\n                assert sep.SplitFrom?(elem.cs, c => Spec.Structural(c, SpecView));\n              }\n              assert sep.cs.StrictlySplitFrom?(elem.cs) by {\n                assert sep.cs.BOF?;\n                assert sep.cs.StrictSuffixOf?(elem.cs) by {\n                  assert !elem.cs.EOF?;\n                }\n              }\n            }\n            assert forall e | e in elems.t :: e.suffix.NonEmpty?;\n            assert {:split_here} true;\n          }\n          var elems := AppendWithSuffix(open.cs, json, elems, elem, sep);\n          Elements(cs0, json, open, elems)\n        else if s0 == CLOSE as opt_byte && sep.t.t.Length() == 1 then\n          assert sep.t.t.Byte?(CLOSE) by {\n            calc {\n              sep.t.t.Byte?(CLOSE);\n              sep.t.t.Bytes() == [CLOSE];\n              sep.t.t.s[(sep.t.t.beg as int)..(sep.t.t.end as int)] == [CLOSE];\n              { assert (sep.t.t.beg as int) + 1 == (sep.t.t.end as int) by { assert sep.t.t.Length() == 1; } }\n              sep.t.t.s[(sep.t.t.beg as int)..(sep.t.t.beg as int) + 1] == [CLOSE];\n              { assert sep.t.t.s[(sep.t.t.beg as int)..(sep.t.t.beg as int) + 1] == [sep.t.t.s[sep.t.t.beg as int]] by { AboutLists(sep.t.t.s, sep.t.t.beg); } }\n              [sep.t.t.s[sep.t.t.beg as int]] == [CLOSE];\n              sep.t.t.s[sep.t.t.beg as int] as opt_byte == CLOSE as opt_byte;\n              sep.t.t.At(0) as opt_byte == CLOSE as opt_byte;\n              (s0 == CLOSE as opt_byte);\n              true;\n            }\n          }\n          var sep: Split<Structural<jclose>> := sep;\n          assert AppendLast.requires(open.cs, json, elems, elem, sep) by {\n            assert elems.cs.StrictlySplitFrom?(json.cs);\n            assert elems.SplitFrom?(open.cs, SuffixedElementsSpec);\n            assert elem.StrictlySplitFrom?(elems.cs, ElementSpec);\n            assert sep.StrictlySplitFrom?(elem.cs, c => Spec.Structural(c, SpecView)) by {\n              assert sep.BytesSplitFrom?(elem.cs, c => Spec.Structural(c, SpecView)) by {\n                assert sep.SplitFrom?(elem.cs, c => Spec.Structural(c, SpecView));\n              }\n              assert sep.cs.StrictlySplitFrom?(elem.cs) by {\n                assert sep.cs.BOF?;\n                assert sep.cs.StrictSuffixOf?(elem.cs) by {\n                  assert !elem.cs.EOF?;\n                }\n              }\n            }\n            assert forall e | e in elems.t :: e.suffix.NonEmpty?;\n          }\n          var elems' := AppendLast(open.cs, json, elems, elem, sep);\n          assert elems'.SplitFrom?(open.cs, SuffixedElementsSpec) by {\n            assert elems'.StrictlySplitFrom?(open.cs, SuffixedElementsSpec);\n          }\n          var bracketed := BracketedFromParts(cs0, open, elems', sep);\n          assert bracketed.StrictlySplitFrom?(cs0, BracketedSpec);\n          Success(bracketed)\n        else\n          var separator := SEPARATOR;\n          var pr := Failure(ExpectingAnyByte([CLOSE, separator], s0));\n          pr\n    }\n\n    lemma AboutCloseParser()\n      ensures Parsers.Parser(Close, SpecViewClose).Valid?()\n    {\n      assert Parsers.Parser(Close, SpecViewClose).Valid?() by {\n        forall cs': FreshCursor ensures Close(cs').Success? ==> Close(cs').value.StrictlySplitFrom?(cs', SpecViewClose) {\n          if Close(cs').Success? {\n            assert Close(cs').value.StrictlySplitFrom?(cs', SpecViewClose) by {\n              assert Close(cs').Success? ==> Close(cs').value.StrictlySplitFrom?(cs', SpecViewClose);\n            }\n          }\n        }\n      }\n    }\n\n    function {:vcs_split_on_every_assert} {:opaque} Bracketed(cs: FreshCursor, json: ValueParser)\n      : (pr: ParseResult<TBracketed>)\n      requires cs.SplitFrom?(json.cs)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, BracketedSpec)\n    {\n      var open :- Core.Structural<jopen>(cs, Parsers.Parser(Open, SpecViewOpen));\n      assert open.cs.StrictlySplitFrom?(json.cs);\n      var elems := SP([], open.cs);\n      if open.cs.Peek() == CLOSE as opt_byte then\n        var p := Parsers.Parser(Close, SpecViewClose);\n        assert p.Valid?() by {\n          AboutCloseParser();\n        }\n        var close :- Core.Structural<jclose>(open.cs, p);\n        Success(BracketedFromParts(cs, open, elems, close))\n      else\n        Elements(cs, json, open, elems)\n    }\n\n    lemma Valid(x: TBracketed)\n      ensures x.l.t.Byte?(OPEN)\n      ensures x.r.t.Byte?(CLOSE)\n      ensures NoTrailingSuffix(x.data)\n      ensures forall pf | pf in x.data ::\n                pf.suffix.NonEmpty? ==> pf.suffix.t.t.Byte?(SEPARATOR)\n    { // DISCUSS: Why is this lemma needed?  Why does it require a body?\n      var xlt: jopen := x.l.t;\n      var xrt: jclose := x.r.t;\n      forall pf | pf in x.data\n        ensures pf.suffix.NonEmpty? ==> pf.suffix.t.t.Byte?(SEPARATOR)\n      {\n        if pf.suffix.NonEmpty? {\n          var xtt := pf.suffix.t.t;\n        }\n      }\n    }\n  }\n\n  module API {\n    import opened BoundedInts\n    import opened Wrappers\n\n    import opened Vs = Utils.Views.Core\n    import opened Grammar\n    import opened Core\n    import opened Errors\n    import Utils.Cursors\n    import Values\n\n    function LiftCursorError(err: Cursors.CursorError<DeserializationError>): DeserializationError {\n      match err\n      case EOF => ReachedEOF\n      case ExpectingByte(expected, b) => ExpectingByte(expected, b)\n      case ExpectingAnyByte(expected_sq, b) => ExpectingAnyByte(expected_sq, b)\n      case OtherError(err) => err\n    }\n\n    function {:vcs_split_on_every_assert} {:opaque} JSON(cs: Cursors.FreshCursor) : (pr: DeserializationResult<Cursors.Split<JSON>>)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, Spec.JSON)\n    {\n      Core.Structural(cs, Parsers.Parser(Values.Value, Spec.Value)).MapFailure(LiftCursorError)\n    }\n\n    function {:opaque} Text(v: View) : (jsr: DeserializationResult<JSON>)\n      ensures jsr.Success? ==> v.Bytes() == Spec.JSON(jsr.value)\n    {\n      var SP(text, cs) :- JSON(Cursors.Cursor.OfView(v));\n      assert Cursors.SP(text, cs).BytesSplitFrom?(Cursors.Cursor.OfView(v), Spec.JSON);\n      assert v.Bytes() == Spec.JSON(text) + cs.Bytes();\n      :- Need(cs.EOF?, Errors.ExpectingEOF);\n      assert cs.Bytes() == [];\n      Success(text)\n    }\n\n    function {:opaque} OfBytes(bs: bytes) : (jsr: DeserializationResult<JSON>)\n      ensures jsr.Success? ==> bs == Spec.JSON(jsr.value)\n    {\n      :- Need(|bs| < TWO_TO_THE_32, Errors.IntOverflow);\n      Text(Vs.View.OfBytes(bs))\n    }\n  }\n\n  module Values {\n    import opened BoundedInts\n    import opened Wrappers\n\n    import opened Grammar\n    import opened Utils.Cursors\n    import opened Core\n\n    import Strings\n    import Numbers\n    import Objects\n    import Arrays\n    import Constants\n\n    import ConcreteSyntax.SpecProperties\n\n    function {:vcs_split_on_every_assert} {:opaque} Value(cs: FreshCursor) : (pr: ParseResult<Value>)\n      decreases cs.Length(), 1\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, Spec.Value)\n    {\n      var c := cs.Peek();\n      if c == '{' as opt_byte then\n        var SP(obj, cs') :- Objects.Object(cs, ValueParser(cs));\n        var v := Grammar.Object(obj);\n        var sp := SP(v, cs');\n        assert sp.StrictlySplitFrom?(cs, Spec.Value) by {\n          Spec.UnfoldValueObject(v);\n          assert SP(obj, cs').StrictlySplitFrom?(cs, Spec.Object);\n        }\n        Spec.UnfoldValueObject(v);\n        assert sp.StrictlySplitFrom?(cs, Spec.Value);\n        Success(sp)\n      else if c == '[' as opt_byte then\n        var SP(arr, cs') :- Arrays.Array(cs, ValueParser(cs));\n        var v := Grammar.Array(arr);\n        var sp := SP(v, cs');\n        assert sp.StrictlySplitFrom?(cs, Spec.Value) by {\n          assert SP(arr, cs').StrictlySplitFrom?(cs, Spec.Array);\n          Spec.UnfoldValueArray(v);\n        }\n        assert sp.StrictlySplitFrom?(cs, Spec.Value);\n        Success(sp)\n      else if c == '\\\"' as opt_byte then\n        var SP(str, cs') :- Strings.String(cs);\n        assert (SP(Grammar.String(str), cs')).StrictlySplitFrom?(cs, Spec.Value) by {\n          calc {\n            (SP(Grammar.String(str), cs')).StrictlySplitFrom?(cs, Spec.Value);\n            cs'.StrictlySplitFrom?(cs) && (SP(Grammar.String(str), cs')).BytesSplitFrom?(cs, Spec.Value);\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == Spec.Value(Grammar.String(str)) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == Spec.String(str) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && SP(str, cs').BytesSplitFrom?(cs, Spec.String);\n            SP(str, cs').StrictlySplitFrom?(cs, Spec.String);\n            true;\n          }\n        }\n        Success(SP(Grammar.String(str), cs'))\n      else if c == 't' as opt_byte then\n        var SP(cst, cs') :- Constants.Constant(cs, TRUE);\n        assert (SP(Grammar.Bool(cst), cs')).StrictlySplitFrom?(cs, Spec.Value) by {\n          var f := _ => TRUE;\n          calc {\n            (SP(Grammar.Bool(cst), cs')).StrictlySplitFrom?(cs, Spec.Value);\n            cs'.StrictlySplitFrom?(cs) && (SP(Grammar.Bool(cst), cs')).BytesSplitFrom?(cs, Spec.Value);\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == Spec.Value(Grammar.Bool(cst)) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == Spec.View(cst) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == cst.Bytes() + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == TRUE + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == f(Grammar.Bool(cst)) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (SP(Grammar.Bool(cst), cs')).BytesSplitFrom?(cs, f);\n            { assert cs'.StrictlySplitFrom?(cs) <==> cs'.SplitFrom?(cs) by { assert cs' != cs; } }\n            cs'.SplitFrom?(cs) && (SP(Grammar.Bool(cst), cs')).BytesSplitFrom?(cs, f);\n            (SP(Grammar.Bool(cst), cs')).SplitFrom?(cs, f);\n            true;\n          }\n        }\n        Success(SP(Grammar.Bool(cst), cs'))\n      else if c == 'f' as opt_byte then\n        var SP(cst, cs') :- Constants.Constant(cs, FALSE);\n        assert (SP(Grammar.Bool(cst), cs')).StrictlySplitFrom?(cs, Spec.Value) by {\n          var f := _ => FALSE;\n          calc {\n            (SP(Grammar.Bool(cst), cs')).StrictlySplitFrom?(cs, Spec.Value);\n            cs'.StrictlySplitFrom?(cs) && (SP(Grammar.Bool(cst), cs')).BytesSplitFrom?(cs, Spec.Value);\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == Spec.Value(Grammar.Bool(cst)) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == Spec.View(cst) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == cst.Bytes() + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == FALSE + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == f(Grammar.Bool(cst)) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (SP(Grammar.Bool(cst), cs')).BytesSplitFrom?(cs, f);\n            { assert cs'.StrictlySplitFrom?(cs) <==> cs'.SplitFrom?(cs) by { assert cs' != cs; } }\n            cs'.SplitFrom?(cs) && (SP(Grammar.Bool(cst), cs')).BytesSplitFrom?(cs, f);\n            (SP(Grammar.Bool(cst), cs')).SplitFrom?(cs, f);\n            true;\n          }\n        }\n        Success(SP(Grammar.Bool(cst), cs'))\n      else if c == 'n' as opt_byte then\n        var SP(cst, cs') :- Constants.Constant(cs, NULL);\n        assert (SP(Grammar.Null(cst), cs')).StrictlySplitFrom?(cs, Spec.Value) by {\n          var f := _ => NULL;\n          calc {\n            (SP(Grammar.Null(cst), cs')).StrictlySplitFrom?(cs, Spec.Value);\n            cs'.StrictlySplitFrom?(cs) && (SP(Grammar.Null(cst), cs')).BytesSplitFrom?(cs, Spec.Value);\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == Spec.Value(Grammar.Null(cst)) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == Spec.View(cst) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == cst.Bytes() + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == NULL + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (cs.Bytes() == f(Grammar.Null(cst)) + cs'.Bytes());\n            cs'.StrictlySplitFrom?(cs) && (SP(Grammar.Null(cst), cs')).BytesSplitFrom?(cs, f);\n            { assert cs'.StrictlySplitFrom?(cs) <==> cs'.SplitFrom?(cs) by { assert cs' != cs; } }\n            cs'.SplitFrom?(cs) && (SP(Grammar.Null(cst), cs')).BytesSplitFrom?(cs, f);\n            (SP(Grammar.Null(cst), cs')).SplitFrom?(cs, f);\n            true;\n          }\n        }\n        Success(SP(Grammar.Null(cst), cs'))\n      else\n        var SP(num, cs') :- Numbers.Number(cs);\n        var v := Grammar.Number(num);\n        var sp := SP(v, cs');\n        assert sp.StrictlySplitFrom?(cs, Spec.Value) by {\n          assert SP(num, cs').StrictlySplitFrom?(cs, Spec.Number);\n          Spec.UnfoldValueNumber(v);\n        }\n        assert sp.StrictlySplitFrom?(cs, Spec.Value);\n        Success(sp)\n    }\n\n    function {:opaque} ValueParser(cs: FreshCursor) : (p: ValueParser)\n      decreases cs.Length(), 0\n      ensures cs.SplitFrom?(p.cs)\n    {\n      var pre := (ps': FreshCursor) => ps'.Length() < cs.Length();\n      var fn := (ps': FreshCursor) requires pre(ps') => Value(ps');\n      Parsers.SubParser(cs, pre, fn, Spec.Value)\n    }\n  }\n\n  module Constants {\n    import opened BoundedInts\n    import opened Wrappers\n\n    import opened Grammar\n    import opened Core\n    import opened Utils.Cursors\n\n    function {:opaque} Constant(cs: FreshCursor, expected: bytes) : (pr: ParseResult<Vs.View>)\n      requires |expected| < TWO_TO_THE_32\n      ensures pr.Success? ==> pr.value.t.Bytes() == expected\n      ensures pr.Success? ==> pr.value.SplitFrom?(cs, _ => expected)\n    {\n      var cs :- cs.AssertBytes(expected);\n      Success(cs.Split())\n    }\n  }\n\n  module Strings {\n    import opened Wrappers\n    import opened BoundedInts\n\n    import opened Grammar\n    import opened Utils.Cursors\n    import opened LC = Utils.Lexers.Core\n    import opened Utils.Lexers.Strings\n    import opened Utils.Parsers\n    import opened Core\n\n    function {:opaque} StringBody(cs: Cursor): (pr: CursorResult<JSONError>)\n      ensures pr.Success? ==> pr.value.AdvancedFrom?(cs)\n    {\n      cs.SkipWhileLexer(Strings.StringBody, StringBodyLexerStart)\n    } by method {\n      reveal StringBody();\n      var escaped := false;\n      for point' := cs.point to cs.end\n        invariant cs.(point := point').Valid?\n        invariant cs.(point := point').SkipWhileLexer(Strings.StringBody, escaped) == StringBody(cs)\n      {\n        var byte := cs.s[point'];\n        if byte == '\\\"' as byte && !escaped {\n          return Success(Cursor(cs.s, cs.beg, point', cs.end));\n        } else if byte == '\\\\' as byte {\n          escaped := !escaped;\n        } else {\n          escaped := false;\n        }\n      }\n      return Failure(EOF);\n    }\n\n    function Quote(cs: FreshCursor) : (pr: ParseResult<jquote>)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, SpecView)\n    {\n      var cs :- cs.AssertChar('\\\"');\n      Success(cs.Split())\n    }\n\n    function {:opaque} String(cs: FreshCursor): (pr: ParseResult<jstring>)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, Spec.String)\n    {\n      var SP(lq, cs) :- Quote(cs);\n      var contents :- StringBody(cs);\n      var SP(contents, cs) := contents.Split();\n      var SP(rq, cs) :- Quote(cs);\n      Success(SP(Grammar.JString(lq, contents, rq), cs))\n    }\n  }\n\n  module Numbers {\n    import opened BoundedInts\n    import opened Wrappers\n\n    import opened Grammar\n    import opened Utils.Cursors\n    import opened Core\n\n    function {:opaque} Digits(cs: FreshCursor) : (sp: Split<jdigits>)\n      ensures sp.SplitFrom?(cs, SpecView)\n    {\n      cs.SkipWhile(Digit?).Split()\n    }\n\n    function {:opaque} NonEmptyDigits(cs: FreshCursor) : (pr: ParseResult<jnum>)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, SpecView)\n    {\n      var sp := Digits(cs);\n      :- Need(!sp.t.Empty?, OtherError(Errors.EmptyNumber));\n      Success(sp)\n    }\n\n    function {:opaque} NonZeroInt(cs: FreshCursor) : (pr: ParseResult<jint>)\n      requires cs.Peek() != '0' as opt_byte\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, SpecView)\n    {\n      NonEmptyDigits(cs)\n    }\n\n    function {:opaque} OptionalMinus(cs: FreshCursor) : (sp: Split<jminus>)\n      ensures sp.SplitFrom?(cs, SpecView)\n    {\n      cs.SkipIf(c => c == '-' as byte).Split()\n    }\n\n    function {:opaque} OptionalSign(cs: FreshCursor) : (sp: Split<jsign>)\n      ensures sp.SplitFrom?(cs, SpecView)\n    {\n      cs.SkipIf(c => c == '-' as byte || c == '+' as byte).Split()\n    }\n\n    function {:opaque} TrimmedInt(cs: FreshCursor) : (pr: ParseResult<jint>)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, SpecView)\n    {\n      var sp := cs.SkipIf(c => c == '0' as byte).Split();\n      if sp.t.Empty? then NonZeroInt(sp.cs)\n      else Success(sp)\n    }\n\n    function {:opaque} {:vcs_split_on_every_assert} Exp(cs: FreshCursor) : (pr: ParseResult<Maybe<jexp>>)\n      ensures pr.Success? ==> pr.value.SplitFrom?(cs, exp => Spec.Maybe(exp, Spec.Exp))\n    {\n      var SP(e, cs) :=\n        cs.SkipIf(c => c == 'e' as byte || c == 'E' as byte).Split();\n      if e.Empty? then\n        Success(SP(Empty(), cs))\n      else\n        assert e.Char?('e') || e.Char?('E');\n        var SP(sign, cs) := OptionalSign(cs);\n        var SP(num, cs) :- NonEmptyDigits(cs);\n        Success(SP(NonEmpty(JExp(e, sign, num)), cs))\n    }\n\n    function {:opaque} Frac(cs: FreshCursor) : (pr: ParseResult<Maybe<jfrac>>)\n      ensures pr.Success? ==> pr.value.SplitFrom?(cs, frac => Spec.Maybe(frac, Spec.Frac))\n    {\n      var SP(period, cs) :=\n        cs.SkipIf(c => c == '.' as byte).Split();\n      if period.Empty? then\n        Success(SP(Empty(), cs))\n      else\n        var SP(num, cs) :- NonEmptyDigits(cs);\n        Success(SP(NonEmpty(JFrac(period, num)), cs))\n    }\n\n    function {:opaque} NumberFromParts(\n      ghost cs: Cursor,\n      minus: Split<jminus>, num: Split<jint>,\n      frac: Split<Maybe<jfrac>>, exp: Split<Maybe<jexp>>\n    )\n      : (sp: Split<jnumber>)\n      requires minus.SplitFrom?(cs, SpecView)\n      requires num.StrictlySplitFrom?(minus.cs, SpecView)\n      requires frac.SplitFrom?(num.cs, frac => Spec.Maybe(frac, Spec.Frac))\n      requires exp.SplitFrom?(frac.cs, exp => Spec.Maybe(exp, Spec.Exp))\n      ensures sp.StrictlySplitFrom?(cs, Spec.Number)\n    {\n      var sp := SP(Grammar.JNumber(minus.t, num.t, frac.t, exp.t), exp.cs);\n      assert cs.Bytes() == Spec.Number(sp.t) + exp.cs.Bytes() by {\n        assert cs.Bytes() == Spec.View(minus.t) + Spec.View(num.t) + Spec.Maybe(frac.t, Spec.Frac) + Spec.Maybe(exp.t, Spec.Exp) + exp.cs.Bytes() by {\n          assert cs.Bytes() == Spec.View(minus.t) + minus.cs.Bytes();\n          assert minus.cs.Bytes() == Spec.View(num.t) + num.cs.Bytes();\n          assert num.cs.Bytes() == Spec.Maybe(frac.t, Spec.Frac) + frac.cs.Bytes();\n          assert frac.cs.Bytes() == Spec.Maybe(exp.t, Spec.Exp) + exp.cs.Bytes();\n          Seq.Assoc'(Spec.View(minus.t), Spec.View(num.t), num.cs.Bytes());\n          Seq.Assoc'(Spec.View(minus.t) + Spec.View(num.t), Spec.Maybe(frac.t, Spec.Frac), frac.cs.Bytes());\n          Seq.Assoc'(Spec.View(minus.t) + Spec.View(num.t) + Spec.Maybe(frac.t, Spec.Frac), Spec.Maybe(exp.t, Spec.Exp), exp.cs.Bytes());\n        }\n      }\n      assert sp.StrictlySplitFrom?(cs, Spec.Number);\n\n\n\n      sp\n    }\n\n    function {:opaque} Number(cs: FreshCursor) : (pr: ParseResult<jnumber>)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, Spec.Number)\n    {\n      var minus := OptionalMinus(cs);\n      var num :- TrimmedInt(minus.cs);\n      var frac :- Frac(num.cs);\n      var exp :- Exp(frac.cs);\n      Success(NumberFromParts(cs, minus, num, frac, exp))\n    }\n  }\n\n  module ArrayParams refines SequenceParams {\n    import opened Strings\n    import opened Wrappers\n\n    type TElement = Value\n\n    const OPEN := '[' as byte\n    const CLOSE := ']' as byte\n\n    function ElementSpec(t: TElement) : bytes {\n      Spec.Value(t)\n    }\n\n    function {:opaque} Element(cs: FreshCursor, json: ValueParser) : (pr: ParseResult<TElement>)\n    {\n      json.fn(cs)\n    }\n  }\n\n  module Arrays refines Sequences {\n    import opened Params = ArrayParams\n\n    lemma {:vcs_split_on_every_assert} BracketedToArray(arr: jarray)\n      ensures Spec.Bracketed(arr, SuffixedElementSpec) == Spec.Array(arr)\n    {\n      var rItem := (d: jitem) requires d < arr => Spec.Item(d);\n      assert Spec.Bracketed(arr, SuffixedElementSpec) == Spec.Bracketed(arr, rItem) by {\n        assert SpecProperties.Bracketed_Morphism_Requires(arr, SuffixedElementSpec, rItem);\n        SpecProperties.Bracketed_Morphism(arr, SuffixedElementSpec, rItem);\n      }\n      calc {\n        Spec.Bracketed(arr, SuffixedElementSpec);\n        Spec.Bracketed(arr, rItem);\n        Spec.Array(arr);\n      }\n    }\n\n    function {:vcs_split_on_every_assert} {:opaque} Array(cs: FreshCursor, json: ValueParser)\n      : (pr: ParseResult<jarray>)\n      requires cs.SplitFrom?(json.cs)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, Spec.Array)\n    {\n      var sp :- Bracketed(cs, json);\n      assert sp.StrictlySplitFrom?(cs, BracketedSpec);\n      BracketedToArray(sp.t);\n      Success(sp)\n    }\n  }\n\n  module ObjectParams refines SequenceParams {\n    import opened Wrappers\n    import Strings\n\n    type TElement = jKeyValue\n\n    const OPEN := '{' as byte\n    const CLOSE := '}' as byte\n\n    function Colon(cs: FreshCursor) : (pr: ParseResult<jcolon>) // DISCUSS: Why can't I make this opaque?\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, SpecView)\n    {\n      var cs :- cs.AssertChar(':');\n      Success(cs.Split())\n    }\n\n    function {:opaque} KeyValueFromParts(ghost cs: Cursor, k: Split<jstring>,\n                                         colon: Split<Structural<jcolon>>, v: Split<Value>)\n      : (sp: Split<jKeyValue>)\n      requires k.StrictlySplitFrom?(cs, Spec.String)\n      requires colon.StrictlySplitFrom?(k.cs, c => Spec.Structural(c, SpecView))\n      requires v.StrictlySplitFrom?(colon.cs, Spec.Value)\n      ensures sp.StrictlySplitFrom?(cs, ElementSpec)\n    {\n      var sp := SP(Grammar.KeyValue(k.t, colon.t, v.t), v.cs);\n      assert cs.Bytes() == Spec.KeyValue(sp.t) + v.cs.Bytes() by {\n        assert cs.Bytes() == Spec.String(k.t) + Spec.Structural(colon.t, SpecView) + Spec.Value(v.t) + v.cs.Bytes() by {\n          assert cs.Bytes() == Spec.String(k.t) + k.cs.Bytes();\n          assert k.cs.Bytes() == Spec.Structural(colon.t, SpecView) + colon.cs.Bytes();\n          assert colon.cs.Bytes() == Spec.Value(v.t) + v.cs.Bytes();\n          Seq.Assoc'(Spec.String(k.t), Spec.Structural(colon.t, SpecView), colon.cs.Bytes());\n          Seq.Assoc'(Spec.String(k.t) + Spec.Structural(colon.t, SpecView), Spec.Value(v.t), v.cs.Bytes());\n        }\n      }\n      assert sp.StrictlySplitFrom?(cs, ElementSpec);\n      sp\n    }\n\n    function ElementSpec(t: TElement) : bytes {\n      Spec.KeyValue(t)\n    }\n\n    function {:vcs_split_on_every_assert} {:opaque} Element(cs: FreshCursor, json: ValueParser)\n      : (pr: ParseResult<TElement>)\n    {\n      var k :- Strings.String(cs);\n      assert k.cs.StrictlySplitFrom?(json.cs);\n      assert k.StrictlySplitFrom?(cs, Spec.String);\n      var p := Parsers.Parser(Colon, SpecView);\n      assert p.Valid?();\n      var colon :- Core.Structural(k.cs, p);\n      assert colon.StrictlySplitFrom?(k.cs, st => Spec.Structural(st, SpecView));\n      assert colon.cs.StrictlySplitFrom?(json.cs);\n\n      assert json.fn.requires(colon.cs) by {\n        assert json.pre(colon.cs) by {\n          assert colon.cs.StrictlySplitFrom?(json.cs);\n          assert json.Valid?();\n        }\n        assert json.Valid?();\n      }\n\n      var v :- json.fn(colon.cs);\n\n      assert v.StrictlySplitFrom?(colon.cs, Spec.Value) by {\n        assert v.cs.StrictlySplitFrom?(colon.cs) by {\n          assert v.StrictlySplitFrom?(colon.cs, json.spec) by {\n            assert json.Valid?();\n          }\n        }\n        assert v.BytesSplitFrom?(colon.cs, Spec.Value) by {\n          calc {\n            colon.cs.Bytes();\n            { assert v.BytesSplitFrom?(colon.cs, json.spec) by { assert json.Valid?(); } }\n            json.spec(v.t) + v.cs.Bytes();\n            { assert json.spec(v.t) == Spec.Value(v.t) by { assert ValueParserValid(json); } }\n            Spec.Value(v.t) + v.cs.Bytes();\n          }\n        }\n      }\n      var kv := KeyValueFromParts(cs, k, colon, v);\n      Success(kv)\n    }\n  }\n\n  module Objects refines Sequences {\n    import opened Params = ObjectParams\n\n    lemma {:vcs_split_on_every_assert} BracketedToObject(obj: jobject)\n      ensures Spec.Bracketed(obj, SuffixedElementSpec) == Spec.Object(obj)\n    {\n      var rMember := (d: jmember) requires d < obj => Spec.Member(d);\n      assert Spec.Bracketed(obj, SuffixedElementSpec) == Spec.Bracketed(obj, rMember) by {\n        assert Spec.Bracketed(obj, SuffixedElementSpec) == Spec.Bracketed(obj, rMember) by {\n          assert SpecProperties.Bracketed_Morphism_Requires(obj, SuffixedElementSpec, rMember);\n          SpecProperties.Bracketed_Morphism(obj, SuffixedElementSpec, rMember);\n        }\n      }\n      calc {\n        Spec.Bracketed(obj, SuffixedElementSpec);\n        Spec.Bracketed(obj, rMember);\n        Spec.Object(obj);\n      }\n    }\n\n    function {:vcs_split_on_every_assert} {:opaque} Object(cs: FreshCursor, json: ValueParser)\n      : (pr: ParseResult<jobject>)\n      requires cs.SplitFrom?(json.cs)\n      ensures pr.Success? ==> pr.value.StrictlySplitFrom?(cs, Spec.Object)\n    {\n      var sp :- Bracketed(cs, json);\n      assert sp.StrictlySplitFrom?(cs, BracketedSpec);\n      BracketedToObject(sp.t);\n      Success(sp)\n    }\n  }\n}\n"}
{"file": "../libraries/src/JSON/API.dfy", "dafny": "// RUN: %verify \"%s\" --unicode-char:false ../Unicode/UnicodeStringsWithoutUnicodeChar.dfy\n// RUN: %verify \"%s\" --unicode-char:true ../Unicode/UnicodeStringsWithUnicodeChar.dfy\n\ninclude \"Serializer.dfy\"\ninclude \"Deserializer.dfy\"\ninclude \"ZeroCopy/API.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.API {\n  import opened BoundedInts\n  import opened Errors\n  import Values\n  import Serializer\n  import Deserializer\n  import ZeroCopy = ZeroCopy.API\n\n  function {:opaque} Serialize(js: Values.JSON) : (bs: SerializationResult<seq<byte>>)\n  {\n    var js :- Serializer.JSON(js);\n    ZeroCopy.Serialize(js)\n  }\n\n  method SerializeAlloc(js: Values.JSON) returns (bs: SerializationResult<array<byte>>)\n  {\n    var js :- Serializer.JSON(js);\n    bs := ZeroCopy.SerializeAlloc(js);\n  }\n\n  method SerializeInto(js: Values.JSON, bs: array<byte>) returns (len: SerializationResult<uint32>)\n    modifies bs\n  {\n    var js :- Serializer.JSON(js);\n    len := ZeroCopy.SerializeInto(js, bs);\n  }\n\n  function {:opaque} Deserialize(bs: seq<byte>) : (js: DeserializationResult<Values.JSON>)\n  {\n    var js :- ZeroCopy.Deserialize(bs);\n    Deserializer.JSON(js)\n  }\n}\n"}
{"file": "../libraries/src/JSON/Grammar.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/// ==========================================\n///  Low-level JSON grammar (Concrete syntax)\n/// ==========================================\n///\n/// See ``JSON.Values`` for the high-level interface.\n\ninclude \"../BoundedInts.dfy\"\ninclude \"Utils/Views.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Grammar {\n  import opened BoundedInts\n  import opened Utils.Views.Core\n\n  const EMPTY := View.OfBytes([])\n  const DOUBLEQUOTE := View.OfBytes(['\\\"' as byte])\n  const PERIOD := View.OfBytes(['.' as byte])\n  const E := View.OfBytes(['e' as byte])\n  const COLON := View.OfBytes([':' as byte])\n  const COMMA := View.OfBytes([',' as byte])\n  const LBRACE := View.OfBytes(['{' as byte])\n  const RBRACE := View.OfBytes(['}' as byte])\n  const LBRACKET := View.OfBytes(['[' as byte])\n  const RBRACKET := View.OfBytes([']' as byte])\n  const MINUS := View.OfBytes(['-' as byte])\n\n  type jchar = v: View | v.Length() == 1 witness View.OfBytes(['b' as byte])\n  type jquote = v: View | v.Char?('\\\"') witness DOUBLEQUOTE\n  type jperiod = v: View | v.Char?('.') witness PERIOD\n  type je = v: View | v.Char?('e') || v.Char?('E') witness E\n  type jcolon = v: View | v.Char?(':') witness COLON\n  type jcomma = v: View | v.Char?(',') witness COMMA\n  type jlbrace = v: View | v.Char?('{') witness LBRACE\n  type jrbrace = v: View | v.Char?('}') witness RBRACE\n  type jlbracket = v: View | v.Char?('[') witness LBRACKET\n  type jrbracket = v: View | v.Char?(']') witness RBRACKET\n  type jminus = v: View | v.Char?('-') || v.Empty? witness MINUS\n  type jsign = v: View | v.Char?('-') || v.Char?('+') || v.Empty? witness EMPTY\n\n  predicate Blank?(b: byte) { b == 0x20 || b == 0x09 || b == 0x0A || b == 0x0D }\n  ghost predicate Blanks?(v: View) { forall b | b in v.Bytes() :: Blank?(b) }\n  type jblanks = v: View | Blanks?(v) witness View.OfBytes([])\n\n  datatype Structural<+T> =\n    Structural(before: jblanks, t: T, after: jblanks)\n\n  datatype Maybe<+T> = Empty() | NonEmpty(t: T)\n\n  datatype Suffixed<+T, +S> =\n    Suffixed(t: T, suffix: Maybe<Structural<S>>)\n\n  type SuffixedSequence<+D, +S> = s: seq<Suffixed<D, S>> | NoTrailingSuffix(s)\n  ghost predicate NoTrailingSuffix<S, D>(s: seq<Suffixed<D, S>>) {\n    forall idx | 0 <= idx < |s| :: s[idx].suffix.Empty? <==> idx == |s| - 1\n  }\n\n  datatype Bracketed<+L, +D, +S, +R> =\n    Bracketed(l: Structural<L>, data: SuffixedSequence<D, S>, r: Structural<R>)\n\n  const NULL: bytes := ['n' as byte, 'u' as byte, 'l' as byte, 'l' as byte]\n  const TRUE: bytes := ['t' as byte, 'r' as byte, 'u' as byte, 'e' as byte]\n  const FALSE: bytes := ['f' as byte, 'a' as byte, 'l' as byte, 's' as byte, 'e' as byte]\n\n  ghost predicate Null?(v: View) { v.Bytes() == NULL }\n  ghost predicate Bool?(v: View) { v.Bytes() in {TRUE, FALSE} }\n  predicate Digit?(b: byte) { '0' as byte <= b <= '9' as byte }\n  ghost predicate Digits?(v: View) { forall b | b in v.Bytes() :: Digit?(b) }\n  ghost predicate Num?(v: View) { Digits?(v) && !v.Empty? }\n  ghost predicate Int?(v: View) { v.Char?('0') || (Num?(v) && v.At(0) != '0' as byte) }\n\n  type jnull = v: View | Null?(v) witness View.OfBytes(NULL)\n  type jbool = v: View | Bool?(v) witness View.OfBytes(TRUE)\n  type jdigits = v: View | Digits?(v) witness View.OfBytes([])\n  type jnum = v: View | Num?(v) witness View.OfBytes(['0' as byte])\n  type jint = v: View | Int?(v) witness View.OfBytes(['0' as byte])\n  type jstr = v: View | true witness View.OfBytes([]) // TODO: Enforce quoting and escaping\n  datatype jstring = JString(lq: jquote, contents: jstr, rq: jquote)\n  datatype jKeyValue = KeyValue(k: jstring, colon: Structural<jcolon>, v: Value)\n\n  // TODO enforce no leading space before closing bracket to disambiguate WS { WS WS } WS\n  type jobject = Bracketed<jlbrace, jKeyValue, jcomma, jrbrace>\n  type jarray = Bracketed<jlbracket, Value, jcomma, jrbracket>\n  type jmembers = SuffixedSequence<jKeyValue, jcomma>\n  type jmember = Suffixed<jKeyValue, jcomma>\n  type jitems = SuffixedSequence<Value, jcomma>\n  type jitem = Suffixed<Value, jcomma>\n\n  datatype jfrac = JFrac(period: jperiod, num: jnum)\n  datatype jexp = JExp(e: je, sign: jsign, num: jnum)\n  datatype jnumber = JNumber(minus: jminus, num: jnum, frac: Maybe<jfrac>, exp: Maybe<jexp>)\n\n  datatype Value =\n    | Null(n: jnull)\n    | Bool(b: jbool)\n    | String(str: jstring)\n    | Number(num: jnumber)\n    | Object(obj: jobject)\n    | Array(arr: jarray)\n\n  type JSON = Structural<Value>\n}\n"}
{"file": "../libraries/src/JSON/Tests.dfy", "dafny": "// RUN: %run \"%s\" --unicode-char:false --input ../Unicode/UnicodeStringsWithoutUnicodeChar.dfy\n// RUN: %run \"%s\" --unicode-char:true --input ../Unicode/UnicodeStringsWithUnicodeChar.dfy\n\n// TODO: Test for Java and other target languages too\n\ninclude \"Errors.dfy\"\ninclude \"API.dfy\"\ninclude \"ZeroCopy/API.dfy\"\ninclude \"../Collections/Sequences/Seq.dfy\"\n\nabstract module JSON.Tests.Wrapper {\n  import Utils.Str\n  import opened BoundedInts\n  import opened UnicodeStrings\n  import opened Errors\n\n  type JSON\n  method Deserialize(bs: bytes) returns (js: DeserializationResult<JSON>)\n  method SpecSerialize(js: JSON) returns (bs: SerializationResult<bytes>)\n  method Serialize(js: JSON) returns (bs: SerializationResult<bytes>)\n  method Check(bs: bytes, js: JSON, bs': bytes, sbs': bytes, js': JSON)\n\n  method TestBytestring(bs: bytes, indent: string) {\n    var js  :- expect Deserialize(bs);\n    // print indent, \"=> \", js, \"\\n\";\n    var bs'  :- expect Serialize(js);\n    print indent, \"=> \", FromUTF8Checked(bs'), \"\\n\";\n    var sbs' :- expect SpecSerialize(js);\n    print indent, \"=> \", FromUTF8Checked(sbs'), \"\\n\";\n    var js'  :- expect Deserialize(bs');\n    Check(bs, js, bs', sbs', js');\n  }\n\n  method TestString(str: string, indent: string) {\n    var bs :- expect ToUTF8Checked(str);\n    TestBytestring(bs, indent);\n  }\n\n  method TestStrings(vectors: seq<string>) {\n    for i := 0 to |vectors| {\n      var input := vectors[i];\n      var idx := Str.OfInt(i);\n      var indent := seq(|idx| + 1, _ => ' ');\n      print \"[\", idx, \"]: \", input, \"\\n\";\n      TestString(input, indent);\n      print \"\\n\";\n    }\n  }\n}\n\nmodule JSON.Tests.ZeroCopyWrapper refines Wrapper {\n  import opened Wrappers\n  import Grammar\n  import ZeroCopy.API\n  import ConcreteSyntax.Spec\n\n  type JSON = Grammar.JSON\n\n  method Deserialize(bs: bytes) returns (js: DeserializationResult<JSON>) {\n    js := API.Deserialize(bs);\n  }\n\n  method Serialize(js: JSON) returns (bs: SerializationResult<bytes>) {\n    // print \"Count: \", wr.chain.Count(), \"\\n\";\n    bs := API.Serialize(js);\n  }\n\n  method SpecSerialize(js: JSON) returns (bs: SerializationResult<bytes>) {\n    bs := Success(Spec.JSON(js));\n  }\n\n  method Check(bs: bytes, js: JSON, bs': bytes, sbs': bytes, js': JSON) {\n    expect sbs' == bs' == bs;\n    expect js' == js; // This doesn't hold in general, since the views could be different\n  }\n}\n\nmodule JSON.Tests.AbstractSyntaxWrapper refines Wrapper {\n  import opened Wrappers\n  import Grammar\n  import API\n  import Values\n  import Spec\n\n  type JSON = Values.JSON\n\n  method Deserialize(bs: bytes) returns (js: DeserializationResult<JSON>) {\n    js := API.Deserialize(bs);\n  }\n\n  method Serialize(js: JSON) returns (bs: SerializationResult<bytes>) {\n    bs := API.Serialize(js);\n  }\n\n  method SpecSerialize(js: JSON) returns (bs: SerializationResult<bytes>) {\n    bs := Spec.JSON(js);\n  }\n\n  method Check(bs: bytes, js: JSON, bs': bytes, sbs': bytes, js': JSON) {\n    expect sbs' == bs'; // Serializing changes number representations, escapes, and spacing, so no == bs\n    expect js' == js;\n  }\n}\n\nmodule JSON.Tests {\n\n  import opened Seq\n\n  const VECTORS := [\n    \"true\",\n    \"false\",\n    \"null\",\n    \"\\\"\\\"\",\n    \"\\\"string\\\"\",\n    \"[\\\"A\\\"]\",\n    \"-123.456e-18\",\n    \"[]\",\n    \"[ ]\",\n    \"[1]\",\n    \"[1, 2]\",\n    \"{}\",\n    \"{ \\\"a\\\": 1 }\",\n    \"{ \\\"a\\\": \\\"b\\\" }\",\n    \"{ \\\"some\\\" : \\\"string\\\", \\\"and\\\": [ \\\"a number\\\", -123.456e-18 ] }\",\n\n    \"  true  \",\n    \" {  } \",\n    \"\\\"\\\\t\\\\r\\\\n\\\\f\\\"\",\n    \"\\\"∀ABC // \\\\u2200ABC\\\"\", // ∀\n    \"\\\"🇫🇷 // \\\\u1f1eb\\\\u1f1EBABC\\\"\", // 🇫🇷\n\n    \"[true, false , null, { \\\"some\\\" : \\\"string\\\", \\\"and\\\": [ \\\"a number\\\", -123.456e-18 ] } ]  \",\n\n    // Stress test - this used to cause stack overflow errors because of non-tail-recursive functions.\n    // We should have these kinds of tests direclty in the Unicode module too.\n    \"\\\"\" + Seq.Repeat('a', 100_000) + \"\\\"\"\n  ];\n\n  method Main() {\n    ZeroCopyWrapper.TestStrings(VECTORS);\n    AbstractSyntaxWrapper.TestStrings(VECTORS);\n  }\n}\n"}
{"file": "../libraries/src/JSON/Utils/Seq.dfy", "dafny": "// RUN: %verify \"%s\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Utils.Seq {\n  lemma Neutral(l: seq)\n    ensures l == l + []\n  {}\n\n  lemma Assoc(a: seq, b: seq, c: seq)\n    // `a + b + c` is parsed as `(a + b) + c`\n    ensures a + b + c == a + (b + c)\n  {}\n\n\n  lemma Assoc'(a: seq, b: seq, c: seq)\n    // `a + b + c` is parsed as `(a + b) + c`\n    ensures a + (b + c) == a + b + c\n  {}\n\n  lemma Assoc2(a: seq, b: seq, c: seq, d: seq)\n    // `a + b + c + d` is parsed as `((a + b) + c) + d`\n    ensures a + b + c + d == a + (b + c + d)\n  {}\n}\n"}
{"file": "../libraries/src/JSON/Utils/Cursors.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"../../BoundedInts.dfy\"\ninclude \"../../Wrappers.dfy\"\ninclude \"Views.dfy\"\ninclude \"Lexers.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Utils.Cursors {\n  import opened BoundedInts\n  import opened Wrappers\n\n  import opened Vs = Views.Core\n  import opened Lx = Lexers.Core\n\n  datatype Split<+T> = SP(t: T, cs: FreshCursor) {\n    ghost predicate BytesSplitFrom?(cs0: Cursor, spec: T -> bytes) {\n      cs0.Bytes() == spec(t) + cs.Bytes()\n    }\n\n    ghost predicate SplitFrom?(cs0: Cursor, spec: T -> bytes) {\n      cs.SplitFrom?(cs0) && BytesSplitFrom?(cs0, spec)\n    }\n\n    ghost predicate StrictlySplitFrom?(cs0: Cursor, spec: T -> bytes) {\n      cs.StrictlySplitFrom?(cs0) && BytesSplitFrom?(cs0, spec)\n    }\n  }\n\n  // LATER: Make this a newtype and put members here instead of requiring `Valid?` everywhere\n  type Cursor = ps: Cursor_ | ps.Valid?\n    witness Cursor([], 0, 0, 0)\n  type FreshCursor = ps: Cursor | ps.BOF?\n    witness Cursor([], 0, 0, 0)\n\n  datatype CursorError<+R> =\n    | EOF\n    | ExpectingByte(expected: byte, b: opt_byte)\n    | ExpectingAnyByte(expected_sq: seq<byte>, b: opt_byte)\n    | OtherError(err: R)\n  { // TODO: Include positions in errors\n    function ToString(pr: R -> string) : string {\n      match this\n      case EOF => \"Reached EOF\"\n      case ExpectingByte(b0, b) =>\n        var c := if b > 0 then \"'\" + [b as char] + \"'\" else \"EOF\";\n        \"Expecting '\" + [b0 as char] + \"', read \" + c\n      case ExpectingAnyByte(bs0, b) =>\n        var c := if b > 0 then \"'\" + [b as char] + \"'\" else \"EOF\";\n        var c0s := seq(|bs0|, idx requires 0 <= idx < |bs0| => bs0[idx] as char);\n        \"Expecting one of '\" + c0s + \"', read \" + c\n      case OtherError(err) => pr(err)\n    }\n  }\n  type CursorResult<+R> = Result<Cursor, CursorError<R>>\n\n  datatype Cursor_ = Cursor(s: bytes, beg: uint32, point: uint32, end: uint32) {\n    ghost const Valid?: bool :=\n      0 <= beg as int <= point as int <= end as int <= |s| < TWO_TO_THE_32;\n\n    const BOF? :=\n      point == beg\n\n    const EOF? :=\n      point == end\n\n    static function OfView(v: View) : FreshCursor {\n      Cursor(v.s, v.beg, v.beg, v.end)\n    }\n\n    static function OfBytes(bs: bytes) : FreshCursor\n      requires |bs| < TWO_TO_THE_32\n    {\n      Cursor(bs, 0, 0, |bs| as uint32)\n    }\n\n    function Bytes() : bytes\n      requires Valid?\n    {\n      s[beg..end]\n    }\n\n    ghost predicate StrictlyAdvancedFrom?(other: Cursor): (b: bool)\n      requires Valid?\n      ensures b ==>\n                SuffixLength() < other.SuffixLength()\n      ensures b ==>\n                beg == other.beg && end == other.end ==>\n                  forall idx | beg <= idx < point :: s[idx] == other.s[idx]\n    {\n      && s == other.s\n      && beg == other.beg\n      && end == other.end\n      && point > other.point\n    }\n\n    ghost predicate AdvancedFrom?(other: Cursor)\n      requires Valid?\n    {\n      || this == other\n      || StrictlyAdvancedFrom?(other)\n    }\n\n    ghost predicate StrictSuffixOf?(other: Cursor)\n      requires Valid?\n      ensures StrictSuffixOf?(other) ==>\n                Length() < other.Length()\n    {\n      && s == other.s\n      && beg > other.beg\n      && end == other.end\n    }\n\n    ghost predicate SuffixOf?(other: Cursor)\n      requires Valid?\n    {\n      || this == other\n      || StrictSuffixOf?(other)\n    }\n\n    ghost predicate StrictlySplitFrom?(other: Cursor)\n      requires Valid?\n    {\n      && BOF?\n      && StrictSuffixOf?(other)\n    }\n\n    ghost predicate SplitFrom?(other: Cursor)\n      requires Valid?\n    {\n      || this == other\n      || StrictlySplitFrom?(other)\n    }\n\n    function Prefix() : View requires Valid? {\n      View(s, beg, point)\n    }\n\n    function Suffix() : Cursor requires Valid? {\n      this.(beg := point)\n    }\n\n    function Split() : (sp: Split<View>) requires Valid?\n      ensures sp.SplitFrom?(this, (v: View) => v.Bytes())\n      ensures beg != point ==> sp.StrictlySplitFrom?(this, (v: View) => v.Bytes())\n      ensures !BOF? ==> (sp.StrictlySplitFrom?(this, (v: View) => v.Bytes()) && sp.cs.StrictSuffixOf?(this))\n      ensures !EOF? <==> !sp.cs.EOF?\n    {\n      SP(this.Prefix(), this.Suffix())\n    }\n\n    function PrefixLength() : uint32 requires Valid? {\n      point - beg\n    }\n\n    function SuffixLength() : uint32 requires Valid? {\n      end - point\n    }\n\n    function Length() : uint32 requires Valid? {\n      end - beg\n    }\n\n    lemma PrefixSuffixLength()\n      requires Valid?\n      ensures Length() == PrefixLength() + SuffixLength()\n    {}\n\n    ghost predicate ValidIndex?(idx: uint32) {\n      beg as int + idx as int < end as int\n    }\n\n    function At(idx: uint32) : byte\n      requires Valid?\n      requires ValidIndex?(idx)\n    {\n      s[beg + idx]\n    }\n\n    ghost predicate ValidSuffixIndex?(idx: uint32) {\n      point as int + idx as int < end as int\n    }\n\n    function SuffixAt(idx: uint32) : byte\n      requires Valid?\n      requires ValidSuffixIndex?(idx)\n    {\n      s[point + idx]\n    }\n\n    function Peek(): (r: opt_byte)\n      requires Valid?\n      ensures r < 0 <==> EOF?\n    {\n      if EOF? then -1\n      else SuffixAt(0) as opt_byte\n    }\n\n    predicate LookingAt(c: char): (b: bool)\n      requires Valid?\n      requires c as int < 256\n      ensures b <==> !EOF? && SuffixAt(0) == c as byte\n    {\n      Peek() == c as opt_byte\n    }\n\n    function Skip(n: uint32): (ps: Cursor)\n      requires Valid?\n      requires point as int + n as int <= end as int\n      ensures n == 0 ==> ps == this\n      ensures n > 0 ==> ps.StrictlyAdvancedFrom?(this)\n    {\n      this.(point := point + n)\n    }\n\n    function Unskip(n: uint32): Cursor\n      requires Valid?\n      requires beg as int <= point as int - n as int\n    {\n      this.(point := point - n)\n    }\n\n    function Get<R>(err: R): (ppr: CursorResult<R>)\n      requires Valid?\n      ensures ppr.Success? ==> ppr.value.StrictlyAdvancedFrom?(this)\n    {\n      if EOF? then Failure(OtherError(err))\n      else Success(Skip(1))\n    }\n\n    function AssertByte<R>(b: byte): (pr: CursorResult<R>)\n      requires Valid?\n      ensures pr.Success? ==> !EOF?\n      ensures pr.Success? ==> s[point] == b\n      ensures pr.Success? ==> pr.value.StrictlyAdvancedFrom?(this)\n    {\n      var nxt := Peek();\n      if nxt == b as opt_byte then Success(Skip(1))\n      else Failure(ExpectingByte(b, nxt))\n    }\n\n    function {:tailrecursion} AssertBytes<R>(bs: bytes, offset: uint32 := 0): (pr: CursorResult<R>)\n      requires Valid?\n      requires |bs| < TWO_TO_THE_32\n      requires offset <= |bs| as uint32\n      requires forall b | b in bs :: b as int < 256\n      decreases SuffixLength()\n      ensures pr.Success? ==> pr.value.AdvancedFrom?(this)\n      ensures pr.Success? && offset < |bs| as uint32 ==> pr.value.StrictlyAdvancedFrom?(this)\n      ensures pr.Success? ==> s[point..pr.value.point] == bs[offset..]\n    {\n      if offset == |bs| as uint32 then Success(this)\n      else\n        var ps :- AssertByte(bs[offset] as byte);\n        ps.AssertBytes(bs, offset + 1)\n    }\n\n    function AssertChar<R>(c0: char): (pr: CursorResult<R>)\n      requires Valid?\n      requires c0 as int < 256\n      ensures pr.Success? ==> pr.value.StrictlyAdvancedFrom?(this)\n    {\n      AssertByte(c0 as byte)\n    }\n\n    function SkipByte(): (ps: Cursor)\n      requires Valid?\n      decreases SuffixLength()\n      ensures ps.AdvancedFrom?(this)\n      ensures !EOF? ==> ps.StrictlyAdvancedFrom?(this)\n    {\n      if EOF? then this\n      else Skip(1)\n    }\n\n    function SkipIf(p: byte -> bool): (ps: Cursor)\n      requires Valid?\n      decreases SuffixLength()\n      ensures ps.AdvancedFrom?(this)\n      ensures !EOF? && p(SuffixAt(0)) ==> ps.StrictlyAdvancedFrom?(this)\n    {\n      if EOF? || !p(SuffixAt(0)) then this\n      else Skip(1)\n    }\n\n    function SkipWhile(p: byte -> bool): (ps: Cursor)\n      requires Valid?\n      decreases SuffixLength()\n      ensures ps.AdvancedFrom?(this)\n      ensures forall idx | point <= idx < ps.point :: p(ps.s[idx])\n    {\n      if EOF? || !p(SuffixAt(0)) then this\n      else Skip(1).SkipWhile(p)\n    } by method {\n      var point' := this.point;\n      var end := this.end;\n      while point' < end && p(this.s[point'])\n        invariant this.(point := point').Valid?\n        invariant this.(point := point').SkipWhile(p) == this.SkipWhile(p)\n      {\n        point' := point' + 1;\n      }\n      return Cursor(this.s, this.beg, point', this.end);\n    }\n\n    function SkipWhileLexer<A, R>(step: Lexer<A, R>, st: A)\n      : (pr: CursorResult<R>)\n      requires Valid?\n      decreases SuffixLength()\n      ensures pr.Success? ==> pr.value.AdvancedFrom?(this)\n    {\n      match step(st, Peek())\n      case Accept => Success(this)\n      case Reject(err) => Failure(OtherError(err))\n      case Partial(st) =>\n        if EOF? then Failure(EOF)\n        else Skip(1).SkipWhileLexer(step, st)\n    } by method {\n      var point' := point;\n      var end := this.end;\n      var st' := st;\n      while true\n        invariant this.(point := point').Valid?\n        invariant this.(point := point').SkipWhileLexer(step, st') == this.SkipWhileLexer(step, st)\n        decreases this.(point := point').SuffixLength()\n      {\n        var eof := point' == end;\n        var minusone: opt_byte := -1; // BUG(https://github.com/dafny-lang/dafny/issues/2191)\n        var c := if eof then minusone else this.s[point'] as opt_byte;\n        match step(st', c)\n        case Accept => return Success(Cursor(this.s, this.beg, point', this.end));\n        case Reject(err) => return Failure(OtherError(err));\n        case Partial(st'') =>\n          if eof { return Failure(EOF); }\n          else { st' := st''; point' := point' + 1; }\n      }\n    }\n  }\n}\n"}
{"file": "../libraries/src/JSON/Utils/Parsers.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"../../BoundedInts.dfy\"\ninclude \"../../Wrappers.dfy\"\ninclude \"Cursors.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Utils.Parsers {\n  import opened BoundedInts\n  import opened Wrappers\n\n  import opened Views.Core\n  import opened Cursors\n\n  type SplitResult<+T, +R> = Result<Split<T>, CursorError<R>>\n\n  type Parser<!T, +R> = p: Parser_<T, R> | p.Valid?()\n      // BUG(https://github.com/dafny-lang/dafny/issues/2103)\n    witness ParserWitness<T, R>() // BUG(https://github.com/dafny-lang/dafny/issues/2175)\n  datatype Parser_<!T, +R> = Parser(fn: FreshCursor -> SplitResult<T, R>,\n                                    ghost spec: T -> bytes) {\n    ghost predicate Valid?() {\n      forall cs': FreshCursor :: fn(cs').Success? ==> fn(cs').value.StrictlySplitFrom?(cs', spec)\n    }\n  }\n\n  function {:opaque} ParserWitness<T, R>(): (p: Parser_<T, R>)\n    ensures p.Valid?()\n  {\n    Parser(_ => Failure(EOF), _ => [])\n  }\n\n  // BUG(https://github.com/dafny-lang/dafny/issues/2137): It would be much\n  // nicer if `SubParser` was a special case of `Parser`, but that would require\n  // making `fn` in parser a partial function `-->`.  The problem with that is\n  // that we would then have to restrict the `Valid?` clause of `Parser` on\n  // `fn.requires()`, thus making it unprovable in the `SubParser` case (`fn`\n  // for subparsers is typically a lambda, and the `requires` of lambdas are\n  // essentially uninformative/opaque).\n  datatype SubParser_<!T, +R> = SubParser(\n    ghost cs: Cursor,\n    ghost pre: FreshCursor -> bool,\n    fn: FreshCursor --> SplitResult<T, R>,\n    ghost spec: T -> bytes)\n  {\n    ghost predicate Valid?() {\n      && (forall cs': FreshCursor | pre(cs') :: fn.requires(cs'))\n      && (forall cs': FreshCursor | cs'.StrictlySplitFrom?(cs) :: pre(cs'))\n      && (forall cs': FreshCursor | pre(cs') :: fn(cs').Success? ==> fn(cs').value.StrictlySplitFrom?(cs', spec))\n    }\n  }\n\n  type SubParser<!T, +R> = p: SubParser_<T, R> | p.Valid?()\n    witness SubParserWitness<T, R>() // BUG(https://github.com/dafny-lang/dafny/issues/2175)\n\n  function {:opaque} SubParserWitness<T, R>(): (subp: SubParser_<T, R>)\n    ensures subp.Valid?()\n  {\n    SubParser(Cursor([], 0, 0, 0),\n              (cs: FreshCursor) => false,\n              (cs: FreshCursor) => Failure(EOF),\n              _ => [])\n  }\n}\n"}
{"file": "../libraries/src/JSON/Utils/Views.Writers.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"../../BoundedInts.dfy\"\ninclude \"../../Wrappers.dfy\"\ninclude \"Views.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Utils.Views.Writers {\n  import opened BoundedInts\n  import opened Wrappers\n\n  import opened Core\n\n  datatype Chain =\n    | Empty\n    | Chain(previous: Chain, v: View)\n  {\n    function Length() : nat {\n      if Empty? then 0\n      else previous.Length() + v.Length() as int\n    }\n\n    function Count() : nat {\n      if Empty? then 0\n      else previous.Count() + 1\n    }\n\n    function Bytes() : (bs: bytes)\n      ensures |bs| == Length()\n    {\n      if Empty? then []\n      else previous.Bytes() + v.Bytes()\n    }\n\n    function Append(v': View): (c: Chain)\n      ensures c.Bytes() == Bytes() + v'.Bytes()\n    {\n      if Chain? && Adjacent(v, v') then\n        Chain(previous, Merge(v, v'))\n      else\n        Chain(this, v')\n    }\n\n    method {:tailrecursion} CopyTo(dest: array<byte>, end: uint32)\n      requires end as int == Length() <= dest.Length\n      modifies dest\n      ensures dest[..end] == Bytes()\n      ensures dest[end..] == old(dest[end..])\n    {\n      if Chain? {\n        var end := end - v.Length();\n        v.CopyTo(dest, end);\n        previous.CopyTo(dest, end);\n      }\n    }\n  }\n\n  type Writer = w: Writer_ | w.Valid? witness Writer(0, Chain.Empty)\n  datatype Writer_ = Writer(length: uint32, chain: Chain)\n  {\n    static const Empty: Writer := Writer(0, Chain.Empty)\n\n    const Empty? := chain.Empty?\n    const Unsaturated? := length != UINT32_MAX\n\n    ghost function Length() : nat { chain.Length() }\n\n    ghost const Valid? :=\n      length == // length is a saturating counter\n      if chain.Length() >= TWO_TO_THE_32 then UINT32_MAX\n      else chain.Length() as uint32\n\n    function Bytes() : (bs: bytes)\n      ensures |bs| == Length()\n    {\n      chain.Bytes()\n    }\n\n    static function SaturatedAddU32(a: uint32, b: uint32): uint32 {\n      if a <= UINT32_MAX - b then a + b\n      else UINT32_MAX\n    }\n\n    function {:opaque} Append(v': View): (rw: Writer)\n      requires Valid?\n      ensures rw.Unsaturated? <==> v'.Length() < UINT32_MAX - length\n      ensures rw.Bytes() == Bytes() + v'.Bytes()\n    {\n      Writer(SaturatedAddU32(length, v'.Length()),\n             chain.Append(v'))\n    }\n\n    function Then(fn: Writer ~> Writer) : Writer\n      reads fn.reads\n      requires Valid?\n      requires fn.requires(this)\n    {\n      fn(this)\n    }\n\n    method {:tailrecursion} CopyTo(dest: array<byte>)\n      requires Valid?\n      requires Unsaturated?\n      requires Length() <= dest.Length\n      modifies dest\n      ensures dest[..length] == Bytes()\n      ensures dest[length..] == old(dest[length..])\n    {\n      chain.CopyTo(dest, length);\n    }\n\n    method ToArray() returns (bs: array<byte>)\n      requires Valid?\n      requires Unsaturated?\n      ensures fresh(bs)\n      ensures bs[..] == Bytes()\n    {\n      bs := new byte[length];\n      CopyTo(bs);\n    }\n  }\n}\n"}
{"file": "../libraries/src/JSON/Utils/Vectors.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"../../BoundedInts.dfy\"\ninclude \"../../Wrappers.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Utils.Vectors {\n  import opened BoundedInts\n  import opened Wrappers\n\n  datatype VectorError = OutOfMemory\n  const OOM_FAILURE := Fail(OutOfMemory)\n\n  class Vector<A> {\n    ghost var items : seq<A>\n    ghost var Repr : set<object>\n\n    const a: A\n    var size: uint32\n    var capacity: uint32\n    var data: array<A>\n\n    const MAX_CAPACITY: uint32 := UINT32_MAX\n    const MAX_CAPACITY_BEFORE_DOUBLING: uint32 := UINT32_MAX / 2\n\n    ghost predicate Valid?()\n      reads this, Repr\n      ensures Valid?() ==> this in Repr\n    {\n      && Repr == {this, data}\n      && capacity != 0\n      && data.Length == capacity as int\n      && size <= capacity\n      && size as int == |items|\n      && items == data[..size]\n    }\n\n    constructor(a0: A, initial_capacity: uint32 := 8)\n      requires initial_capacity > 0\n      ensures size == 0\n      ensures items == []\n      ensures fresh(Repr)\n      ensures Valid?()\n    {\n      a := a0;\n      items := [];\n      size := 0;\n      capacity := initial_capacity;\n      data := new A[initial_capacity](_ => a0);\n      Repr := {this, data};\n    }\n\n    function At(idx: uint32) : (a: A)\n      reads this, this.data\n      requires idx < size\n      requires Valid?()\n      ensures a == data[idx] == items[idx]\n    {\n      data[idx]\n    }\n\n    function Top() : (a: A)\n      reads this, this.data\n      requires 0 < size\n      requires Valid?()\n      ensures a == data[size - 1] == items[size - 1]\n    {\n      data[size - 1]\n    }\n\n    method Put(idx: uint32, a: A)\n      requires idx < size\n      requires Valid?()\n      modifies data, `items\n      ensures Valid?()\n      ensures items == old(items)[idx := a]\n    {\n      data[idx] := a;\n      items := items[idx := a];\n    }\n\n    method CopyFrom(new_data: array<A>, count: uint32)\n      requires count as int <= new_data.Length\n      requires count <= capacity\n      requires data.Length == capacity as int\n      modifies data\n      ensures data[..count] == new_data[..count]\n      ensures data[count..] == old(data[count..])\n    {\n      for idx: uint32 := 0 to count\n        invariant idx <= capacity\n        invariant data.Length == capacity as int\n        invariant data[..idx] == new_data[..idx]\n        invariant data[count..] == old(data[count..])\n      {\n        data[idx] := new_data[idx];\n      }\n    }\n\n    method Realloc(new_capacity: uint32)\n      requires Valid?()\n      requires new_capacity > capacity\n      modifies `capacity, `data, `Repr, data\n      ensures Valid?()\n      ensures capacity == new_capacity\n      ensures fresh(data)\n    {\n      var old_data, old_capacity := data, capacity;\n      data, capacity := new A[new_capacity](_ => a), new_capacity;\n      CopyFrom(old_data, old_capacity);\n      Repr := {this, data};\n    }\n\n    function DefaultNewCapacity(capacity: uint32) : uint32 {\n      if capacity < MAX_CAPACITY_BEFORE_DOUBLING\n      then 2 * capacity\n      else MAX_CAPACITY\n    }\n\n    method ReallocDefault() returns (o: Outcome<VectorError>)\n      requires Valid?()\n      modifies `capacity, `data, `Repr, data\n      ensures Valid?()\n      ensures o.Fail? <==> old(capacity) == MAX_CAPACITY\n      ensures o.Fail? ==>\n                && unchanged(this)\n                && unchanged(data)\n      ensures o.Pass? ==>\n                && fresh(data)\n                && old(capacity) < MAX_CAPACITY\n                && capacity == old(if capacity < MAX_CAPACITY_BEFORE_DOUBLING\n                                   then 2 * capacity else MAX_CAPACITY)\n\n    {\n      if capacity == MAX_CAPACITY {\n        return Fail(OutOfMemory);\n      }\n      Realloc(DefaultNewCapacity(capacity));\n      return Pass;\n    }\n\n    method Ensure(reserved: uint32) returns (o: Outcome<VectorError>)\n      requires Valid?()\n      modifies this, `data\n      ensures Valid?()\n      modifies `capacity, `data, `Repr, data\n      ensures reserved <= capacity - size ==>\n                o.Pass?\n      ensures o.Pass? ==>\n                old(size as int + reserved as int) <= capacity as int\n      ensures o.Fail? ==>\n                reserved > MAX_CAPACITY - size\n    {\n      if reserved > MAX_CAPACITY - size {\n        return Fail(OutOfMemory);\n      }\n      if reserved <= capacity - size {\n        return Pass;\n      }\n      var new_capacity := capacity;\n      while reserved > new_capacity - size\n        decreases MAX_CAPACITY - new_capacity\n        invariant new_capacity >= capacity\n      {\n        new_capacity := DefaultNewCapacity(new_capacity);\n      }\n      Realloc(new_capacity);\n      return Pass;\n    }\n\n    method PopFast()\n      requires Valid?()\n      requires size > 0\n      modifies `size, `items\n      ensures Valid?()\n      ensures size == old(size) - 1\n      ensures items == old(items[..|items| - 1])\n    {\n      size := size - 1;\n      items := items[..|items| - 1];\n    }\n\n    method PushFast(a: A)\n      requires Valid?()\n      requires size < capacity\n      modifies `size, `items, data\n      ensures Valid?()\n      ensures size == old(size) + 1\n      ensures items == old(items) + [a]\n    {\n      data[size] := a;\n      size := size + 1;\n      items := items + [a];\n    }\n\n    method Push(a: A) returns (o: Outcome<VectorError>)\n      requires Valid?()\n      modifies this, data\n      ensures Valid?()\n      ensures o.Fail? ==>\n                && unchanged(this)\n                && unchanged(data)\n      ensures o.Pass? ==>\n                && old(size) < MAX_CAPACITY\n                && size == old(size) + 1\n                && items == old(items) + [a]\n                && capacity >= old(capacity)\n                && if old(size == capacity) then fresh(data) else unchanged(`data)\n    {\n      if size == capacity {\n        var d := ReallocDefault();\n        if d.Fail? { return d; }\n      }\n      PushFast(a);\n      return Pass;\n    }\n  }\n}\n"}
{"file": "../libraries/src/JSON/Utils/Lexers.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"../../Wrappers.dfy\"\ninclude \"../../BoundedInts.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Utils.Lexers {\n  module Core {\n    import opened Wrappers\n    import opened BoundedInts\n\n    datatype LexerResult<+T, +R> =\n        // A Lexer may return three results:\n      | Accept // The input is valid.\n      | Reject(err: R) // The input is not valid; `err` says why.\n      | Partial(st: T) // More input is needed to finish lexing.\n\n    type Lexer<!T, +R> = (T, opt_byte) -> LexerResult<T, R>\n  }\n\n  module Strings {\n    import opened Core\n    import opened BoundedInts\n\n    type StringBodyLexerState = /* escaped: */ bool\n    const StringBodyLexerStart: StringBodyLexerState := false;\n\n    function StringBody<R>(escaped: StringBodyLexerState, byte: opt_byte)\n      : LexerResult<StringBodyLexerState, R>\n    {\n      if byte == '\\\\' as opt_byte then Partial(!escaped)\n      else if byte == '\\\"' as opt_byte && !escaped then Accept\n      else Partial(false)\n    }\n\n    datatype StringLexerState = Start | Body(escaped: bool) | End\n    const StringLexerStart: StringLexerState := Start;\n\n    function String(st: StringLexerState, byte: opt_byte)\n      : LexerResult<StringLexerState, string>\n    {\n      match st\n      case Start() =>\n        if byte == '\\\"' as opt_byte then Partial(Body(false))\n        else Reject(\"String must start with double quote\")\n      case End() =>\n        Accept\n      case Body(escaped) =>\n        if byte == '\\\\' as opt_byte then Partial(Body(!escaped))\n        else if byte == '\\\"' as opt_byte && !escaped then Partial(End)\n        else Partial(Body(false))\n    }\n  }\n}\n"}
{"file": "../libraries/src/JSON/Utils/Views.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"../../BoundedInts.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Utils.Views.Core {\n  import opened BoundedInts\n\n  type View = v: View_ | v.Valid? witness View([], 0, 0)\n  datatype View_ = View(s: bytes, beg: uint32, end: uint32) {\n    ghost const Valid?: bool :=\n      0 <= beg as int <= end as int <= |s| < TWO_TO_THE_32;\n\n    static const Empty: View :=\n      View([], 0, 0)\n\n    const Empty? :=\n      beg == end\n\n    function Length(): uint32 requires Valid? {\n      end - beg\n    }\n\n    function Bytes(): bytes requires Valid? {\n      s[beg..end]\n    }\n\n    static function OfBytes(bs: bytes) : (v: View)\n      requires |bs| < TWO_TO_THE_32\n      ensures v.Bytes() == bs\n    {\n      View(bs, 0 as uint32, |bs| as uint32)\n    }\n\n    static function OfString(s: string) : bytes\n      requires forall c: char | c in s :: c as int < 256\n    {\n      seq(|s|, i requires 0 <= i < |s| =>\n        assert s[i] in s; s[i] as byte)\n    }\n\n    ghost predicate SliceOf?(v': View) {\n      v'.s == s && v'.beg <= beg && end <= v'.end\n    }\n\n    ghost predicate StrictPrefixOf?(v': View) {\n      v'.s == s && v'.beg == beg && end < v'.end\n    }\n\n    ghost predicate StrictSuffixOf?(v': View) {\n      v'.s == s && v'.beg < beg && end == v'.end\n    }\n\n    predicate Byte?(c: byte)\n      requires Valid?\n    {\n      Bytes() == [c]\n    } by method {\n      return Length() == 1 && At(0) == c;\n    }\n\n    predicate Char?(c: char)\n      requires Valid?\n      requires c as int < 256\n    {\n      Byte?(c as byte)\n    }\n\n    ghost predicate ValidIndex?(idx: uint32) {\n      beg as int + idx as int < end as int\n    }\n\n    function At(idx: uint32) : byte\n      requires Valid?\n      requires ValidIndex?(idx)\n    {\n      s[beg + idx]\n    }\n\n    function Peek(): (r: opt_byte)\n      requires Valid?\n      ensures r < 0 <==> Empty?\n    {\n      if Empty? then -1\n      else At(0) as opt_byte\n    }\n\n    method CopyTo(dest: array<byte>, start: uint32 := 0)\n      requires Valid?\n      requires start as int + Length() as int <= dest.Length\n      requires start as int + Length() as int < TWO_TO_THE_32\n      modifies dest\n      ensures dest[start..start + Length()] == Bytes()\n      ensures dest[start + Length()..] == old(dest[start + Length()..])\n    {\n      for idx := 0 to Length()\n        invariant dest[start..start + idx] == Bytes()[..idx]\n        invariant dest[start + Length()..] == old(dest[start + Length()..])\n      {\n        dest[start + idx] := s[beg + idx];\n      }\n    }\n  }\n\n  predicate Adjacent(lv: View, rv: View) {\n    // Compare endpoints first to short-circuit the potentially-costly string\n    // comparison\n    && lv.end == rv.beg\n       // We would prefer to use reference equality here, but doing so in a sound\n       // way is tricky (see chapter 9 of ‘Verasco: a Formally Verified C Static\n       // Analyzer’ by Jacques-Henri Jourdan for details).  The runtime optimizes\n       // the common case of physical equality and otherwise performs a length\n       // check, so the worst case (checking for adjacency in two slices that have\n       // equal but not physically-equal contents) is hopefully not too common.\n    && lv.s == rv.s\n  }\n\n  function Merge(lv: View, rv: View) : (v: View)\n    requires Adjacent(lv, rv)\n    ensures v.Bytes() == lv.Bytes() + rv.Bytes()\n  {\n    lv.(end := rv.end)\n  }\n}\n"}
{"file": "../libraries/src/JSON/Utils/Str.dfy", "dafny": "// RUN: %verify --disable-nonlinear-arithmetic \"%s\"\n\ninclude \"../../BoundedInts.dfy\"\ninclude \"../../Wrappers.dfy\"\ninclude \"../../NonlinearArithmetic/Mul.dfy\"\ninclude \"../../NonlinearArithmetic/DivMod.dfy\"\ninclude \"../../NonlinearArithmetic/Logarithm.dfy\"\ninclude \"../../NonlinearArithmetic/Power.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Utils.Str {\n  import opened Wrappers\n  import opened Power\n  import opened Logarithm\n\n  abstract module ParametricConversion {\n    import opened Wrappers\n    import opened Mul\n    import opened DivMod\n    import opened Power\n    import opened Logarithm\n\n    type Char(==)\n    type String = seq<Char>\n\n    // FIXME the design in LittleEndianNat makes BASE a module-level constant\n    // instead of a function argument\n    function Digits(n: nat, base: int): (digits: seq<int>)\n      requires base > 1\n      decreases n\n      ensures n == 0 ==> |digits| == 0\n      ensures n > 0 ==> |digits| == Log(base, n) + 1\n      ensures forall d | d in digits :: 0 <= d < base\n    {\n      if n == 0 then\n        assert Pow(base, 0) == 1 by { reveal Pow(); }\n        []\n      else\n        LemmaDivPosIsPosAuto(); LemmaDivDecreasesAuto();\n        var digits' := Digits(n / base, base);\n        var digits := digits' + [n % base];\n        assert |digits| == Log(base, n) + 1 by {\n          assert |digits| == |digits'| + 1;\n          if n < base {\n            LemmaLog0(base, n);\n            assert n / base == 0 by { LemmaBasicDiv(base); }\n          } else {\n            LemmaLogS(base, n);\n            assert n / base > 0 by { LemmaDivNonZeroAuto(); }\n          }\n        }\n        digits\n    }\n\n    function OfDigits(digits: seq<int>, chars: seq<Char>) : (str: String)\n      requires forall d | d in digits :: 0 <= d < |chars|\n      ensures forall c | c in str :: c in chars\n      ensures |str| == |digits|\n    {\n      if digits == [] then []\n      else\n        assert digits[0] in digits;\n        assert forall d | d in digits[1..] :: d in digits;\n        [chars[digits[0]]] + OfDigits(digits[1..], chars)\n    }\n\n    function OfNat_any(n: nat, chars: seq<Char>) : (str: String)\n      requires |chars| > 1\n      ensures |str| == Log(|chars|, n) + 1\n      ensures forall c | c in str :: c in chars\n    {\n      var base := |chars|;\n      if n == 0 then reveal Log(); [chars[0]]\n      else OfDigits(Digits(n, base), chars)\n    }\n\n    predicate NumberStr(str: String, minus: Char, is_digit: Char -> bool) {\n      str != [] ==>\n        && (str[0] == minus || is_digit(str[0]))\n        && forall c | c in str[1..] :: is_digit(c)\n    }\n\n    function OfInt_any(n: int, chars: seq<Char>, minus: Char) : (str: String)\n      requires |chars| > 1\n      ensures NumberStr(str, minus, c => c in chars)\n    {\n      if n >= 0 then OfNat_any(n, chars)\n      else [minus] + OfNat_any(-n, chars)\n    }\n\n    function {:vcs_split_on_every_assert} ToNat_any(str: String, base: nat, digits: map<Char, nat>) : (n: nat)\n      requires base > 0\n      requires forall c | c in str :: c in digits\n    {\n      if str == [] then 0\n      else\n        LemmaMulNonnegativeAuto();\n        ToNat_any(str[..|str| - 1], base, digits) * base + digits[str[|str| - 1]]\n    }\n\n    lemma {:induction false} ToNat_bound(str: String, base: nat, digits: map<Char, nat>)\n      requires base > 0\n      requires forall c | c in str :: c in digits\n      requires forall c | c in str :: digits[c] < base\n      ensures ToNat_any(str, base, digits) < Pow(base, |str|)\n    {\n      if str == [] {\n        reveal Pow();\n      } else {\n        calc <= {\n          ToNat_any(str, base, digits);\n          ToNat_any(str[..|str| - 1], base, digits) * base + digits[str[|str| - 1]];\n          ToNat_any(str[..|str| - 1], base, digits) * base + (base - 1);\n          { ToNat_bound(str[..|str| - 1], base, digits);\n            LemmaMulInequalityAuto(); }\n          (Pow(base, |str| - 1) - 1) * base + base - 1;\n          { LemmaMulIsDistributiveAuto(); }\n          Pow(base, |str| - 1) * base - 1;\n          { reveal Pow(); LemmaMulIsCommutativeAuto(); }\n          Pow(base, |str|) - 1;\n        }\n      }\n    }\n\n    function ToInt_any(str: String, minus: Char, base: nat, digits: map<Char, nat>) : (s: int)\n      requires base > 0\n      requires str != [minus]\n      requires NumberStr(str, minus, c => c in digits)\n    {\n      if [minus] <= str then -(ToNat_any(str[1..], base, digits) as int)\n      else\n        assert str == [] || str == [str[0]] + str[1..];\n        ToNat_any(str, base, digits)\n    }\n  }\n\n  abstract module ParametricEscaping {\n    import opened Wrappers\n\n    type Char(==)\n    type String = seq<Char>\n\n    function Escape(str: String, special: set<Char>, escape: Char): String {\n      if str == [] then str\n      else if str[0] in special then [escape, str[0]] + Escape(str[1..], special, escape)\n      else [str[0]] + Escape(str[1..], special, escape)\n    }\n\n    datatype UnescapeError =\n      EscapeAtEOS\n\n    function Unescape(str: String, escape: Char): Result<String, UnescapeError> {\n      if str == [] then Success(str)\n      else if str[0] == escape then\n        if |str| > 1 then var tl :- Unescape(str[2..], escape); Success([str[1]] + tl)\n        else Failure(EscapeAtEOS)\n      else var tl :- Unescape(str[1..], escape); Success([str[0]] + tl)\n    }\n\n    lemma {:induction false} Unescape_Escape(str: String, special: set<Char>, escape: Char)\n      requires escape in special\n      ensures Unescape(Escape(str, special, escape), escape) == Success(str)\n    {\n      if str == [] {\n      } else {\n        assert str == [str[0]] + str[1..];\n        Unescape_Escape(str[1..], special, escape);\n      }\n    }\n  }\n\n  module CharStrConversion refines ParametricConversion {\n    type Char = char\n  }\n\n  module CharStrEscaping refines ParametricEscaping {\n    type Char = char\n  }\n\n  const HEX_DIGITS: seq<char> := \"0123456789ABCDEF\"\n\n  const HEX_TABLE :=\n    map[\n      '0' := 0, '1' := 1, '2' := 2, '3' := 3, '4' := 4, '5' := 5, '6' := 6, '7' := 7, '8' := 8, '9' := 9,\n      'a' := 0xA, 'b' := 0xB, 'c' := 0xC, 'd' := 0xD, 'e' := 0xE, 'f' := 0xF,\n      'A' := 0xA, 'B' := 0xB, 'C' := 0xC, 'D' := 0xD, 'E' := 0xE, 'F' := 0xF\n    ]\n\n  function OfNat(n: nat, base: int := 10) : (str: string)\n    requires 2 <= base <= 16\n    ensures |str| == Log(base, n) + 1\n    ensures forall c | c in str :: c in HEX_DIGITS[..base]\n  {\n    CharStrConversion.OfNat_any(n, HEX_DIGITS[..base])\n  }\n\n  function OfInt(n: int, base: int := 10) : (str: string)\n    requires 2 <= base <= 16\n    ensures CharStrConversion.NumberStr(str, '-', c => c in HEX_DIGITS[..base])\n  {\n    CharStrConversion.OfInt_any(n, HEX_DIGITS[..base], '-')\n  }\n\n  function ToNat(str: string, base: int := 10) : (n: nat)\n    requires 2 <= base <= 16\n    requires forall c | c in str :: c in HEX_TABLE && HEX_TABLE[c] as int < base\n    ensures n < Pow(base, |str|)\n  {\n    CharStrConversion.ToNat_bound(str, base, HEX_TABLE);\n    CharStrConversion.ToNat_any(str, base, HEX_TABLE)\n  }\n\n  function ToInt(str: string, base: int := 10) : (n: int)\n    requires str != \"-\"\n    requires 2 <= base <= 16\n    requires CharStrConversion.NumberStr(str, '-', (c: char) => c in HEX_TABLE && HEX_TABLE[c] as int < base)\n  {\n    CharStrConversion.ToInt_any(str, '-', base, HEX_TABLE)\n  }\n\n  function EscapeQuotes(str: string): string {\n    CharStrEscaping.Escape(str, {'\\\"', '\\''}, '\\\\')\n  }\n\n  function UnescapeQuotes(str: string): Result<string, CharStrEscaping.UnescapeError> {\n    CharStrEscaping.Unescape(str, '\\\\')\n  }\n\n  method Test() { // FIXME {:test}?\n    expect OfInt(0, 10) == \"0\";\n    expect OfInt(3, 10) == \"3\";\n    expect OfInt(302, 10) == \"302\";\n    expect OfInt(-3, 10) == \"-3\";\n    expect OfInt(-302, 10) == \"-302\";\n  }\n\n  function OfBool(b: bool) : string {\n    if b then \"true\" else \"false\"\n  }\n\n  function OfChar(c: char) : string {\n    [c]\n  }\n\n  function Join(sep: string, strs: seq<string>) : string {\n    if |strs| == 0 then \"\"\n    else if |strs| == 1 then strs[0]\n    else strs[0] + sep + Join(sep, strs[1..])\n  }\n\n  function Concat(strs: seq<string>) : string {\n    if |strs| == 0 then \"\"\n    else strs[0] + Concat(strs[1..])\n  }\n\n  lemma Concat_Join(strs: seq<string>)\n    ensures Concat(strs) == Join(\"\", strs)\n  {}\n}\n"}
{"file": "../libraries/src/JSON/ConcreteSyntax.SpecProperties.dfy", "dafny": "// RUN: %verify \"%s\" --unicode-char:false ../Unicode/UnicodeStringsWithoutUnicodeChar.dfy\n// RUN: %verify \"%s\" --unicode-char:true ../Unicode/UnicodeStringsWithUnicodeChar.dfy\n\ninclude \"ConcreteSyntax.Spec.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.ConcreteSyntax.SpecProperties\n// Some useful properties about the functions used in `ConcreteSyntax.Spec`.\n{\n  import opened BoundedInts\n\n  import Vs = Utils.Views.Core\n  import opened Grammar\n  import Spec\n\n  ghost predicate Bracketed_Morphism_Requires<D, S>(bracketed: Bracketed<Vs.View, D, S, Vs.View>, pd0: Suffixed<D, S> --> bytes, pd1: Suffixed<D, S> --> bytes) {\n    && (forall d | d < bracketed :: pd0.requires(d))\n    && (forall d | d < bracketed :: pd1.requires(d))\n    && (forall d | d < bracketed :: pd0(d) == pd1(d))\n  }\n\n  lemma Bracketed_Morphism<D, S>(bracketed: Bracketed<Vs.View, D, S, Vs.View>, pd0: Suffixed<D, S> --> bytes, pd1: Suffixed<D, S> --> bytes)\n    requires Bracketed_Morphism_Requires(bracketed, pd0, pd1)\n    ensures Spec.Bracketed(bracketed, pd0) == Spec.Bracketed(bracketed, pd1)\n  {\n    calc {\n      Spec.Bracketed(bracketed, pd0);\n      { ConcatBytes_Morphism(bracketed.data, pd0, pd1); }\n      Spec.Bracketed(bracketed, pd1);\n    }\n  }\n\n  lemma {:induction ts} ConcatBytes_Morphism<T>(ts: seq<T>, pt0: T --> bytes, pt1: T --> bytes)\n    requires forall d | d in ts :: pt0.requires(d)\n    requires forall d | d in ts :: pt1.requires(d)\n    requires forall d | d in ts :: pt0(d) == pt1(d)\n    ensures Spec.ConcatBytes(ts, pt0) == Spec.ConcatBytes(ts, pt1)\n  {}\n\n  lemma {:induction ts0} ConcatBytes_Linear<T>(ts0: seq<T>, ts1: seq<T>, pt: T --> bytes)\n    requires forall d | d in ts0 :: pt.requires(d)\n    requires forall d | d in ts1 :: pt.requires(d)\n    ensures Spec.ConcatBytes(ts0 + ts1, pt) == Spec.ConcatBytes(ts0, pt) + Spec.ConcatBytes(ts1, pt)\n  {\n    if |ts0| == 0 {\n      assert [] + ts1 == ts1;\n    } else {\n      assert ts0 + ts1 == [ts0[0]] + (ts0[1..] + ts1);\n    }\n  }\n}\n"}
{"file": "../libraries/src/JSON/Serializer.dfy", "dafny": "// RUN: %verify \"%s\" --unicode-char:false ../Unicode/UnicodeStringsWithoutUnicodeChar.dfy\n// RUN: %verify \"%s\" --unicode-char:true ../Unicode/UnicodeStringsWithUnicodeChar.dfy\n\n/// ================================================\n///  Serialization from JSON.Values to JSON.Grammar\n/// ================================================\n///\n/// For the spec, see ``JSON.Spec.dfy``.\n\ninclude \"../Collections/Sequences/Seq.dfy\"\ninclude \"../BoundedInts.dfy\"\ninclude \"../Math.dfy\"\n\ninclude \"Utils/Views.dfy\"\ninclude \"Utils/Vectors.dfy\"\ninclude \"Errors.dfy\"\ninclude \"Values.dfy\"\ninclude \"Grammar.dfy\"\ninclude \"Spec.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Serializer {\n  import Seq\n  import Math\n  import opened Wrappers\n  import opened BoundedInts\n  import opened Utils.Str\n\n  import Values\n  import Spec\n  import opened Errors\n  import opened Utils.Vectors\n  import opened Grammar\n  import opened Utils.Views.Core\n\n  type Result<+T> = SerializationResult<T>\n\n  type bytes = seq<uint8>\n  type bytes32 = bs: bytes | |bs| < TWO_TO_THE_32\n  type string32 = s: string | |s| < TWO_TO_THE_32\n\n  function Bool(b: bool): jbool {\n    View.OfBytes(if b then TRUE else FALSE)\n  }\n\n  function CheckLength<T>(s: seq<T>, err: SerializationError): Outcome<SerializationError> {\n    Need(|s| < TWO_TO_THE_32, err)\n  }\n\n  function String(str: string): Result<jstring> {\n    var bs :- Spec.EscapeToUTF8(str);\n    :- CheckLength(bs, StringTooLong(str));\n    Success(Grammar.JString(Grammar.DOUBLEQUOTE, View.OfBytes(bs), Grammar.DOUBLEQUOTE))\n  }\n\n  function Sign(n: int): jminus {\n    View.OfBytes(if n < 0 then ['-' as byte] else [])\n  }\n\n  module ByteStrConversion refines Str.ParametricConversion {\n    import opened BoundedInts\n    type Char = uint8\n  }\n\n  const DIGITS := [\n    '0' as uint8, '1' as uint8, '2' as uint8, '3' as uint8,\n    '4' as uint8, '5' as uint8, '6' as uint8, '7' as uint8,\n    '8' as uint8, '9' as uint8\n  ]\n\n  const MINUS := '-' as uint8\n\n  function Int'(n: int) : (str: bytes)\n    ensures forall c | c in str :: c in DIGITS || c == MINUS\n  {\n    ByteStrConversion.OfInt_any(n, DIGITS, MINUS)\n  }\n\n  function Int(n: int) : Result<View> {\n    var bs := Int'(n);\n    :- CheckLength(bs, IntTooLarge(n));\n    Success(View.OfBytes(bs))\n  }\n\n  function Number(dec: Values.Decimal): Result<jnumber> {\n    var minus: jminus := Sign(dec.n);\n    var num: jnum :- Int(Math.Abs(dec.n));\n    var frac: Maybe<jfrac> := Empty();\n    var exp: Maybe<jexp> :-\n      if dec.e10 == 0 then\n        Success(Empty())\n      else\n        var e: je := View.OfBytes(['e' as byte]);\n        var sign: jsign := Sign(dec.e10);\n        var num: jnum :- Int(Math.Abs(dec.e10));\n        Success(NonEmpty(JExp(e, sign, num)));\n    Success(JNumber(minus, num, Empty, exp))\n  }\n\n  function MkStructural<T>(v: T): Structural<T> {\n    Structural(EMPTY, v, EMPTY)\n  }\n\n  const COLON: Structural<jcolon> :=\n    MkStructural(Grammar.COLON)\n\n  function KeyValue(kv: (string, Values.JSON)): Result<jKeyValue> {\n    var k :- String(kv.0);\n    var v :- Value(kv.1);\n    Success(Grammar.KeyValue(k, COLON, v))\n  }\n\n  function MkSuffixedSequence<D, S>(ds: seq<D>, suffix: Structural<S>, start: nat := 0)\n    : SuffixedSequence<D, S>\n    decreases |ds| - start\n  {\n    if start >= |ds| then []\n    else if start == |ds| - 1 then [Suffixed(ds[start], Empty)]\n    else [Suffixed(ds[start], NonEmpty(suffix))] + MkSuffixedSequence(ds, suffix, start + 1)\n  }\n\n  const COMMA: Structural<jcomma> :=\n    MkStructural(Grammar.COMMA)\n\n  function Object(obj: seq<(string, Values.JSON)>): Result<jobject> {\n    var items :- Seq.MapWithResult(v requires v in obj => KeyValue(v), obj);\n    Success(Bracketed(MkStructural(LBRACE),\n                      MkSuffixedSequence(items, COMMA),\n                      MkStructural(RBRACE)))\n  }\n\n\n  function Array(arr: seq<Values.JSON>): Result<jarray> {\n    var items :- Seq.MapWithResult(v requires v in arr => Value(v), arr);\n    Success(Bracketed(MkStructural(LBRACKET),\n                      MkSuffixedSequence(items, COMMA),\n                      MkStructural(RBRACKET)))\n  }\n\n  function Value(js: Values.JSON): Result<Grammar.Value> {\n    match js\n    case Null => Success(Grammar.Null(View.OfBytes(NULL)))\n    case Bool(b) => Success(Grammar.Bool(Bool(b)))\n    case String(str) => var s :- String(str); Success(Grammar.String(s))\n    case Number(dec) => var n :- Number(dec); Success(Grammar.Number(n))\n    case Object(obj) => var o :- Object(obj); Success(Grammar.Object(o))\n    case Array(arr) => var a :- Array(arr); Success(Grammar.Array(a))\n  }\n\n  function JSON(js: Values.JSON): Result<Grammar.JSON> {\n    var val :- Value(js);\n    Success(MkStructural(val))\n  }\n}\n"}
{"file": "../libraries/src/JSON/Deserializer.dfy", "dafny": "// RUN: %verify \"%s\" --unicode-char:false ../Unicode/UnicodeStringsWithoutUnicodeChar.dfy\n// RUN: %verify \"%s\" --unicode-char:true ../Unicode/UnicodeStringsWithUnicodeChar.dfy\n\n/// ==================================================\n///  Deserialization from JSON.Grammar to JSON.Values\n/// ==================================================\n///\n/// For the spec, see ``JSON.Spec.dfy``.\n\ninclude \"../Collections/Sequences/Seq.dfy\"\ninclude \"../BoundedInts.dfy\"\n\ninclude \"Utils/Views.dfy\"\ninclude \"Utils/Vectors.dfy\"\ninclude \"Errors.dfy\"\ninclude \"Values.dfy\"\ninclude \"Grammar.dfy\"\ninclude \"Spec.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Deserializer {\n  import Seq\n\n  import opened Wrappers\n  import opened BoundedInts\n  import opened Logarithm\n  import opened Power\n  import opened Utils.Str\n  import opened UnicodeStrings\n\n  import Values\n  import Spec\n  import opened Errors\n  import opened Utils.Vectors\n  import opened Grammar\n  import opened Utils.Views.Core\n\n  function Bool(js: Grammar.jbool): bool {\n    assert js.Bytes() in {Grammar.TRUE, Grammar.FALSE};\n    js.At(0) == 't' as byte\n  }\n\n  function UnsupportedEscape16(code: seq<uint16>): DeserializationError {\n    UnsupportedEscape(FromUTF16Checked(code).UnwrapOr(\"Couldn't decode UTF-16\"))\n  }\n\n  module Uint16StrConversion refines Str.ParametricConversion {\n    import opened BoundedInts\n\n    type Char = uint16\n  }\n\n  const HEX_TABLE_16: map<Uint16StrConversion.Char, nat> :=\n    map[\n      '0' as uint16 := 0, '1' as uint16 := 1, '2' as uint16 := 2, '3' as uint16 := 3, '4' as uint16 := 4,\n      '5' as uint16 := 5, '6' as uint16 := 6, '7' as uint16 := 7, '8' as uint16 := 8, '9' as uint16 := 9,\n      'a' as uint16 := 0xA, 'b' as uint16 := 0xB, 'c' as uint16 := 0xC, 'd' as uint16 := 0xD, 'e' as uint16 := 0xE, 'f' as uint16 := 0xF,\n      'A' as uint16 := 0xA, 'B' as uint16 := 0xB, 'C' as uint16 := 0xC, 'D' as uint16 := 0xD, 'E' as uint16 := 0xE, 'F' as uint16 := 0xF\n    ]\n\n  function ToNat16(str: Uint16StrConversion.String): uint16\n    requires |str| <= 4\n    requires forall c | c in str :: c in HEX_TABLE_16\n  {\n    Uint16StrConversion.ToNat_bound(str, 16, HEX_TABLE_16);\n    var hd := Uint16StrConversion.ToNat_any(str, 16, HEX_TABLE_16);\n    assert hd < 0x1_0000 by { reveal Pow(); }\n    hd as uint16\n  }\n\n  function {:tailrecursion} {:vcs_split_on_every_assert} Unescape(str: seq<uint16>, start: nat := 0, prefix: seq<uint16> := []): DeserializationResult<seq<uint16>>\n    decreases |str| - start\n  { // Assumes UTF-16 strings\n    if start >= |str| then Success(prefix)\n    else if str[start] == '\\\\' as uint16 then\n      if |str| == start + 1 then\n        Failure(EscapeAtEOS)\n      else\n        var c := str[start + 1];\n        if c == 'u' as uint16 then\n          if |str| <= start + 6 then\n            Failure(EscapeAtEOS)\n          else\n            var code := str[start + 2..start + 6];\n            if exists c | c in code :: c !in HEX_TABLE_16 then\n              Failure(UnsupportedEscape16(code))\n            else\n              var hd := ToNat16(code);\n              Unescape(str, start + 6, prefix + [hd])\n        else\n          var unescaped: uint16 := match c\n            case 0x22 => 0x22 as uint16 // \\\" => quotation mark\n            case 0x5C => 0x5C as uint16 // \\\\ => reverse solidus\n            case 0x62 => 0x08 as uint16 // \\b => backspace\n            case 0x66 => 0x0C as uint16 // \\f => form feed\n            case 0x6E => 0x0A as uint16 // \\n => line feed\n            case 0x72 => 0x0D as uint16 // \\r => carriage return\n            case 0x74 => 0x09 as uint16 // \\t => tab\n            case _    => 0 as uint16;\n          if unescaped as int == 0 then\n            Failure(UnsupportedEscape16(str[start..start+2]))\n          else\n            Unescape(str, start + 2, prefix + [unescaped])\n    else\n      Unescape(str, start + 1, prefix + [str[start]])\n  }\n\n  function String(js: Grammar.jstring): DeserializationResult<string> {\n    var asUtf32 :- FromUTF8Checked(js.contents.Bytes()).ToResult'(DeserializationError.InvalidUnicode);\n    var asUint16 :- ToUTF16Checked(asUtf32).ToResult'(DeserializationError.InvalidUnicode);\n    var unescaped :- Unescape(asUint16);\n    FromUTF16Checked(unescaped).ToResult'(DeserializationError.InvalidUnicode)\n  }\n\n  module ByteStrConversion refines Str.ParametricConversion {\n    import opened BoundedInts\n    type Char = byte\n  }\n\n  const DIGITS :=\n    map[\n      '0' as uint8 := 0, '1' as uint8 := 1, '2' as uint8 := 2, '3' as uint8 := 3,\n      '4' as uint8 := 4, '5' as uint8 := 5, '6' as uint8 := 6, '7' as uint8 := 7,\n      '8' as uint8 := 8, '9' as uint8 := 9\n    ]\n\n  const MINUS := '-' as uint8\n\n  function ToInt(sign: jsign, n: jnum): DeserializationResult<int> {\n    var n: int := ByteStrConversion.ToNat_any(n.Bytes(), 10, DIGITS);\n    Success(if sign.Char?('-') then -n else n)\n  }\n\n  function Number(js: Grammar.jnumber): DeserializationResult<Values.Decimal> {\n    var JNumber(minus, num, frac, exp) := js;\n    var n :-\n      ToInt(minus, num);\n    var e10 :- match exp\n      case Empty => Success(0)\n      case NonEmpty(JExp(_, sign, num)) => ToInt(sign, num);\n    match frac\n    case Empty => Success(Values.Decimal(n, e10))\n    case NonEmpty(JFrac(_, num)) =>\n      var pow10 := num.Length() as int;\n      var frac :- ToInt(minus, num);\n      Success(Values.Decimal(n * Pow(10, pow10) + frac, e10 - pow10))\n  }\n\n  function KeyValue(js: Grammar.jKeyValue): DeserializationResult<(string, Values.JSON)> {\n    var k :- String(js.k);\n    var v :- Value(js.v);\n    Success((k, v))\n  }\n\n  function Object(js: Grammar.jobject): DeserializationResult<seq<(string, Values.JSON)>> {\n    Seq.MapWithResult(d requires d in js.data => KeyValue(d.t), js.data)\n  }\n\n  function Array(js: Grammar.jarray): DeserializationResult<seq<Values.JSON>> {\n    Seq.MapWithResult(d requires d in js.data => Value(d.t), js.data)\n  }\n\n  function Value(js: Grammar.Value): DeserializationResult<Values.JSON> {\n    match js\n    case Null(_) => Success(Values.Null())\n    case Bool(b) => Success(Values.Bool(Bool(b)))\n    case String(str) => var s :- String(str); Success(Values.String(s))\n    case Number(dec) => var n :- Number(dec); Success(Values.Number(n))\n    case Object(obj) => var o :- Object(obj); Success(Values.Object(o))\n    case Array(arr) => var a :- Array(arr); Success(Values.Array(a))\n  }\n\n  function JSON(js: Grammar.JSON): DeserializationResult<Values.JSON> {\n    Value(js.t)\n  }\n}\n"}
{"file": "../libraries/src/JSON/Values.dfy", "dafny": "// RUN: %verify \"%s\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Values {\n  datatype Decimal =\n    Decimal(n: int, e10: int) // (n) * 10^(e10)\n\n  function Int(n: int): Decimal {\n    Decimal(n, 0)\n  }\n\n  datatype JSON =\n    | Null\n    | Bool(b: bool)\n    | String(str: string)\n    | Number(num: Decimal)\n    | Object(obj: seq<(string, JSON)>) // Not a map to preserve order\n    | Array(arr: seq<JSON>)\n}\n"}
{"file": "../libraries/src/JSON/Tutorial.dfy", "dafny": "// RUN: %run \"%s\" --unicode-char:false --input ../Unicode/UnicodeStringsWithoutUnicodeChar.dfy\n// RUN: %run \"%s\" --unicode-char:true --input ../Unicode/UnicodeStringsWithUnicodeChar.dfy\n\n/// # Using the JSON library\n\ninclude \"API.dfy\"\ninclude \"ZeroCopy/API.dfy\"\n\n/// This library offers two APIs: a high-level one (giving abstract value trees\n/// with no concrete syntactic details) and a low-level one (including all\n/// information about blanks, separator positions, character escapes, etc.).\n///\n/// ## High-level API (JSON values)\n\nmodule {:options \"-functionSyntax:4\"} JSON.Examples.AbstractSyntax {\n  import API\n  import opened Values\n  import opened Wrappers\n\n/// Note that you will need to include one of the two files that defines UnicodeStrings\n/// according to whether you are using --unicode-char:false or --unicode-char:true.\n/// See ../../Unicode/UnicodeStrings.dfy for more details.\n\n  import opened UnicodeStrings\n\n/// The high-level API works with fairly simple datatype values that contain native Dafny\n/// strings:\n\n  method {:test} Test() {\n\n/// Use `API.Deserialize` to deserialize a byte string.\n///\n/// For example, here is how to decode the JSON test `\"[true]\"`.  (We need to\n/// convert from Dafny's native strings to byte strings because Dafny does not\n/// have syntax for byte strings; in a real application, we would be reading and\n/// writing raw bytes directly from disk or from the network instead).\n\n    var SIMPLE_JS :- expect ToUTF8Checked(\"[true]\");\n    var SIMPLE_VALUE := Array([Bool(true)]);\n    expect API.Deserialize(SIMPLE_JS) == Success(SIMPLE_VALUE);\n\n/// Here is a larger object, written using a verbatim string (with `@\"`).  In\n/// verbatim strings `\"\"` represents a single double-quote character):\n\n    var CITIES_JS :- expect ToUTF8Checked(@\"{\n        \"\"Cities\"\": [\n          {\n            \"\"Name\"\": \"\"Boston\"\",\n            \"\"Founded\"\": 1630,\n            \"\"Population\"\": 689386,\n            \"\"Area (km2)\"\": 4584.2\n          }, {\n            \"\"Name\"\": \"\"Rome\"\",\n            \"\"Founded\"\": -753,\n            \"\"Population\"\": 2.873e6,\n            \"\"Area (km2)\"\": 1285\n          }, {\n            \"\"Name\"\": \"\"Paris\"\",\n            \"\"Founded\"\": null,\n            \"\"Population\"\": 2.161e6,\n            \"\"Area (km2)\"\": 2383.5\n          }\n        ]\n      }\");\n    var CITIES_VALUE :=\n      Object([\n               (\"Cities\", Array([\n                Object([\n                (\"Name\", String(\"Boston\")),\n                (\"Founded\", Number(Int(1630))),\n                (\"Population\", Number(Int(689386))),\n                (\"Area (km2)\", Number(Decimal(45842, -1)))\n                ]),\n                Object([\n                (\"Name\", String(\"Rome\")),\n                (\"Founded\", Number(Int(-753))),\n                (\"Population\", Number(Decimal(2873, 3))),\n                (\"Area (km2)\", Number(Int(1285)))\n                ]),\n                Object([\n                (\"Name\", String(\"Paris\")),\n                (\"Founded\", Null),\n                (\"Population\", Number(Decimal(2161, 3))),\n                (\"Area (km2)\", Number(Decimal(23835, -1)))\n                ])\n                ]))\n             ]);\n    expect API.Deserialize(CITIES_JS) == Success(CITIES_VALUE);\n\n/// Serialization works similarly, with `API.Serialize`.  For this first example\n/// the generated string matches what we started with exactly:\n\n    expect API.Serialize(SIMPLE_VALUE) == Success(SIMPLE_JS);\n\n/// For more complex object, the generated layout may not be exactly the same; note in particular how the representation of numbers and the whitespace have changed.\n\n    var EXPECTED :- expect ToUTF8Checked(\n      @\"{\"\"Cities\"\":[{\"\"Name\"\":\"\"Boston\"\",\"\"Founded\"\":1630,\"\"Population\"\":689386,\"\"Area (km2)\"\":45842e-1},{\"\"Name\"\":\"\"Rome\"\",\"\"Founded\"\":-753,\"\"Population\"\":2873e3,\"\"Area (km2)\"\":1285},{\"\"Name\"\":\"\"Paris\"\",\"\"Founded\"\":null,\"\"Population\"\":2161e3,\"\"Area (km2)\"\":23835e-1}]}\"\n    );\n\n    expect API.Serialize(CITIES_VALUE) == Success(EXPECTED);\n\n/// Additional methods are defined in `API.dfy` to serialize an object into an\n/// existing buffer or into an array.  Below is the smaller example from the\n/// README, as a sanity check:\n\n    var CITY_JS :- expect ToUTF8Checked(@\"{\"\"Cities\"\": [{\n      \"\"Name\"\": \"\"Boston\"\",\n      \"\"Founded\"\": 1630,\n      \"\"Population\"\": 689386,\n      \"\"Area (km2)\"\": 4584.2}]}\");\n\n    var CITY_VALUE :=\n      Object([(\"Cities\", Array([\n               Object([\n               (\"Name\", String(\"Boston\")),\n               (\"Founded\", Number(Int(1630))),\n               (\"Population\", Number(Int(689386))),\n               (\"Area (km2)\", Number(Decimal(45842, -1)))])]))]);\n\n    expect API.Deserialize(CITY_JS) == Success(CITY_VALUE);\n\n    var EXPECTED' :- expect ToUTF8Checked(\n      @\"{\"\"Cities\"\":[{\"\"Name\"\":\"\"Boston\"\",\"\"Founded\"\":1630,\"\"Population\"\":689386,\"\"Area (km2)\"\":45842e-1}]}\"\n    );\n\n    expect API.Serialize(CITY_VALUE) == Success(EXPECTED');\n  }\n}\n\n/// ## Low-level API (concrete syntax)\n///\n/// If you care about low-level performance, or about preserving existing\n/// formatting as much as possible, you may prefer to use the lower-level API:\n\nmodule {:options \"-functionSyntax:4\"} JSON.Examples.ConcreteSyntax {\n  import ZeroCopy.API\n  import opened UnicodeStrings\n  import opened Grammar\n  import opened Wrappers\n\n/// The low-level API works with ASTs that record all details of formatting and\n/// encoding: each node contains pointers to parts of a string, such that\n/// concatenating the fields of all nodes reconstructs the serialized value.\n\n  method {:test} Test() {\n\n/// The low-level API exposes the same functions and methods as the high-level\n/// one, but the type that they consume and produce is `Grammar.JSON` (defined\n/// in `Grammar.dfy` as a `Grammar.Value` surrounded by optional whitespace)\n/// instead of `Values.JSON` (defined in `Values.dfy`).  Since `Grammar.JSON` contains\n/// all formatting information, re-serializing an object produces the original\n/// value:\n\n    var CITIES :- expect ToUTF8Checked(@\"{\n        \"\"Cities\"\": [\n          {\n            \"\"Name\"\": \"\"Boston\"\",\n            \"\"Founded\"\": 1630,\n            \"\"Population\"\": 689386,\n            \"\"Area (km2)\"\": 4600\n          }, {\n            \"\"Name\"\": \"\"Rome\"\",\n            \"\"Founded\"\": -753,\n            \"\"Population\"\": 2.873e6,\n            \"\"Area (km2)\"\": 1285\n          }, {\n            \"\"Name\"\": \"\"Paris\"\",\n            \"\"Founded\"\": null,\n            \"\"Population\"\": 2.161e6,\n            \"\"Area (km2)\"\": 2383.5\n          }\n        ]\n      }\");\n\n    var deserialized :- expect API.Deserialize(CITIES);\n    expect API.Serialize(deserialized) == Success(CITIES);\n\n/// Since the formatting is preserved, it is also possible to write\n/// minimally-invasive transformations over an AST.  For example, let's replace\n/// `null` in the object above with `\"Unknown\"`.\n///\n/// First, we construct a JSON value for the string `\"Unknown\"`; this could be\n/// done by hand using `View.OfBytes()`, but using `API.Deserialize` is even\n/// simpler:\n    var UNKNOWN_JS :- expect ToUTF8Checked(@\"\"\"Unknown\"\"\");\n    var UNKNOWN :- expect API.Deserialize(UNKNOWN_JS);\n\n/// `UNKNOWN` is of type `Grammar.JSON`, which contains optional whitespace and\n/// a `Grammar.Value` under the name `UNKNOWN.t`, which we can use in the\n/// replacement:\n\n    var without_null := deserialized.(t := ReplaceNull(deserialized.t, UNKNOWN.t));\n\n/// Then, if we reserialize, we see that all formatting (and, in fact, all of\n/// the serialization work) has been reused:\n\n    var expected_js :- expect ToUTF8Checked(@\"{\n        \"\"Cities\"\": [\n          {\n            \"\"Name\"\": \"\"Boston\"\",\n            \"\"Founded\"\": 1630,\n            \"\"Population\"\": 689386,\n            \"\"Area (km2)\"\": 4600\n          }, {\n            \"\"Name\"\": \"\"Rome\"\",\n            \"\"Founded\"\": -753,\n            \"\"Population\"\": 2.873e6,\n            \"\"Area (km2)\"\": 1285\n          }, {\n            \"\"Name\"\": \"\"Paris\"\",\n            \"\"Founded\"\": \"\"Unknown\"\",\n            \"\"Population\"\": 2.161e6,\n            \"\"Area (km2)\"\": 2383.5\n          }\n        ]\n      }\");\n    var actual_js :- expect API.Serialize(without_null);\n    expect actual_js == expected_js;\n  }\n\n/// All that remains is to write the recursive traversal:\n\n  import Seq\n\n  function ReplaceNull(js: Value, replacement: Value): Value {\n    match js\n\n/// Non-recursive cases are untouched:\n\n    case Bool(_) => js\n    case String(_) => js\n    case Number(_) => js\n\n/// `Null` is replaced with the new `replacement` value:\n\n    case Null(_) => replacement\n\n/// … and objects and arrays are traversed recursively (only the data part of is\n/// traversed: other fields record information about the formatting of braces,\n/// square brackets, and whitespace, and can thus be reused without\n/// modifications):\n\n    case Object(obj) =>\n      Object(obj.(data := MapSuffixedSequence(obj.data, (s: Suffixed<jKeyValue, jcomma>) requires s in obj.data =>\n                                                s.t.(v := ReplaceNull(s.t.v, replacement)))))\n    case Array(arr) =>\n      Array(arr.(data := MapSuffixedSequence(arr.data, (s: Suffixed<Value, jcomma>) requires s in arr.data =>\n                                               ReplaceNull(s.t, replacement))))\n  }\n\n/// Note that well-formedness criteria on the low-level AST are enforced using\n/// subset types, which is why we need a bit more work to iterate over the\n/// sequences of key-value paris and of values in objects and arrays.\n/// Specifically, we need to prove that mapping over these sequences doesn't\n/// introduce dangling punctuation (`NoTrailingSuffix`).  We package this\n/// reasoning into a `MapSuffixedSequence` function:\n\n  function MapSuffixedSequence<D, S>(sq: SuffixedSequence<D, S>, fn: Suffixed<D, S> --> D)\n    : SuffixedSequence<D, S>\n    requires forall suffixed | suffixed in sq :: fn.requires(suffixed)\n  {\n    // BUG(https://github.com/dafny-lang/dafny/issues/2184)\n    // BUG(https://github.com/dafny-lang/dafny/issues/2690)\n    var fn' := (sf: Suffixed<D, S>) requires (ghost var in_sq := sf => sf in sq; in_sq(sf)) => sf.(t := fn(sf));\n    var sq' := Seq.Map(fn', sq);\n\n    assert NoTrailingSuffix(sq') by {\n      forall idx | 0 <= idx < |sq'| ensures sq'[idx].suffix.Empty? <==> idx == |sq'| - 1 {\n        calc {\n          sq'[idx].suffix.Empty?;\n          fn'(sq[idx]).suffix.Empty?;\n          sq[idx].suffix.Empty?;\n          idx == |sq| - 1;\n          idx == |sq'| - 1;\n        }\n      }\n    }\n\n    sq'\n  }\n}\n\n/// The examples in this file can be run with `Dafny -compile:4 -runAllTests:1`\n/// (the tests produce no output, but their calls to `expect` will be checked\n/// dynamically).\n"}
{"file": "../libraries/src/JSON/ConcreteSyntax.Spec.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"Grammar.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.ConcreteSyntax.Spec {\n  import opened BoundedInts\n\n  import Vs = Utils.Views.Core\n  import opened Grammar\n\n  function View(v: Vs.View) : bytes {\n    v.Bytes()\n  }\n\n  function Structural<T>(self: Structural<T>, fT: T -> bytes): bytes {\n    View(self.before) + fT(self.t) + View(self.after)\n  }\n\n  function StructuralView(self: Structural<Vs.View>): bytes {\n    Structural<Vs.View>(self, View)\n  }\n\n  function Maybe<T>(self: Maybe<T>, fT: T -> bytes): (bs: bytes)\n    ensures self.Empty? ==> bs == []\n    ensures self.NonEmpty? ==> bs == fT(self.t)\n  {\n    if self.Empty? then [] else fT(self.t)\n  }\n\n  function ConcatBytes<T>(ts: seq<T>, fT: T --> bytes) : bytes\n    requires forall d | d in ts :: fT.requires(d)\n  {\n    if |ts| == 0 then []\n    else fT(ts[0]) + ConcatBytes(ts[1..], fT)\n  }\n\n  function Bracketed<D, S>(self: Bracketed<Vs.View, D, S, Vs.View>, fDatum: Suffixed<D, S> --> bytes): bytes\n    requires forall d | d < self :: fDatum.requires(d)\n  {\n    StructuralView(self.l) +\n    ConcatBytes(self.data, fDatum) +\n    StructuralView(self.r)\n  }\n\n  function KeyValue(self: jKeyValue): bytes {\n    String(self.k) + StructuralView(self.colon) + Value(self.v)\n  }\n\n  function Frac(self: jfrac): bytes {\n    View(self.period) + View(self.num)\n  }\n\n  function Exp(self: jexp): bytes {\n    View(self.e) + View(self.sign) + View(self.num)\n  }\n\n  function Number(self: jnumber): bytes {\n    View(self.minus) + View(self.num) + Maybe(self.frac, Frac) + Maybe(self.exp, Exp)\n  }\n\n  function String(self: jstring): bytes {\n    View(self.lq) + View(self.contents) + View(self.rq)\n  }\n\n  function CommaSuffix(c: Maybe<Structural<jcomma>>): bytes {\n    // BUG(https://github.com/dafny-lang/dafny/issues/2179)\n    Maybe<Structural<Vs.View>>(c, StructuralView)\n  }\n\n  function Member(self: jmember) : bytes {\n    KeyValue(self.t) + CommaSuffix(self.suffix)\n  }\n\n  function Item(self: jitem) : bytes {\n    Value(self.t) + CommaSuffix(self.suffix)\n  }\n\n  function Object(obj: jobject) : bytes {\n    Bracketed(obj, (d: jmember) requires d < obj => Member(d))\n  }\n\n  function Array(arr: jarray) : bytes {\n    Bracketed(arr, (d: jitem) requires d < arr => Item(d))\n  }\n\n  function Value(self: Value) : bytes {\n    match self {\n      case Null(n) => View(n)\n      case Bool(b) => View(b)\n      case String(str) => String(str)\n      case Number(num) => Number(num)\n      case Object(obj) => Object(obj)\n      case Array(arr) => Array(arr)\n    }\n  }\n\n  lemma UnfoldValueNumber(v: Value)\n    requires v.Number?\n    ensures Value(v) == Number(v.num)\n  {\n    assert Value(v) == match v { case Number(num) => Number(num) case _ => []};\n  }\n\n  lemma UnfoldValueObject(v: Value)\n    requires v.Object?\n    ensures Value(v) == Object(v.obj)\n  {\n    assert Value(v) == match v { case Object(obj) => Object(obj) case _ => []};\n  }\n\n  lemma UnfoldValueArray(v: Value)\n    requires v.Array?\n    ensures Value(v) == Array(v.arr)\n  {\n    assert Value(v) == match v { case Array(arr) => Array(arr) case _ => []};\n  }\n\n  function JSON(js: JSON) : bytes {\n    Structural(js, Value)\n  }\n}\n"}
{"file": "../libraries/src/JSON/Errors.dfy", "dafny": "// RUN: %verify \"%s\"\n\ninclude \"../Wrappers.dfy\"\ninclude \"../BoundedInts.dfy\"\ninclude \"Utils/Str.dfy\"\n\nmodule {:options \"-functionSyntax:4\"} JSON.Errors {\n  import Wrappers\n  import opened BoundedInts\n  import Utils.Str\n\n  datatype DeserializationError =\n    | UnterminatedSequence\n    | UnsupportedEscape(str: string)\n    | EscapeAtEOS\n    | EmptyNumber\n    | ExpectingEOF\n    | IntOverflow\n    | ReachedEOF\n    | ExpectingByte(expected: byte, b: opt_byte)\n    | ExpectingAnyByte(expected_sq: seq<byte>, b: opt_byte)\n    | InvalidUnicode\n  {\n    function ToString() : string {\n      match this\n      case UnterminatedSequence => \"Unterminated sequence\"\n      case UnsupportedEscape(str) => \"Unsupported escape sequence: \" + str\n      case EscapeAtEOS => \"Escape character at end of string\"\n      case EmptyNumber => \"Number must contain at least one digit\"\n      case ExpectingEOF => \"Expecting EOF\"\n      case IntOverflow => \"Input length does not fit in a 32-bit counter\"\n      case ReachedEOF => \"Reached EOF\"\n      case ExpectingByte(b0, b) =>\n        var c := if b > 0 then \"'\" + [b as char] + \"'\" else \"EOF\";\n        \"Expecting '\" + [b0 as char] + \"', read \" + c\n      case ExpectingAnyByte(bs0, b) =>\n        var c := if b > 0 then \"'\" + [b as char] + \"'\" else \"EOF\";\n        var c0s := seq(|bs0|, idx requires 0 <= idx < |bs0| => bs0[idx] as char);\n        \"Expecting one of '\" + c0s + \"', read \" + c\n      case InvalidUnicode => \"Invalid Unicode sequence\"\n    }\n  }\n\n  datatype SerializationError =\n    | OutOfMemory\n    | IntTooLarge(i: int)\n    | StringTooLong(s: string)\n    | InvalidUnicode\n  {\n    function ToString() : string {\n      match this\n      case OutOfMemory => \"Out of memory\"\n      case IntTooLarge(i: int) => \"Integer too large: \" + Str.OfInt(i)\n      case StringTooLong(s: string) => \"String too long: \" + s\n      case InvalidUnicode => \"Invalid Unicode sequence\"\n    }\n  }\n\n  type SerializationResult<+T> = Wrappers.Result<T, SerializationError>\n  type DeserializationResult<+T> = Wrappers.Result<T, DeserializationError>\n}\n"}
{"file": "../libraries/src/Relations.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\nmodule {:options \"-functionSyntax:4\"} Relations {\n\n  ghost predicate Reflexive<T(!new)>(R: (T, T) -> bool) {\n    forall x :: R(x, x)\n  }\n\n  ghost predicate Irreflexive<T(!new)>(R: (T, T) -> bool) {\n    forall x :: !R(x, x)\n  }\n\n  ghost predicate AntiSymmetric<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) && R(y, x) ==> x == y\n  }\n\n  ghost predicate Symmetric<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) <==> R(y, x)\n  }\n\n  ghost predicate Connected<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: x != y ==> R(x, y) || R(y, x)\n  }\n\n  ghost predicate StronglyConnected<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) || R(y, x)\n  }\n\n  ghost predicate Transitive<T(!new)>(R: (T, T) -> bool) {\n    forall x, y, z :: R(x, y) && R(y, z) ==> R(x, z)\n  }\n\n  ghost predicate TotalOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && AntiSymmetric(R)\n    && Transitive(R)\n    && StronglyConnected(R)\n  }\n\n  ghost predicate StrictTotalOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Irreflexive(R)\n    && AntiSymmetric(R)\n    && Transitive(R)\n    && Connected(R)\n  }\n\n  ghost predicate PreOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && Transitive(R)\n  }\n\n  ghost predicate PartialOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && Transitive(R)\n    && AntiSymmetric(R)\n  }\n\n  ghost predicate EquivalenceRelation<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && Symmetric(R)\n    && Transitive(R)\n  }\n\n  ghost predicate SortedBy<T>(a: seq<T>, lessThan: (T, T) -> bool) {\n    forall i, j | 0 <= i < j < |a| :: lessThan(a[i], a[j])\n  }\n\n  /** An element in an ordered set is called a least element (or a minimum), if it is less than \n      every other element of the set. */\n  ghost predicate IsLeast<T>(R: (T, T) -> bool, min: T, s: set<T>) {\n    min in s && forall x | x in s :: R(min, x)\n  }\n\n  /** An element in an ordered set is called a minimal element, if no other element is less than it. */\n  ghost predicate IsMinimal<T>(R: (T, T) -> bool, min: T, s: set<T>) {\n    min in s && forall x | x in s && R(x, min) ::  R(min, x)\n  }\n\n  /** An element in an ordered set is called a greatest element (or a maximum), if it is greater than \n      every other element of the set. */\n  ghost predicate IsGreatest<T>(R: (T, T) -> bool, max: T, s: set<T>) {\n    max in s && forall x | x in s :: R(x, max)\n  }\n\n  /** An element in an ordered set is called a maximal element, if no other element is greater than it. */\n  ghost predicate IsMaximal<T>(R: (T, T) -> bool, max: T, s: set<T>) {\n    max in s && forall x | x in s && R(max, x) :: R(x, max)\n  }\n\n  lemma LemmaNewFirstElementStillSortedBy<T>(x: T, s: seq<T>, lessThan: (T, T) -> bool)\n    requires SortedBy(s, lessThan)\n    requires |s| == 0 || lessThan(x, s[0])\n    requires TotalOrdering(lessThan)\n    ensures SortedBy([x] + s, lessThan)\n  {}\n}\n"}
{"file": "../libraries/src/Math.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\nmodule {:options \"-functionSyntax:4\"} Math {\n  function Min(a: int, b: int): int\n  {\n    if a < b\n    then a\n    else\n      b\n  }\n\n  function Max(a: int, b: int): int\n  {\n    if a < b\n    then b\n    else\n      a\n  }\n\n  function Abs(a: int): (a': int)\n    ensures a' >= 0\n  {\n    if a >= 0 then a else -a\n  }\n}\n"}
{"file": "../libraries/src/Wrappers.dfy", "dafny": "// RUN: %verify \"%s\"\n\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\nmodule {:options \"-functionSyntax:4\"} Wrappers {\n\n  datatype Option<+T> = None | Some(value: T) {\n    function ToResult(): Result<T, string> {\n      match this\n      case Some(v) => Success(v)\n      case None() => Failure(\"Option is None\")\n    }\n\n    function ToResult'<R>(error: R): Result<T, R> {\n      match this\n      case Some(v) => Success(v)\n      case None() => Failure(error)\n    }\n\n    function UnwrapOr(default: T): T {\n      match this\n      case Some(v) => v\n      case None() => default\n    }\n\n    predicate IsFailure() {\n      None?\n    }\n\n    function PropagateFailure<U>(): Option<U>\n      requires None?\n    {\n      None\n    }\n\n    function Extract(): T\n      requires Some?\n    {\n      value\n    }\n  }\n\n  datatype Result<+T, +R> = | Success(value: T) | Failure(error: R) {\n    function ToOption(): Option<T>\n    {\n      match this\n      case Success(s) => Some(s)\n      case Failure(e) => None()\n    }\n\n    function UnwrapOr(default: T): T\n    {\n      match this\n      case Success(s) => s\n      case Failure(e) => default\n    }\n\n    predicate IsFailure() {\n      Failure?\n    }\n\n    function PropagateFailure<U>(): Result<U, R>\n      requires Failure?\n    {\n      Failure(this.error)\n    }\n\n    function MapFailure<NewR>(reWrap: R -> NewR): Result<T, NewR>\n    {\n      match this\n      case Success(s) => Success(s)\n      case Failure(e) => Failure(reWrap(e))\n    }\n\n    function Extract(): T\n      requires Success?\n    {\n      value\n    }\n  }\n\n  datatype Outcome<E> = Pass | Fail(error: E)\n  {\n    predicate IsFailure() {\n      Fail?\n    }\n    // Note: PropagateFailure returns a Result, not an Outcome.\n    function PropagateFailure<U>(): Result<U, E>\n      requires Fail?\n    {\n      Failure(this.error)\n    }\n    // Note: no Extract method\n  }\n\n  // A helper function to ensure a requirement is true at runtime\n  // :- Need(5 == |mySet|, \"The set MUST have 5 elements.\")\n  function Need<E>(condition: bool, error: E): (result: Outcome<E>)\n  {\n    if condition then Pass else Fail(error)\n  }\n}\n"}{"file": "../program-proofs-code/ch3/3-Examples.dfy", "dafny": "function Fib(n: nat): nat\n  decreases n\n{\n  if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n}\n\nfunction SeqSum(s: seq<int>, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  decreases hi - lo\n{\n  if lo == hi then 0 else s[lo] + SeqSum(s, lo + 1, hi)\n}\n\nfunction Ack(m: nat, n: nat): nat\n  // decreases ...?\n{\n  if m == 0 then\n    n + 1\n  else if n == 0 then\n    Ack(m - 1, 1)\n  else\n    Ack(m - 1, Ack(m, n - 1))\n}\n\n// Exercises:\n\nfunction F(x: int): int\n  // decreases ...?\n{\n  if x < 10 then x else F(x - 1)\n}\n\nfunction G(x: int): int\n  // decreases ...?\n{\n  if 0 <= x then G(x - 2) else x\n}\n\nfunction H(x: int): int\n  // decreases ...?\n{\n  if x < -60 then x else H(x - 1)\n}\n\nfunction I(x: nat, y: nat): int\n  // decreases ...?\n{\n  if x == 0 || y == 0 then\n    12\n  else if x % 2 == y % 2 then\n    I(x - 1, y)\n  else\n    I(x, y - 1)\n}\n\nfunction J(x: nat, y: nat): int\n  // decreases ...?\n{\n  if x == 0 then\n    y\n  else if y == 0 then\n    J(x - 1, 3)\n  else\n    J(x, y - 1)\n}\n\nfunction K(x: nat, y: nat, z: nat): int\n  // decreases ...?\n{\n  if x < 10 || y < 5 then\n    x + y\n  else if z == 0 then\n    K(x - 1, y, 5)\n  else\n    K(x, y - 1, z - 1)\n}\n\nfunction L(x: int): int\n  // decreases ...?\n{\n  if x < 100 then L(x + 1) + 10 else x\n}\n\nfunction M(x: int, b: bool): int\n  // decreases ...?\n{\n  if b then x else M(x + 25, true)\n}\n\nfunction N(x: int, y: int, b: bool): int\n  // decreases ...?\n{\n  if x <= 0 || y <= 0 then\n    x + y\n  else if b then\n    N(x, y + 3, !b)\n  else\n    N(x - 1, y, true)\n}\n"}
{"file": "../program-proofs-code/ch3/3.3.3-ExpLess1.dfy", "dafny": "// Simple recursion\n\nfunction ExpLess1S(n: nat): nat {\n  if n == 0 then 0 else 2 * ExpLess1S(n - 1) + 1\n}\n\n// Mutual recursion\n\nfunction ExpLess1(n: nat): nat\n  decreases n, 1\n{\n  if n == 0 then 0 else ExpLess2(n) + 1\n}\n\nfunction ExpLess2(n: nat): nat\n  requires 1 <= n\n  decreases n, 0\n{\n  2 * ExpLess1(n - 1)\n}\n"}
{"file": "../program-proofs-code/ch3/3.0-EndlessProblems.dfy", "dafny": "method BadDouble(x: int) returns (d: int)\n  ensures d == 2 * x\n{\n  var y := BadDouble(x - 1); // error: failure to prove termination\n  d := y + 2;\n}\n\nmethod PartialId(x: int) returns (y: int)\n  ensures y == x\n{\n  if x % 2 == 0 {\n    y := x;\n  } else {\n    y := PartialId(x); // error: failure to prove termination\n  }\n}\n\nmethod Squarish(x: int, guess: int) returns (y: int)\n  ensures x * x == y\n{\n  if\n  case guess == x * x => // good guess!\n    y := guess;\n  case true =>\n    y := Squarish(x, guess - 1); // error: failure to prove termination\n  case true =>\n    y := Squarish(x, guess + 1); // error: failure to prove termination\n}\n\nmethod Impossible(x: int) returns (y: int)\n  ensures y % 2 == 0 && y == 10 * x - 3\n{\n  y := Impossible(x); // error: failure to prove termination\n}\n\nfunction Dubious(): int {\n  1 + Dubious() // error: failure to prove termination\n}\n"}
{"file": "../program-proofs-code/ch3/3-Hofstadter.dfy", "dafny": "function G(n: nat): nat\n  // decreases ...?\n{\n  if n == 0 then 0 else n - G(G(n - 1))\n}\n\nfunction F(n: nat): nat\n  // decreases ...?\n{\n  if n == 0 then 1 else n - M(F(n - 1))\n}\n\nfunction M(n: nat): nat\n  // decreases ...?\n{\n  if n == 0 then 0 else n - F(M(n - 1))\n}\n"}
{"file": "../program-proofs-code/ch3/3.3-Study.dfy", "dafny": "method RequiredStudyTime(c: nat) returns (hours: nat)\n  ensures hours <= 200\n\nmethod Study(n: nat, h: nat)\n  decreases n, h\n{\n  if h != 0 {\n    // first, study for an hour, and then:\n    Study(n, h - 1);\n  } else if n == 0 {\n    // you just finished course 0 -- woot woot, graduation time!\n  } else {\n    // find out how much studying is needed for the next course\n    var hours := RequiredStudyTime(n - 1);\n    // get started with course n-1:\n    Study(n - 1, hours);\n  }\n}\n\nmethod StudyPlan(n: nat)\n  requires n <= 40\n  decreases 40 - n\n{\n  if n == 40 {\n    // done\n  } else {\n    var hours := RequiredStudyTime(n);\n    Learn(n, hours);\n  }\n}\n\nmethod Learn(n: nat, h: nat)\n  requires n < 40\n  decreases 40 - n, h\n{\n  if h == 0 {\n    // done with class n; continue with the rest of the study plan\n    StudyPlan(n + 1);\n  } else {\n    // some learning to take place here...\n    Learn(n, h - 1);\n  }\n}\n"}
{"file": "../program-proofs-code/ch11/11.2-Termination.dfy", "dafny": "method DivMod7() {\n  var x, y;\n\n  x, y := 0, 191;\n  while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191\n    decreases y\n  {\n    y := y - 7;\n    x := x + 1;\n  }\n}\n\nmethod LeapToTheAnswer() {\n  var x, y;\n\n  x, y := 0, 191;\n  while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191\n    decreases y\n  {\n    x, y := 27, 2;\n  }\n}\n\nmethod SwitchingDirections() {\n  var x, y;\n\n  x, y := 0, 191;\n  while 7 <= y // cannot prove termination\n    invariant 0 <= y && 7 * x + y == 191\n  {\n    x, y := x - 1, y + 7;\n  }\n}\n\nmethod UpDoesNotTerminate() {\n  var x, y;\n\n  x, y := 0, 191;\n  while 7 <= y // cannot prove termination\n    invariant 0 <= y && 7 * x + y == 191\n    invariant 7 <= y\n  {\n    x, y := x - 1, y + 7;\n  }\n}\n"}
{"file": "../program-proofs-code/ch11/11.1-LoopImplementations.dfy", "dafny": "method DivMod7() {\n  var x, y;\n\n  x, y := 0, 191;\n  while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191\n  {\n    y := y - 7;\n    x := x + 1;\n  }\n  assert x == 191 / 7 && y == 191 % 7;\n}\n\nmethod LeapToTheAnswer() {\n  var x, y;\n\n  x, y := 0, 191;\n  while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191\n  {\n    x, y := 27, 2;\n  }\n  assert x == 191 / 7 && y == 191 % 7;\n}\n\nmethod GoingTwiceAsFast() {\n  var x, y;\n\n  x, y := 0, 191;\n  while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191 // error: loop invariant not maintained\n  {\n    x, y := x + 2, y - 14;\n  }\n  assert x == 191 / 7 && y == 191 % 7;\n}\n\nmethod Sum() {\n  var n, s;\n\n  n, s := 0, 0;\n  while n != 33\n    invariant s == n * (n - 1) / 2\n  {\n    s := s + n;\n    n := n + 1;\n  }\n}\n\nmethod LoopFrameExample(X: int, Y: int)\n  requires 0 <= X <= Y\n{\n  var i, a, b := 0, X, Y;\n  while i < 100 {\n    i, b := i + 1, b + X;\n  }\n  assert a == X;\n  assert Y <= b; // not provable without an invariant for the loop\n}\n"}
{"file": "../program-proofs-code/ch11/11.4-SquareRoot.dfy", "dafny": "method SquareRoot(N: nat) returns (r: nat)\n  ensures r * r <= N < (r + 1) * (r + 1)\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= N\n    invariant r * r <= N\n  {\n    r := r + 1;\n  }\n}\n\nmethod MoreEfficientSquareRoot(N: nat) returns (r: nat)\n  ensures r * r <= N < (r + 1) * (r + 1)\n{\n  r := 0;\n  var s := 1;\n  while s <= N\n    invariant r * r <= N\n    invariant s == (r + 1) * (r + 1)\n  {\n    s := s + 2*r + 3;\n    r := r + 1;\n  }\n}\n"}
{"file": "../program-proofs-code/ch11/11.0-LoopSpecifications.dfy", "dafny": "// Section 11.0.2\n\nmethod Example0() {\n  var x := 0;\n\n  while x < 300\n    invariant x % 2 == 0\n}\n\nmethod Example1() {\n  var x := 1;\n\n  while x % 2 == 1\n    invariant 0 <= x <= 100\n}\n\nmethod Example2() {\n  var x;\n\n  x := 2;\n  while x < 50\n    invariant x % 2 == 0\n  assert 50 <= x && x % 2 == 0;\n}\n\nmethod Example3() {\n  var x;\n\n  x := 0;\n  while x % 2 == 0\n    invariant 0 <= x <= 20\n  assert x == 19; // not provable\n}\n\n// Section 11.0.3\n\nmethod Example4() {\n  var i;\n\n  i := 0;\n  while i != 100\n    invariant 0 <= i <= 100\n  assert i == 100;\n}\n\nmethod Example5() {\n  var i;\n\n  i := 0;\n  while i != 100\n    invariant true\n  assert i == 100;\n}\n\nmethod Example6() {\n  var i;\n\n  i := 0;\n  while i < 100\n    invariant 0 <= i <= 100\n  assert i == 100;\n}\n\nmethod Example7() {\n  var i;\n\n  i := 0;\n  while i < 100\n    invariant true\n  assert i == 100; // not provable\n}\n\n// Section 11.0.4\n\nmethod Example8() {\n  var x, y;\n  x, y := 0, 0;\n  while x < 300\n    invariant 2 * x == 3 * y\n  assert 200 <= y;\n}\n\nmethod Example9() {\n  var x, y;\n\n  x, y := 0, 191;\n  while !(0 <= y < 7)\n    invariant 7 * x + y == 191\n  assert x == 191 / 7 && y == 191 % 7;\n}\n\nmethod Example10() {\n  var x, y;\n\n  x, y := 0, 191;\n  while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191\n  assert x == 191 / 7 && y == 191 % 7;\n}\n\nmethod Example11() {\n  var n, s;\n\n  n, s := 0, 0;\n  while n != 33\n    invariant s == n * (n - 1) / 2\n}\n\n// Section 11.0.5\n\nmethod Example12() {\n  var r, N;\n\n  r, N := 0, 104;\n  while (r+1)*(r+1) <= N\n    invariant 0 <= r && r*r <= N\n  assert 0 <= r && r*r <= N < (r+1)*(r+1);\n}\n"}
{"file": "../program-proofs-code/ch15/15.0-DutchFlag.dfy", "dafny": "datatype Color = Red | White | Blue\n\nghost predicate Below(c: Color, d: Color) {\n  c == Red || c == d || d == Blue\n}\n\nmethod DutchFlag(a: array<Color>)\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length ==> Below(a[i], a[j])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var r, w, b := 0, 0, a.Length;\n  while w < b\n    invariant 0 <= r <= w <= b <= a.Length\n    invariant forall i :: 0 <= i < r ==> a[i] == Red\n    invariant forall i :: r <= i < w ==> a[i] == White\n    invariant forall i :: b <= i < a.Length ==> a[i] == Blue\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    match a[w]\n    case White =>\n      w := w + 1;\n    case Red =>\n      a[r], a[w] := a[w], a[r];\n      r, w := r + 1, w + 1;\n    case Blue =>\n      a[w], a[b-1] := a[b-1], a[w];\n      b := b - 1;\n  }\n}\n"}
{"file": "../program-proofs-code/ch15/15.2-Quicksort.dfy", "dafny": "method Quicksort(a: array<int>)\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  QuicksortAux(a, 0, a.Length);\n}\n\nmethod QuicksortAux(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n  ensures SwapFrame(a, lo, hi)\n  requires SplitPoint(a, lo) && SplitPoint(a, hi)\n  ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n  decreases hi - lo\n{\n  if 2 <= hi - lo {\n    var p := Partition(a, lo, hi);\n    QuicksortAux(a, lo, p);\n    QuicksortAux(a, p + 1, hi);\n  }\n}\n\ntwostate predicate SwapFrame(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  reads a\n{\n  (forall i :: 0 <= i < lo || hi <= i < a.Length ==>\n    a[i] == old(a[i])) &&\n  multiset(a[..]) == old(multiset(a[..]))\n}\n\nghost predicate SplitPoint(a: array<int>, n: int)\n  requires 0 <= n <= a.Length\n  reads a\n{\n  forall i, j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (p: int)\n  requires 0 <= lo < hi <= a.Length\n  requires SplitPoint(a, lo) && SplitPoint(a, hi)\n  modifies a\n  ensures lo <= p < hi\n  ensures forall i :: lo <= i < p ==> a[i] < a[p]\n  ensures forall i :: p <= i < hi ==> a[p] <= a[i]\n  ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n  ensures SwapFrame(a, lo, hi)\n{\n  var pivot := a[lo];\n  var m, n := lo + 1, hi;\n  while m < n\n    invariant lo + 1 <= m <= n <= hi\n    invariant a[lo] == pivot\n    invariant forall i :: lo + 1 <= i < m ==> a[i] < pivot\n    invariant forall i :: n <= i < hi ==> pivot <= a[i]\n    invariant SplitPoint(a, lo) && SplitPoint(a, hi)\n    invariant SwapFrame(a, lo, hi)\n  {\n    if a[m] < pivot {\n      m := m + 1;\n    } else {\n      a[m], a[n-1] := a[n-1], a[m];\n      n := n - 1;\n    }\n  }\n  a[lo], a[m - 1] := a[m - 1], a[lo];\n  return m - 1;\n}\n\nmethod Partition_Median(a: array<int>, lo: int, hi: int) returns (p: int)\n  requires 0 <= lo < hi <= a.Length\n  requires SplitPoint(a, lo) && SplitPoint(a, hi)\n  modifies a\n  ensures lo <= p < hi\n  ensures forall i :: lo <= i < p ==> a[i] < a[p]\n  ensures forall i :: p <= i < hi ==> a[p] <= a[i]\n  ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n  ensures SwapFrame(a, lo, hi)\n{\n  var p0, p1, p2 := a[lo], a[(lo + hi) / 2], a[hi - 1];\n  if {\n    case p0 <= p1 <= p2 || p2 <= p1 <= p0 =>\n      a[(lo + hi) / 2], a[lo] := a[lo], a[(lo + hi) / 2];\n    case p1 <= p2 <= p0 || p0 <= p2 <= p1 =>\n      a[hi - 1], a[lo] := a[lo], a[hi - 1];\n    case p2 <= p0 <= p1 || p1 <= p0 <= p2 =>\n      // nothing to do\n  }\n  var pivot := a[lo];\n  var m, n := lo + 1, hi;\n  while m < n\n    invariant lo + 1 <= m <= n <= hi\n    invariant a[lo] == pivot\n    invariant forall i :: lo + 1 <= i < m ==> a[i] < pivot\n    invariant forall i :: n <= i < hi ==> pivot <= a[i]\n    invariant SplitPoint(a, lo) && SplitPoint(a, hi)\n    invariant SwapFrame(a, lo, hi)\n  {\n    if a[m] < pivot {\n      m := m + 1;\n    } else {\n      a[m], a[n-1] := a[n-1], a[m];\n      n := n - 1;\n    }\n  }\n  a[lo], a[m - 1] := a[m - 1], a[lo];\n  return m - 1;\n}\n"}
{"file": "../program-proofs-code/ch15/15.1-SelectionSort.dfy", "dafny": "// First attempt\n\nmethod SelectionSort0(a: array<int>)\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i, j :: 0 <= i < j < n ==> a[i] <= a[j] // cannot prove the loop maintains this invariant\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var mindex, m := n, n;\n    while m != a.Length\n      invariant n <= m <= a.Length && n <= mindex < a.Length\n      invariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    a[n], a[mindex] := a[mindex], a[n];\n    n := n + 1;\n  }\n}\n\n// Improved inner-loop invariant\n\nmethod SelectionSort1(a: array<int>)\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i, j :: 0 <= i < j < n ==> a[i] <= a[j] // cannot prove the loop maintains this invariant\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var mindex, m := n, n + 1;\n    while m != a.Length\n      invariant n <= mindex < m <= a.Length\n      invariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    a[n], a[mindex] := a[mindex], a[n];\n    n := n + 1;\n  }\n}\n\n// Add assert to aid in verification debugging\n\nmethod SelectionSort2(a: array<int>)\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i, j :: 0 <= i < j < n ==> a[i] <= a[j] // cannot prove the loop maintains this invariant\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var mindex, m := n, n + 1;\n    while m != a.Length\n      invariant n <= mindex < m <= a.Length\n      invariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    a[n], a[mindex] := a[mindex], a[n];\n    assert forall i, j :: 0 <= i < j < n ==> a[i] <= a[j];\n    n := n + 1;\n  }\n}\n\n// Final program\n\nghost predicate SplitPoint(a: array<int>, n: int)\n  requires 0 <= n <= a.Length\n  reads a\n{\n  forall i, j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n}\n\nmethod SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i, j :: 0 <= i < j < n ==> a[i] <= a[j]\n    invariant multiset(a[..]) == old(multiset(a[..]))\n    invariant SplitPoint(a, n)\n  {\n    var mindex, m := n, n + 1;\n    while m != a.Length\n      invariant n <= mindex < m <= a.Length\n      invariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    a[n], a[mindex] := a[mindex], a[n];\n    n := n + 1;\n  }\n}\n"}
{"file": "../program-proofs-code/ch9/9.3-ImmutableQueue.dfy", "dafny": "module ListLibrary {\n  datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\n  function Snoc<T>(xs: List<T>, y: T): List<T> {\n    match xs\n    case Nil => Cons(y, Nil)\n    case Cons(x, tail) => Cons(x, Snoc(tail, y))\n  }\n}\n\nmodule ImmutableQueue {\n  import LL = ListLibrary\n\n  export\n    provides Queue, Empty, Enqueue, Dequeue\n    provides LL, Elements\n    provides EmptyCorrect, EnqueueCorrect, DequeueCorrect\n    provides EmptyUnique\n\n  type Queue<A>\n  function Empty(): Queue\n  function Enqueue<A>(q: Queue, a: A): Queue\n  function Dequeue<A>(q: Queue): (A, Queue)\n    requires q != Empty<A>()\n\n  ghost function Elements(q: Queue): LL.List\n\n  lemma EmptyCorrect<A>()\n    ensures Elements(Empty<A>()) == LL.Nil\n  lemma EnqueueCorrect<A>(q: Queue, x: A)\n    ensures Elements(Enqueue(q, x)) == LL.Snoc(Elements(q), x)\n  lemma DequeueCorrect(q: Queue)\n    requires q != Empty()\n    ensures var (a, q') := Dequeue(q);\n      LL.Cons(a, Elements(q')) == Elements(q)\n\n  lemma EmptyUnique(q: Queue)\n    ensures Elements(q) == LL.Nil ==> q == Empty()\n}\n\nmodule QueueClient {\n  import IQ = ImmutableQueue\n  method Client() {\n    IQ.EmptyCorrect<int>();   var q := IQ.Empty();\n    IQ.EnqueueCorrect(q, 20); q := IQ.Enqueue(q, 20);\n    IQ.DequeueCorrect(q);     var (a, q') := IQ.Dequeue(q);\n    assert a == 20;\n    IQ.EmptyUnique(q');\n    assert q' == IQ.Empty();\n  }\n}\n"}
{"file": "../program-proofs-code/ch9/9.0-ListLibrary.dfy", "dafny": "module ListLibrary {\n  datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\n  function Append(xs: List, ys: List): List\n  {\n    match xs\n    case Nil => ys\n    case Cons(x, tail) => Cons(x, Append(tail, ys))\n  }\n\n  lemma AppendAssociative(xs: List, ys: List, zs: List)\n    ensures Append(Append(xs, ys), zs) == Append(xs, Append(ys, zs))\n  {\n  }\n\n  // many other declarations go here...\n}\n\nmethod Main() {\n  var xs, i := ListLibrary.Nil, 0;\n  while i < 5 {\n    xs, i := ListLibrary.Cons(i, xs), i + 1;\n  }\n  print xs, \"\\n\";\n}\n"}
{"file": "../program-proofs-code/ch9/9.2-ExportSets.dfy", "dafny": "\nmodule ModuleC {\n  export\n    provides Color\n    reveals Double\n\n  datatype Color = Blue | Yellow | Green | Red\n\n  function Double(x: int): nat\n    requires 0 <= x\n    ensures Double(x) % 2 == 0\n  {\n    if x == 0 then 0 else 2 + Double(x - 1)\n  }\n}\n\nmodule ModuleD {\n  import ModuleC\n\n  method Test() {\n    var c: ModuleC.Color;\n    c := ModuleC.Yellow; // error: unresolved identifier 'Yellow'\n    assert ModuleC.Double(3) == 6;\n  }\n}\n\nmodule ModuleE {\n  export\n    provides Parity, F\n\n  datatype Parity = Even | Odd\n\n  function F(x: int): Parity\n  {\n    if x % 2 == 0 then Even else Odd\n  }\n}\n"}
{"file": "../program-proofs-code/ch9/9.3.4-Queue-implementation.dfy", "dafny": "module ImmutableQueue {\n  import LL = ListLibrary\n\n  export\n    provides Queue, Empty, Enqueue, Dequeue\n    provides LL, Elements\n    provides EmptyCorrect, EnqueueCorrect, DequeueCorrect\n    provides EmptyUnique\n    provides IsEmpty\n\n  datatype Queue<A> = FQ(front: LL.List<A>, rear: LL.List<A>)\n\n  function Empty(): Queue {\n    FQ(LL.Nil, LL.Nil)\n  }\n\n  predicate IsEmpty(q: Queue)\n    ensures IsEmpty(q) <==> q == Empty()\n  {\n    q == FQ(LL.Nil, LL.Nil)\n  }\n\n  function Enqueue<A>(q: Queue, x: A): Queue {\n    FQ(q.front, LL.Cons(x, q.rear))\n  }\n\n  function Dequeue<A>(q: Queue): (A, Queue)\n    requires q != Empty()\n  {\n    match q.front\n    case Cons(x, front') =>\n      (x, FQ(front', q.rear))\n    case Nil =>\n      var front := LL.Reverse(q.rear);\n      (front.head, FQ(front.tail, LL.Nil))\n  }\n\n  ghost function Elements(q: Queue): LL.List {\n    LL.Append(q.front, LL.Reverse(q.rear))\n  }\n\n  lemma EmptyCorrect<A>()\n    ensures Elements(Empty<A>()) == LL.Nil\n  {\n  }\n\n  lemma EnqueueCorrect<A>(q: Queue, x: A)\n    ensures Elements(Enqueue(q, x)) == LL.Snoc(Elements(q), x)\n  {\n    calc {\n      Elements(Enqueue(q, x));\n    ==  // def. Enqueue\n      Elements(FQ(q.front, LL.Cons(x, q.rear)));\n    ==  // def. Elements\n      LL.Append(q.front, LL.Reverse(LL.Cons(x, q.rear)));\n    ==  { LL.ReverseCons(x, q.rear); }\n      LL.Append(q.front,\n                LL.Append(LL.Reverse(q.rear), LL.Cons(x, LL.Nil)));               \n    ==  { LL.AppendAssociative(q.front, LL.Reverse(q.rear),\n                               LL.Cons(x, LL.Nil)); }\n      LL.Append(LL.Append(q.front, LL.Reverse(q.rear)),\n                LL.Cons(x, LL.Nil));\n    ==  // def. Elements\n      LL.Append(Elements(q), LL.Cons(x, LL.Nil));\n    ==  { LL.SnocAppend(Elements(q), x); }\n      LL.Snoc(Elements(q), x);\n    }\n  }\n\n  lemma DequeueCorrect(q: Queue)\n    requires q != Empty()\n    ensures var (a, q') := Dequeue(q);\n      LL.Cons(a, Elements(q')) == Elements(q)\n  {\n    match q.front\n    case Cons(x, front') =>\n    case Nil =>\n      var front := LL.Reverse(q.rear);\n      var (a, q') := (front.head, FQ(front.tail, LL.Nil));\n      calc {\n        LL.Cons(a, Elements(q'));\n      ==  // def. Elements\n        LL.Cons(a, LL.Append(q'.front, LL.Reverse(q'.rear)));\n      ==  // what q' is\n        LL.Cons(a, LL.Append(front.tail, LL.Reverse(LL.Nil)));\n      ==  // def. LL.Reverse\n        LL.Cons(a, LL.Append(front.tail, LL.Nil));\n      ==  { LL.AppendNil(front.tail); }\n        LL.Cons(a, front.tail);\n      ==  // what a is, def. LL.Cons, and what front is\n        LL.Reverse(q.rear);\n      ==  // def. LL.Append, since q.front is empty\n        LL.Append(q.front, LL.Reverse(q.rear));\n      ==  // def. Elements\n        Elements(q);\n      }\n  }\n\n  lemma EmptyUnique(q: Queue)\n    ensures Elements(q) == LL.Nil ==> q == Empty()\n  {\n  }\n}\n\nmodule QueueClient {\n  import IQ = ImmutableQueue\n\n  method Client() {\n    IQ.EmptyCorrect<int>();   var q := IQ.Empty();\n    IQ.EnqueueCorrect(q, 20); q := IQ.Enqueue(q, 20);\n    IQ.DequeueCorrect(q);     var (a, q') := IQ.Dequeue(q);\n    assert a == 20;\n    IQ.EmptyUnique(q');\n    assert q' == IQ.Empty();\n  }\n}\n\nmodule QueueExtender {\n  import IQ = ImmutableQueue\n\n  function TryDequeue<A>(q: IQ.Queue, default: A): (A, IQ.Queue)\n  {\n    if IQ.IsEmpty(q) then (default, q) else IQ.Dequeue(q)\n  }\n}\n\n// List library\n\nmodule ListLibrary {\n  datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\n  function Length(xs: List): nat\n  {\n    match xs\n    case Nil => 0\n    case Cons(_, tail) => 1 + Length(tail)\n  }\n\n  function Append(xs: List, ys: List): List\n  {\n    match xs\n    case Nil => ys\n    case Cons(x, tail) => Cons(x, Append(tail, ys))\n  }\n\n  lemma AppendAssociative(xs: List, ys: List, zs: List)\n    ensures Append(Append(xs, ys), zs) == Append(xs, Append(ys, zs))\n  {\n  }\n\n  lemma AppendNil<T>(xs: List<T>)\n    ensures Append(xs, Nil) == xs\n  {\n  }\n\n  function Snoc<T>(xs: List<T>, y: T): List<T> {\n    match xs\n    case Nil => Cons(y, Nil)\n    case Cons(x, tail) => Cons(x, Snoc(tail, y))\n  }\n\n  lemma SnocAppend<T>(xs: List<T>, y: T)\n    ensures Snoc(xs, y) == Append(xs, Cons(y, Nil))\n  {\n  }\n\n  function Reverse(xs: List): List\n    ensures Length(Reverse(xs)) == Length(xs)\n  {\n    ReverseAux(xs, Nil)\n  }\n\n  function ReverseAux(xs: List, acc: List): List\n    ensures Length(ReverseAux(xs, acc)) == Length(xs) + Length(acc)\n  {\n    match xs\n    case Nil => acc\n    case Cons(x, tail) => ReverseAux(tail, Cons(x, acc))\n  }\n\n  lemma ReverseCons<A>(y: A, xs: List)\n    ensures Reverse(Cons(y, xs)) == Append(Reverse(xs), Cons(y, Nil))\n  {\n    ReverseAuxCons(y, xs, Nil);\n  }\n\n  lemma ReverseAuxCons<A>(y: A, xs: List, acc: List)\n    ensures ReverseAux(Cons(y, xs), acc) == Append(Reverse(xs), Cons(y, acc))\n  {\n    ReverseAuxCorrect(xs, Cons(y, acc));\n  }\n\n  lemma ReverseAuxCorrect(xs: List, acc: List)\n    ensures ReverseAux(xs, acc) == Append(Reverse(xs), acc)\n  {\n    match xs\n    case Nil =>\n    case Cons(x, tail) =>\n      calc {\n        ReverseAux(Cons(x, tail), acc);\n      ==\n        ReverseAux(tail, Cons(x, acc));\n      ==  { ReverseAuxCorrect(tail, Cons(x, acc)); }\n        Append(Reverse(tail), Cons(x, acc));\n      ==\n        Append(Reverse(tail), Append(Cons(x, Nil), acc));\n      ==  { AppendAssociative(Reverse(tail), Cons(x, Nil), acc); }\n        Append(Append(Reverse(tail), Cons(x, Nil)), acc);\n      }\n  }\n}\n"}
{"file": "../program-proofs-code/ch9/9.1-Imports.dfy", "dafny": "module ModuleA {\n  function Plus(x: int, y: int): int {\n    x + y\n  }\n}\n\nmodule ModuleB {\n  import ModuleA\n  function Double(x: int): int {\n    ModuleA.Plus(x, x)\n  }\n}\n"}
{"file": "../program-proofs-code/ch9/ImmutableQueue.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule ListLibrary {\n  datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\n  function Snoc<T>(xs: List<T>, y: T): List<T> {\n    match xs\n    case Nil => Cons(y, Nil)\n    case Cons(x, tail) => Cons(x, Snoc(tail, y))\n  }\n}\n\nmodule PreFinal0 {\n//# ImmutableQueue-0\n//#\n}\n\nmodule AddingElementFunction {\n  type Queue<A>\n  type List<A>\n//# Elements\n  ghost function Elements(q: Queue): List\n//#\n}\n\n//# ImmutableQueue-1:start\nmodule ImmutableQueue {\n  import LL = ListLibrary\n//# export:all\n  export provides *\n//# export:0\n  export\n//#\n    GoodExportSet\n//# export:1\n    provides Queue, Empty, Enqueue, Dequeue\n    provides LL, Elements\n    provides EmptyCorrect, EnqueueCorrect, DequeueCorrect\n//#\n    provides EmptyUnique\n//# ImmutableQueue-1:decls\n\n  type Queue<A>\n  function Empty(): Queue\n  function Enqueue<A>(q: Queue, a: A): Queue\n  function Dequeue<A>(q: Queue): (A, Queue)\n    requires q != Empty()\n\n  ghost function Elements(q: Queue): LL.List\n  lemma EmptyCorrect<A>()\n    ensures Elements(Empty<A>()) == LL.Nil\n  lemma EnqueueCorrect<A>(q: Queue, x: A)\n    ensures Elements(Enqueue(q, x)) == LL.Snoc(Elements(q), x)\n  lemma DequeueCorrect(q: Queue)\n    requires q != Empty()\n    ensures var (a, q') := Dequeue(q);\n      LL.Cons(a, Elements(q')) == Elements(q)\n//# EmptyUnique\n  lemma EmptyUnique(q: Queue)\n    ensures Elements(q) == LL.Nil ==> q == Empty()\n//# ImmutableQueue-1:end\n}\n//#\n\nmodule LengthInsteadOfElements {\n//# ImmutableQueue-2:start\nmodule ImmutableQueue {\n  import LL = ListLibrary\n\n  type Queue<A>\n  function Empty(): Queue\n  function Enqueue<A>(q: Queue, a: A): Queue\n  function Dequeue<A>(q: Queue): (A, Queue)\n    requires q != Empty<A>()\n\n//# Length\n  ghost function Length(q: Queue): nat\n//# ImmutableQueue-2:more\n  lemma EmptyCorrect<A>()\n    ensures Length(Empty<A>()) == 0\n  lemma EnqueueCorrect<A>(q: Queue, x: A)\n    ensures Length(Enqueue(q, x)) == Length(q) + 1\n  lemma DequeueCorrect(q: Queue)\n    requires q != Empty()\n    ensures Length(Dequeue(q).1) == Length(q) - 1\n}\n//#\n}\n"}
{"file": "../program-proofs-code/ch9/9.3-BlockChain.dfy", "dafny": "module BlockChain {\n  export\n    provides Ledger, Balance\n    provides Init, Deposit, Withdraw\n\n  import LL = ListLibrary\n\n  type Ledger = LL.List<int>\n\n  function Init(): Ledger\n    // specification left as an exercise...\n\n  function Deposit(ledger: Ledger, n: nat): Ledger\n    // specification left as an exercise...\n\n  function Withdraw(ledger: Ledger, n: nat): Ledger\n    // specification left as an exercise...\n\n  ghost function Balance(ledger: Ledger): int\n    // specification left as an exercise...\n}\n\nmodule ListLibrary {\n  datatype List<T> = Nil | Cons(T, List<T>)\n}\n"}
{"file": "../program-proofs-code/ch8/8-Sorting.dfy", "dafny": "// List\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nghost predicate Ordered(xs: List<int>) {\n  match xs\n  case Nil => true\n  case Cons(x, Nil) => true\n  case Cons(x, Cons(y, _)) => x <= y && Ordered(xs.tail)\n}\n\nfunction Length<T>(xs: List<T>): nat {\n  match xs\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(xs: List<T>, ys: List<T>): List<T>\n  ensures Length(Append(xs, ys)) == Length(xs) + Length(ys)\n{\n  match xs\n  case Nil => ys\n  case Cons(x, tail) => Cons(x, Append(tail, ys))\n}\n\nfunction At<T>(xs: List<T>, i: nat): T\n  requires i < Length(xs)\n{\n  if i == 0 then xs.head else At(xs.tail, i - 1)\n}\n\n// Sorting\n\nlemma AllOrdered(xs: List<int>, i: nat, j: nat)\n  requires Ordered(xs) && i <= j < Length(xs)\n  ensures At(xs, i) <= At(xs, j)\n{\n  if i != 0 {\n    AllOrdered(xs.tail, i - 1, j - 1);\n  } else if i == j {\n  } else {\n    AllOrdered(xs.tail, 0, j - 1);\n  }\n}\n\nghost function Count(xs: List<int>, p: int): nat {\n  match xs\n  case Nil => 0\n  case Cons(x, tail) =>\n    (if x == p then 1 else 0) + Count(tail, p)\n}\n\nghost function Project(xs: List<int>, p: int): List<int> {\n  match xs\n  case Nil => Nil\n  case Cons(x, tail) =>\n    if x == p then Cons(x, Project(tail, p)) else Project(tail, p)\n}\n\n// Insertion Sort\n\nfunction InsertionSort(xs: List<int>): List<int> {\n  match xs\n  case Nil => Nil\n  case Cons(x, tail) => Insert(x, InsertionSort(tail))\n}\n\nfunction Insert(y: int, xs: List<int>): List<int> {\n  match xs\n  case Nil => Cons(y, Nil)\n  case Cons(x, tail) =>\n    if y < x then Cons(y, xs) else Cons(x, Insert(y, tail))\n}\n\nlemma InsertionSortOrdered(xs: List<int>)\n  ensures Ordered(InsertionSort(xs))\n{\n  match xs\n  case Nil =>\n  case Cons(x, tail) =>\n    InsertOrdered(x, InsertionSort(tail));\n}\n\nlemma InsertOrdered(y: int, xs: List<int>)\n  requires Ordered(xs)\n  ensures Ordered(Insert(y, xs))\n{\n}\n\nlemma InsertionSortSameElements(xs: List<int>, p: int)\n  ensures Project(xs, p) == Project(InsertionSort(xs), p)\n{\n  match xs\n  case Nil =>\n  case Cons(x, tail) =>\n    InsertSameElements(x, InsertionSort(tail), p);\n}\n\nlemma InsertSameElements(y: int, xs: List<int>, p: int)\n  ensures Project(Cons(y, xs), p) == Project(Insert(y, xs), p)\n{\n}\n\n// Merge Sort\n\nfunction MergeSort(xs: List<int>): List<int> {\n  MergeSortAux(xs, Length(xs))\n}\n\nfunction MergeSortAux(xs: List<int>, len: nat): List<int>\n  requires len == Length(xs)\n  decreases len\n{\n  if len < 2 then\n    xs\n  else\n    var (left, right) := Split(xs, len / 2);\n    Merge(MergeSortAux(left, len / 2),\n          MergeSortAux(right, len - len / 2))\n}\n\nfunction Split(xs: List, n: nat): (List, List)\n  requires n <= Length(xs)\n  ensures var (left, right) := Split(xs, n);\n    Length(left) == n &&\n    Length(right) == Length(xs) - n &&\n    Append(left, right) == xs\n{\n  if n == 0 then\n    (Nil, xs)\n  else\n    var (l, r) := Split(xs.tail, n - 1);\n    (Cons(xs.head, l), r)\n}\n\nfunction Merge(xs: List<int>, ys: List<int>): List<int>\n{\n  match (xs, ys)\n  case (Nil, Nil) => Nil\n  case (Cons(_, _), Nil) => xs\n  case (Nil, Cons(_, _)) => ys\n  case (Cons(x, xtail), Cons(y, ytail)) =>\n    if x <= y then\n      Cons(x, Merge(xtail, ys))\n    else\n      Cons(y, Merge(xs, ytail))\n}\n\nfunction Split'(xs: List, nn: List): (List, List)\n  requires Length(nn) <= Length(xs)\n  ensures var (left, right) := Split'(xs, nn);\n    var n := Length(nn) / 2;\n    Length(left) == n &&\n    Length(right) == Length(xs) - n &&\n    Append(left, right) == xs\n// body left as an exercise\n\nlemma MergeSortOrdered(xs: List<int>)\n  ensures Ordered(MergeSort(xs))\n{\n  MergeSortAuxOrdered(xs, Length(xs));\n}\n\nlemma MergeSortAuxOrdered(xs: List<int>, len: nat)\n  requires len == Length(xs)\n  ensures Ordered(MergeSortAux(xs, len))\n  decreases len\n{\n  if 2 <= len {\n    var (left, right) := Split(xs, len / 2);\n    MergeOrdered(MergeSortAux(left, len / 2),\n                 MergeSortAux(right, len - len / 2));\n  }\n}\n\nlemma MergeOrdered(xs: List<int>, ys: List<int>)\n  requires Ordered(xs) && Ordered(ys)\n  ensures Ordered(Merge(xs, ys))\n{\n}\n\nlemma MergeSortSameElements(xs: List<int>, p: int)\n  ensures Project(xs, p) == Project(MergeSort(xs), p)\n{\n  MergeSortAuxSameElements(xs, Length(xs), p);\n}\n\nlemma MergeSortAuxSameElements(xs: List<int>, len: nat, p: int)\n  requires len == Length(xs)\n  ensures Project(xs, p) == Project(MergeSortAux(xs, len), p)\n  decreases len\n{\n  if 2 <= len {\n    var (left, right) := Split(xs, len / 2);\n    calc {\n      Project(MergeSortAux(xs, len), p);\n    ==  // def. MergeSortAux\n      Project(Merge(MergeSortAux(left, len / 2),\n                    MergeSortAux(right, len - len / 2)), p);\n      Project(Merge(MergeSortAux(left, len / 2),\n                    MergeSortAux(right, len - len / 2)),\n              p);\n    ==  { MergeSortAuxOrdered(left, len / 2);\n          MergeSortAuxOrdered(right, len - len / 2);\n          MergeSameElements(\n            MergeSortAux(left, len / 2),\n            MergeSortAux(right, len - len / 2),\n            p);\n        }\n      Append(\n        Project(MergeSortAux(left, len / 2), p),\n        Project(MergeSortAux(right, len - len / 2), p));\n    ==  { MergeSortAuxSameElements(left, len / 2, p);\n          MergeSortAuxSameElements(right, len - len / 2, p); }\n      Append(Project(left, p), Project(right, p));\n    ==  { AppendProject(left, right, p); }\n      Project(Append(left, right), p);\n    ==\n      Project(xs, p);\n    }\n  }\n}\n\nlemma MergeSameElements(xs: List<int>, ys: List<int>, p: int)\n  requires Ordered(xs) && Ordered(ys)\n  ensures Project(Merge(xs, ys), p)\n       == Append(Project(xs, p), Project(ys, p))\n{\n}\n\nlemma AppendProject(xs: List<int>, ys: List<int>, p: int)\n  ensures Append(Project(xs, p), Project(ys, p))\n       == Project(Append(xs, ys), p)\n{\n}\n"}
{"file": "../program-proofs-code/ch14/14-Programs.dfy", "dafny": "method SetEndPoints(a: array<int>, left: int, right: int)\n  requires a.Length != 0\n  modifies a\n{\n  a[0] := left;\n  a[a.Length - 1] := right;\n}\n\nmethod Aliases(a: array<int>, b: array<int>)\n  requires 100 <= a.Length\n  modifies a\n{\n  a[0] := 10;\n  var c := a;\n  if b == a {\n    b[10] := b[0] + 1;\n  }\n  c[20] := a[14] + 2;\n}\n\nmethod UpdateElements(a: array<int>)\n  requires a.Length == 10\n  modifies a\n  ensures old(a[4]) < a[4]\n  ensures a[6] <= old(a[6])\n  ensures a[8] == old(a[8])\n{\n  a[4], a[8] := a[4] + 3, a[8] + 1;\n  a[7], a[8] := 516, a[8] - 1;\n}\n\nmethod OldVsParameters(a: array<int>, i: int) returns (y: int)\n  requires 0 <= i < a.Length\n  modifies a\n  ensures old(a[i] + y) == 25\n{\n  y := 25 - a[i];\n}\n\nmethod Increment(a: array<int>, i: int)\n  requires 0 <= i < a.Length\n  modifies a\n  ensures a[i] == old(a)[i] + 1 // common mistake\n{\n  a[i] := a[i] + 1; // error: postcondition violation\n}\n\nmethod NewArray() returns (a: array<int>)\n  ensures a.Length == 20\n{\n  a := new int[20];\n  var b := new int[30];\n  a[6] := 216;\n  b[7] := 343;\n}\n\nmethod Caller() {\n  var a := NewArray();\n  a[8] := 512; // error: modification of a's elements not allowed\n}\n\n\n// ----------------------------------------\n\n// Fix to NewArray specification\n\nmethod NewArray'() returns (a: array<int>)\n  ensures fresh(a) && a.Length == 20\n{\n  a := new int[20];\n  var b := new int[30];\n  a[6] := 216;\n  b[7] := 343;\n}\n\nmethod Caller'() {\n  var a := NewArray'();\n  a[8] := 512;\n}\n\n// ----------------------------------------\n\npredicate IsZeroArray(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  reads a\n  decreases hi - lo\n{\n  lo == hi || (a[lo] == 0 && IsZeroArray(a, lo + 1, hi))\n}\n\npredicate IsZeroSeq(a: seq<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |a|\n  decreases hi - lo\n{\n  lo == hi || (a[lo] == 0 && IsZeroSeq(a, lo + 1, hi))\n}\n\n// ----------------------------------------\n\nmethod InitArray<T>(a: array<T>, d: T)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == d\n{\n  var n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> a[i] == d\n  {\n    a[n] := d;\n    n := n + 1;\n  }\n}\n\n// ----------------------------------------\n\nmethod InitMatrix<T>(a: array2<T>, d: T)\n  modifies a\n  ensures forall i, j ::\n    0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == d\n{\n  var m := 0;\n  while m != a.Length0\n    invariant 0 <= m <= a.Length0\n    invariant forall i, j ::\n      0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == d\n  {\n    var n := 0;\n    while n != a.Length1\n      invariant 0 <= n <= a.Length1\n      invariant forall i, j ::\n        0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == d\n      invariant forall j :: 0 <= j < n ==> a[m,j] == d\n    {\n      a[m,n] := d;\n      n := n + 1;\n    }\n    m := m + 1;\n  }\n}\n\n// ----------------------------------------\n\nmethod IncrementArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[i]) + 1\n{\n  var n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> a[i] == old(a[i]) + 1\n    invariant forall i :: n <= i < a.Length ==> a[i] == old(a[i])\n  {\n    a[n] := a[n] + 1;\n    n := n + 1;\n  }\n}\n\nmethod IncrementArray_WithAsserts(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[i]) + 1\n{\n  var n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> a[i] == old(a[i]) + 1\n    invariant forall i :: n <= i < a.Length ==> a[i] == old(a[i])\n  {\n    assert a[n] + 1 == old(a[n]) + 1;\n    a[n] := a[n] + 1;\n    assert forall i :: 0 <= i < n ==> a[i] == old(a[i]) + 1;\n    assert a[n] == old(a[n]) + 1;\n    assert forall i :: 0 <= i < n + 1 ==> a[i] == old(a[i]) + 1;\n    n := n + 1;\n  }\n}\n\n// ----------------------------------------\n\nmethod CopyArray(src: array, dst: array)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < src.Length ==> dst[i] == old(src[i])\n{\n  var n := 0;\n  while n != src.Length\n    invariant 0 <= n <= src.Length\n    invariant forall i :: 0 <= i < n ==> dst[i] == old(src[i])\n    invariant forall i :: 0 <= i < src.Length ==> src[i] == old(src[i])\n  {\n    dst[n] := src[n];\n    n := n + 1;\n  }\n}\n\n// ----------------------------------------\n\nfunction F(i: int): int {\n  i\n}\n\nmethod Aggregate_Int<T>(n: nat, d: int) {\n  var a: array<int>;\n  var m: array2<int>;\n\n  a := new int[25](F);\n\n  a := new int[25](i => i * i);\n\n  a := new int[n](_ => 0);\n\n  m := new int[50, 50]((i, j) => if i == j then d else 0);\n}\n\nmethod Aggregate_Generic<T>(a: array<T>) {\n  var b: array<T>;\n\n  b := new T[a.Length](i => a[i]); // error in accessing a\n\n  b := new T[a.Length](i requires 0 <= i < a.Length reads a =>\n                       a[i]);\n}\n\n// ----------------------------------------\n\nmethod SequenceConstructor() {\n  var s: seq<bool> := seq(500, i => i % 2 == 0);\n}\n\n// ----------------------------------------\n\nmethod ArrayMultiassignment() {\n  var a := new int[100];\n\n  a[5], a[7] := a[5] + 25, a[7] + 49;\n\n  forall i | 0 <= i < a.Length {\n    a[i] := a[i] + i * i;\n  }\n\n  forall i | 0 <= i < a.Length && i % 2 == 0 {\n    a[i] := a[i] + 1;\n  }\n\n  forall i | 0 <= i < a.Length {\n    a[i] := a[i] + 1;\n  }\n\n  forall i | 0 <= i < a.Length {\n    a[i] := a[(i + 1) % a.Length];\n  }\n}\n\nmethod MatrixMultiassignment(d: int) {\n  var a := new int[100, 100];\n\n  forall i, j | 0 <= i < a.Length0 && 0 <= j < a.Length1 {\n    a[i,j] := d;\n  }\n}\n\n// ----------------------------------------\n\nmethod CopyMatrix<T>(src: array2<T>, dst: array2<T>)\n  requires src.Length0 == dst.Length0\n  requires src.Length1 == dst.Length1\n  modifies dst\n  ensures forall i, j :: 0 <= i < dst.Length0 && 0 <= j < dst.Length1 ==>\n    dst[i, j] == old(src[i, j])\n{\n  forall i, j | 0 <= i < dst.Length0 && 0 <= j < dst.Length1 {\n    dst[i, j] := src[i, j];\n  }\n}\n\nmethod TestHarness() {\n  var m := new int[2, 1];\n  m[0, 0], m[1, 0] := 5, 7;\n  CopyMatrix(m, m);\n  // the following assertion will not hold if you forget\n  // 'old' in the specification of CopyMatrix\n  assert m[1, 0] == 7;\n  var n := new int[2, 1];\n  CopyMatrix(m, n);\n  assert m[1, 0] == n[1, 0] == 7;\n}\n"}
{"file": "../program-proofs-code/ch4/4.2-Destructors.dfy", "dafny": "datatype BYTree = BlueLeaf\n                | YellowLeaf\n                | Node(left: BYTree, right: BYTree)\n\nfunction BlueCount(t: BYTree): nat {\n  if t.BlueLeaf? then 1\n  else if t.YellowLeaf? then 0\n  else BlueCount(t.left) + BlueCount(t.right)\n}\n\nmethod Test() {\n  assert BlueCount(BlueLeaf) == 1;\n  assert BlueCount(Node(YellowLeaf, BlueLeaf)) == 1;\n}\n"}
{"file": "../program-proofs-code/ch4/4.4-ColoredTree.dfy", "dafny": "datatype ColoredTree = Leaf(Color)\n                     | Node(ColoredTree, ColoredTree)\n\ndatatype Color = Blue | Yellow | Green | Red\n\npredicate IsSwedishFlagColor(c: Color) {\n  c.Blue? || c.Yellow?\n}\n\npredicate IsLithuanianFlagColor(c: Color) {\n  c != Blue\n}\n\nlemma Test(a: Color) {\n  var y := Yellow;\n  assert IsSwedishFlagColor(y) && IsLithuanianFlagColor(y);\n  var b := Blue;\n  assert IsSwedishFlagColor(b) && !IsLithuanianFlagColor(b);\n  var r := Red;\n  assert !IsSwedishFlagColor(r) && IsLithuanianFlagColor(r);\n\n  if IsSwedishFlagColor(a) && IsLithuanianFlagColor(a) {\n    assert a == Yellow;\n  }\n}\n"}
{"file": "../program-proofs-code/ch4/4.5-Tree.dfy", "dafny": "datatype Color = Blue | Yellow | Green | Red\n\ndatatype Tree<T> = Leaf(data: T)\n                 | Node(left: Tree<T>, right: Tree<T>)\n\npredicate AllBlue(t: Tree<Color>) {\n  match t\n  case Leaf(c) => c == Blue\n  case Node(left, right) => AllBlue(left) && AllBlue(right) \n}\n\nfunction Size<T>(t: Tree<T>): nat {\n  match t\n  case Leaf(_) => 1\n  case Node(left, right) => Size(left) + Size(right)\n}\n\nlemma Test() {\n  var a := Leaf(Color.Blue);\n  var b := Leaf(Color.Yellow);\n  var t := Tree.Node(a, b);\n\n  assert Size(t) == Size(t) == 2;\n}\n"}
{"file": "../program-proofs-code/ch4/4.6-Expr.dfy", "dafny": "datatype Expr = Const(nat)\n              | Var(string)\n              | Node(op: Op, args: List<Expr>)\n\ndatatype Op = Add | Mul\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\n\nfunction AST_Example(): Expr {\n  // 10 * (x + 7 * y)\n  Node(Mul,\n    Cons(Const(10),\n    Cons(Node(Add,\n      Cons(Var(\"x\"),\n      Cons(Node(Mul,\n        Cons(Const(7),\n        Cons(Var(\"y\"),\n        Nil))),\n      Nil))),\n    Nil)))\n}\n\nfunction Eval(e: Expr, env: map<string, nat>): nat {\n  match e\n  case Const(c) => c\n  case Var(s) => if s in env.Keys then env[s] else 0\n  case Node(op, args) => EvalList(args, op, env)\n}\n\nfunction EvalList(args: List<Expr>, op: Op,\n                  env: map<string, nat>): nat\n{\n  match args\n  case Nil =>\n    (match op case Add => 0 case Mul => 1)\n  case Cons(e, tail) =>\n    var v0, v1 := Eval(e, env), EvalList(tail, op, env);\n    match op\n    case Add => v0 + v1\n    case Mul => v0 * v1\n}\n"}
{"file": "../program-proofs-code/ch4/4-BYTree.dfy", "dafny": "datatype BYTree = BlueLeaf | YellowLeaf | Node(BYTree, BYTree)\n\nfunction Example(): BYTree {\n  Node(BlueLeaf, Node(YellowLeaf, BlueLeaf))\n}\n\nfunction BlueCount(t: BYTree): nat {\n  match t\n  case BlueLeaf => 1\n  case YellowLeaf => 0\n  case Node(left, right) => BlueCount(left) + BlueCount(right)\n}\n\nfunction LeftDepth(t: BYTree): nat {\n  match t\n  case BlueLeaf => 0\n  case YellowLeaf => 0\n  case Node(left, _) => 1 + LeftDepth(left)\n}\n\npredicate IsNode(t: BYTree) {\n  match t\n  case BlueLeaf => false\n  case YellowLeaf => false\n  case Node(_, _) => true\n}\n\nfunction GetLeft(t: BYTree): BYTree\n  requires t.Node?\n{\n  match t\n  case Node(left, _) => left\n}\n"}
{"file": "../program-proofs-code/ch2/2.3.0-Swap.dfy", "dafny": "method Swap(X: int, Y: int) {\n  var x, y := X, Y;\n\n  var tmp := x;\n  x := y;\n  y := tmp;\n\n  assert x == Y && y == X;\n}\n\nmethod SwapArithetic(X: int, Y: int) {\n  var x, y := X, Y;\n\n  x := y - x;\n  y := y - x;\n  x := y + x;\n\n  assert x == Y && y == X;\n}\n\nmethod SwapBitvectors(X: bv8, Y: bv8) {\n  var x, y := X, Y;\n\n  x := x ^ y;\n  y := x ^ y;\n  x := x ^ y;\n\n  assert x == Y && y == X;\n}\n\nmethod SwapSimultaneous(X: int, Y: int) {\n  var x, y := X, Y;\n\n  x, y := y, x;\n\n  assert x == Y && y == X;\n}\n"}
{"file": "../program-proofs-code/ch2/2.1-MyMethod.dfy", "dafny": "method MyMethod(x: int) returns (y: int)\n  requires 10 <= x\n  ensures 25 <= y\n{\n  var a := x + 3;\n  var b := 12;\n  y := a + b;\n}\n"}
{"file": "../program-proofs-code/ch2/2.0-MyMethod.dfy", "dafny": "method MyMethod(x: int) returns (y: int)\n  requires 10 <= x\n  ensures 25 <= y\n{\n  var a, b;\n  a := x + 3;\n  if x < 20 {\n    b := 32 - x;\n  } else {\n    b := 16;\n  }\n  y := a + b;\n}\n"}
{"file": "../program-proofs-code/ch2/2.11-Abs.dfy", "dafny": "function Abs(x: int): int {\n  if x < 0 then -x else x\n}\n\nmethod AbsMethod(x: int) returns (y: int)\n  ensures 0 <= y && (x == y || x == -y)\n{\n  y := Abs(x);\n}\n"}
{"file": "../program-proofs-code/ch10/10.1-PriorityQueue.dfy", "dafny": "module PriorityQueue {\n  export\n    provides PQueue, Empty, IsEmpty, Insert, RemoveMin\n    provides Elements\n    provides EmptyCorrect, IsEmptyCorrect\n    provides InsertCorrect, RemoveMinCorrect\n    reveals IsMin\n    provides Valid\n\n  type PQueue = BraunTree\n  datatype BraunTree =\n    | Leaf\n    | Node(x: int, left: BraunTree, right: BraunTree)\n\n  ghost predicate Valid(pq: PQueue)\n\n  function Empty(): PQueue\n  predicate IsEmpty(pq: PQueue)\n  function Insert(pq: PQueue, y: int): PQueue\n  function RemoveMin(pq: PQueue): (int, PQueue)\n    requires !IsEmpty(pq)\n\n  ghost function Elements(pq: PQueue): multiset<int>\n\n  lemma EmptyCorrect()\n    ensures var pq := Empty();\n      Valid(pq) &&\n      Elements(pq) == multiset{}\n  lemma IsEmptyCorrect(pq: PQueue)\n    requires Valid(pq)\n    ensures IsEmpty(pq) <==> Elements(pq) == multiset{}\n  lemma InsertCorrect(pq: PQueue, y: int)\n    requires Valid(pq)\n    ensures var pq' := Insert(pq, y);\n      Valid(pq') &&\n      Elements(pq') == Elements(pq) + multiset{y}\n  lemma RemoveMinCorrect(pq: PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var (y, pq') := RemoveMin(pq);\n      Valid(pq') &&\n      IsMin(y, Elements(pq)) &&\n      Elements(pq') + multiset{y} == Elements(pq)\n\n  ghost predicate IsMin(y: int, s: multiset<int>) {\n    y in s && forall x :: x in s ==> y <= x\n  }\n}\n"}
{"file": "../program-proofs-code/ch10/10.3.2-PriorityQueue.dfy", "dafny": "module PriorityQueue {\n  export\n    provides PQueue, Empty, IsEmpty, Insert, RemoveMin\n    provides Valid, Elements\n    reveals IsMin\n    provides Extrinsic\n\n  import Extrinsic = PriorityQueueExtrinsic\n\n  type PQueue = Extrinsic.PQueue\n  \n  ghost predicate Valid(pq: PQueue) {\n    Extrinsic.Valid(pq)\n  }\n  \n  ghost function Elements(pq: PQueue): multiset<int> {\n    Extrinsic.Elements(pq)\n  }\n\n  ghost predicate IsMin(m: int, s: multiset<int>) {\n    Extrinsic.IsMin(m, s)\n  }\n\n  function Empty(): PQueue\n    ensures var pq := Empty();\n      Valid(pq) &&\n      Elements(pq) == multiset{}\n  {\n    Extrinsic.EmptyCorrect();\n    Extrinsic.Empty()\n  }\n  \n  predicate IsEmpty(pq: PQueue)\n    requires Valid(pq)\n    ensures IsEmpty(pq) <==> Elements(pq) == multiset{}\n  {\n    Extrinsic.IsEmptyCorrect(pq);\n    Extrinsic.IsEmpty(pq)\n  }\n  \n  function Insert(pq: PQueue, y: int): PQueue\n    requires Valid(pq)\n    ensures var pq' := Insert(pq, y);\n      Valid(pq') &&\n      Elements(pq') == multiset{y} + Elements(pq)\n  {\n    Extrinsic.InsertCorrect(pq, y);\n    Extrinsic.Insert(pq, y)\n  }\n  \n  function RemoveMin(pq: PQueue): (int, PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var (y, pq') := RemoveMin(pq);\n      Valid(pq') &&\n      IsMin(y, Elements(pq)) &&\n      Elements(pq') + multiset{y} == Elements(pq)\n  {\n    Extrinsic.RemoveMinCorrect(pq);\n    Extrinsic.RemoveMin(pq)\n  }\n}\n\nmodule PriorityQueueExtrinsic {\n  export\n    provides PQueue, Empty, IsEmpty, Insert, RemoveMin\n    provides Valid, Elements\n    reveals IsMin\n    provides EmptyCorrect, IsEmptyCorrect, InsertCorrect\n    provides RemoveMinCorrect\n\n  type PQueue = BraunTree\n  datatype BraunTree =\n    | Leaf\n    | Node(x: int, left: BraunTree, right: BraunTree)\n\n  ghost predicate Valid(pq: PQueue) {\n    IsBinaryHeap(pq) && IsBalanced(pq)\n  }\n\n  ghost predicate IsBinaryHeap(pq: PQueue) {\n    match pq\n    case Leaf => true\n    case Node(x, left, right) =>\n      IsBinaryHeap(left) && IsBinaryHeap(right) &&\n      (left == Leaf || x <= left.x) &&\n      (right == Leaf || x <= right.x)\n  }\n\n  ghost predicate IsBalanced(pq: PQueue) {\n    match pq\n    case Leaf => true\n    case Node(_, left, right) =>\n      IsBalanced(left) && IsBalanced(right) &&\n      var L, R := |Elements(left)|, |Elements(right)|;\n      L == R || L == R + 1\n  }\n\n  function Empty(): PQueue {\n    Leaf\n  }\n\n  predicate IsEmpty(pq: PQueue) {\n    pq == Leaf\n  }\n\n  function Insert(pq: PQueue, y: int): PQueue {\n    match pq\n    case Leaf => Node(y, Leaf, Leaf)\n    case Node(x, left, right) =>\n      if y < x then\n        Node(y, Insert(right, x), left)\n      else\n        Node(x, Insert(right, y), left)\n  }\n\n  function RemoveMin(pq: PQueue): (int, PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n  {\n    (pq.x, DeleteMin(pq))\n  }\n\n  function DeleteMin(pq: PQueue): PQueue\n    requires IsBalanced(pq) && !IsEmpty(pq)\n  {\n    if pq.right == Leaf then\n      pq.left\n    else if pq.left.x <= pq.right.x then\n      Node(pq.left.x, pq.right, DeleteMin(pq.left))\n    else\n      Node(pq.right.x, ReplaceRoot(pq.right, pq.left.x),\n           DeleteMin(pq.left))\n  }\n\n  function ReplaceRoot(pq: PQueue, y: int): PQueue\n    requires !IsEmpty(pq)\n  {\n    if pq.left == Leaf ||\n       (y <= pq.left.x && (pq.right == Leaf || y <= pq.right.x))\n    then\n      Node(y, pq.left, pq.right)\n    else if pq.right == Leaf then\n      Node(pq.left.x, Node(y, Leaf, Leaf), Leaf)\n    else if pq.left.x < pq.right.x then\n      Node(pq.left.x, ReplaceRoot(pq.left, y), pq.right)\n    else\n      Node(pq.right.x, pq.left, ReplaceRoot(pq.right, y))\n  }\n\n  ghost function Elements(pq: PQueue): multiset<int> {\n    match pq\n    case Leaf => multiset{}\n    case Node(x, left, right) =>\n      multiset{x} + Elements(left) + Elements(right)\n  }\n\n  lemma EmptyCorrect()\n    ensures var pq := Empty();\n      Valid(pq) &&\n      Elements(pq) == multiset{}\n  {\n  }\n\n  lemma IsEmptyCorrect(pq: PQueue)\n    requires Valid(pq)\n    ensures IsEmpty(pq) <==> Elements(pq) == multiset{}\n  {\n  }\n\n  lemma InsertCorrect(pq: PQueue, y: int)\n    requires Valid(pq)\n    ensures var pq' := Insert(pq, y);\n      Valid(pq') &&\n      Elements(pq') == Elements(pq) + multiset{y}\n  {\n  }\n\n  lemma RemoveMinCorrect(pq: PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var (y, pq') := RemoveMin(pq);\n      Valid(pq') &&\n      IsMin(y, Elements(pq)) &&\n      Elements(pq') + multiset{y} == Elements(pq)\n  {\n    DeleteMinCorrect(pq);\n  }\n\n  lemma DeleteMinCorrect(pq: PQueue)\n    requires Valid(pq) && pq != Leaf\n    ensures var pq' := DeleteMin(pq);\n      Valid(pq') &&\n      Elements(pq') + multiset{pq.x} == Elements(pq)\n  {\n    if pq.left == Leaf || pq.right == Leaf {\n    } else if pq.left.x <= pq.right.x {\n      DeleteMinCorrect(pq.left);\n    } else {\n      var left, right :=\n        ReplaceRoot(pq.right, pq.left.x), DeleteMin(pq.left);\n      var pq' := Node(pq.right.x, left, right);\n      assert pq' == DeleteMin(pq);\n      ReplaceRootCorrect(pq.right, pq.left.x);\n      DeleteMinCorrect(pq.left);\n      calc {\n        Elements(pq') + multiset{pq.x};\n      ==  // def. Elements, since pq' is a Node\n        multiset{pq.right.x} + Elements(left) +\n        Elements(right) + multiset{pq.x};\n      ==\n        Elements(left) + multiset{pq.right.x} +\n        Elements(right) + multiset{pq.x};\n      ==  { assert Elements(left) + multiset{pq.right.x}\n                == Elements(pq.right) + multiset{pq.left.x}; }\n        Elements(pq.right) + multiset{pq.left.x} +\n        Elements(right) + multiset{pq.x};\n      ==\n        Elements(right) + multiset{pq.left.x} +\n        Elements(pq.right) + multiset{pq.x};\n      ==  { assert Elements(right) + multiset{pq.left.x}\n                == Elements(pq.left); }\n        Elements(pq.left) + Elements(pq.right) +\n        multiset{pq.x};\n      ==\n        multiset{pq.x} + Elements(pq.left) +\n        Elements(pq.right);\n      ==  // def. Elements, since pq is a Node\n        Elements(pq);\n      }\n    }\n  }\n\n  lemma ReplaceRootCorrect(pq: PQueue, y: int)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var pq' := ReplaceRoot(pq, y);\n      Valid(pq') &&\n      Elements(pq) + multiset{y} == Elements(pq') + multiset{pq.x} &&\n      |Elements(pq')| == |Elements(pq)|\n  {\n    if pq.left == Leaf ||\n       (y <= pq.left.x && (pq.right == Leaf || y <= pq.right.x))\n    {\n    } else if pq.right == Leaf {\n    } else if pq.left.x < pq.right.x {\n      var left := ReplaceRoot(pq.left, y);\n      var pq' := Node(pq.left.x, left, pq.right);\n      assert pq' == ReplaceRoot(pq, y);\n      ReplaceRootCorrect(pq.left, y);\n      calc {\n        Elements(pq) + multiset{y};\n      ==  // def. Elements, since pq is a Node\n        multiset{pq.x} + Elements(pq.left) +\n        Elements(pq.right) + multiset{y};\n      ==\n        Elements(pq.left) + multiset{y} +\n        Elements(pq.right) + multiset{pq.x};\n      ==  { assert Elements(pq.left) + multiset{y}\n                == Elements(left) + multiset{pq.left.x}; } // I.H.\n        multiset{pq.left.x} + Elements(left) +\n        Elements(pq.right) + multiset{pq.x};\n      ==  // def. Elements, since pq' is a Node\n        Elements(pq') + multiset{pq.x};\n      }\n    } else {\n      var right := ReplaceRoot(pq.right, y);\n      var pq' := Node(pq.right.x, pq.left, right);\n      assert pq' == ReplaceRoot(pq, y);\n      ReplaceRootCorrect(pq.right, y);\n      calc {\n        Elements(pq) + multiset{y};\n      ==  // def. Elements, since pq is a Node\n        multiset{pq.x} + Elements(pq.left) +\n        Elements(pq.right) + multiset{y};\n      ==\n        Elements(pq.right) + multiset{y} +\n        Elements(pq.left) + multiset{pq.x};\n      ==  { assert Elements(pq.right) + multiset{y}\n                == Elements(right) + multiset{pq.right.x}; }\n        multiset{pq.right.x} + Elements(pq.left) +\n        Elements(right) + multiset{pq.x};\n      ==  // def. Elements, since pq' is a Node\n        Elements(pq') + multiset{pq.x};\n      }\n    }\n  }\n\n  ghost predicate IsMin(y: int, s: multiset<int>) {\n    y in s && forall x :: x in s ==> y <= x\n  }\n}\n"}
{"file": "../program-proofs-code/ch10/10.0-PriorityQueue.dfy", "dafny": "module PriorityQueue {\n  export\n    provides PQueue, Empty, IsEmpty, Insert, RemoveMin\n    provides Elements\n    provides EmptyCorrect, IsEmptyCorrect\n    provides InsertCorrect, RemoveMinCorrect\n    reveals IsMin\n\n  type PQueue\n\n  function Empty(): PQueue\n  predicate IsEmpty(pq: PQueue)\n  function Insert(pq: PQueue, y: int): PQueue\n  function RemoveMin(pq: PQueue): (int, PQueue)\n    requires !IsEmpty(pq)\n\n  ghost function Elements(pq: PQueue): multiset<int>\n\n  lemma EmptyCorrect()\n    ensures Elements(Empty()) == multiset{}\n  lemma IsEmptyCorrect(pq: PQueue)\n    ensures IsEmpty(pq) <==> Elements(pq) == multiset{}\n  lemma InsertCorrect(pq: PQueue, y: int)\n    ensures Elements(Insert(pq, y))\n         == Elements(pq) + multiset{y}\n  lemma RemoveMinCorrect(pq: PQueue)\n    requires !IsEmpty(pq)\n    ensures var (y, pq') := RemoveMin(pq);\n      IsMin(y, Elements(pq)) &&\n      Elements(pq') + multiset{y} == Elements(pq)\n\n  ghost predicate IsMin(y: int, s: multiset<int>) {\n    y in s && forall x :: x in s ==> y <= x\n  }\n}\n"}
{"file": "../program-proofs-code/ch10/10.3-PriorityQueue.dfy", "dafny": "module PriorityQueue {\n  export\n    provides PQueue, Empty, IsEmpty, Insert, RemoveMin\n    provides Elements\n    provides EmptyCorrect, IsEmptyCorrect\n    provides InsertCorrect, RemoveMinCorrect\n    reveals IsMin\n    provides Valid\n\n  type PQueue = BraunTree\n  datatype BraunTree =\n    | Leaf\n    | Node(x: int, left: BraunTree, right: BraunTree)\n\n  ghost predicate Valid(pq: PQueue) {\n    IsBinaryHeap(pq) && IsBalanced(pq)\n  }\n\n  ghost predicate IsBinaryHeap(pq: PQueue) {\n    match pq\n    case Leaf => true\n    case Node(x, left, right) =>\n      IsBinaryHeap(left) && IsBinaryHeap(right) &&\n      (left == Leaf || x <= left.x) &&\n      (right == Leaf || x <= right.x)\n  }\n\n  ghost predicate IsBalanced(pq: PQueue) {\n    match pq\n    case Leaf => true\n    case Node(_, left, right) =>\n      IsBalanced(left) && IsBalanced(right) &&\n      var L, R := |Elements(left)|, |Elements(right)|;\n      L == R || L == R + 1\n  }\n\n  function Empty(): PQueue {\n    Leaf\n  }\n\n  predicate IsEmpty(pq: PQueue) {\n    pq == Leaf\n  }\n\n  function Insert(pq: PQueue, y: int): PQueue {\n    match pq\n    case Leaf => Node(y, Leaf, Leaf)\n    case Node(x, left, right) =>\n      if y < x then\n        Node(y, Insert(right, x), left)\n      else\n        Node(x, Insert(right, y), left)\n  }\n\n  function RemoveMin(pq: PQueue): (int, PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n  {\n    (pq.x, DeleteMin(pq))\n  }\n\n  function DeleteMin(pq: PQueue): PQueue\n    requires IsBalanced(pq) && !IsEmpty(pq)\n  {\n    if pq.right == Leaf then\n      pq.left\n    else if pq.left.x <= pq.right.x then\n      Node(pq.left.x, pq.right, DeleteMin(pq.left))\n    else\n      Node(pq.right.x, ReplaceRoot(pq.right, pq.left.x),\n           DeleteMin(pq.left))\n  }\n\n  function ReplaceRoot(pq: PQueue, y: int): PQueue\n    requires !IsEmpty(pq)\n  {\n    if pq.left == Leaf ||\n       (y <= pq.left.x && (pq.right == Leaf || y <= pq.right.x))\n    then\n      Node(y, pq.left, pq.right)\n    else if pq.right == Leaf then\n      Node(pq.left.x, Node(y, Leaf, Leaf), Leaf)\n    else if pq.left.x < pq.right.x then\n      Node(pq.left.x, ReplaceRoot(pq.left, y), pq.right)\n    else\n      Node(pq.right.x, pq.left, ReplaceRoot(pq.right, y))\n  }\n\n  ghost function Elements(pq: PQueue): multiset<int> {\n    match pq\n    case Leaf => multiset{}\n    case Node(x, left, right) =>\n      multiset{x} + Elements(left) + Elements(right)\n  }\n\n  lemma EmptyCorrect()\n    ensures var pq := Empty();\n      Valid(pq) &&\n      Elements(pq) == multiset{}\n  {\n  }\n\n  lemma IsEmptyCorrect(pq: PQueue)\n    requires Valid(pq)\n    ensures IsEmpty(pq) <==> Elements(pq) == multiset{}\n  {\n  }\n\n  lemma InsertCorrect(pq: PQueue, y: int)\n    requires Valid(pq)\n    ensures var pq' := Insert(pq, y);\n      Valid(pq') &&\n      Elements(pq') == Elements(pq) + multiset{y}\n  {\n  }\n\n  lemma RemoveMinCorrect(pq: PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var (y, pq') := RemoveMin(pq);\n      Valid(pq') &&\n      IsMin(y, Elements(pq)) &&\n      Elements(pq') + multiset{y} == Elements(pq)\n  {\n    DeleteMinCorrect(pq);\n  }\n\n  lemma DeleteMinCorrect(pq: PQueue)\n    requires Valid(pq) && pq != Leaf\n    ensures var pq' := DeleteMin(pq);\n      Valid(pq') &&\n      Elements(pq') + multiset{pq.x} == Elements(pq)\n  {\n    if pq.left == Leaf || pq.right == Leaf {\n    } else if pq.left.x <= pq.right.x {\n      DeleteMinCorrect(pq.left);\n    } else {\n      var left, right :=\n        ReplaceRoot(pq.right, pq.left.x), DeleteMin(pq.left);\n      var pq' := Node(pq.right.x, left, right);\n      assert pq' == DeleteMin(pq);\n      ReplaceRootCorrect(pq.right, pq.left.x);\n      DeleteMinCorrect(pq.left);\n      calc {\n        Elements(pq') + multiset{pq.x};\n      ==  // def. Elements, since pq' is a Node\n        multiset{pq.right.x} + Elements(left) +\n        Elements(right) + multiset{pq.x};\n      ==\n        Elements(left) + multiset{pq.right.x} +\n        Elements(right) + multiset{pq.x};\n      ==  { assert Elements(left) + multiset{pq.right.x}\n                == Elements(pq.right) + multiset{pq.left.x}; }\n        Elements(pq.right) + multiset{pq.left.x} +\n        Elements(right) + multiset{pq.x};\n      ==\n        Elements(right) + multiset{pq.left.x} +\n        Elements(pq.right) + multiset{pq.x};\n      ==  { assert Elements(right) + multiset{pq.left.x}\n                == Elements(pq.left); }\n        Elements(pq.left) + Elements(pq.right) +\n        multiset{pq.x};\n      ==\n        multiset{pq.x} + Elements(pq.left) +\n        Elements(pq.right);\n      ==  // def. Elements, since pq is a Node\n        Elements(pq);\n      }\n    }\n  }\n\n  lemma ReplaceRootCorrect(pq: PQueue, y: int)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var pq' := ReplaceRoot(pq, y);\n      Valid(pq') &&\n      Elements(pq) + multiset{y} == Elements(pq') + multiset{pq.x} &&\n      |Elements(pq')| == |Elements(pq)|\n  {\n    if pq.left == Leaf ||\n       (y <= pq.left.x && (pq.right == Leaf || y <= pq.right.x))\n    {\n    } else if pq.right == Leaf {\n    } else if pq.left.x < pq.right.x {\n      var left := ReplaceRoot(pq.left, y);\n      var pq' := Node(pq.left.x, left, pq.right);\n      assert pq' == ReplaceRoot(pq, y);\n      ReplaceRootCorrect(pq.left, y);\n      calc {\n        Elements(pq) + multiset{y};\n      ==  // def. Elements, since pq is a Node\n        multiset{pq.x} + Elements(pq.left) +\n        Elements(pq.right) + multiset{y};\n      ==\n        Elements(pq.left) + multiset{y} +\n        Elements(pq.right) + multiset{pq.x};\n      ==  { assert Elements(pq.left) + multiset{y}\n                == Elements(left) + multiset{pq.left.x}; } // I.H.\n        multiset{pq.left.x} + Elements(left) +\n        Elements(pq.right) + multiset{pq.x};\n      ==  // def. Elements, since pq' is a Node\n        Elements(pq') + multiset{pq.x};\n      }\n    } else {\n      var right := ReplaceRoot(pq.right, y);\n      var pq' := Node(pq.right.x, pq.left, right);\n      assert pq' == ReplaceRoot(pq, y);\n      ReplaceRootCorrect(pq.right, y);\n      calc {\n        Elements(pq) + multiset{y};\n      ==  // def. Elements, since pq is a Node\n        multiset{pq.x} + Elements(pq.left) +\n        Elements(pq.right) + multiset{y};\n      ==\n        Elements(pq.right) + multiset{y} +\n        Elements(pq.left) + multiset{pq.x};\n      ==  { assert Elements(pq.right) + multiset{y}\n                == Elements(right) + multiset{pq.right.x}; }\n        multiset{pq.right.x} + Elements(pq.left) +\n        Elements(right) + multiset{pq.x};\n      ==  // def. Elements, since pq' is a Node\n        Elements(pq') + multiset{pq.x};\n      }\n    }\n  }\n\n  ghost predicate IsMin(y: int, s: multiset<int>) {\n    y in s && forall x :: x in s ==> y <= x\n  }\n}\n"}
{"file": "../program-proofs-code/ch10/10.2-PriorityQueue.dfy", "dafny": "module PriorityQueue {\n  export\n    provides PQueue, Empty, IsEmpty, Insert, RemoveMin\n    provides Elements\n    provides EmptyCorrect, IsEmptyCorrect\n    provides InsertCorrect, RemoveMinCorrect\n    reveals IsMin\n    provides Valid\n\n  type PQueue = BraunTree\n  datatype BraunTree =\n    | Leaf\n    | Node(x: int, left: BraunTree, right: BraunTree)\n\n  ghost predicate Valid(pq: PQueue) {\n    IsBinaryHeap(pq) && IsBalanced(pq)\n  }\n\n  ghost predicate IsBinaryHeap(pq: PQueue) {\n    match pq\n    case Leaf => true\n    case Node(x, left, right) =>\n      IsBinaryHeap(left) && IsBinaryHeap(right) &&\n      (left == Leaf || x <= left.x) &&\n      (right == Leaf || x <= right.x)\n  }\n\n  ghost predicate IsBalanced(pq: PQueue) {\n    match pq\n    case Leaf => true\n    case Node(_, left, right) =>\n      IsBalanced(left) && IsBalanced(right) &&\n      var L, R := |Elements(left)|, |Elements(right)|;\n      L == R || L == R + 1\n  }\n\n  function Empty(): PQueue {\n    Leaf\n  }\n\n  predicate IsEmpty(pq: PQueue) {\n    pq == Leaf\n  }\n\n  function Insert(pq: PQueue, y: int): PQueue {\n    match pq\n    case Leaf => Node(y, Leaf, Leaf)\n    case Node(x, left, right) =>\n      if y < x then\n        Node(y, Insert(right, x), left)\n      else\n        Node(x, Insert(right, y), left)\n  }\n\n  function RemoveMin(pq: PQueue): (int, PQueue)\n    requires !IsEmpty(pq)\n  {\n    (pq.x, DeleteMin(pq))\n  }\n\n  function DeleteMin(pq: PQueue): PQueue\n    requires !IsEmpty(pq)\n  {\n    if pq.left == Leaf || pq.right == Leaf then\n      pq.left\n    else if pq.left.x <= pq.right.x then\n      Node(pq.left.x, pq.right, DeleteMin(pq.left))\n    else\n      Node(pq.right.x, ReplaceRoot(pq.right, pq.left.x),\n           DeleteMin(pq.left))\n  }\n\n  function ReplaceRoot(pq: PQueue, y: int): PQueue\n    requires !IsEmpty(pq)\n  {\n    if pq.left == Leaf ||\n       (y <= pq.left.x && (pq.right == Leaf || y <= pq.right.x))\n    then\n      Node(y, pq.left, pq.right)\n    else if pq.right == Leaf then\n      Node(pq.left.x, Node(y, Leaf, Leaf), Leaf)\n    else if pq.left.x < pq.right.x then\n      Node(pq.left.x, ReplaceRoot(pq.left, y), pq.right)\n    else\n      Node(pq.right.x, pq.left, ReplaceRoot(pq.right, y))\n  }\n\n  ghost function Elements(pq: PQueue): multiset<int> {\n    match pq\n    case Leaf => multiset{}\n    case Node(x, left, right) =>\n      multiset{x} + Elements(left) + Elements(right)\n  }\n\n  lemma EmptyCorrect()\n    ensures var pq := Empty();\n      Valid(pq) &&\n      Elements(pq) == multiset{}\n  {\n  }\n\n  lemma IsEmptyCorrect(pq: PQueue)\n    requires Valid(pq)\n    ensures IsEmpty(pq) <==> Elements(pq) == multiset{}\n  {\n  }\n\n  lemma InsertCorrect(pq: PQueue, y: int)\n    requires Valid(pq)\n    ensures var pq' := Insert(pq, y);\n      Valid(pq') &&\n      Elements(pq') == Elements(pq) + multiset{y}\n  {\n  }\n\n  lemma RemoveMinCorrect(pq: PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var (y, pq') := RemoveMin(pq);\n      Valid(pq') &&\n      IsMin(y, Elements(pq)) &&\n      Elements(pq') + multiset{y} == Elements(pq)\n  {\n    DeleteMinCorrect(pq);\n  }\n\n  lemma DeleteMinCorrect(pq: PQueue)\n    requires Valid(pq) && pq != Leaf\n    ensures var pq' := DeleteMin(pq);\n      Valid(pq') &&\n      Elements(pq') + multiset{pq.x} == Elements(pq)\n  {\n    if pq.left == Leaf || pq.right == Leaf {\n    } else if pq.left.x <= pq.right.x {\n      DeleteMinCorrect(pq.left);\n    } else {\n      var left, right :=\n        ReplaceRoot(pq.right, pq.left.x), DeleteMin(pq.left);\n      var pq' := Node(pq.right.x, left, right);\n      assert pq' == DeleteMin(pq);\n      ReplaceRootCorrect(pq.right, pq.left.x);\n      DeleteMinCorrect(pq.left);\n      calc {\n        Elements(pq') + multiset{pq.x};\n      ==  // def. Elements, since pq' is a Node\n        multiset{pq.right.x} + Elements(left) +\n        Elements(right) + multiset{pq.x};\n      ==\n        Elements(left) + multiset{pq.right.x} +\n        Elements(right) + multiset{pq.x};\n      ==  { assert Elements(left) + multiset{pq.right.x}\n                == Elements(pq.right) + multiset{pq.left.x}; }\n        Elements(pq.right) + multiset{pq.left.x} +\n        Elements(right) + multiset{pq.x};\n      ==\n        Elements(right) + multiset{pq.left.x} +\n        Elements(pq.right) + multiset{pq.x};\n      ==  { assert Elements(right) + multiset{pq.left.x}\n                == Elements(pq.left); }\n        Elements(pq.left) + Elements(pq.right) +\n        multiset{pq.x};\n      ==\n        multiset{pq.x} + Elements(pq.left) +\n        Elements(pq.right);\n      ==  // def. Elements, since pq is a Node\n        Elements(pq);\n      }\n    }\n  }\n\n  lemma ReplaceRootCorrect(pq: PQueue, y: int)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var pq' := ReplaceRoot(pq, y);\n      Valid(pq') &&\n      Elements(pq) + multiset{y} == Elements(pq') + multiset{pq.x} &&\n      |Elements(pq')| == |Elements(pq)|\n  {\n    if pq.left == Leaf ||\n       (y <= pq.left.x && (pq.right == Leaf || y <= pq.right.x))\n    {\n    } else if pq.right == Leaf {\n    } else if pq.left.x < pq.right.x {\n      var left := ReplaceRoot(pq.left, y);\n      var pq' := Node(pq.left.x, left, pq.right);\n      assert pq' == ReplaceRoot(pq, y);\n      ReplaceRootCorrect(pq.left, y);\n      calc {\n        Elements(pq) + multiset{y};\n      ==  // def. Elements, since pq is a Node\n        multiset{pq.x} + Elements(pq.left) +\n        Elements(pq.right) + multiset{y};\n      ==\n        Elements(pq.left) + multiset{y} +\n        Elements(pq.right) + multiset{pq.x};\n      ==  { assert Elements(pq.left) + multiset{y}\n                == Elements(left) + multiset{pq.left.x}; } // I.H.\n        multiset{pq.left.x} + Elements(left) +\n        Elements(pq.right) + multiset{pq.x};\n      ==  // def. Elements, since pq' is a Node\n        Elements(pq') + multiset{pq.x};\n      }\n    } else {\n      var right := ReplaceRoot(pq.right, y);\n      var pq' := Node(pq.right.x, pq.left, right);\n      assert pq' == ReplaceRoot(pq, y);\n      ReplaceRootCorrect(pq.right, y);\n      calc {\n        Elements(pq) + multiset{y};\n      ==  // def. Elements, since pq is a Node\n        multiset{pq.x} + Elements(pq.left) +\n        Elements(pq.right) + multiset{y};\n      ==\n        Elements(pq.right) + multiset{y} +\n        Elements(pq.left) + multiset{pq.x};\n      ==  { assert Elements(pq.right) + multiset{y}\n                == Elements(right) + multiset{pq.right.x}; }\n        multiset{pq.right.x} + Elements(pq.left) +\n        Elements(right) + multiset{pq.x};\n      ==  // def. Elements, since pq' is a Node\n        Elements(pq') + multiset{pq.x};\n      }\n    }\n  }\n\n  ghost predicate IsMin(y: int, s: multiset<int>) {\n    y in s && forall x :: x in s ==> y <= x\n  }\n}\n"}
{"file": "../program-proofs-code/ch6/6-Lists.dfy", "dafny": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(xs: List<T>): nat {\n  match xs\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Length'<T>(xs: List<T>): nat {\n  if xs == Nil then 0 else 1 + Length'(xs.tail)\n}\n\nlemma LengthLength'<T>(xs: List<T>)\n  ensures Length(xs) == Length'(xs)\n{\n}\n\nfunction Snoc<T>(xs: List<T>, y: T): List<T> {\n  match xs\n  case Nil => Cons(y, Nil)\n  case Cons(x, tail) => Cons(x, Snoc(tail, y))\n}\n\nlemma LengthSnoc<T>(xs: List<T>, x: T)\n  ensures Length(Snoc(xs, x)) == Length(xs) + 1\n{\n}\n\nfunction Append<T>(xs: List<T>, ys: List<T>): List<T>\n  ensures Length(Append(xs, ys)) == Length(xs) + Length(ys)\n{\n  match xs\n  case Nil => ys\n  case Cons(x, tail) => Cons(x, Append(tail, ys))\n}\n\nlemma LengthAppend<T>(xs: List<T>, ys: List<T>)\n  ensures Length(Append(xs, ys)) == Length(xs) + Length(ys)\n{\n}\n\nlemma SnocAppend<T>(xs: List<T>, y: T)\n  ensures Snoc(xs, y) == Append(xs, Cons(y, Nil))\n{\n}\n\nlemma {:induction false} AppendNil<T>(xs: List<T>)\n  ensures Append(xs, Nil) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(x, tail) =>\n    calc {\n      Append(xs, Nil);\n    ==  // def. Append\n      Cons(x, Append(tail, Nil));\n    ==  { AppendNil(tail); }\n      Cons(x, tail);\n    ==\n      xs;\n    }\n}\n\nlemma AppendAssociative<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures Append(Append(xs, ys), zs) == Append(xs, Append(ys, zs))\n{\n}\n\nfunction Take<T>(xs: List<T>, n: nat): List<T>\n  requires n <= Length(xs)\n{\n  if n == 0 then Nil else Cons(xs.head, Take(xs.tail, n - 1))\n}\n\nfunction Drop<T>(xs: List<T>, n: nat): List<T>\n  requires n <= Length(xs)\n{\n  if n == 0 then xs else Drop(xs.tail, n - 1)\n}\n\nfunction LiberalTake<T>(xs: List<T>, n: nat): List<T>\n{\n  if n == 0 || xs == Nil then\n    Nil\n  else\n    Cons(xs.head, LiberalTake(xs.tail, n - 1))\n}\n\nfunction LiberalDrop<T>(xs: List<T>, n: nat): List<T>\n{\n  if n == 0 || xs == Nil then\n    xs\n  else\n    LiberalDrop(xs.tail, n - 1)\n}\n\nlemma TakesDrops<T>(xs: List<T>, n: nat)\n  requires n <= Length(xs)\n  ensures Take(xs, n) == LiberalTake(xs, n)\n  ensures Drop(xs, n) == LiberalDrop(xs, n)\n{\n}\n\nlemma AppendTakeDrop<T>(xs: List<T>, n: nat)\n  requires n <= Length(xs)\n  ensures Append(Take(xs, n), Drop(xs, n)) == xs\n{\n}\n\nlemma TakeDropAppend<T>(xs: List<T>, ys: List<T>)\n  ensures Take(Append(xs, ys), Length(xs)) == xs\n  ensures Drop(Append(xs, ys), Length(xs)) == ys\n{\n}\n\nfunction At<T>(xs: List<T>, i: nat): T\n  requires i < Length(xs)\n{\n  if i == 0 then xs.head else At(xs.tail, i - 1)\n}\n\nlemma AtDropHead<T>(xs: List<T>, i: nat)\n  requires i < Length(xs)\n  ensures Drop(xs, i).Cons? && At(xs, i) == Drop(xs, i).head\n{\n}\n\nlemma AtAppend<T>(xs: List<T>, ys: List<T>, i: nat)\n  requires i < Length(Append(xs, ys))\n  ensures At(Append(xs, ys), i)\n       == if i < Length(xs) then\n            At(xs, i)\n          else\n            At(ys, i - Length(xs))\n{\n}\n\nfunction Find<T(==)>(xs: List<T>, y: T): nat\n  ensures Find(xs, y) <= Length(xs)\n{\n  match xs\n  case Nil => 0\n  case Cons(x, tail) =>\n    if x == y then 0 else 1 + Find(tail, y)\n}\n\nfunction SlowReverse<T>(xs: List<T>): List<T> {\n  match xs\n  case Nil => Nil\n  case Cons(x, tail) => Snoc(SlowReverse(tail), x)\n}\n\nlemma LengthSlowReverse<T>(xs: List<T>)\n  ensures Length(SlowReverse(xs)) == Length(xs)\n{\n  match xs\n  case Nil =>\n  case Cons(x, tail) =>\n    LengthSnoc(SlowReverse(tail), x);\n}\n\nfunction ReverseAux<T>(xs: List<T>, acc: List<T>): List<T>\n{\n  match xs\n  case Nil => acc\n  case Cons(x, tail) => ReverseAux(tail, Cons(x, acc))\n}\n\nlemma ReverseAuxSlowCorrect<T>(xs: List<T>, acc: List<T>)\n  ensures ReverseAux(xs, acc) == Append(SlowReverse(xs), acc)\n{\n  match xs\n  case Nil =>\n  case Cons(x, tail) =>\n    calc {\n      Append(SlowReverse(xs), acc);\n    ==  // def. SlowReverse\n      Append(Snoc(SlowReverse(tail), x), acc);\n    ==  { SnocAppend(SlowReverse(tail), x); }\n      Append(Append(SlowReverse(tail), Cons(x, Nil)), acc);\n    ==  { AppendAssociative(SlowReverse(tail), Cons(x, Nil), acc); }\n      Append(SlowReverse(tail), Append(Cons(x, Nil), acc));\n    ==  { assert Append(Cons(x, Nil), acc) == Cons(x, acc); }\n      Append(SlowReverse(tail), Cons(x, acc));\n    ==  { ReverseAuxSlowCorrect(tail, Cons(x, acc)); }\n      ReverseAux(tail, Cons(x, acc));\n    ==  // def. ReverseAux\n      ReverseAux(xs, acc);\n    }\n}\n\n\nfunction Reverse<T>(xs: List<T>): List<T> {\n  ReverseAux(xs, Nil)\n}\n\nlemma ReverseCorrect<T>(xs: List<T>)\n  ensures Reverse(xs) == SlowReverse(xs)\n{\n  calc {\n    Reverse(xs);\n  ==  // def. Reverse\n    ReverseAux(xs, Nil);\n  ==  { ReverseAuxSlowCorrect(xs, Nil); }\n    Append(SlowReverse(xs), Nil);\n  ==  { AppendNil(SlowReverse(xs)); }\n    SlowReverse(xs);\n  }\n}\n\nlemma ReverseAuxCorrect<T>(xs: List<T>, acc: List<T>)\n  ensures ReverseAux(xs, acc) == Append(Reverse(xs), acc)\n{\n  ReverseCorrect(xs);\n  ReverseAuxSlowCorrect(xs, acc);\n}\n\nlemma LengthReverse<T>(xs: List<T>)\n  ensures Length(Reverse(xs)) == Length(xs)\n{\n  ReverseCorrect(xs);\n  LengthSlowReverse(xs);\n}\n\nlemma ReverseAuxAppend<T>(xs: List<T>, ys: List<T>, acc: List<T>)\n  ensures ReverseAux(Append(xs, ys), acc)\n       == Append(Reverse(ys), ReverseAux(xs, acc))\n{\n  match xs\n  case Nil =>\n    ReverseAuxCorrect(ys, acc);\n  case Cons(x, tail) =>\n}\n\nlemma AtReverse<T>(xs: List<T>, i: nat)\n  requires i < Length(xs)\n  ensures (LengthReverse(xs);\n    At(xs, i) == At(Reverse(xs), Length(xs) - 1 - i))\n{\n  var x, tail := xs.head, xs.tail;\n  LengthReverse(xs);\n  calc {\n    At(Reverse(xs), Length(xs) - 1 - i);\n  ==  // def. Reverse\n    At(ReverseAux(xs, Nil), Length(xs) - 1 - i);\n  ==  // def. ReverseAux\n    At(ReverseAux(tail, Cons(x, Nil)), Length(xs) - 1 - i);\n  ==  { ReverseAuxSlowCorrect(tail, Cons(x, Nil)); }\n    At(Append(SlowReverse(tail), Cons(x, Nil)), Length(xs) - 1 - i);\n  ==  { ReverseCorrect(tail); }\n    At(Append(Reverse(tail), Cons(x, Nil)), Length(xs) - 1 - i);\n  ==  { AtAppend(Reverse(tail), Cons(x, Nil), Length(xs) - 1 - i); }\n    if Length(xs) - 1 - i < Length(Reverse(tail)) then\n      At(Reverse(tail), Length(xs) - 1 - i)\n    else\n      At(Cons(x, Nil), Length(xs) - 1 - i-Length(Reverse(tail)));\n  ==  { LengthReverse(tail); }\n    if Length(xs) - 1 - i < Length(tail) then\n      At(Reverse(tail), Length(xs) - 1 - i)\n    else\n      At(Cons(x, Nil), Length(xs) - 1 - i - Length(tail));\n  ==  // arithmetic, using Length(xs) == Length(tail) + 1 and 0 <= i\n    if 0 < i then\n      At(Reverse(tail), Length(tail) - 1 - (i - 1))\n    else\n      At(Cons(x, Nil), 0);\n  }\n  if 0 < i {\n    LengthReverse(tail);\n    calc {\n      At(Reverse(tail), Length(tail) - 1 - (i - 1));\n    ==  { AtReverse(tail, i - 1); }\n      At(tail, i - 1);\n    ==  // def. At\n      At(xs, i);\n    }\n  }\n}\n"}
{"file": "../program-proofs-code/ch6/6.2-Algebra.dfy", "dafny": "function F(x: int, y: int): int\n\nconst L: int\nconst R: int\n\nlemma LeftUnit(x: int)\n  ensures F(L, x) == x\n\nlemma RightUnit(x: int)\n  ensures F(x, R) == x\n\nlemma UnitsAreTheSame()\n  ensures L == R\n{\n  calc {\n    L;\n  ==  { RightUnit(L); }\n    F(L, R);\n  ==  { LeftUnit(R); }\n    R;\n  }\n}\n"}
{"file": "../program-proofs-code/ch7/7-Unary.dfy", "dafny": "datatype Unary = Zero | Suc(pred: Unary)\n\nfunction UnaryToNat(x: Unary): nat {\n  match x\n  case Zero => 0\n  case Suc(x') => 1 + UnaryToNat(x')\n}\n\nfunction NatToUnary(n: nat): Unary {\n  if n == 0 then Zero else Suc(NatToUnary(n-1))\n}\n\nlemma NatUnaryCorrespondence(n: nat, x: Unary)\n  ensures UnaryToNat(NatToUnary(n)) == n\n  ensures NatToUnary(UnaryToNat(x)) == x\n{\n}\n\npredicate Less(x: Unary, y: Unary) {\n  y != Zero && (x.Suc? ==> Less(x.pred, y.pred))\n}\n\npredicate LessAlt(x: Unary, y: Unary) {\n  y != Zero && (x == Zero || Less(x.pred, y.pred))\n}\n\nlemma LessSame(x: Unary, y: Unary)\n  ensures Less(x, y) == LessAlt(x, y)\n{\n}\n\nlemma LessCorrect(x: Unary, y: Unary)\n  ensures Less(x, y) <==> UnaryToNat(x) < UnaryToNat(y)\n{\n}\n\nlemma LessTransitive(x: Unary, y: Unary, z: Unary)\n  requires Less(x, y) && Less(y, z)\n  ensures Less(x, z)\n{\n}\n\nlemma LessTrichotomous(x: Unary, y: Unary)\n  // 1 or 3 of them are true:\n  ensures Less(x, y) <==> x == y <==> Less(y, x)\n  // not all 3 are true:\n  ensures !(Less(x, y) && x == y && Less(y, x))\n{\n}\n\nfunction Add(x: Unary, y: Unary): Unary {\n  match y\n  case Zero => x\n  case Suc(y') => Suc(Add(x, y'))\n}\n\nlemma {:induction false} AddCorrect(x: Unary, y: Unary)\n  ensures UnaryToNat(Add(x, y)) == UnaryToNat(x) + UnaryToNat(y)\n{\n  match y\n  case Zero =>\n  case Suc(y') =>\n    calc {\n      UnaryToNat(Add(x, y));\n    ==  // y == Suc(y')\n      UnaryToNat(Add(x, Suc(y')));\n    ==  // def. Add\n      UnaryToNat(Suc(Add(x, y')));\n    ==  // def. UnaryToNat\n      1 + UnaryToNat(Add(x, y'));\n    ==  { AddCorrect(x, y'); }\n      1 + UnaryToNat(x) + UnaryToNat(y');\n    ==  // def. UnaryToNat\n      UnaryToNat(x) + UnaryToNat(Suc(y'));\n    ==  // y == Suc(y')\n      UnaryToNat(x) + UnaryToNat(y);\n    }\n}\n\nlemma {:induction false} SucAdd(x: Unary, y: Unary)\n  ensures Suc(Add(x, y)) == Add(Suc(x), y)\n{\n  match y\n  case Zero =>\n  case Suc(y') =>\n    calc {\n      Suc(Add(x, Suc(y')));\n    ==  // def. Add\n      Suc(Suc(Add(x, y')));\n    ==  { SucAdd(x, y'); }\n      Suc(Add(Suc(x), y'));\n    ==  // def. Add\n      Add(Suc(x), Suc(y'));\n    }\n}\n\nlemma {:induction false} AddZero(x: Unary)\n  ensures Add(Zero, x) == x\n{\n  match x\n  case Zero =>\n  case Suc(x') =>\n    calc {\n      Add(Zero, Suc(x'));\n    ==  // def. Add\n      Suc(Add(Zero, x'));\n    ==  { AddZero(x'); }\n      Suc(x');\n    }\n}\n\nfunction Sub(x: Unary, y: Unary): Unary\n  requires !Less(x, y)\n{\n  match y\n  case Zero => x\n  case Suc(y') => Sub(x.pred, y')\n}\n\nlemma SubCorrect(x: Unary, y: Unary)\n  requires !Less(x, y)\n  ensures UnaryToNat(Sub(x, y)) == UnaryToNat(x) - UnaryToNat(y)\n{\n}\n\nfunction Mul(x: Unary, y: Unary): Unary {\n  match x\n  case Zero => Zero\n  case Suc(x') => Add(Mul(x', y), y)\n}\n\nlemma MulCorrect(x: Unary, y: Unary)\n  ensures UnaryToNat(Mul(x, y)) == UnaryToNat(x) * UnaryToNat(y)\n{\n  match x\n  case Zero =>\n  case Suc(x') =>\n    calc {\n      UnaryToNat(Mul(x, y));\n    ==  // def. Mul\n      UnaryToNat(Add(Mul(x', y), y));\n    ==  { AddCorrect(Mul(x', y), y); }\n      UnaryToNat(Mul(x', y)) + UnaryToNat(y);\n      // Dafny can take it from here on\n    }\n}\n\nfunction DivMod(x: Unary, y: Unary): (Unary, Unary)\n  requires y != Zero\n  decreases UnaryToNat(x)\n{\n  if Less(x, y) then\n    (Zero, x)\n  else\n    SubCorrect(x, y);\n    var r := DivMod(Sub(x, y), y);\n    (Suc(r.0), r.1)\n}\n\nlemma SubStructurallySmaller(x: Unary, y: Unary)\n  requires !Less(x, y) && y != Zero\n  ensures Sub(x, y) < x\n{\n}\n\nlemma AddSub(x: Unary, y: Unary)\n  requires !Less(x, y)\n  ensures Add(Sub(x, y), y) == x\n// proof left as an exercise\n\nlemma AddCommAssoc(x: Unary, y: Unary, z: Unary)\n  ensures Add(Add(x, y), z) == Add(Add(x, z), y)\n// proof left as an exercise\n\nlemma DivModCorrect(x: Unary, y: Unary)\n  requires y != Zero\n  ensures var (d, m) := DivMod(x, y);\n    Add(Mul(d, y), m) == x &&\n    Less(m, y)\n{\n  var (d, m) := DivMod(x, y);\n  if Less(x, y) {\n    assert d == Zero && m == x; // since (d, m) == DivMod(x, y)\n    calc {\n      Add(Mul(d, y), m) == x;\n    ==  // d, m\n      Add(Mul(Zero, y), x) == x;\n    ==  // def. Mul\n      Add(Zero, x) == x;\n    ==  { AddZero(x); }\n      true;\n    }\n  } else {\n    var (d', m') := DivMod(Sub(x, y), y);\n    assert d == Suc(d') && m == m'; // since (d, m) == DivMod(x, y)\n    calc {\n      true;\n    ==>  { SubStructurallySmaller(x, y);\n           DivModCorrect(Sub(x, y), y); }\n      Add(Mul(d', y), m) == Sub(x, y) && Less(m, y);\n    ==>  // add y to both sides\n      Add(Add(Mul(d', y), m), y) == Add(Sub(x, y), y) &&\n      Less(m, y);\n    ==  { AddSub(x, y); }\n      Add(Add(Mul(d', y), m), y) == x && Less(m, y);\n    ==  { AddCommAssoc(Mul(d', y), m, y); }\n      Add(Add(Mul(d', y), y), m) == x && Less(m, y);\n    ==  // def. Mul, d\n      Add(Mul(d, y), m) == x && Less(m, y);\n    }\n  }\n}\n"}
{"file": "../program-proofs-code/ch7/7.4.2-DivMod.dfy", "dafny": "datatype Unary = Zero | Suc(pred: Unary)\n\npredicate Less(x: Unary, y: Unary) {\n  y != Zero && (x.Suc? ==> Less(x.pred, y.pred))\n}\n\nfunction Sub(x: Unary, y: Unary): Unary\n  requires !Less(x, y)\n{\n  match y\n  case Zero => x\n  case Suc(y') => Sub(x.pred, y')\n}\n\nlemma SubStructurallySmaller(x: Unary, y: Unary)\n  requires !Less(x, y) && y != Zero\n  ensures Sub(x, y) < x\n{\n}\n\nfunction DivMod(x: Unary, y: Unary): (Unary, Unary)\n  requires y != Zero\n{\n  if Less(x, y) then\n    (Zero, x)\n  else\n    SubStructurallySmaller(x, y);\n    var (d, m) := DivMod(Sub(x, y), y);\n    (Suc(d), m)\n}\n"}
{"file": "../program-proofs-code/ch7/7.4.1-DivMod.dfy", "dafny": "datatype Unary = Zero | Suc(pred: Unary)\n\npredicate Less(x: Unary, y: Unary) {\n  y != Zero && (x.Suc? ==> Less(x.pred, y.pred))\n}\n\nfunction Sub(x: Unary, y: Unary): Unary\n  requires !Less(x, y)\n{\n  match y\n  case Zero => x\n  case Suc(y') => Sub(x.pred, y')\n}\n\nlemma SubStructurallySmaller(x: Unary, y: Unary)\n  requires !Less(x, y) && y != Zero\n  ensures Sub(x, y) < x\n{\n}\n\nfunction DivMod(x: Unary, y: Unary): (Unary, Unary)\n  requires y != Zero\n{\n  if Less(x, y) then\n    (Zero, x)\n  else\n    SubStructurallySmaller(x, y);\n    var r := DivMod(Sub(x, y), y); // cannot prove termination\n    (Suc(r.0), r.1)\n}\n"}
{"file": "../program-proofs-code/ch7/LessLemmas.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ninclude \"Unary.dfy\"\n\n// ----------------------------------------------------------------------\n\nmodule LessLemmas0 {\n  import opened UnaryLibrary\n\n//# LessCorrect\n//#\n\n//#\nlemma LessCorrect_AltPost(x: Unary, y: Unary)\n//# LessCorrect:AltPost\n  ensures Less(x, y) == (UnaryToNat(x) < UnaryToNat(y))\n//#\n{\n}\n\n//# LessTransitive:0\nlemma LessTransitive(x: Unary, y: Unary, z: Unary)\n  requires Less(x, y) && Less(y, z)\n  ensures Less(x, z)\n{\n}\n//#\n}\n\n// ----------------------------------------------------------------------\n\nmodule LessLemmas1 {\n  import opened UnaryLibrary\n\n//# LessTransitive:1\nlemma LessTransitive(x: Unary, y: Unary, z: Unary)\n  ensures Less(x, y) && Less(y, z) ==> Less(x, z)\n//# LessTransitive:1:0\n{\n  if Less(x, y) && Less(y, z) {\n//# LessTransitive:1:1\n    if x.Suc? {\n//# LessTransitive:1:2\n      LessTransitive(x.pred, y.pred, z.pred);\n    }\n  }\n}\n//#\n\n//# LessTrichotomous\nlemma LessTrichotomous(x: Unary, y: Unary)\n  // 1 or 3 of them are true:\n  ensures Less(x, y) <==> x == y <==> Less(y, x)\n  // not all 3 are true:\n  ensures !(Less(x, y) && x == y && Less(y, x))\n{\n}\n//#\n\n}\n"}
{"file": "../program-proofs-code/ch7/DivMod.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ninclude \"Unary.dfy\"\n\n// ----------------------------------------------------------------------\n\nmodule DivMod0 {\n  import opened UnaryLibrary\n\n//# SubStructurallySmaller\nlemma SubStructurallySmaller(x: Unary, y: Unary)\n  requires !Less(x, y) && y != Zero\n  ensures Sub(x, y) < x\n{\n}\n//#\n\n//# DivMod:0\nfunction DivMod(x: Unary, y: Unary): (Unary, Unary)\n//# DivMod:1\n  requires y != Zero\n//# DivMod:2\n{\n  if Less(x, y) then\n    (Zero, x)\n  else\n    var r := DivMod(Sub(x, y), y); // cannot prove termination\n    (Suc(r.0), r.1)\n}\n//#\n}\n\n// ----------------------------------------------------------------------\n\nmodule DivModTermination0 {\n  import opened UnaryLibrary\n\n}\n\nmodule DivModTermination1 {\n  import opened UnaryLibrary\n\nfunction DivMod(x: Unary, y: Unary): (Unary, Unary)\n  requires y != Zero\n  decreases UnaryToNat(x)\n{\n  if Less(x, y) then\n    (Zero, x)\n  else\n//# DivMod:termination:decr:1\n    var r := (SubCorrect(x, y); DivMod(Sub(x, y), y));\n//#\n    (Suc(r.0), r.1)\n}\n}\n\nmodule DivModTermination2 {\n  import opened UnaryLibrary\n\nfunction DivMod(x: Unary, y: Unary): (Unary, Unary)\n  requires y != Zero\n  decreases UnaryToNat(x)\n{\n  if Less(x, y) then\n    (Zero, x)\n  else\n//# DivMod:termination:decr:2\n    var r := DivMod(SubCorrect(x, y); Sub(x, y), y);\n//#\n    (Suc(r.0), r.1)\n}\n}\n\n// ----------------------------------------------------------------------\n\nmodule DivMod1 {\n  import opened UnaryLibrary\n  import opened DivMod0\n\n//# DivMod\nfunction DivMod(x: Unary, y: Unary): (Unary, Unary)\n  requires y != Zero\n{\n  if Less(x, y) then\n    (Zero, x)\n  else\n    SubStructurallySmaller(x, y);\n    var r := DivMod(Sub(x, y), y);\n    (Suc(r.0), r.1)\n}\n//#\n\n/*\n//# DivMod:alt\n    var (d, m) := DivMod(Sub(x, y), y);\n    (Suc(d), m)\n//#\n*/\n}\n\n// ----------------------------------------------------------------------\n\nmodule DivMod2 {\n  import opened UnaryLibrary\n  import opened DivMod0\n\n//# DivModCorrect:0\nlemma DivModCorrect(x: Unary, y: Unary)\n  requires y != Zero\n  ensures var (d, m) := DivMod(x, y);\n    Add(Mul(d, y), m) == x &&\n    Less(m, y)\n//# DivModCorrect:1\n{\n  var (d, m) := DivMod(x, y);\n//# DivModCorrect:2\n  if Less(x, y) {\n    assert d == Zero && m == x; // since (d, m) == DivMod(x, y)\n//# DivModCorrect:3\n    calc {\n      Add(Mul(d, y), m) == x;\n    ==  // d, m\n      Add(Mul(Zero, y), x) == x;\n    ==  // def. Mul\n      Add(Zero, x) == x;\n    ==  { AddZero(x); }\n      true;\n    }\n//# DivModCorrect:4\n  } else {\n    var (d', m') := DivMod(Sub(x, y), y);\n    assert d == Suc(d') && m == m'; // since (d, m) == DivMod(x, y)\n//# DivModCorrect:5\n    calc {\n      true;\n//# DivModCorrect:6\n    ==>  { SubStructurallySmaller(x, y);\n           DivModCorrect(Sub(x, y), y); }\n      Add(Mul(d', y), m) == Sub(x, y) && Less(m, y);\n//# DivModCorrect:7\n    ==>  // add y to both sides\n      Add(Add(Mul(d', y), m), y) == Add(Sub(x, y), y) &&\n      Less(m, y);\n    ==  { AddSub(x, y); }\n      Add(Add(Mul(d', y), m), y) == x && Less(m, y);\n    ==  { AddCommAssoc(Mul(d', y), m, y); }\n      Add(Add(Mul(d', y), y), m) == x && Less(m, y);\n    ==  // def. Mul, d\n      Add(Mul(d, y), m) == x && Less(m, y);\n    }\n  }\n}\n//#\n}\n"}
{"file": "../program-proofs-code/ch1/1.4-Triple-b.dfy", "dafny": "method Triple(x: int) returns (r: int)\n  requires x % 2 == 0\n  ensures r == 3 * x\n{\n  var y := x / 2;\n  r := 6 * y;\n}\n\nmethod Caller() {\n  var t := Triple(18);\n  assert t < 100;\n}\n"}
{"file": "../program-proofs-code/ch1/1.0-Triple.dfy", "dafny": "method Triple(x: int) returns (r: int) {\n  var y := 2 * x;\n  r := x + y;\n}\n\nmethod Main() {\n  var t := Triple(18);\n  print t, \"\\n\"; // 54\n}\n"}
{"file": "../program-proofs-code/ch1/1.4.1-Min.dfy", "dafny": "method Min(x: int, y: int) returns (m: int)\n  ensures m <= x && m <= y\n  ensures m == x || m == y\n"}
{"file": "../program-proofs-code/ch1/1.5-IsEven.dfy", "dafny": "predicate IsEven(x: int) {\n  x % 2 == 0\n}\n"}
{"file": "../program-proofs-code/ch1/1.3-Triple-b.dfy", "dafny": "method Triple(x: int) returns (r: int) {\n  if {\n    case x < 18 =>\n      var a, b := 2 * x, 4 * x;\n      r := (a + b) / 2;\n    case 0 <= x =>\n      var y := 2 * x;\n      r := x + y;\n  }\n  assert r == 3 * x;\n}\n"}
{"file": "../program-proofs-code/ch1/1.6.0-DoubleQuadruple.dfy", "dafny": "method Triple(x: int) returns (r: int)\n  ensures r == 3 * x\n{\n  var y := 2 * x;\n  r := x + y;\n  ghost var a, b := DoubleQuadruple(x);\n  assert a <= r <= b || b <= r <= a;\n}\n\nghost method DoubleQuadruple(x: int) returns (a: int, b: int)\n  ensures a == 2 * x && b == 4 * x\n{\n  a := 2 * x;\n  b := 2 * a;\n}\n"}
{"file": "../program-proofs-code/ch1/1.4-Triple-a.dfy", "dafny": "method Triple(x: int) returns (r: int)\n  ensures r == 3 * x\n{\n  var y := 2 * x;\n  r := x + y;\n}\n\nmethod Caller() {\n  var t := Triple(18);\n  assert t < 100;\n}\n"}
{"file": "../program-proofs-code/ch1/1.5-Average.dfy", "dafny": "function Average(a: int, b: int): int\n  requires 0 <= a && 0 <= b\n{\n  (a + b) / 2\n}\n\nmethod Triple(x: int) returns (r: int)\n  ensures r == 3 * x\n{\n  if 0 <= x {\n    r := Average(2 * x, 4 * x);\n  } else {\n    r := -Average(-2 * x, -4 * x);\n  }\n}\n"}
{"file": "../program-proofs-code/ch1/1.4.0-Index.dfy", "dafny": "method Index(n: int) returns (i: int)\n  requires 1 <= n\n  ensures 0 <= i < n\n{\n  i := n / 2;\n\n  // Or, the following statement also satisfies the specification:\n  // i := 0;\n}\n\nmethod Caller() {\n  var x := Index(50);\n  var y := Index(50);\n  assert x == y; // error: the specification of Index does not allow you to prove this condition\n}\n"}
{"file": "../program-proofs-code/ch1/1.2-Triple.dfy", "dafny": "method Triple(x: int) returns (r: int) {\n  var y := 2 * x;\n  r := x + y;\n  assert r == 10 * x; // error\n  assert r < 5;\n  assert false; // error\n}\n"}
{"file": "../program-proofs-code/ch1/1.6-Ghost.dfy", "dafny": "method IllegalAssignment() returns (y: int) {\n  ghost var x := 10;\n  y := 2 * x; // error: cannot assign to compiled variable using a ghost\n}\n"}
{"file": "../program-proofs-code/ch1/1.3-Triple-a.dfy", "dafny": "method Triple(x: int) returns (r: int) {\n  if x == 0 {\n    r := 0;\n  } else {\n    var y := 2 * x;\n    r := x + y;\n  } \n  assert r == 3 * x;\n}\n"}
{"file": "../program-proofs-code/ch1/1.1-Triple.dfy", "dafny": "method Triple(x: int) returns (r: int) {\n  var y := 2 * x;\n  r := x + y;\n  assert r == 3 * x;\n}\n"}
{"file": "../program-proofs-code/ch13/13.4-CoincidenceCount-g.dfy", "dafny": "method CoincidenceCount_Debug4(a: array<int>, b: array<int>) returns (c: nat)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i, j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures c == |multiset(a[..]) * multiset(b[..])|\n{\n  c := 0;\n  var m, n := 0, 0;\n  while m < a.Length && n < b.Length\n    invariant 0 <= m <= a.Length && 0 <= n <= b.Length\n    invariant c + |multiset(a[m..]) * multiset(b[n..])|\n           == |multiset(a[..]) * multiset(b[..])|\n    decreases a.Length - m + b.Length - n\n  {\n    if\n    case a[m] == b[n] =>\n      MultisetIntersectionPrefix(a, b, m, n);\n      c, m, n := c + 1, m + 1, n + 1;\n    case a[m] < b[n] =>\n      MultisetIntersectionAdvance(a, m, multiset(b[n..]));\n      m := m + 1;\n    case b[n] < a[m] =>\n      calc {\n        multiset(a[m..]) * multiset(b[n..]);\n      ==  // multiset union is commutative\n        multiset(b[n..]) * multiset(a[m..]);\n      ==  { MultisetIntersectionAdvance(b, n, multiset(a[m..])); }\n        multiset(b[n+1..]) * multiset(a[m..]);\n      ==  // multiset union is commutative\n        multiset(a[m..]) * multiset(b[n+1..]);\n      }\n      n := n + 1;\n  }\n}\n\nlemma MultisetIntersectionPrefix(a: array<int>, b: array<int>,\n                                 m: nat, n: nat)\n  requires m < a.Length && n < b.Length\n  requires a[m] == b[n]\n  ensures multiset(a[m..]) * multiset(b[n..])\n       == multiset{a[m]} + (multiset(a[m+1..]) * multiset(b[n+1..]))\n{\n  var E := multiset{a[m]};\n  calc {\n    multiset(a[m..]) * multiset(b[n..]);\n    multiset(a[m..]) * multiset(b[n..]);\n  ==  { assert a[m..] == [a[m]] + a[m+1..]\n            && b[n..] == [b[n]] + b[n+1..]; }\n    (E + multiset(a[m+1..])) * (E + multiset(b[n+1..]));\n  ==  // distribute * over +\n    E + (multiset(a[m+1..]) * multiset(b[n+1..]));\n  }\n}\n\nlemma MultisetIntersectionAdvance(a: array<int>, m: nat,\n                                  B: multiset<int>)\n  requires m < a.Length && a[m] !in B\n  ensures multiset(a[m..]) * B == multiset(a[m+1..]) * B\n{\n  var E := multiset{a[m]};\n  calc {\n    multiset(a[m..]) * B;\n  ==  { assert a[m..] == [a[m]] + a[m+1..]; }\n    (E + multiset(a[m+1..])) * B;\n  ==  // distribute * over +\n    (E * B) + (multiset(a[m+1..]) * B);\n  ==  { assert E * B == multiset{}; }\n    multiset(a[m+1..]) * B;\n  }\n}\n"}
{"file": "../program-proofs-code/ch13/13.4-CoincidenceCount-c.dfy", "dafny": "method CoincidenceCount(a: array<int>, b: array<int>) returns (c: nat)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i, j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures c == |multiset(a[..]) * multiset(b[..])|\n{\n  c := 0;\n  var m, n := 0, 0;\n  while m < a.Length && n < b.Length\n    invariant 0 <= m <= a.Length && 0 <= n <= b.Length\n    invariant c + |multiset(a[m..]) * multiset(b[n..])|\n           == |multiset(a[..]) * multiset(b[..])|\n    decreases a.Length - m + b.Length - n\n  {\n    if\n    case a[m] == b[n] =>\n      assert multiset(a[m..]) * multiset(b[n..]) // unable to prove this assertion\n          == multiset{a[m]} + (multiset(a[m+1..]) * multiset(b[n+1..]));\n      c, m, n := c + 1, m + 1, n + 1;\n      assert c + |multiset(a[m..]) * multiset(b[n..])|\n          == |multiset(a[..]) * multiset(b[..])|;\n    case a[m] < b[n] =>\n      m := m + 1;\n      assert c + |multiset(a[m..]) * multiset(b[n..])| // unable to prove this assertion\n          == |multiset(a[..]) * multiset(b[..])|;\n    case b[n] < a[m] =>\n      n := n + 1;\n      assert c + |multiset(a[m..]) * multiset(b[n..])| // unable to prove this assertion\n          == |multiset(a[..]) * multiset(b[..])|;\n  }\n}\n"}
{"file": "../program-proofs-code/ch13/13.2-BinarySearch.dfy", "dafny": "// Sortedness\n\nghost predicate IsSorted0(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nghost predicate IsSorted1(a: array<int>)\n  reads a\n{\n  forall i :: 0 <= i ==>\n    forall j :: i < j < a.Length ==> a[i] <= a[j]\n}\n\nghost predicate IsSorted2(a: array<int>)\n  reads a\n{\n  forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n}\n\nlemma SortedTheSame(a: array<int>)\n  ensures IsSorted0(a) == IsSorted1(a) == IsSorted2(a)\n{\n  assert IsSorted0(a) == IsSorted1(a);\n  assert IsSorted0(a) ==> IsSorted2(a);\n  if IsSorted2(a) && a.Length != 0 {\n    for n := 1 to a.Length\n      invariant forall i, j :: 0 <= i < j < n ==> a[i] <= a[j]\n    {\n      assert a[n-1] <= a[n];\n    }\n  }\n}\n\nlemma SortedTransitive(a: array<int>, i: int, j: int)\n  requires forall k :: 0 <= k < a.Length - 1 ==> a[k] <= a[k+1]\n  requires 0 <= i <= j < a.Length\n  ensures a[i] <= a[j]\n// proof left as an exercise\n\n// Binary Search\n\nmethod BinarySearch(a: array<int>, key: int) returns (n: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= n <= a.Length\n  ensures forall i :: 0 <= i < n ==> a[i] < key\n  ensures forall i :: n <= i < a.Length ==> key <= a[i]\n{\n  var lo, hi := 0, a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] < key\n    invariant forall i :: hi <= i < a.Length ==> key <= a[i]\n  {\n    calc {\n      lo;\n    ==\n      (lo + lo) / 2;\n    <=  { assert lo <= hi; }\n      (lo + hi) / 2; // this is mid\n    <  { assert lo < hi; }\n      (hi + hi) / 2;\n    ==\n      hi;\n    }\n    var mid := (lo + hi) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else {\n      hi := mid;\n    }\n  }\n  n := lo;\n}\n\nmethod Contains(a: array<int>, key: int) returns (present: bool)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures present == exists i :: 0 <= i < a.Length && key == a[i]\n{\n  var n := BinarySearch(a, key);\n  present := n < a.Length && a[n] == key;\n}\n"}
{"file": "../program-proofs-code/ch13/13.1-LinearSearch.dfy", "dafny": "method LinearSearch<T>(a: array<T>, P: T -> bool) returns (n: int)\n\npredicate NearPi(r: real) {\n  3.14 <= r <= 3.15\n}\n\nmethod TestLinearSearch(rls: array<real>) {\n  var n := LinearSearch(rls, NearPi);\n}\n\nmethod LinearSearch0<T>(a: array<T>, P: T -> bool) returns (n: int)\n  ensures 0 <= n <= a.Length\n  ensures n == a.Length || P(a[n])\n{\n  n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n  {\n    if P(a[n]) {\n      return;\n    }\n    n := n + 1;\n  }\n}\n\nmethod LinearSearch1<T>(a: array<T>, P: T -> bool) returns (n: int)\n  ensures 0 <= n <= a.Length\n  ensures n == a.Length || P(a[n])\n  ensures n == a.Length ==>\n    forall i :: 0 <= i < a.Length ==> !P(a[i])\n{\n  n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> !P(a[i])\n  {\n    if P(a[n]) {\n      return;\n    }\n    n := n + 1;\n  }\n}\n\nmethod LinearSearch2<T>(a: array<T>, P: T -> bool) returns (n: int)\n  ensures 0 <= n <= a.Length\n  ensures n == a.Length || P(a[n])\n  ensures forall i :: 0 <= i < n ==> !P(a[i])\n{\n  n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> !P(a[i])\n  {\n    if P(a[n]) {\n      return;\n    }\n    n := n + 1;\n  }\n}\n\nmethod LinearSearch3<T>(a: array<T>, P: T -> bool) returns (n: int)\n  requires exists i :: 0 <= i < a.Length && P(a[i])\n  ensures 0 <= n < a.Length && P(a[n])\n{\n  n := 0;\n  while true\n    invariant 0 <= n < a.Length\n    invariant exists i :: n <= i < a.Length && P(a[i])\n    decreases a.Length - n\n  {\n    if P(a[n]) {\n      return;\n    }\n    n := n + 1;\n  }\n}\n"}
{"file": "../program-proofs-code/ch13/13.4-CoincidenceCount-f.dfy", "dafny": "method CoincidenceCount_Debug4(a: array<int>, b: array<int>) returns (c: nat)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i, j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures c == |multiset(a[..]) * multiset(b[..])|\n{\n  c := 0;\n  var m, n := 0, 0;\n  while m < a.Length && n < b.Length\n    invariant 0 <= m <= a.Length && 0 <= n <= b.Length\n    invariant c + |multiset(a[m..]) * multiset(b[n..])|\n           == |multiset(a[..]) * multiset(b[..])|\n    decreases a.Length - m + b.Length - n\n  {\n    if\n    case a[m] == b[n] =>\n      MultisetIntersectionPrefix(a, b, m, n);\n      c, m, n := c + 1, m + 1, n + 1;\n    case a[m] < b[n] =>\n      MultisetIntersectionAdvance(a, m, multiset(b[n..]));\n      m := m + 1;\n    case b[n] < a[m] =>\n      MultisetIntersectionAdvance(b, n, multiset(a[m..]));\n      n := n + 1;\n      assert c + |multiset(a[m..]) * multiset(b[n..])| // unable to prove this assertion\n          == |multiset(a[..]) * multiset(b[..])|;\n  }\n}\n\nlemma MultisetIntersectionPrefix(a: array<int>, b: array<int>,\n                                 m: nat, n: nat)\n  requires m < a.Length && n < b.Length\n  requires a[m] == b[n]\n  ensures multiset(a[m..]) * multiset(b[n..])\n       == multiset{a[m]} + (multiset(a[m+1..]) * multiset(b[n+1..]))\n{\n  var E := multiset{a[m]};\n  calc {\n    multiset(a[m..]) * multiset(b[n..]);\n    multiset(a[m..]) * multiset(b[n..]);\n  ==  { assert a[m..] == [a[m]] + a[m+1..]\n            && b[n..] == [b[n]] + b[n+1..]; }\n    (E + multiset(a[m+1..])) * (E + multiset(b[n+1..]));\n  ==  // distribute * over +\n    E + (multiset(a[m+1..]) * multiset(b[n+1..]));\n  }\n}\n\nlemma MultisetIntersectionAdvance(a: array<int>, m: nat,\n                                  B: multiset<int>)\n  requires m < a.Length && a[m] !in B\n  ensures multiset(a[m..]) * B == multiset(a[m+1..]) * B\n{\n  var E := multiset{a[m]};\n  calc {\n    multiset(a[m..]) * B;\n  ==  { assert a[m..] == [a[m]] + a[m+1..]; }\n    (E + multiset(a[m+1..])) * B;\n  ==  // distribute * over +\n    (E * B) + (multiset(a[m+1..]) * B);\n  ==  { assert E * B == multiset{}; }\n    multiset(a[m+1..]) * B;\n  }\n}\n"}
{"file": "../program-proofs-code/ch13/13.3-Min.dfy", "dafny": "method Min'(a: array<int>) returns (m: int)\n  ensures forall i :: 0 <= i < a.Length ==> m <= a[i]\n{\n  m := *; // see https://program-proofs.com/errata.html about this line\n  var n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> m <= a[i]\n  {\n    if a[n] < m {\n      m := a[n];\n    }\n    n := n + 1;\n  }\n}\n\nmethod Min(a: array<int>) returns (m: int)\n  requires a.Length != 0\n  ensures forall i :: 0 <= i < a.Length ==> m <= a[i]\n  ensures exists i :: 0 <= i < a.Length && m == a[i]\n{\n  m := a[0];\n  var n := 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> m <= a[i]\n    invariant exists i :: 0 <= i < a.Length && m == a[i]\n  {\n    if a[n] < m {\n      m := a[n];\n    }\n    n := n + 1;\n  }\n}\n"}
{"file": "../program-proofs-code/ch13/13.7-MajorityVote.dfy", "dafny": "function Count<T(==)>(a: seq<T>, lo: int, hi: int, x: T): nat\n  requires 0 <= lo <= hi <= |a|\n{\n  if lo == hi then\n    0\n  else\n    Count(a, lo, hi - 1, x) + if a[hi - 1] == x then 1 else 0\n}\n\nlemma SplitCount<T>(a: seq<T>, lo: int, mid: int, hi: int, x: T)\n  requires 0 <= lo <= mid <= hi <= |a|\n  ensures Count(a, lo, mid, x) + Count(a, mid, hi, x)\n       == Count(a, lo, hi, x);\n{\n}\n\nlemma DistinctCounts<T>(a: seq<T>, lo: int, hi: int, x: T, y: T)\n  requires 0 <= lo <= hi <= |a|\n  ensures x != y ==>\n    Count(a, lo, hi, x) + Count(a, lo, hi, y) <= hi - lo\n{\n}\n\n// ----------------------------------------\n\npredicate HasMajority<T(==)>(a: seq<T>, lo: int, hi: int, x: T)\n  requires 0 <= lo <= hi <= |a|\n{\n  hi - lo < 2 * Count(a, lo, hi, x)\n}\n\npredicate HasMajority_Alternative<T(==)>(a: seq<T>, lo: int, hi: int, x: T)\n  requires 0 <= lo <= hi <= |a|\n{\n  (hi - lo) / 2 < Count(a, lo, hi, x)\n}\n\nlemma HasMajority_Alt_Same<T>(a: seq<T>, lo: int, hi: int, x: T)\n  requires 0 <= lo <= hi <= |a|\n  ensures HasMajority(a, lo, hi, x) == HasMajority_Alternative(a, lo, hi, x)\n{\n}\n\n// ----------------------------------------\n\nmethod FindWinner'<Candidate(==)>(a: seq<Candidate>) returns (k: Candidate)\n  requires exists K :: HasMajority(a, 0, |a|, K)\n  ensures HasMajority(a, 0, |a|, k)\n{\n  ghost var K :| HasMajority(a, 0, |a|, K);\n  k := FindWinner(a, K);\n}\n\nmethod FindWinner_Ghost<Candidate(==)>(a: seq<Candidate>, ghost K: Candidate)\n    returns (ghost k: Candidate)\n  requires HasMajority(a, 0, |a|, K)\n  ensures k == K\n{\n  k := K;\n}\n\n// ----------------------------------------\n\nmethod FindWinner<Candidate(==)>(a: seq<Candidate>, ghost K: Candidate)\n    returns (k: Candidate)\n  requires HasMajority(a, 0, |a|, K)\n  ensures k == K\n{\n  k := a[0];\n  var lo, hi, c := 0, 1, 1;\n  while hi < |a|\n    invariant 0 <= lo <= hi <= |a|\n    invariant c == Count(a, lo, hi, k)\n    invariant HasMajority(a, lo, hi, k)\n    invariant HasMajority(a, lo, |a|, K)\n  {\n    if a[hi] == k {\n      hi, c := hi + 1, c + 1;\n    } else if hi + 1 - lo < 2 * c {\n      hi := hi + 1;\n    } else {\n      hi := hi + 1;\n      calc {\n        true;\n      ==>\n        2 * Count(a, lo, hi, k) == hi - lo;\n      ==>  { DistinctCounts(a, lo, hi, k, K); }\n        2 * Count(a, lo, hi, K) <= hi - lo;\n      ==>  { SplitCount(a, lo, hi, |a|, K); }\n        |a| - hi < 2 * Count(a, hi, |a|, K);\n      ==  // def. HasMajority\n        HasMajority(a, hi, |a|, K);\n      }\n      k, lo, hi, c := a[hi], hi, hi + 1, 1;\n    }\n  }\n  DistinctCounts(a, lo, |a|, k, K);\n}\n\n// ----------------------------------------\n\nmethod FindWinner_NoCalc<Candidate(==)>(a: seq<Candidate>, ghost K: Candidate)\n    returns (k: Candidate)\n  requires HasMajority(a, 0, |a|, K)\n  ensures k == K\n{\n  k := a[0];\n  var lo, hi, c := 0, 1, 1;\n  while hi < |a|\n    invariant 0 <= lo <= hi <= |a|\n    invariant c == Count(a, lo, hi, k)\n    invariant HasMajority(a, lo, hi, k)\n    invariant HasMajority(a, lo, |a|, K)\n  {\n    if a[hi] == k {\n      hi, c := hi + 1, c + 1;\n    } else if hi + 1 - lo < 2 * c {\n      hi := hi + 1;\n    } else {\n      hi := hi + 1;\n      DistinctCounts(a, lo, hi, k, K);\n      SplitCount(a, lo, hi, |a|, K);\n      k, lo, hi, c := a[hi], hi, hi + 1, 1;\n    }\n  }\n  DistinctCounts(a, lo, |a|, k, K);\n}\n\n// ----------------------------------------\n\nmethod SearchForWinner<Candidate(==)>(a: seq<Candidate>,\n                                      ghost hasWinner: bool,\n                                      ghost K: Candidate)\n    returns (k: Candidate)\n  requires |a| != 0\n  requires hasWinner ==> HasMajority(a, 0, |a|, K)\n  ensures hasWinner ==> k == K\n{\n  k := a[0];\n  var lo, hi, c := 0, 1, 1;\n  while hi < |a|\n    invariant 0 <= lo <= hi <= |a|\n    invariant c == Count(a, lo, hi, k)\n    invariant HasMajority(a, lo, hi, k)\n    invariant hasWinner ==> HasMajority(a, lo, |a|, K)\n  {\n    if a[hi] == k {\n      hi, c := hi + 1, c + 1;\n    } else if hi + 1 - lo < 2 * c {\n      hi := hi + 1;\n    } else {\n      hi := hi + 1;\n      DistinctCounts(a, lo, hi, k, K);\n      SplitCount(a, lo, hi, |a|, K);\n      if hi == |a| {\n        return;\n      }\n      k, lo, hi, c := a[hi], hi, hi + 1, 1;\n    }\n  }\n  DistinctCounts(a, lo, |a|, k, K);\n}\n\n// ----------------------------------------\n\ndatatype Result<Candidate> = NoWinner | Winner(Candidate)\n\n// Note, method \"DetermineElection\" is slightly different here than\n// in Section 13.7.5 of the book (pages 317 and 318). The difference\n// comes about from a necessary change in the Dafny verifier that\n// took place after the book had gone into production. It now takes\n// more work to convince the verifier that \"DetermineElection\" returns\n// \"NoWinner\" under the right circumstances.\n//\n// There are several ways to convince the verifier of the method's\n// correctness. The solution that's easiest to understand is to add\n// a call to a new lemma, \"MajorityIsAmongTheVotes(a)\", which says:\n//\n//     If the votes in a sequence \"a\" contain a majority winner,\n//     then that winner is among the votes in \"a\".\n//\n// The lemma seems obvious, but needs to be given to the verifier.\n//\n// In more detail, the delicate part of the situation is that, if\n// the type parameter \"Candidate\" stands for some kind of reference\n// type (like the \"class\" types that are used in Chapters 16 and 17),\n// then what if there's no winner at the time \"SearchForWinner\" is\n// called, but then \"SearchForWinner\" allocates a new \"Candidate\"\n// object that turns out to be a majority winner? This situation\n// cannot arise, because any majority winner must already be in the\n// sequence given to \"SearchForWinner\". But the verifier does not\n// figure that out by itself.\n//\n// A moral of the story is that it's often not a good idea to, as\n// I had done, quantify over all values of a given type. A more\n// advisable approach is to give \"SearchForWinner\" a set \"S\" of\n// candidates (say, a set of registered candidates of the election),\n// require that all candidates in \"a\" are drawn from the set \"S\",\n// and to restrict the quantifications such that they range only\n// over candidates in \"S\".\n\nmethod DetermineElection<Candidate(==)>(a: seq<Candidate>)\n    returns (result: Result<Candidate>)\n  ensures match result\n    case Winner(c) => HasMajority(a, 0, |a|, c)\n    case NoWinner => !exists c :: HasMajority(a, 0, |a|, c)\n{\n  if |a| == 0 {\n    return NoWinner;\n  }\n\n  ghost var hasWinner := exists c :: HasMajority(a, 0, |a|, c);\n  ghost var w;\n  if hasWinner {\n    w :| HasMajority(a, 0, |a|, w);\n  } else {\n    w := a[0];\n  }\n  var c := SearchForWinner(a, hasWinner, w);\n  MajorityIsAmongTheVotes(a); // this lemma call was not in the book (see comment above)\n  return if HasMajority(a, 0, |a|, c) then\n      Winner(c)\n    else\n      NoWinner;\n}\n\n// The following two lemmas were not used in the book.\n\nlemma MajorityIsAmongTheVotes<Candidate>(a: seq<Candidate>)\n  ensures forall c :: HasMajority(a, 0, |a|, c) ==> c in a;\n{\n  // The \"forall\" statement on the following line is a variation of\n  // the aggregate statement that is used in Chapters 14 and 15.\n  // Here, it corresponds to the \"universal introduction\" rule in logi.\n  // For details, see the Dafny reference manual.\n  forall c | Count(a, 0, |a|, c) != 0\n    ensures c in a\n  {\n    NonemptyCount(a, 0, |a|, c);\n  }\n}\n\nlemma NonemptyCount<T>(a: seq<T>, lo: int, hi: int, x: T)\n  requires 0 <= lo <= hi <= |a|\n  requires Count(a, lo, hi, x) != 0\n  ensures x in a\n{\n  // proved by automatic induction\n}\n\n// There are other ways to solve the problem. Since the problem only\n// occurs when type parameter \"Candidate\" can stand for some kind of\n// reference type, another solution is to restrict the type parameters\n// to non-reference types. This is done by adding the \"(!new)\" type\n// characteristic, as the following method does:\n\nmethod DetermineElection'<Candidate(==,!new)>(a: seq<Candidate>)\n    returns (result: Result<Candidate>)\n  ensures match result\n    case Winner(c) => HasMajority(a, 0, |a|, c)\n    case NoWinner => !exists c :: HasMajority(a, 0, |a|, c)\n{\n  if |a| == 0 {\n    return NoWinner;\n  }\n\n  ghost var hasWinner := exists c :: HasMajority(a, 0, |a|, c);\n  ghost var w;\n  if hasWinner {\n    w :| HasMajority(a, 0, |a|, w);\n  } else {\n    w := a[0];\n  }\n  var c := SearchForWinner(a, hasWinner, w);\n  return if HasMajority(a, 0, |a|, c) then\n      Winner(c)\n    else\n      NoWinner;\n}\n"}
{"file": "../program-proofs-code/ch13/13.4-CoincidenceCount-a.dfy", "dafny": "method CoincidenceCount(a: array<int>, b: array<int>) returns (c: nat)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i, j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures c == |multiset(a[..]) * multiset(b[..])|\n{\n  c := 0;\n  var m, n := 0, 0;\n  while m < a.Length && n < b.Length\n    invariant 0 <= m <= a.Length && 0 <= n <= b.Length\n    invariant c + |multiset(a[m..]) * multiset(b[n..])| // unable to prove this invariant is maintained by the loop\n           == |multiset(a[..]) * multiset(b[..])|\n    decreases a.Length - m + b.Length - n\n  {\n    if\n    case a[m] == b[n] =>\n      c, m, n := c + 1, m + 1, n + 1;\n    case a[m] < b[n] =>\n      m := m + 1;\n    case b[n] < a[m] =>\n      n := n + 1;\n  }\n}\n"}
{"file": "../program-proofs-code/ch13/13.4-CoincidenceCount-e.dfy", "dafny": "method CoincidenceCount_Debug4(a: array<int>, b: array<int>) returns (c: nat)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i, j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures c == |multiset(a[..]) * multiset(b[..])|\n{\n  c := 0;\n  var m, n := 0, 0;\n  while m < a.Length && n < b.Length\n    invariant 0 <= m <= a.Length && 0 <= n <= b.Length\n    invariant c + |multiset(a[m..]) * multiset(b[n..])|\n           == |multiset(a[..]) * multiset(b[..])|\n    decreases a.Length - m + b.Length - n\n  {\n    if\n    case a[m] == b[n] =>\n      MultisetIntersectionPrefix(a, b, m, n);\n      c, m, n := c + 1, m + 1, n + 1;\n    case a[m] < b[n] =>\n      MultisetIntersectionAdvance(a, m, multiset(b[n..]));\n      m := m + 1;\n    case b[n] < a[m] =>\n      n := n + 1;\n      assert c + |multiset(a[m..]) * multiset(b[n..])| // unable to prove this assertion\n          == |multiset(a[..]) * multiset(b[..])|;\n  }\n}\n\nlemma MultisetIntersectionPrefix(a: array<int>, b: array<int>,\n                                 m: nat, n: nat)\n  requires m < a.Length && n < b.Length\n  requires a[m] == b[n]\n  ensures multiset(a[m..]) * multiset(b[n..])\n       == multiset{a[m]} + (multiset(a[m+1..]) * multiset(b[n+1..]))\n{\n  var E := multiset{a[m]};\n  calc {\n    multiset(a[m..]) * multiset(b[n..]);\n    multiset(a[m..]) * multiset(b[n..]);\n  ==  { assert a[m..] == [a[m]] + a[m+1..]\n            && b[n..] == [b[n]] + b[n+1..]; }\n    (E + multiset(a[m+1..])) * (E + multiset(b[n+1..]));\n  ==  // distribute * over +\n    E + (multiset(a[m+1..]) * multiset(b[n+1..]));\n  }\n}\n\nlemma MultisetIntersectionAdvance(a: array<int>, m: nat,\n                                  B: multiset<int>)\n  requires m < a.Length && a[m] !in B\n  ensures multiset(a[m..]) * B == multiset(a[m+1..]) * B\n{\n  var E := multiset{a[m]};\n  calc {\n    multiset(a[m..]) * B;\n  ==  { assert a[m..] == [a[m]] + a[m+1..]; }\n    (E + multiset(a[m+1..])) * B;\n  ==  // distribute * over +\n    (E * B) + (multiset(a[m+1..]) * B);\n  ==  { assert E * B == multiset{}; }\n    multiset(a[m+1..]) * B;\n  }\n}\n"}
{"file": "../program-proofs-code/ch13/13.6-CanyonSearch.dfy", "dafny": "function Dist(x: int, y: int): nat {\n  if x < y then y - x else x - y\n}\n\nmethod CanyonSearch(a: array<int>, b: array<int>) returns (d: nat)\n  requires a.Length != 0 && b.Length != 0\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i, j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures exists i, j ::\n    0 <= i < a.Length && 0 <= j < b.Length && d == Dist(a[i], b[j])\n  ensures\n    forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==>\n      d <= Dist(a[i], b[j])\n{\n  d := Dist(a[0], b[0]);\n  var m, n := 0, 0;\n  while m < a.Length && n < b.Length\n    invariant 0 <= m <= a.Length && 0 <= n <= b.Length\n    invariant exists i, j ::\n      0 <= i < a.Length && 0 <= j < b.Length &&\n        d == Dist(a[i], b[j])\n    invariant forall i, j ::\n      0 <= i < a.Length && 0 <= j < b.Length ==>\n        d <= Dist(a[i], b[j]) || (m <= i && n <= j)\n    decreases a.Length - m + b.Length - n\n  {\n    d := if Dist(b[n], a[m]) < d then Dist(b[n], a[m]) else d;\n    if\n    case a[m] <= b[n] =>\n      m := m + 1;\n    case b[n] <= a[m] =>\n      n := n + 1;\n  }\n}\n\nmethod CanyonSearch_Optimized(a: array<int>, b: array<int>) returns (d: nat)\n  requires a.Length != 0 && b.Length != 0\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i, j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures exists i, j ::\n    0 <= i < a.Length && 0 <= j < b.Length && d == Dist(a[i], b[j])\n  ensures\n    forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==>\n      d <= Dist(a[i], b[j])\n{\n  d := Dist(a[0], b[0]);\n  var m, n := 0, 0;\n  while m < a.Length && n < b.Length\n    invariant 0 <= m <= a.Length && 0 <= n <= b.Length\n    invariant exists i, j ::\n      0 <= i < a.Length && 0 <= j < b.Length &&\n        d == Dist(a[i], b[j])\n    invariant forall i, j ::\n      0 <= i < a.Length && 0 <= j < b.Length ==>\n        d <= Dist(a[i], b[j]) || (m <= i && n <= j)\n    decreases a.Length - m + b.Length - n\n  {\n    d := if Dist(b[n], a[m]) < d then Dist(b[n], a[m]) else d;\n    if\n    case a[m] == b[n] =>\n      return 0;\n    case a[m] < b[n] =>\n      m := m + 1;\n    case b[n] < a[m] =>\n      n := n + 1;\n  }\n}\n"}
{"file": "../program-proofs-code/ch13/13.4-CoincidenceCount-b.dfy", "dafny": "method CoincidenceCount(a: array<int>, b: array<int>) returns (c: nat)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i, j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures c == |multiset(a[..]) * multiset(b[..])|\n{\n  c := 0;\n  var m, n := 0, 0;\n  while m < a.Length && n < b.Length\n    invariant 0 <= m <= a.Length && 0 <= n <= b.Length\n    invariant c + |multiset(a[m..]) * multiset(b[n..])|\n           == |multiset(a[..]) * multiset(b[..])|\n    decreases a.Length - m + b.Length - n\n  {\n    if\n    case a[m] == b[n] =>\n      c, m, n := c + 1, m + 1, n + 1;\n      assert c + |multiset(a[m..]) * multiset(b[n..])| // unable to prove this assertion\n          == |multiset(a[..]) * multiset(b[..])|;\n    case a[m] < b[n] =>\n      m := m + 1;\n      assert c + |multiset(a[m..]) * multiset(b[n..])| // unable to prove this assertion\n          == |multiset(a[..]) * multiset(b[..])|;\n    case b[n] < a[m] =>\n      n := n + 1;\n      assert c + |multiset(a[m..]) * multiset(b[n..])| // unable to prove this assertion\n          == |multiset(a[..]) * multiset(b[..])|;\n  }\n}\n"}
{"file": "../program-proofs-code/ch13/13.0-Arrays.dfy", "dafny": "method IntroduceArrays() {\n  var a := new int[100];\n  assert a.Length == 100;\n  a := new int[20];\n\n  a[9] := a[9] + 5;\n\n  a[6] := 2;\n  a[7] := 3;\n  assert a[6] == 2 && a[7] == 3;\n}\n\nmethod TestArrayElements(j: nat, k: nat)\n  requires j < 10 && k < 10\n{\n  var a := new int[10];\n  a[j] := 60;\n  a[k] := 65;\n  if j == k {\n    assert a[j] == 65;\n  } else {\n    assert a[j] == 60;\n  }\n}\n\nmethod ArraysAreReferences() {\n  var a := new string[20];\n  a[7] := \"hello\";\n\n  var b := a;\n  assert b[7] == \"hello\";\n\n  b[7] := \"hi\";\n  a[8] := \"greetings\";\n  assert a[7] == \"hi\" && b[8] == \"greetings\";\n\n  b := new string[8];\n  b[7] := \"long time, no see\";\n  assert a[7] == \"hi\";\n  assert a.Length == 20 && b.Length == 8;\n}\n\nmethod MultiDimensionalArrays() {\n  var m := new bool[3, 10];\n  m[0, 9] := true;\n  m[1, 8] := false;\n  assert m.Length0 == 3 && m.Length1 == 10;\n}\n\nmethod SequenceExamples() {\n  var greetings := [\"hey\", \"hola\", \"tjena\"];\n\n  assert [1, 5, 12] + [22, 35] == [1, 5, 12, 22, 35];\n\n  var p := [1, 5, 12, 22, 35];\n  assert p[2..4] == [12, 22];\n  assert p[..2] == [1, 5];\n  assert p[2..] == [12, 22, 35];\n\n  assert greetings[..1] == [\"hey\"];\n  assert greetings[1..2] == [\"hola\"];\n}\n\nmethod PerfectStart() {\n  var a := new int[3];\n  a[0], a[1], a[2] := 6, 28, 496;\n  assert a[..2] == [6, 28] && a[1..] == [28, 496];\n  var s := a[..];\n  assert s == [6, 28, 496];\n  a[0] := 8128;\n  assert s[0] == 6 && a[0] == 8128;\n}\n"}
{"file": "../program-proofs-code/ch13/13.5-SlopeSearch.dfy", "dafny": "method SlopeSearch(a: array2<int>, key: int) returns (m: int, n: int)\n  requires forall i, j, j' ::\n    0 <= i < a.Length0 && 0 <= j < j' < a.Length1 ==>\n      a[i,j] <= a[i,j']\n  requires forall i, i', j ::\n    0 <= i < i' < a.Length0 && 0 <= j < a.Length1 ==>\n      a[i,j] <= a[i',j]\n  requires exists i, j ::\n    0 <= i < a.Length0 && 0 <= j < a.Length1 && a[i,j] == key\n  ensures 0 <= m < a.Length0 && 0 <= n < a.Length1\n  ensures a[m,n] == key\n{\n  m, n := 0, a.Length1 - 1;\n  while a[m,n] != key\n    invariant 0 <= m < a.Length0 && 0 <= n < a.Length1\n    invariant exists i, j ::\n      m <= i < a.Length0 && 0 <= j <= n && a[i,j] == key\n    decreases a.Length0 - m + n\n  {\n    if a[m,n] < key {\n      m := m + 1;\n    } else {\n      n := n - 1;\n    }\n  }\n}\n"}
{"file": "../program-proofs-code/ch13/13.4-CoincidenceCount-d.dfy", "dafny": "method CoincidenceCount(a: array<int>, b: array<int>) returns (c: nat)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  requires forall i, j :: 0 <= i < j < b.Length ==> b[i] <= b[j]\n  ensures c == |multiset(a[..]) * multiset(b[..])|\n{\n  c := 0;\n  var m, n := 0, 0;\n  while m < a.Length && n < b.Length\n    invariant 0 <= m <= a.Length && 0 <= n <= b.Length\n    invariant c + |multiset(a[m..]) * multiset(b[n..])|\n           == |multiset(a[..]) * multiset(b[..])|\n    decreases a.Length - m + b.Length - n\n  {\n    if\n    case a[m] == b[n] =>\n      MultisetIntersectionPrefix(a, b, m, n);\n      c, m, n := c + 1, m + 1, n + 1;\n    case a[m] < b[n] =>\n      m := m + 1;\n      assert c + |multiset(a[m..]) * multiset(b[n..])| // unable to prove this assertion\n          == |multiset(a[..]) * multiset(b[..])|;\n    case b[n] < a[m] =>\n      n := n + 1;\n      assert c + |multiset(a[m..]) * multiset(b[n..])| // unable to prove this assertion\n          == |multiset(a[..]) * multiset(b[..])|;\n  }\n}\n\nlemma MultisetIntersectionPrefix(a: array<int>, b: array<int>,\n                                 m: nat, n: nat)\n  requires m < a.Length && n < b.Length\n  requires a[m] == b[n]\n  ensures multiset(a[m..]) * multiset(b[n..])\n       == multiset{a[m]} + (multiset(a[m+1..]) * multiset(b[n+1..]))\n{\n  var E := multiset{a[m]};\n  calc {\n    multiset(a[m..]) * multiset(b[n..]);\n    multiset(a[m..]) * multiset(b[n..]);\n  ==  { assert a[m..] == [a[m]] + a[m+1..]\n            && b[n..] == [b[n]] + b[n+1..]; }\n    (E + multiset(a[m+1..])) * (E + multiset(b[n+1..]));\n  ==  // distribute * over +\n    E + (multiset(a[m+1..]) * multiset(b[n+1..]));\n  }\n}\n"}
{"file": "../program-proofs-code/ch12/12.3-Sums.dfy", "dafny": "function F(x: int): int\n\nghost function SumUp(lo: int, hi: int): int\n  requires lo <= hi\n  decreases hi - lo\n{\n  if lo == hi then 0 else F(lo) + SumUp(lo + 1, hi)\n}\n\nghost function SumDown(lo: int, hi: int): int\n  requires lo <= hi\n  decreases hi - lo\n{\n  if lo == hi then 0 else SumDown(lo, hi - 1) + F(hi - 1)\n}\n\nlemma SameSums(lo: int, hi: int)\n  requires lo <= hi\n  ensures SumUp(lo, hi) == SumDown(lo, hi)\n  decreases hi - lo\n{\n  if lo != hi {\n    PrependSumDown(lo, hi);\n  }\n}\n\nlemma PrependSumDown(lo: int, hi: int)\n  requires lo < hi\n  ensures F(lo) + SumDown(lo + 1, hi) == SumDown(lo, hi)\n  decreases hi - lo\n{\n}\n\nlemma {:induction false} AppendSumUp(lo: int, hi: int)\n  requires lo < hi\n  ensures SumUp(lo, hi - 1) + F(hi - 1) == SumUp(lo, hi)\n  decreases hi - lo\n{\n  if lo == hi - 1 {\n  } else {\n    AppendSumUp(lo + 1, hi);\n  }\n}\n\n// Loop Up\n\nmethod LoopUp0(lo: int, hi: int) returns (s: int)\n  requires lo <= hi\n  ensures s == SumUp(lo, hi)\n{\n  s := 0;\n  var i := lo;\n  while i != hi\n    invariant lo <= i <= hi\n    invariant s == SumUp(lo, i)\n  {\n    s := s + F(i);\n    i := i + 1;\n    AppendSumUp(lo, i);\n  }\n}\n\nmethod LoopUp1(lo: int, hi: int) returns (s: int)\n  requires lo <= hi\n  ensures s == SumDown(lo, hi)\n{\n  s := 0;\n  var i := lo;\n  while i != hi\n    invariant lo <= i <= hi\n    invariant s == SumDown(lo, i)\n  {\n    s := s + F(i);\n    i := i + 1;\n  }\n}\n\nmethod LoopUp2(lo: int, hi: int) returns (s: int)\n  requires lo <= hi\n  ensures s == SumUp(lo, hi)\n{\n  s := 0;\n  var i := lo;\n  while i != hi\n    invariant lo <= i <= hi\n    invariant s + SumUp(i, hi)\n           == SumUp(lo, hi)\n  {\n    s := s + F(i);\n    i := i + 1;\n  }\n}\n\n// Loop Down\n\nmethod LoopDown0(lo: int, hi: int) returns (s: int)\n  requires lo <= hi\n  ensures s == SumDown(lo, hi)\n{\n  s := 0;\n  var i := hi;\n  while i != lo\n    invariant lo <= i <= hi\n    invariant s == SumDown(i, hi)\n  {\n    i := i - 1;\n    s := s + F(i);\n    PrependSumDown(i, hi);\n  }\n}\n\nmethod LoopDown1(lo: int, hi: int) returns (s: int)\n  requires lo <= hi\n  ensures s == SumUp(lo, hi)\n{\n  s := 0;\n  var i := hi;\n  while i != lo\n    invariant lo <= i <= hi\n    invariant s == SumUp(i, hi)\n  {\n    i := i - 1;\n    s := s + F(i);\n  }\n}\n\nmethod LoopDown2(lo: int, hi: int) returns (s: int)\n  requires lo <= hi\n  ensures s == SumDown(lo, hi)\n{\n  s := 0;\n  var i := hi;\n  while i != lo\n    invariant lo <= i <= hi\n    invariant SumDown(lo, i) + s\n    == SumDown(lo, hi)\n  {\n    i := i - 1;\n    s := s + F(i);\n  }\n}\n"}
{"file": "../program-proofs-code/ch12/12.2-PowersOf2.dfy", "dafny": "ghost function Power(n: nat): nat {\n  if n == 0 then 1 else 2 * Power(n - 1)\n}\n\nmethod ComputePower(n: nat) returns (p: nat)\n  ensures p == Power(n)\n{\n  p := 1;\n  var i := 0;\n  while i != n\n    invariant 0 <= i <= n\n    invariant p == Power(i)\n  {\n    p := 2 * p;\n    i := i + 1;\n  }\n}\n\nmethod ComputePower'(n: nat) returns (p: nat)\n  ensures p == Power(n)\n{\n  p := 1;\n  var i := 0;\n  while i != n\n    invariant 0 <= i <= n\n    invariant p * Power(n - i) == Power(n)\n  {\n    p := 2 * p;\n    i := i + 1;\n  }\n}\n"}
{"file": "../program-proofs-code/ch12/12.0-Fib.dfy", "dafny": "function Fib(n: nat): nat {\n  if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n}\n\nmethod ComputeFib(n: nat) returns (x: nat)\n  ensures x == Fib(n)\n{\n  x := 0;\n  var y := 1;\n  var i := 0;\n  while i != n\n    invariant 0 <= i <= n\n    invariant x == Fib(i) && y == Fib(i + 1)\n  {\n    x, y := y, x + y;\n    i := i + 1;\n  }\n}\n\nmethod SquareFib(N: nat) returns (x: nat)\n  ensures x == Fib(N) * Fib(N)\n{\n  x := 0;\n  var n := 0;\n  while n != N\n    invariant 0 <= n <= N\n    invariant x == Fib(n) * Fib(n)\n}\n\nmethod SquareFib'y(N: nat) returns (x: nat)\n  ensures x == Fib(N) * Fib(N)\n{\n  x := 0;\n  var n, y := 0, 1;\n  while n != N\n    invariant 0 <= n <= N\n    invariant x == Fib(n) * Fib(n)\n    invariant y == Fib(n + 1) * Fib(n + 1)\n  {\n    calc {\n      Fib(n + 2) * Fib(n + 2);\n    ==  // def. Fib\n      (Fib(n) + Fib(n + 1)) * (Fib(n) + Fib(n + 1));\n    ==  // cross multiply\n      Fib(n) * Fib(n) + 2 * Fib(n) * Fib(n + 1) + Fib(n + 1) * Fib(n + 1);\n    ==  // invariant\n      x + 2 * Fib(n) * Fib(n + 1) + y;\n    }\n    x, y := y, Fib(n + 2) * Fib(n + 2);\n    n := n + 1;\n  }\n}\n\nmethod SquareFib'k(N: nat) returns (x: nat)\n  ensures x == Fib(N) * Fib(N)\n{\n  x := 0;\n  var n, y, k := 0, 1, 0;\n  while n != N\n    invariant 0 <= n <= N\n    invariant x == Fib(n) * Fib(n)\n    invariant y == Fib(n + 1) * Fib(n + 1)\n    invariant k == 2 * Fib(n) * Fib(n + 1)\n  {\n    calc {\n      2 * Fib(n + 1) * Fib(n + 2);\n    ==  // def. Fib\n      2 * Fib(n + 1) * (Fib(n) + Fib(n + 1));\n    ==  // distribute arithmetic\n      2 * Fib(n + 1) * Fib(n) + 2 * Fib(n + 1) * Fib(n + 1);\n    }\n    x, y, k := y, x + k + y, k + y + y;\n    n := n + 1;\n  }\n}\n\nmethod SquareFib'final(N: nat) returns (x: nat)\n  ensures x == Fib(N) * Fib(N)\n{\n  x := 0;\n  var n, y, k := 0, 1, 0;\n  while n != N\n    invariant 0 <= n <= N\n    invariant x == Fib(n) * Fib(n)\n    invariant y == Fib(n + 1) * Fib(n + 1)\n    invariant k == 2 * Fib(n) * Fib(n + 1)\n  {\n    x, y, k := y, x + k + y, k + y + y;\n    n := n + 1;\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5.6-Mult.dfy", "dafny": "function Mult(x: nat, y: nat): nat {\n  if y == 0 then 0 else x + Mult(x, y - 1)\n}\n\nlemma {:induction false} MultCommutative(x: nat, y: nat)\n  ensures Mult(x, y) == Mult(y, x)\n{\n  if x == y {\n  } else if x == 0 {\n    MultCommutative(x, y - 1);\n  } else if y < x {\n    MultCommutative(y, x);\n  } else {\n    calc {\n      Mult(x, y);\n    ==  // def. Mult\n      x + Mult(x, y - 1);\n    ==  { MultCommutative(x, y - 1); }\n      x + Mult(y - 1, x);\n    ==  // def. Mult\n      x + y - 1 + Mult(y - 1, x - 1);\n    ==  { MultCommutative(x - 1, y - 1); }\n      x + y - 1 + Mult(x - 1, y - 1);\n    ==  // def. Mult\n      y + Mult(x - 1, y);\n    ==  { MultCommutative(x - 1, y); }\n      y + Mult(y, x - 1);\n    ==  // def. Mult\n      Mult(y, x);\n    }\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing-Proof0.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma Increasing(x: int)\n  ensures x < More(x)\n{\n  // proof is automatic by Dafny's automatic induction\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing-Proof6.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    // let's get ridiculously detailed, to illustrate what you can do\n    calc {\n      x;\n    <=  { assert x <= 0; }\n      0;\n    <  // arithmetic\n      1;\n    ==  // def. More\n      More(x);\n    }\n  } else {\n    // here's a nice calculation\n    calc {\n      More(x);\n    ==  // def. More, since 0 < x\n      More(x - 2) + 3;\n    >  { Increasing(x - 2); }\n      x - 2 + 3;\n    >  // arithmetic\n      x;\n    }\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5.5-Reduce.dfy", "dafny": "function Reduce(m: nat, x: int): int {\n  if m == 0 then x else Reduce(m / 2, x + 1) - m\n}\n\n\nlemma {:induction false} ReduceUpperBound(m: nat, x: int)\n  ensures Reduce(m, x) <= x\n{\n  if m == 0 {\n    // trivial\n  } else {\n    calc {\n      Reduce(m, x);\n    ==  // def. Reduce\n      Reduce(m / 2, x + 1) - m;\n    <=  { ReduceUpperBound(m / 2, x + 1);\n          assert Reduce(m / 2, x + 1) <= x + 1; }\n      x + 1 - m;\n    <=  { assert 0 < m; }\n      x;\n    }\n  }\n}\n\nlemma {:induction false} ReduceLowerBound(m: nat, x: int)\n  ensures x - 2 * m <= Reduce(m, x)\n{\n  if m == 0 {\n  } else {\n    calc {\n      Reduce(m, x);\n    ==  // def. Reduce\n      Reduce(m / 2, x + 1) - m;\n    >=  { ReduceLowerBound(m / 2, x + 1);\n          assert x + 1 - 2 * (m / 2) <= Reduce(m / 2, x + 1); }\n      x + 1 - 2 * (m / 2) - m;\n    >=  { assert 2 * (m / 2) <= m; }\n      x + 1 - m - m;\n    >  // reduce it further by 1\n      x - 2 * m;\n    }\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing-Proof4.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    assert More(x) == 1; // def. More for x <= 0\n  } else {\n    assert More(x) == More(x - 2) + 3; // def. More for 0 < x\n    Increasing(x - 2); // induction hypothesis\n    assert More(x) == More(x - 2) + 3 &&\n           x - 2 < More(x - 2);\n    assert More(x) == More(x - 2) + 3 &&\n           x + 1 < More(x - 2) + 3;\n    assert x + 1 < More(x);\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5.8-AST.dfy", "dafny": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\ndatatype Op = Add | Mul\ndatatype Expr = Const(nat)\n              | Var(string)\n              | Node(op: Op, args: List<Expr>)\n\nfunction Eval(e: Expr, env: map<string, nat>): nat {\n  match e\n  case Const(c) => c\n  case Var(s) => if s in env.Keys then env[s] else 0\n  case Node(op, args) => EvalList(args, op, env)\n}\n\nfunction EvalList(args: List<Expr>, op: Op,\n                  env: map<string, nat>): nat\n{\n  match args\n  case Nil =>\n    (match op case Add => 0 case Mul => 1)\n  case Cons(e, tail) =>\n    var v0, v1 := Eval(e, env), EvalList(tail, op, env);\n    match op\n    case Add => v0 + v1\n    case Mul => v0 * v1\n}\n\nfunction Substitute(e: Expr, n: string, c: nat): Expr\n{\n  match e\n  case Const(_) => e\n  case Var(s) => if s == n then Const(c) else e\n  case Node(op, args) => Node(op, SubstituteList(args, n, c))\n}\n\nfunction SubstituteList(es: List<Expr>, n: string, c: nat): List<Expr>\n{\n  match es\n  case Nil => Nil\n  case Cons(e, tail) =>\n    Cons(Substitute(e, n, c), SubstituteList(tail, n, c))\n}\n\nlemma EvalSubstitute(e: Expr, n: string, c: nat, env: map<string, nat>)\n  ensures Eval(Substitute(e, n, c), env) == Eval(e, env[n := c])\n{\n  match e\n  case Const(_) =>\n  case Var(_) =>\n  case Node(op, args) =>\n    EvalSubstituteList(args, op, n, c, env);\n}\n\nlemma {:induction false} EvalSubstituteList(\n    args: List<Expr>, op: Op, n: string, c: nat, env: map<string, nat>)\n  ensures EvalList(SubstituteList(args, n, c), op, env)\n       == EvalList(args, op, env[n := c])\n{\n  match args\n  case Nil =>\n  case Cons(e, tail) =>\n    EvalSubstitute(e, n, c, env);\n    EvalSubstituteList(tail, op, n, c, env);\n}\n\nfunction Unit(op: Op): nat {\n  match op case Add => 0 case Mul => 1\n}\n\nfunction Optimize(e: Expr): Expr {\n  if e.Node? then\n    var args := OptimizeAndFilter(e.args, Unit(e.op));\n    Shorten(e.op, args)\n  else\n    e // no change\n}\n\nfunction Shorten(op: Op, args: List<Expr>): Expr {\n  match args\n  case Nil => Const(Unit(op))\n  case Cons(e, Nil) => e\n  case _ => Node(op, args)\n}\n\nfunction OptimizeAndFilter(es: List<Expr>, unit: nat): List<Expr>\n{\n  match es\n  case Nil => Nil\n  case Cons(e, tail) =>\n    var e', tail' := Optimize(e), OptimizeAndFilter(tail, unit);\n    if e' == Const(unit) then tail' else Cons(e', tail')\n}\n\nlemma OptimizeCorrect(e: Expr, env: map<string, nat>)\n  ensures Eval(Optimize(e), env) == Eval(e, env) \n{\n  if e.Node? {\n    var args := OptimizeAndFilter(e.args, Unit(e.op));\n    calc {\n      Eval(Optimize(e), env);\n    ==  // def. Optimize\n      Eval(Shorten(e.op, args), env);\n    ==  { ShortenCorrect(e.op, args, env); }\n      Eval(Node(e.op, args), env);\n    ==  { OptimizeAndFilterCorrect(e.args, e.op, env); }\n      Eval(Node(e.op, e.args), env);\n    }\n  }\n}\n\nlemma ShortenCorrect(op: Op, args: List<Expr>, env: map<string, nat>)\n  ensures Eval(Shorten(op, args), env) == Eval(Node(op, args), env) \n{\n  match args\n  case Nil =>\n  case Cons(a, Nil) =>\n    calc {\n      Eval(Node(op, Cons(a, Nil)), env);\n    ==  // def. Eval\n      EvalList(Cons(a, Nil), op, env);\n    ==  // def. EvalList\n      var v0, v1 := Eval(a, env), EvalList(Nil, op, env);\n      match op\n      case Add => v0 + v1\n      case Mul => v0 * v1;\n    ==  // def. EvalList\n      var v0, v1 := Eval(a, env), Unit(op);\n      match op\n      case Add => v0 + v1\n      case Mul => v0 * v1;\n    ==  // substitute for v0, v1\n      match op\n      case Add => Eval(a, env) + Unit(op)\n      case Mul => Eval(a, env) * Unit(op);\n    ==  // def. Unit in each case\n      Eval(a, env);\n    }\n  case _ =>\n}\n\nlemma OptimizeAndFilterCorrect(args: List<Expr>, op: Op,\n                               env: map<string, nat>)\n  ensures Eval(Node(op, OptimizeAndFilter(args, Unit(op))), env)\n       == Eval(Node(op, args), env) \n{\n  match args\n  case Nil =>\n  case Cons(e, tail) =>\n    OptimizeCorrect(e, env);\n    OptimizeAndFilterCorrect(tail, op, env);\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing-Proof2.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if 0 < x {\n    var y := x - 2;\n    Increasing(y);\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma Increasing(x: int)\n  ensures x < More(x)\n// proof omitted here, but see separate files\n\nmethod ExampleLemmaUse(a: int)\n{\n  var b := More(a);\n  Increasing(a);\n  Increasing(b);\n  var c := More(b);\n  assert 2 <= c - a;\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing-Proof9.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    // let's get ridiculously detailed, to illustrate what you can do\n    calc {\n      x;\n    <=  { assert x <= 0; }\n      0;\n    <  // arithmetic\n      1;\n    ==  // def. More\n      More(x);\n    }\n  } else {\n    calc {\n      x < More(x);\n    ==  // def. More, since 0 < x\n      x < More(x - 2) + 3;\n    ==  // subtract 3 from each side, to get More(x-2) alone on the right\n      x - 3 < More(x - 2);\n    <==  // arithmetic\n      x - 2 < More(x - 2);\n    <==  { Increasing(x - 2); }\n      true;\n    }\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing-Proof5.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    assert More(x) == 1; // def. More for x <= 0\n  } else {\n    assert More(x) == More(x - 2) + 3; // def. More for 0 < x\n    Increasing(x - 2); // induction hypothesis\n    assert x - 2 < More(x - 2); // what we get from the recursive call\n    assert x + 1 < More(x - 2) + 3; // add 3 to each side\n    assert x + 1 < More(x); // previous line and def. More above\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5.4-Calc.dfy", "dafny": "method CalcExample0(x: int) {\n  calc {\n    5 * (x + 3);\n  ==  // distribute multiplication over addition\n    5 * x + 5 * 3;\n  ==  // use the arithmetic fact that 5 * 3 == 15\n    5 * x + 15;\n  }\n}\n\nmethod CalcExample1(x: int, y: int) {\n  calc {\n    (x + y) * (x - y);\n  ==  // distribute * over + and - (i.e., cross multiply)\n    x*x - x*y + y*x - y*y;\n  ==  // * is commutative: y*x == x*y\n    x*x - x*y + x*y - y*y;\n  ==  // the terms - x*y and + x*y cancel\n    x*x - y*y;\n  }\n}\n\nmethod CalcExample2(x: int, n: nat) {\n  calc {\n    3*x + n + n;\n  ==  // n + n == 2*n\n    3*x + 2*n;\n  <=  // 2*n <= 3*n, since 0 <= n\n    3*x + 3*n;\n  ==  // distribute * over +\n    3 * (x + n);\n  }\n}\n\n// Shorter forms\n\nmethod CalcExample0a(x: int, n: nat) {\n  calc {\n    5 * (x + 3);\n    5 * x + 5 * 3;\n    5 * x + 15;\n  }\n}\n\nmethod CalcExample2a(x: int, n: nat) {\n  calc {\n    3*x + n + n;\n    3*x + 2*n;\n  <=\n    3*x + 3*n;\n    3*(x + n);\n  }\n}\n\nmethod CalcExample2b(x: int, n: nat) {\n  calc <= { // set default operator to be <=\n    3*x + n + n;\n  ==\n    3*x + 2*n;\n    3*x + 3*n;\n  ==\n    3*(x + n);\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5.7-Mirror.dfy", "dafny": "datatype Tree<T> = Leaf(data: T)\n                 | Node(left: Tree<T>, right: Tree<T>)\n\nfunction Mirror<T>(t: Tree<T>): Tree<T> {\n  match t\n  case Leaf(_) => t\n  case Node(left, right) => Node(Mirror(right), Mirror(left))\n}\n\nlemma {:induction false} MirrorMirror<T>(t: Tree<T>)\n  ensures Mirror(Mirror(t)) == t\n{\n  match t\n  case Leaf(_) =>\n    // trivial\n  case Node(left, right) =>\n    calc {\n      Mirror(Mirror(Node(left, right)));\n    ==  // def. Mirror (inner)\n      Mirror(Node(Mirror(right), Mirror(left)));\n    ==  // def. Mirror (outer)\n      Node(Mirror(Mirror(left)), Mirror(Mirror(right)));\n    ==  { MirrorMirror(left); MirrorMirror(right); } // I.H.\n      Node(left, right);\n    }\n}\n\nfunction Size<T>(t: Tree<T>): nat {\n  match t\n  case Leaf(_) => 1\n  case Node(left, right) => Size(left) + Size(right)\n}\n\nlemma {:induction false} MirrorSize<T>(t: Tree<T>)\n  ensures Size(Mirror(t)) == Size(t)\n{\n  match t\n  case Leaf(_) =>\n  case Node(left, right) =>\n    calc {\n      Size(Mirror(Node(left, right)));\n    ==  // def. Mirror\n      Size(Node(Mirror(right), Mirror(left)));\n    ==  // def. Size\n      Size(Mirror(right)) + Size(Mirror(left));\n    ==  { MirrorSize(right); MirrorSize(left); } // I.H.\n      Size(right) + Size(left);\n    ==  // def. Size\n      Size(Node(left, right));\n    }\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing-Proof7.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    // let's get ridiculously detailed, to illustrate what you can do\n    calc {\n      x;\n    <=  { assert x <= 0; }\n      0;\n    <  // arithmetic\n      1;\n    ==  // def. More\n      More(x);\n    }\n  } else {\n    calc {\n      true;\n    ==>  { Increasing(x - 2); }\n      x - 2 < More(x - 2);\n    ==  // add 3 to each side\n      x + 1 < More(x - 2) + 3;\n    ==  // def. More, since 0 < x\n      x + 1 < More(x);\n    ==>  // arithmetic\n      x < More(x);\n    }\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing-Proof3.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  assert true;\n  if x <= 0 {\n    assert x <= 0;\n    assert x <= 0 && More(x) == 1; // def. More for x <= 0\n    assert x < More(x);\n  } else {\n    assert 0 < x;\n    assert 0 < x && More(x) == More(x - 2) + 3; // def. More for 0 < x\n    Increasing(x - 2); // induction hypothesis\n    assert 0 < x && More(x) == More(x - 2) + 3 &&\n           x - 2 < More(x - 2);\n    assert More(x) == More(x - 2) + 3 &&\n           x + 1 < More(x - 2) + 3;\n    assert x + 1 < More(x);\n    assert x < More(x);\n  }\n  assert x < More(x);\n}\n"}
{"file": "../program-proofs-code/ch5/5.4.0-Ack.dfy", "dafny": "function Ack(m: nat, n: nat): nat\n  decreases m, n\n{\n  if m == 0 then\n    n + 1\n  else if n == 0 then\n    Ack(m - 1, 1)\n  else\n    Ack(m - 1, Ack(m, n - 1))\n}\n\nlemma Ack1(n: nat)\n  ensures Ack(1, n) == n + 2\n{\n  if n == 0 {\n    // trivial\n  } else {\n    calc {\n      Ack(1, n);\n    ==  // def. Ack\n      Ack(0, Ack(1, n - 1));\n    ==  // def. Ack(0, _)\n      Ack(1, n - 1) + 1;\n    ==  { Ack1(n - 1); } // induction hypothesis\n      (n - 1) + 2 + 1;\n    ==  // arithmetic\n      n + 2;\n    }\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing-Proof1.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n  } else {\n    Increasing(x-2); // this call gives us: x-2 < More(x-2)\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5-Increasing-Proof8.dfy", "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\n\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    // let's get ridiculously detailed, to illustrate what you can do\n    calc {\n      x;\n    <=  { assert x <= 0; }\n      0;\n    <  // arithmetic\n      1;\n    ==  // def. More\n      More(x);\n    }\n  } else {\n    calc {\n      x < More(x);\n    <==  // arithmetic\n      x + 1 < More(x);\n    ==  // def. More, since 0 < x\n      x + 1 < More(x - 2) + 3;\n    ==  // subtract 3 from each side\n      x - 2 < More(x - 2);\n    <==  { Increasing(x - 2); }\n      true;\n    }\n  }\n}\n"}
{"file": "../program-proofs-code/ch5/5.8.0-EvalSubstituteList.dfy", "dafny": "// This file contains a more detailed proof of EvalSubstituteList\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\ndatatype Op = Add | Mul\ndatatype Expr = Const(nat)\n              | Var(string)\n              | Node(op: Op, args: List<Expr>)\n\nfunction Eval(e: Expr, env: map<string, nat>): nat {\n  match e\n  case Const(c) => c\n  case Var(s) => if s in env.Keys then env[s] else 0\n  case Node(op, args) => EvalList(args, op, env)\n}\n\nfunction EvalList(args: List<Expr>, op: Op,\n                  env: map<string, nat>): nat\n{\n  match args\n  case Nil =>\n    (match op case Add => 0 case Mul => 1)\n  case Cons(e, tail) =>\n    var v0, v1 := Eval(e, env), EvalList(tail, op, env);\n    match op\n    case Add => v0 + v1\n    case Mul => v0 * v1\n}\n\nfunction Substitute(e: Expr, n: string, c: nat): Expr\n{\n  match e\n  case Const(_) => e\n  case Var(s) => if s == n then Const(c) else e\n  case Node(op, args) => Node(op, SubstituteList(args, n, c))\n}\n\nfunction SubstituteList(es: List<Expr>, n: string, c: nat): List<Expr>\n{\n  match es\n  case Nil => Nil\n  case Cons(e, tail) =>\n    Cons(Substitute(e, n, c), SubstituteList(tail, n, c))\n}\n\nlemma EvalSubstitute(e: Expr, n: string, c: nat, env: map<string, nat>)\n  ensures Eval(Substitute(e, n, c), env) == Eval(e, env[n := c])\n{\n  match e\n  case Const(_) =>\n  case Var(_) =>\n  case Node(op, args) =>\n    EvalSubstituteList(args, op, n, c, env);\n}\n\nlemma {:induction false} EvalSubstituteList(\n    args: List<Expr>, op: Op, n: string, c: nat, env: map<string, nat>)\n  ensures EvalList(SubstituteList(args, n, c), op, env)\n       == EvalList(args, op, env[n := c])\n{\n  match args\n  case Nil =>\n  case Cons(e, tail) =>\n    calc {\n      EvalList(SubstituteList(args, n, c), op, env);\n    ==  // args == Cons(e, tail)\n      EvalList(SubstituteList(Cons(e, tail), n, c), op, env);\n    ==  // def. SubstituteList\n      EvalList(Cons(Substitute(e, n, c),\n               SubstituteList(tail, n, c)), op, env);\n    ==  // def. EvalList\n      var v0, v1 :=\n        Eval(Substitute(e, n, c), env),\n        EvalList(SubstituteList(tail, n, c), op, env);\n      match op\n      case Add => v0 + v1\n      case Mul => v0 * v1;\n    ==  { EvalSubstitute(e, n, c, env); }\n      var v0, v1 :=\n        Eval(e, env[n := c]),\n        EvalList(SubstituteList(tail, n, c), op, env);\n      match op\n      case Add => v0 + v1\n      case Mul => v0 * v1;\n    ==  { EvalSubstituteList(tail, op, n, c, env); }\n      var v0, v1 :=\n        Eval(e, env[n := c]),\n        EvalList(tail, op, env[n := c]);\n      match op\n      case Add => v0 + v1\n      case Mul => v0 * v1;\n    ==  // def. EvalList\n      EvalList(Cons(e, tail), op, env[n := c]);\n    ==  // args == Cons(e, tail)\n      EvalList(args, op, env[n := c]);\n    }\n}\n"}
{"file": "../dafny/Test/separate-verification/Inputs/wrappers.dfy", "dafny": "module Wrappers {\n  datatype Option<T> = Some(value: T) | None {\n    function UnwrapOr(default: T): T {\n      match this\n      case Some(v) => v\n      case None() => default\n    }\n  }\n}"}
{"file": "../dafny/Test/verification/relaxAssignmentEnforceDeterminism.dfy", "dafny": "// RUN: ! %baredafny build %args --relax-definite-assignment --enforce-determinism \"%s\" 2> \"%t\"\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK: The option relax-definite-assignment can not be used in conjunction with enforce-determinism.\n\nmethod Foo() {\n}\n"}
{"file": "../dafny/Test/Landin/Knot5.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\ndatatype Pack<T> = Pack(ghost c: T)\n\nclass Y {\n  const f: Pack<Y -> nat>\n  constructor(f: Pack<Y -> nat>)\n    ensures this.f == f\n  {\n    this.f := f;\n  }\n}\n\nmethod Main()\n  ensures false\n{\n  // error: x.f.c calls itself without decreasing\n  var knot := new Y(Pack((x: Y) => 1 + x.f.c(x)));\n  var a := knot.f.c(knot);\n}"}
{"file": "../dafny/Test/Landin/Knot16.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\ntrait YT {\n  const f: Y -> nat\n}\n\nclass Y extends YT {\n  constructor(f: YT -> nat)\n    ensures this.f == f\n  {\n    this.f := f;\n  }\n}\n\nmethod Main()\n  ensures false\n{\n  // error: knot.f calls itself without decreasing\n  var knot := new Y((x: YT) => if x is Y then 1 + x.f(x as Y) else 0);\n  var a := knot.f(knot);\n}"}
{"file": "../dafny/Test/Landin/Knot11.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\ndatatype Pack<T> = Pack(ghost c: T)\n\nclass Ref {\n  ghost var hogp: Pack<() ~> int>\n}\n\nmethod Main()\n  ensures false\n{\n  var r := new Ref;\n  // error: r.hogp calls itself without decreasing\n  r.hogp := Pack(() reads r, r.hogp.c.reads() => if r.hogp.c.requires() then 1 + r.hogp.c() else 0);\n}"}
{"file": "../dafny/Test/Landin/Knot3.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\nclass C {\n\n  var f: () ~> bool\n\n  constructor()\n    ensures Invariant()\n  {\n    f := () requires true => true;\n  }\n\n  ghost predicate Invariant()\n    reads this, f.reads()\n  {\n    f.requires()\n  }\n\n}\n\nmethod update(t: C)\n  modifies t\n  requires t.Invariant()\n  ensures false\n{\n  // error: t.f calls itself without decreasing\n  t.f := () reads t, t.f.reads() requires t.f.requires() => !t.f();\n  assert t.f.requires() == old(t.f).requires();\n  var b := t.f();\n}\n\nmethod Main()\n{\n  var t := new C();\n  update(t);\n}"}
{"file": "../dafny/Test/Landin/Knot13.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\nclass Ref1 {\n  ghost var hogp: () ~> int\n}\n\nclass Ref2 {\n  ghost var r: Ref1\n  constructor()\n}\n\nmethod Main()\n  ensures false\n{\n  var r := new Ref2();\n  r.r := new Ref1;\n  // error: r.r.hogp calls itself without decreasing\n  r.r.hogp := () reads r, r.r, r.r.hogp.reads() => if r.r.hogp.requires() then 1 + r.r.hogp() else 0;\n}"}
{"file": "../dafny/Test/Landin/Knot2.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\nclass Ref {\n  ghost var hogp: () ~> int\n}\n\nmethod LogicKnot(r1: Ref,r2: Ref)\n  modifies r1, r2\n  ensures false\n{\n  // error: r1.hogp and r2.hogp call each others without decreasing\n  r1.hogp := () reads r2, r2.hogp.reads() => if r2.hogp.requires() then 1 + r2.hogp() else 0;\n  r2.hogp := () reads r1, r1.hogp.reads() => if r1.hogp.requires() then 1 + r1.hogp() else 0;\n}\n\nmethod Main()\n  ensures false\n{\n  var r1 := new Ref;\n  var r2 := new Ref;\n  LogicKnot(r1,r2);\n}"}
{"file": "../dafny/Test/Landin/Knot15.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\nclass Y {\n  const f: YWithConstraint -> nat\n  constructor(f: YWithConstraint -> nat)\n    ensures this.f == f\n  {\n    this.f := f;\n  }\n}\n\ntype YWithConstraint = y: Y | true witness *\n\nmethod Main()\n  ensures false\n{\n  // error: knot.f calls itself without decreasing\n  var knot := new Y((x: YWithConstraint) => 1 + x.f(x));\n  var a := knot.f(knot);\n}"}
{"file": "../dafny/Test/Landin/Knot1.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\nclass Ref {\n  ghost var hogp: () ~> int\n}\n\nmethod Main()\n  ensures false\n{\n  var r := new Ref;\n  // error: r.hogp calls itself without decreasing\n  r.hogp := () reads r, r.hogp.reads() => if r.hogp.requires() then 1 + r.hogp() else 0;\n}"}
{"file": "../dafny/Test/Landin/Knot9.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\ntrait T<U> {\n  const f: U -> nat // Type error here? because since Y can be accessed, -> should be ~>\n}\n\nclass Y extends T<Y> {\n  constructor(f: Y -> nat)\n    ensures this.f == f\n  {\n    this.f := f;\n  }\n}\n\nmethod Main()\n  ensures false\n{\n  // error: x.f calls itself without decreasing\n  var knot := new Y((x: Y) => 1 + x.f(x)); // Why doesn't it have a reads clause? Because f can pretend that it does not\n  var a := knot.f(knot);\n}"}
{"file": "../dafny/Test/Landin/Knot4.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\nclass Y {\n  const f: Y -> nat // Type error here? because since Y can be accessed, -> should be ~>\n  constructor(f: Y -> nat)\n    ensures this.f == f\n  {\n    this.f := f;\n  }\n}\n\nmethod Main()\n  ensures false\n{\n  // error: knot.f calls itself without decreasing\n  var knot := new Y((x: Y) => 1 + x.f(x)); // Why doesn't it have a reads clause? Because f can pretend that it does not\n  var a := knot.f(knot);\n}"}
{"file": "../dafny/Test/Landin/Knot14.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\nclass Y {\n  const f: Y? -> nat\n  constructor(f: Y? -> nat)\n    ensures this.f == f\n  {\n    this.f := f;\n  }\n}\n\nmethod Main()\n  ensures false\n{\n  // error: knot.f calls itself without decreasing\n  var knot := new Y((x: Y?) => if x == null then 0 else 1 + x.f(x));\n  var a := knot.f(knot);\n}"}
{"file": "../dafny/Test/Landin/Knot10.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\ndatatype Pack<T> = Pack(ghost c: T)\n\nmethod M()\n  ensures false\n{\n  var r := new Pack<() ~> bool>[1];\n  r[0] := Pack(() => false);\n  var tf := Pack(() reads r, r[0].c.reads => \n                     if r[0].c.requires() then !r[0].c() else false\n                   );\n  // error: r[0] calls itself without decreasing\n  r[0] := tf;\n}"}
{"file": "../dafny/Test/Landin/Knot7.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\nclass Ref {\n  ghost var hogp: Ref ~> int\n}\n\nghost function F(r: Ref): int\n  reads r, r.hogp.reads(r)\n{\n  if r.hogp.requires(r) then 1 + r.hogp(r) else 0\n}\n\n\nmethod Main()\n  ensures false\n{\n  var r := new Ref;\n  r.hogp := F;\n  // error: r.hogp calls itself without decreasing\n  var f := r.hogp(r);\n}"}
{"file": "../dafny/Test/Landin/Knot8.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\nclass Ref<T> {\n  ghost var hogp: T\n  constructor()\n}\n\nmethod Main()\n  ensures false\n{\n  var r := new Ref<() ~> int>();\n  // error: r.hogp calls itself without decreasing\n  r.hogp := () reads r, r.hogp.reads() => if r.hogp.requires() then 1 + r.hogp() else 0;\n}"}
{"file": "../dafny/Test/Landin/Knot6.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\nclass Ref {\n  ghost var hogp: () ~> int\n}\n\nmethod LogicKnot1(r1: Ref,r2: Ref)\n  modifies r1\n  ensures r1.hogp == (() reads r2, r2.hogp.reads() => if r2.hogp.requires() then 1 + r2.hogp() else 0)\n{\n  // error: r1.hogp calls itself through r2.hogp without decreasing\n  r1.hogp := () reads r2, r2.hogp.reads() => if r2.hogp.requires() then 1 + r2.hogp() else 0;\n}\n\nmethod LogicKnot2(r1: Ref,r2: Ref)\n  modifies r2\n  ensures r2.hogp == (() reads r1, r1.hogp.reads() => if r1.hogp.requires() then 1 + r1.hogp() else 0)\n{\n  // error: r1.hogp calls itself through r1.hogp without decreasing\n  r2.hogp := () reads r1, r1.hogp.reads() => if r1.hogp.requires() then 1 + r1.hogp() else 0;\n}\n\nmethod Main()\n  ensures false\n{\n  var r1 := new Ref;\n  var r2 := new Ref;\n  LogicKnot1(r1,r2);\n  LogicKnot2(r1,r2);\n}\n"}
{"file": "../dafny/Test/Landin/Knot17.dfy", "dafny": "// RUN: %testDafnyForEachResolver --expect-exit-code=2 \"%s\"\n\n\ntrait YT {\n  const f: YT -> nat\n}\n\nclass Y extends YT {\n  constructor(f: YT -> nat)\n    ensures this.f == f\n  {\n    this.f := f;\n  }\n}\n\nmethod Main()\n  ensures false\n{\n  // error: knot.f calls itself without decreasing\n  var knot := new Y((x: YT) => if x is Y then 1 + x.f(x as Y) else 0);\n  var a := knot.f(knot);\n}"}
{"file": "../dafny/Test/dafny0/RuntimeTypeTests0.dfy", "dafny": "// UNSUPPORTED: windows\n// RUN: %testDafnyForEachCompiler --refresh-exit-code=0 \"%s\"\n\n// The code in this file demonstrates complications in sorting out covariance in some\n// compilation target languages.\n//\n// Part of the solution in Java is to use Java's wildcard types: a \"Dafny.Sequence<T>\"\" is assignable to\n// a \"Dafny.Sequence<? extends T>\".\n//\n// Covariance is not a problem in JavaScript, since JavaScript has no static types. It's also\n// not a problem in Go, because Go has no type parameters and Dafny therefore encodes all\n// type parameters as interface{}.\n\nmethod G()\n{\n  var s: set<int>;\n  var t: set<nat>;\n  // the following assignments are fine, because \"s\" and \"t\" are represented\n  // the same way in the target language\n  s := {5, 7};\n  t := s;\n  s := t;\n  print s, \" and \", t, \"\\n\";\n}\n\ntrait Tr { var u: char }\n\nclass Class0 extends Tr { var x: int }\n\nclass Class1 extends Tr { var y: real }\n\ndatatype Dt<+A> = Atom(get: A, more: int)\n\nmethod H() {\n  var c := new Class0;\n  var a: Dt<Class0> := Atom(c, 10);\n  var b: Dt<object>; // compilation error: compilation does not support trait types as a type parameter; consider introducing a ghost\n  b := a;\n  print a, \" and \", b, \"\\n\";\n}\n\nmethod I()\n{\n  var c := new Class0;\n  var a: Dt<Class0> := Atom(c, 10);\n  var b: Dt<object>; // compilation error: compilation does not support trait types as a type parameter; consider introducing a ghost\n  b := a;\n  print a, \" and \", b, \"\\n\";\n}\n\nmethod J()\n{\n  var c0 := new Class0;\n  var c1 := new Class1;\n  var s: set<Tr> := {c0, c1}; // fine, this is supported\n  var t: set<Class0> := {c0};\n  s := t;\n  print s, \" and \", t, \"\\n\";\n}\n\nmethod K()\n{\n  var c0 := new Class0;\n  var c1 := new Class1;\n  var s: seq<Tr> := [c0, c1]; // fine, this is supported\n  var t: seq<Class0> := [c0];\n  s := t;\n  print s, \" and \", t, \"\\n\";\n}\n\nmethod L()\n{\n  var c0 := new Class0;\n  var c1 := new Class1;\n  var s: multiset<Tr> := multiset{c0, c1}; // fine, this is supported\n  var t: multiset<Class0> := multiset{c0};\n  s := t;\n  print s, \" and \", t, \"\\n\";\n}\n\nmethod M()\n{\n  var c0 := new Class0;\n  var c1 := new Class1;\n  var s: map<int, Tr> := map[8 := c0, 9 := c1]; // supported\n  var t: map<int, Class0> := map[7 := c0];\n  s := t;\n  print s, \" and \", t, \"\\n\";\n}\n\nmethod Downcast()\n{\n  var c0 := new Class0;\n  var s: seq<Class0> := [c0, c0];\n  var t: seq<Tr> := s;\n  t := s;\n  print s, \" and \", t, \"\\n\";\n}\n\nmethod Main()\n{\n  G();\n  H();\n  I();\n  J();\n  K();\n  L();\n  M();\n  Downcast();\n\n}\n"}
{"file": "../dafny/Test/dafny0/Stdin.dfy", "dafny": "// RUN: %exits-with 0 %stdin \"module A{}\" %baredafny verify --show-snippets:false --stdin > \"%t\"\n// RUN: %exits-with 4 %stdin \"method a() { assert false; }\" %baredafny verify --show-snippets:false --stdin >> \"%t\"\n// RUN: %exits-with 0 %stdin \"\" %baredafny verify --show-snippets:false --stdin >> \"%t\"\n// Ensuring include statements work when processing standard in too\n// (regression test for https://github.com/dafny-lang/dafny/issues/4135)\n// We don't capture the output to %t because it ends up including paths,\n// which are platform-dependent (i.e. \"\\\" on Windows vs. \"/\" on Mac OS and Linux)\n// RUN: %exits-with 4 %baredafny verify --show-snippets:false --verify-included-files --stdin < %S/Input/IncludesTuples.dfy\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/dafny0/DiscoverBounds.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nnewtype NT = x | 0 <= x < 100\nnewtype UT = NT\n\nnewtype Lower = x | -2 <= x\nnewtype Upper = x: Lower | x < 100\n\nnewtype Int = int\n\nnewtype NR = r | -2.0 <= r <= 5.4\n\nmethod Main()\n{\n  var n: NT :| true;\n  var t: UT :| true;\n\n  var u: Upper :| true;\n  var l: Lower :| l < 20;\n  var o: Lower :| true;\n\n  var j: Int :| true;\n\n  print n, \"\\n\";\n  print t, \"\\n\";\n  print u, \"\\n\";\n  print l, \"\\n\";\n  print o, \"\\n\";\n\n  var b: bool;\n  b := forall n': NT :: true ==> P(n' as int);\n  b := forall t': UT :: true ==> P(t' as int);\n  b := forall u': Upper :: true ==> P(u' as int);\n  b := forall l': Lower :: l' < 20 ==> P(l' as int);\n  b := forall j': Int :: -3 <= j' < 7 ==> P(j' as int);\n\n  var x0, x1, x2, x3, x4, x5 := OtherEq(false, {}, [], map[198 := 200], multiset{}, iset{}, imap[]);\n  print x0, \" \", x1, \" \", x2, \" \", x3, \" \", x4, \" \", x5, \"\\n\";\n  x0, x1, x2, x3, x4, x5 := OtherEq(true, {}, [], map[198 := 200], multiset{}, iset{}, imap[]);\n  print x0, \" \", x1, \" \", x2, \" \", x3, \" \", x4, \" \", x5, \"\\n\";\n}\n\npredicate P(x: int)\n{\n  x == 157\n}\n\npredicate Q(r: real)\n{\n  r / 2.0 <= r\n}\n\nmethod OtherEq<U,V(==)>(b: bool, s: set<int>, t: seq<real>, u: map<U,V>, v: multiset<char>, w: iset<bv12>, x: imap<bv28,int>)\n  returns (s': set<int>, t': seq<real>, u': map<U,V>, v': multiset<char>, w': iset<bv12>, x': imap<bv28,int>)\n{\n  if b {\n    s' :| s' == s;\n    t' :| t' == t;\n    u' :| u' == u;\n    v' :| v' == v;\n    w' :| w' == w;\n    x' :| x' == x;\n  } else {\n    s' := var s'' :| s'' == s; s'';\n    t' := var t'' :| t'' == t; t'';\n    u' := var u'' :| u'' == u; u'';\n    v' := var v'' :| v'' == v; v'';\n    w' := var w'' :| w'' == w; w'';\n    x' := var x'' :| x'' == x; x'';\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/PrecedenceLinter.dfy", "dafny": "// RUN: %dafny /compile:0 /functionSyntax:4 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate P0(A: bool, B: bool, C: bool) {\n  A &&\n  B ==> C // warning: suspicious lack of parentheses (lhs of ==>)\n}\n\nghost predicate P1(A: bool, B: bool, C: bool) {\n  A && B ==>\n    C\n}\n\nghost predicate P2(A: bool, B: bool, C: bool) {\n  A &&\n  B\n  ==>\n  C\n}\n\nghost predicate P3(A: bool, B: bool, C: bool, D: bool) {\n  A &&\n  B ==>\n  C &&\n  D\n}\n\nghost predicate P4(A: bool, B: bool, C: bool, D: bool) {\n    A &&\n    B\n  ==>\n    C &&\n    D\n}\n\nghost predicate P5(A: bool, B: bool, C: bool) {\n  A ==>\n  && B\n  && C\n}\n\nghost predicate P6(A: bool, B: bool, C: bool) {\n  A ==>\n  || B\n  || C\n}\n\nghost predicate Q0(A: bool, B: bool, C: bool, D: bool) {\n  A &&\n  B ==> C && // warning (x2): suspicious lack of parentheses (lhs and rhs of ==>)\n  D\n}\n\nghost predicate Q1(A: bool, B: bool, C: bool, D: bool) {\n  A &&\n  B ==> C && // warning: suspicious lack of parentheses (lhs of ==>)\n        D\n}\n\nghost predicate Q2(A: bool, B: bool, C: bool, D: bool) {\n  A &&\n  B ==> (C && // warning: suspicious lack of parentheses (lhs of ==>)\n  D)\n}\n\nghost predicate Q3(A: bool, B: bool, C: bool, D: bool) {\n  (A &&\n  B) ==> (C &&\n  D)\n}\n\nghost predicate Q4(A: bool, B: bool, C: bool, D: bool) {\n  && A\n  && B ==> C // warning (x2): suspicious lack of parentheses (lhs and rhs of ==>)\n  && D\n}\n\nghost predicate Q4a(A: bool, B: bool, C: bool, D: bool) {\n  && A\n  && B ==>\n    C && D\n}\n\nghost predicate Q4b(A: bool, B: bool, C: bool, D: bool) {\n  && A\n  && B ==>\n    C &&\n    D\n}\n\nghost predicate Q4c(A: bool, B: bool, C: bool, D: bool) {\n  && A\n  && B ==>\n  && C\n  && D\n}\n\nghost predicate Q4d(A: bool, B: bool, C: bool, D: bool) {\n  && A\n  && B ==>\n    && C\n    && D\n}\n\nghost predicate Q5(A: bool, B: bool, C: bool, D: bool) {\n  && A\n  && B ==> C // warning: suspicious lack of parentheses (lhs of ==>)\n           && D\n}\n\nghost predicate Q6(A: bool, B: bool, C: bool, D: bool) {\n  && A\n  && B ==> && C // warning (x2): suspicious lack of parentheses (lhs and rhs of ==>)\n           && D\n}\n\nghost predicate Q7(A: bool, B: bool, C: bool, D: bool) {\n  A\n  ==> // warning: suspicious lack of parentheses (rhs of ==>)\n    B && C &&\n  D\n}\n\nghost predicate Q8(A: bool, B: bool, C: bool, D: bool) {\n  A\n  ==>\n    B && C &&\n    D\n}\n\nghost predicate Q8a(A: bool, B: bool, C: bool, D: bool) {\n  (A\n  ==>\n    B && C &&\n    D\n  ) &&\n  (B || C)\n}\n\nghost predicate Q8b(A: bool, B: bool, C: bool, D: bool) {\n    A &&\n    B\n  ==>\n    B &&\n    D\n}\n\nghost predicate Q8c(t: int, x: int, y: int)\n{\n  && (t == 2 ==> x < y)\n  && (|| t == 3\n      || t == 2\n     ==>\n     && x == 100\n     && y == 1000\n     )\n  && (t == 4 ==> || 0 <= x || 0 <= y)\n}\n\nghost predicate Q8d(t: int, x: int, y: int)\n{\n  || t == 3\n  || t == 2\n  ==>\n  && x == 100\n  && y == 1000\n}\n\nghost predicate Q9(A: bool, B: bool, C: bool) {\n  A ==> B ==>\n  C\n}\n\nghost predicate R0(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) ==>\n    Q(x) &&\n    R(x)\n}\n\nghost predicate R1(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) && Q(x) ==>\n    R(x)\n}\n\nghost predicate R2(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) ==> Q(x) ==>\n    R(x)\n}\n\nghost predicate R3(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) ==>\n    Q(x) ==>\n    R(x)\n}\n\nghost predicate R4(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) ==> Q(x) ==>\n  R(x)\n}\n\nghost predicate R5(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) ==>\n  forall y :: Q(y) ==>\n  R(x)\n}\n\nghost predicate R6(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: (P(x) ==> Q(x)) && // warning: suspicious lack of parentheses (forall)\n  R(x)\n}\n\nghost predicate R7(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x ::\n  (P(x) ==> Q(x)) &&\n  R(x)\n}\n\nghost predicate R8(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x ::\n    (P(x) ==> Q(x)) &&\n    R(x)\n}\n\nghost predicate R9(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  exists x :: (P(x) ==> Q(x)) && // warning: suspicious lack of parentheses (exists)\n  R(x)\n}\n\nghost predicate R10(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  exists x :: P(x) && // warning: suspicious lack of parentheses (exists)\n  exists y :: Q(y) && // warning: suspicious lack of parentheses (exists)\n  R(x)\n}\n\nlemma Injective()\n  ensures forall x, y ::\n    Negate(x) == Negate(y)\n    ==> x == y\n{\n}\n\nghost function Negate(x: int): int {\n  -x\n}\n\nghost predicate Quant0(s: string) {\n  && s != []\n  && (|| 'a' <= s[0] <= 'z'\n      || 'A' <= s[0] <= 'Z')\n  && forall i :: 1 <= i < |s| ==>\n    || 'a' <= s[i] <= 'z'\n    || 'A' <= s[i] <= 'Z'\n    || '0' <= s[i] <= '9'\n}\n\nghost predicate Quant1(m: array2<string>, P: int -> bool)\n  reads m\n{\n  forall i :: 0 <= i < m.Length0 && P(i) ==> forall j :: 0 <= j < m.Length1 ==>\n    m[i, j] != \"\"\n}\n\nghost predicate Quant2(s: string) {\n  forall i :: 0 <= i < |s| ==> if s[i] == '*' then false else\n    s[i] == 'a' || s[i] == 'b'\n}\n\nghost predicate Quant3(f: int -> int, g: int -> int) {\n  forall x ::\n    f(x) == g(x)\n}\n\nghost predicate Quant4(f: int -> int, g: int -> int) {\n  forall x :: f(x) ==\n    g(x)\n}\n\nghost predicate Quant5(f: int -> int, g: int -> int) {\n  forall x :: f(x)\n     == g(x)\n}\n\nghost function If0(s: string): int {\n  if |s| == 3 then 2 else 3 + // warning: suspicious lack of parentheses (if-then-else)\n    (2 * |s|)\n}\n\nghost function If1(s: string): int {\n  if |s| == 3 then 2 else\n    3 + (2 * |s|)\n}\n\nghost function If2(s: string): int {\n  if |s| == 3 then 2 else (3 +\n    2 * |s|)\n}\n\nghost function If3(s: string): int {\n  if |s| == 3 then 2 else\n    3 +\n    2 * |s|\n}\n\nghost predicate Waterfall(A: bool, B: bool, C: bool, D: bool, E: bool) {\n          A ==>\n        B ==>\n      C ==>\n    D ==>\n  E\n}\n\nghost predicate MoreOps0(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) <== Q(x) <== // warning: suspicious lack of parentheses (rhs of <==)\n    R(x)\n}\n\nghost predicate MoreOps1(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) <== Q(x) <==>\n    R(x)\n}\n\nghost predicate MoreOps2(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) ==> Q(x) <==>\n    R(x)\n}\n\nghost predicate MoreOps3(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) ==> Q(x) <==>\n    R(x) ==>\n    P(x)\n}\n\nghost predicate MoreOps4(P: int -> bool, Q: int -> bool, R: int -> bool) {\n  forall x :: P(x) <==> Q(x) && // warning: suspicious lack of parentheses (rhs of <==>)\n    R(x)\n}\n\nlemma IntLemma(x: int)\n\nghost function StmtExpr0(x: int): int {\n  if x == 17 then\n    2\n  else\n    IntLemma(x);\n    3\n}\n\nghost function StmtExpr1(x: int): int {\n  if x == 17 then // warning: suspicious lack of parentheses (if-then-else)\n    2\n  else\n     IntLemma(x);\n    3\n}\n\nghost function StmtExpr2(x: int): int {\n  if x == 17 then\n    2\n  else\n    assert x != 17;\n    3\n}\n\nghost function StmtExpr3(x: int): int {\n  if x == 17 then // warning: suspicious lack of parentheses (if-then-else)\n    2\n  else\n     assert x != 17;\n    3\n}\n\nghost function FunctionWithDefaultParameterValue(x: int, y: int := 100): int\n\nghost function UseDefaultValues(x: int): int {\n  if x <= 0 then 0 else\n    FunctionWithDefaultParameterValue(x - 1)\n}\n\nghost function Square(x: int): int {\n  x * x\n}\n\nghost predicate Let0(lo: int, hi: int)\n  requires lo <= hi\n{\n  forall x :: lo <= x < hi ==> var square := Square(x);\n    0 <= square\n}\n\nghost predicate Let1(P: int -> bool) {\n  forall x :: 0 <= x && P(x) ==> var bigger :| x <= bigger;\n    0 <= bigger\n}\n\nghost predicate SomeProperty<X>(x: X)\n\nmethod Parentheses0(arr: array<int>, P: int -> bool)\n{\n  assert forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr\n    [i]);\n  var x := forall i :: 0 <= i < arr.Length ==> SomeProperty(\n    arr[i]);\n  var y := forall i :: 0 <= i < arr.Length ==> P(\n    arr[i]);\n  assert forall i :: 0 <= i < arr.Length && SomeProperty(i) ==> unchanged(\n    arr);\n  var u := if arr.Length == 3 then true else fresh(\n    arr);\n}\n\nmethod Parentheses1(w: bool, x: int)\n{\n  var a := if w then {} else {x,\n    x, x};\n  var b := if w then iset{} else iset{x,\n    x, x};\n  var c := if w then [] else [x,\n    x, x];\n  var d := if w then multiset{} else multiset{x,\n    x, x};\n  var e := if w then map[] else map[x :=\n    x];\n  var f := if w then imap[] else imap[\n    x := x];\n}\n\ndatatype Record = Record(x: int, y: int)\n\nmethod Parentheses2(w: bool, x: int, y: int)\n{\n  var a := if w then Record(0,\n    0\n  ) else Record(x,\n    y);\n  var b := if w then\n      a else a\n    .\n    (\n    x\n    :=\n    y\n    )\n    ;\n}\n\nmethod Parentheses3(w: bool, arr: array<int>, m: array2<int>, i: nat, j: nat)\n  requires i < j < arr.Length <= m.Length0 <= m.Length1\n{\n  var a := if w then 0 else arr\n    [\n    i];\n  var b := if w then [] else arr\n    [ i .. ];\n  var c := if w then [] else arr\n    [..\n    i];\n  var d := if w then [] else arr\n    [\n    i..j];\n  var e := if w then [] else arr\n    [\n    ..j][i..];\n  var f := if w then [] else arr // warning: suspicious lack of parentheses (if-then-else)\n    [..i] + arr[i..];\n  var g := if w then 0 else m\n    [i,\n    j];\n  var h := if w then arr[..] else arr[..j]\n    [0 := 25];\n}\n\ncodatatype Stream = More(head: int, tail: Stream)\n\nmethod Parentheses4(w: bool, s: Stream, t: Stream)\n{\n  ghost var a := if w then true else s ==#[\n    12]                              t;\n  ghost var b := if w then true else s ==#[ // warning: suspicious lack of parentheses (ternary)\n    12] t;\n  ghost var c := if w then true else s // warning: suspicious lack of parentheses (ternary)\n    !=#[12] t;\n  ghost var d := if w then true else s\n    !=#[12]                          t;\n}\n/**** revisit the following when the original match'es are being resolved (https://github.com/dafny-lang/dafny/pull/2734)\ndatatype Color = Red | Blue\n\nmethod Parentheses5(w: bool, color: Color) {\n  var a := if w then 5 else match color\n        case Red => 6\n      case\n    Blue => 7;\n  var b := if w then 5 else match\n          color\n        case Red => 6\n      case\n    Blue => 7;\n  var c := if w then 5 else match color { // warning: suspicious lack of parentheses (if-then-else)\n        case Red => 6\n      case\n    Blue => 7} + 10;\n  var d :=\n    match color\n    case Red => 6\n    case Blue => 7 // warning: suspicious lack of parentheses (case)\n    + 10;\n  var e :=\n    match color\n    case Red => 6\n    + 10\n    case Blue => 7;\n  var f :=\n    match color {\n    case Red => 6\n    case Blue => 7\n    + 10 };\n  var g :=\n    if w then 5 else match color { // warning: suspicious lack of parentheses (if-then-else)\n      case Red => 6\n      case Blue => 7\n      + 10 }\n      + 20;\n}\n***/\n\nmodule MyModule {\n  ghost function MyFunction(x: int): int\n  lemma Lemma(x: int)\n}\n\nmodule QualifiedNames {\n  import MyModule\n\n  ghost predicate P(x: int) {\n    var u := x;\n    MyModule.MyFunction(x) ==\n    x\n  }\n\n  ghost predicate Q(x: int) {\n    var u := x;\n    MyModule.Lemma(x);\n    x == MyModule.MyFunction(x)\n  }\n\n  ghost function F(): int\n  {\n    var p := 1000;\n    MyModule.Lemma(p);\n    p\n  }\n\n  ghost predicate R(x: int) {\n    var u := x; // warning: suspicious lack of parentheses (let)\n                MyModule.\n                Lemma(x);\n                x ==\n             MyModule.MyFunction(x)\n  }\n}  \n\nmodule MatchAcrossMultipleLines {\n  datatype PQ = P(int) | Q(bool)\n\n  method M(s: set<PQ>)\n    requires\n      (forall pq | pq in s :: match pq {\n          case P(x) => true\n          case Q(y) => y == false\n      })\n  {\n  }\n\n  datatype YZ = Y | Z\n\n  ghost function F(A: bool, B: int, C: YZ): int\n    requires C != Y\n  {\n    if A then B else match C {\n      case Z => 3\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/PrintUTF8.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  print \"Mikaël fixed UTF8\\n\";\n}\n"}
{"file": "../dafny/Test/dafny0/formatting1-3.dfy", "dafny": "// RUN: echo 'lit should ignore this file' \n\n"}
{"file": "../dafny/Test/dafny0/PrefixSyntax.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype TextProcessing =\n  | TeX    // prefix |\n  | LaTeX\n  | Madoko\n\nghost predicate InfixStyle(x: int, y: int, t: TextProcessing)\n{\n  (t == TeX ==> x < y) &&\n  (t == LaTeX || t == TeX ==> x == 100 && y == 1000) &&\n  (t == Madoko ==> 0 <= x || 0 <= y)\n}\n\nghost predicate TLA_plus_Style(x: int, y: int, t: TextProcessing)\n{\n  // This expression is semantically the same as the one in InfixStyle\n  && (t == TeX ==> x < y)\n  && (|| t == LaTeX\n      || t == TeX\n    ==>\n     && x == 100\n     && y == 1000\n     )\n  && (t == Madoko ==> || 0 <= x || 0 <= y)\n}\n\nlemma Same(x: int, y: int, t: TextProcessing)\n  ensures InfixStyle(x, y, t) == TLA_plus_Style(x, y, t)\n{\n}\n\ndatatype MyRecord = | MakeItHere(z: int)\n\nghost function UnitConjunct(y: int): bool\n{\n  && y == 5\n}\n\nghost function UnitDisjunct(y: int): bool\n{\n  || y == 5\n}\n\nlemma Units(y: int)\n  ensures UnitConjunct(y) == UnitDisjunct(y)\n{\n}\n\nghost function MyPredicate(y: int): bool\n{\n  // the <==> in the following line has lower precedence than the unit disjunnctions\n  || 5 + y == 0 <==> && 10 + y == 0\n}\n\n\nghost function MyPredicateClean(y: int): bool\n{\n  5 + y == 0 <==> 10 + y == 0\n}\n\nlemma MyPred(y: int)\n  ensures MyPredicate(y) == MyPredicateClean(y)\n{\n}\n\nlemma CheckMyPred_0(y: int)\n  requires MyPredicate(y)\n  ensures y != -5 && y != -10\n{\n}\n\nlemma CheckMyPred_1(y: int)\n  ensures MyPredicate(4)\n{\n}\n"}
{"file": "../dafny/Test/dafny0/fun-with-slices.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This test was contributed by Bryan. It has shown some instabilities in the past.\n\nmethod seqIntoArray<A>(s: seq<A>, a: array<A>, index: nat)\n  requires index + |s| <= a.Length\n  modifies a\n  ensures  a[..] == old(a[0..index]) + s + old(a[index + |s|..])\n{\n    var i := index;\n\n    while i < index + |s|\n      invariant index <= i <= index + |s| <= a.Length\n      invariant a[..] == old(a[..index]) + s[..i - index] + old(a[i..])\n    {\n        a[i] := s[i - index];\n        i := i + 1;\n    }\n}\n"}
{"file": "../dafny/Test/dafny0/NullComparisonWarnings.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\nmethod Main() {\n  print \"despite the warnings, the program still compiles\\n\";\n  var c := new MyClass();\n  M(c, c, 0, {});\n}\n\nclass MyClass {\n  var next: MyClass\n\n  constructor () {\n    next := this;\n  }\n}\n\nmethod M(x: MyClass, c: MyClass, N: nat, S: set<MyClass>) {\n  var y: MyClass := new MyClass();\n  var n: nat := N;\n  while n != 0 {\n    y := new MyClass();\n    n := n - 1;\n  }\n\n  var b;\n  b := x == null;  // warning (with hint)\n  b := y == null;  // warning (with hint)\n  b := c.next == null;  // warning (with hint)\n  b := x != null;  // warning (with hint)\n  b := y != null;  // warning (with hint)\n  b := c.next != null;  // warning (with hint)\n\n  b := null == x;\n  b := x == (null);  // no warning (this could easily be changed in the implementation, but I left it as a kind of \"nowarn\" feature)\n\n  b := null in S;  // warning\n  b := null !in S;  // warning\n\n  b := forall u: MyClass :: u in S ==> u != null;  // warning\n\n  var c0: Cell<MyClass?> := new Cell<MyClass?>(c);\n  var c1: Cell<MyClass> := new Cell<MyClass>(c);\n  b := null != c0.data;\n  b := null != c1.data;  // warning (no hint)\n}\n\nclass Cell<G> {\n  var data: G\n  constructor (g: G) {\n    data := g;\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/TriggerInPredicate.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate A(x: bool, y: bool) { x }\n\nghost predicate B(x: bool, z: bool) { forall y {:trigger A(x, y)} :: A(x, y) && z }\n\n// Inlining is disabled here to prevent pollution of the trigger in B\nmethod C() requires B(true || false, true) {}\n\n// Inlining should work fine here\nmethod C'() requires B(true, true) {}\n\n// Inlining should work fine here\nmethod C''() requires B(true, true && false) {}\n\n// Local Variables:\n// dafny-prover-local-args: (\"/autoTriggers:1\")\n// End:\n"}
{"file": "../dafny/Test/dafny0/ForallCompilation.dfy", "dafny": "// NONUNIFORM: New CLI doesn't support /autoTriggers:0\n// RUN: %dafny /compile:3 /print:\"%t.print\" /dprint:\"%t.dprint\" /autoTriggers:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  var c := new MyClass;\n  c.arr := new int[10,20];\n  c.K0(3, 12);\n  c.K1(3, 12);\n  c.K2(3, 12);\n  c.K3(3, 12);\n  c.K4(12);\n  c.M();\n  c.N();\n  c.P();\n  c.Q();\n}\n\nclass MyClass\n{\n  var arr: array2<int>\n\n  method K0(i: int, j: int)\n    requires 0 <= i < arr.Length0 && 0 <= j < arr.Length1\n    modifies arr\n  {\n    forall k | k in {-3, 4} {\n      arr[i,j] := 50;\n    }\n  }\n\n  method K1(i: int, j: int)\n    requires 0 <= i < arr.Length0 && 0 <= j < arr.Length1\n    // note the absence of a modifies clause\n  {\n    forall k: int | k in {} {\n      arr[i,j] := k;  // fine, since control will never reach here\n    }\n  }\n\n  method K2(i: int, j: int)\n    requires 0 <= i < arr.Length0 && 0 <= j < arr.Length1\n    modifies arr\n  {\n    forall k: int | k in {-3, 4} {\n      // The following would have been an error (since this test file tests\n      // compilation, we don't include the test here):\n      // arr[i,j] := k;  // error: k can take on more than one value\n    }\n  }\n\n  method K3(i: int, j: int)\n    requires 0 <= i < arr.Length0 && 0 <= j < arr.Length1\n    modifies arr\n  {\n    forall k: nat | k in {-3, 4} && k <= i {\n      arr[k,j] := 50;  // fine, since k:nat is at least 0\n    }\n  }\n\n  method K4(j: int)\n    requires 0 <= j < arr.Length1\n    modifies arr\n  {\n    forall i, k: nat | 0 <= i < arr.Length0 && k in {-3, 4} {\n      arr[i,j] := k;  // fine, since k can only take on one value\n    }\n  }\n\n  method M()\n  {\n    var ar := new int [3,3];\n    var S: set<int> := {2,0};\n    forall k | k in S {\n      ar[k,1]:= 0;\n    }\n    forall k, j | k in S && j in S {\n      ar[k,j]:= 0;\n    }\n  }\n\n  method N() {\n    var ar := new int[3, 3];\n    ar[2,2] := 0;\n  }\n\n  method P() {\n    var ar := new int[3];\n    var prev := ar[..];\n    var S: set<int> := {};\n    forall k | k in S {\n      ar[k] := 0;\n    }\n    assert ar[..] == prev;\n  }\n\n  method Q() {\n    var ar := new int[3,3];\n    var S: set<int> := {1,2};\n    forall k | k in S {\n      ar[0,0] := 0;\n    }\n    assert ar[0,0] == 0;\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/ContainerRanks.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Abc = End | Wrapper(seq<Abc>)\n\nlemma SeqRank0(a: Abc)\n  ensures a != Wrapper([a])\n{\n  assert [a][0] == a;  // TODO: one could consider strengthening axioms to eliminate the need for this assert\n                       // The reason we need the assert is to match the trigger in the rank axioms produced\n                       // for datatypes containing sequences.\n                       // See \"is SeqType\" case of AddDatatype in Translator.cs\n}\n\nlemma SeqRank1(s: seq<Abc>)\n  requires s != []\n  ensures s[0] != Wrapper(s)\n{\n}\n\ndatatype Def = End | MultiWrapper(multiset<Def>)\n\nlemma MultisetRank(a: Def)\n  ensures a != MultiWrapper(multiset{a})\n{\n}\n\ndatatype Ghi = End | SetWrapper(set<Ghi>)\n\nlemma SetRank(a: Ghi)\n  ensures a != SetWrapper({a})\n{\n}\n"}
{"file": "../dafny/Test/dafny0/RankPos.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype list<A> = Nil | Cons(head: A, tail: list<A>)\ndatatype d = A | B(ds: list<d>)\ndatatype d2 = A2 | B2(ds: seq<d2>)\ndatatype d3 = A3 | B3(ds: set<d3>)\n\nghost function d_size(x: d): int\n{\n  match x\n  case A => 1\n  case B(ds) => 1+ds_size(ds)\n}\n\nghost function ds_size(xs: list<d>): int\n{\n  match xs\n  case Nil => 1\n  case Cons(head, tail) => d_size(head)+ds_size(tail)\n}\n\nghost function d2_size(x: d2): int\n{\n  match x\n  case A2 => 1\n  case B2(ds) => 1+ds2_size(ds)\n}\n\nghost function ds2_size(xs: seq<d2>): int\n{\n  if (|xs|==0) then 1 else 1+d2_size(xs[0])+ds2_size(xs[1..])\n}\n\nghost function seq_dec_drop(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  1+seq_dec_drop(xs[1..])\n}\n\nghost function seq_dec_take(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  1+seq_dec_take(xs[..|xs|-1])\n}\n\nghost function seq_dec(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  var i :| 0 < i <= |xs|;\n  i+seq_dec(xs[i..])\n}\n\nghost function seq_dec'(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  var i :| 0 <= i < |xs|;\n  i+seq_dec'(xs[..i])\n}\n\nghost function seq_dec''(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  var i :| 0 <= i < |xs|;\n  assert xs[0..i] == xs[..i];\n  i+seq_dec''(xs[0..i])\n}\n\nghost function seq_dec'''(xs: seq<int>): int\n  decreases |xs|\n{\n  if (|xs|==0) then 0 else\n  var i :| 0 <= i < |xs|;\n  i+seq_dec'''(xs[..i]+xs[i+1..])\n}\n\nghost function seq_dec''''(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  var i :| 0 <= i < |xs|;\n  i+seq_dec''''(xs[..i]+xs[i+1..])\n}\n"}
{"file": "../dafny/Test/dafny0/SharedDestructorsCompile.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype Dt =\n  | A(x: int, y: real)\n  | B(h: MyClass, x: int)\n  | C(y: real)\n\nclass MyClass { }\n\nmethod Main()\n{\n  var o := new MyClass;\n  var s := [A(10, 12.0), B(o, 6), C(3.14)];\n  assert s[0].x == 10 && s[0].y == 12.0;\n  assert s[1].h == o && s[1].x == 6;\n  assert s[2].y == 3.14;\n\n  var d := s[0];\n  print d, \":  x=\", d.x, \" y=\", d.y, \"\\n\";\n  d := s[1];\n  print d, \":  h=\", d.h, \" x=\", d.x, \"\\n\";\n  d := s[2];\n  print d, \":  y=\", d.y, \"\\n\";\n\n  s := [A(71, 0.1), B(o, 71)];\n  var i := 0;\n  while i < |s|\n  {\n    print d, \"\\n\";\n    d := s[i];\n    assert d.x == 71;\n    i := i + 1;\n  }\n\n  BaseKlef(C3(44, 55, 66, 77));\n  Matte(AA(10, 2));\n}\n\ndatatype Klef =\n  | C0(0: int, 1: int, 2: int, c0: int)\n  | C1(1: int, 2: int, 3: int, c1: int)\n  | C2(2: int, 3: int, 0: int, c2: int)\n  | C3(3: int, 0: int, 1: int, c3: int)\n\nmethod BaseKlef(k: Klef)\n  requires !k.C0? && !k.C2? && !k.C1?\n{\n  var k' := k.(0 := 100, c3 := 200);  // makes a C3\n  assert k' == C3(k.3, 100, k.1, 200);\n  print k', \"\\n\";\n}\n\ndatatype Datte<T> = AA(a: int, x: int) | BB(b: bool, x: int) | CC(c: real) | DD(x: int, o: set<int>, p: bv27, q: T)\n\nmethod Matte(d: Datte<real>)\n  requires !d.CC?\n{\n  var d := d;\n\n  var s := d.(x := 5);\n  print d, \" \", s, \"\\n\";  // AA(10, 2) AA(10, 5)\n\n  d := BB(false, 12);\n  s := d.(x := 6);\n  print d, \" \", s, \"\\n\";  // BB(false, 12) BB(false, 6)\n\n  d := CC(3.2);\n  s := d.(c := 3.4);\n  print d, \" \", s, \"\\n\";  // CC(3.2) CC(3.4)\n\n  d := DD(100, {7}, 5, 9.0);\n  s := d.(x := 30);\n  print d, \" \", s, \"\\n\";  // DD(100, {7}, 5, 9.0) DD(30, {7}, 5, 9.0)\n  s := s.(q := 2.0, p := d.p);\n  print d, \" \", s, \"\\n\";  // DD(100, {7}, 5, 9.0) DD(30, {7}, 5, 2.0)\n}\n"}
{"file": "../dafny/Test/dafny0/PrintEffects.dfy", "dafny": "// NONUNIFORM: Multiple testing scenarios (could be split)\n// RUN:   %baredafny run %args \"%s\" > \"%t\"\n// RUN: ! %baredafny run %args --track-print-effects \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"hello, Main\\n\"; // error: cannot print from this method\n  P(); // error: cannot call printing method\n  var iter0 := new NoPrintIter(3);\n  var iter1 := new PrintIter(3);\n  var _ := iter0.MoveNext();\n  var _ := iter1.MoveNext(); // error: cannot call printing method\n  var cl0 := new Cl.NoPrint();\n  var cl1 := new Cl.Print(); // error: cannot call printing constructor\n}\n\nmethod {:print} P() {\n  print \"method P here\\n\";\n  M();\n  var iter0 := new NoPrintIter(3);\n  var iter1 := new PrintIter(3);\n  print \"calling MoveNexts\\n\";\n  MoveNexts(iter0, iter1);\n  var cl := new Cl.NoPrint();\n  cl := new Cl.Print();\n\n  TestOverrides();\n}\n\nmethod MoveNexts(iter0: NoPrintIter, iter1: PrintIter)\n  requires iter0.Valid() && iter1.Valid()\n  requires iter0._modifies == iter0._new == iter0._reads == {}\n  requires iter1._modifies == iter1._new == iter1._reads == {}\n  modifies iter0, iter1\n{\n  var more0 := iter0.MoveNext();\n  var more1 := iter1.MoveNext(); // error: cannot print from this method\n}\n\nmethod M() {\n  var x := F(3);\n  print \"bye, from M\\n\"; // error: cannot print from this method\n}\n\nfunction F(x: int): int {\n  10\n} by method {\n  print \"function-by-method F\\n\"; // error: cannot print from this method\n  return 10;\n}\n\niterator NoPrintIter(a: int) yields (x: int)\n{\n  print \"Start of Iter 0\\n\"; // error: cannot print from this method\n  yield 3 + a;\n  print \"End of Iter 0\\n\"; // error: cannot print from this method\n}\n\niterator {:print} PrintIter(a: int) yields (x: int)\n{\n  print \"Start of Iter 1\\n\";\n  yield 3 + a;\n  print \"End of Iter 1\\n\";\n}\n\nclass Cl {\n  constructor NoPrint() {\n    print \"Cl.NoPrint ctor\\n\"; // error: cannot print from this method\n  }\n  constructor {:print} Print() {\n    print \"Cl.Print ctor\\n\";\n  }\n}\n\ntrait Trait {\n  method {:print} MayPrint()\n  method {:print} AlwaysPrints()\n}\n\nclass Overrides extends Trait {\n  method MayPrint() { // allowed to drop {:print} attribute\n    print \"Override X\"; // error: cannot print without a {:print} attribute\n  }\n  method {:print} AlwaysPrints() {\n    print \" Y\\n\";\n  }\n}\n\nmethod {:print} TestOverrides() {\n  var c: Overrides := new Overrides;\n  var t: Trait := c;\n\n  t.MayPrint();\n  t.AlwaysPrints();\n\n  c.MayPrint();\n  c.AlwaysPrints();\n\n  TestOverridesNoPrint(c, t);\n}\n\nmethod TestOverridesNoPrint(c: Overrides, t: Trait) {\n  t.MayPrint(); // error: cannot call printing method\n  t.AlwaysPrints(); // error: cannot call printing method\n\n  c.MayPrint();\n  c.AlwaysPrints(); // error: cannot call printing method\n}\n"}
{"file": "../dafny/Test/dafny0/ArrayElementInitCompile.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment --unicode-char:false\n\nmethod Main()\n{\n  var a := SingleValued(67);\n  PrintArray(a);\n\n  var mx := NewMatrix();\n  PrintMatrix(mx);\n\n  var c := InitArray(F);\n  PrintArray(c);\n\n  var s := InitArray(_ => 12);\n  PrintArray(s);\n\n  var t := new TrickyLets(0, null);\n  t.RegressionTests();\n  t.Do();\n  t.DoDisplay();\n  t.DoDefault();\n\n  SubsetType();\n\n  Display(98);\n}\n\nmethod SingleValued(d: int) returns (a: array<int>)\n  ensures a.Length == 8\n{\n  a := new int[8](_ => d);\n}\n\nfunction F(x: int): char\n{\n  if x % 2 == 0 then 'O' else '.'\n}\n\nmethod InitArray<D>(f: int -> D) returns (a: array<D>)\n  requires forall x :: 0 <= x < 12 ==> f.requires(x)\n{\n  a := new D[12](f);\n}\n\nmethod NewMatrix() returns (m: array2<int>)\n{\n  m := new int[5, 4]((x,y) => x+y);\n}\n\nmethod PrintMatrix(m: array2<int>)\n{\n  var i := 0;\n  while i < m.Length0\n  {\n    var j := 0;\n    while j < m.Length1\n    {\n      print m[i,j], \" \";\n      j := j + 1;\n    }\n    print \"\\n\";\n    i := i + 1;\n  }\n}\n\nmethod PrintArray<D>(a: array<D>)\n{\n  var i := 0;\n  while i < a.Length\n  {\n    print a[i], \" \";\n    i := i + 1;\n  }\n  print \"\\n\";\n}\n\nclass TrickyLets\n{\n  var next: TrickyLets?\n  var arr: array<char>\n\n  constructor (n: nat, w: TLWrapper?)\n    modifies w\n    ensures w != null ==> w.data == null\n  {\n    if w != null {\n      w.data := null;\n    }\n    if n != 0 {\n      next := new TrickyLets(n-1, null);\n    }\n  }\n  method RegressionTests()\n  {\n    // make sure l-values are captured before any assignment takes place\n    var t := new TrickyLets(0, null);\n    var w := new TLWrapper;\n    w.data := t;\n    w.data, w.data.next := null, null;\n\n    // ditto\n    t := new TrickyLets(0, null);\n    w := new TLWrapper;\n    w.data := t;\n    w.data.next, w.data := null, null;\n\n    // (here's the thing that once had been buggy)\n    // also check that l-values are captured when the RHS is a \"new\"\n    t := new TrickyLets(0, null);\n    w := new TLWrapper;\n    w.data := t;\n    w.data.next := new TrickyLets(0, w);\n    assert t.next != null;\n    assert w.data == null;\n  }\n  method Do()\n    modifies this\n  {\n    this.arr := new char[20](_ => 'D');\n    assert arr[12] == 'D';\n    print arr[12], \" \";\n    // Now, do the same thing, but with various let expressions\n    (var u := this; u).arr := new char[var n := 20; n](var fn := _ => 'E'; fn);\n    assert arr[13] == 'E';\n    print arr[13], \"\\n\";\n  }\n  method DoDisplay()\n    modifies this\n  {\n    this.arr := new char[3] ['x', 'y', 'z'];\n    assert arr[1] == 'y';\n    print arr[1], \" \";\n    // Now, do the same thing, but with various let expressions\n    (var u := this; u).arr := new char[var n := 3; n] [var x := 'x'; x, var y := 'y'; y, var z := 'z'; z];\n    assert arr[2] == 'z';\n    print arr[2], \"\\n\";\n  }\n  method DoDefault()\n    modifies this\n  {\n    this.arr := new char[4];\n    assert arr.Length == 4;\n    print arr.Length, \" \";\n    // Now, do (almost) the same thing, but with various let expressions\n    (var u := this; u).arr := new char[var n := 3; n];\n    assert arr.Length == 3;\n    print arr.Length, \"\\n\";\n  }\n}\n\nclass TLWrapper\n{\n  var data: TrickyLets?\n}\n\ntype Six = x | 6 <= x witness 7\nnewtype int32 = x | -0x8000_0000 <= x < 0x8000_0000\n\nmethod SubsetType()\n{\n  var a := new Six[12];\n  assert 6 <= a[6];\n  print a[6], \"\\n\";\n}\n\nmethod Display(n: nat)\n{\n  var b := new nat[4] [100, 75, n, 25];\n  var d := new char[0][];\n  var s := new string[4][\"looks\", \"like\", \"this\", \"rocks\"];\n  var i := new int32[7][-2, -1, 0, 1, 2, 3, 4];\n  PrintArray(b);\n  PrintArray(d);\n  PrintArray(s);\n  PrintArray(i);\n}\n"}
{"file": "../dafny/Test/dafny0/ModuleInsertion.dfy", "dafny": "// NONUNIFORM: Tests printing much more than compilation\n// RUN: %dafny /env:0 /dprint:- /dafnyVerify:0 \"%s\" > \"%t\"\n// RUN: %dafny /env:0 /rprint:- /compile:3 \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  Outer.Test();\n  XY.Test();\n  U.V.Test();\n  print MyModule.Q.W.E.R.T.Y.h, \"\\n\";\n}\n\n// ----- Outer\n\nmodule Outer {\n  module C {\n    import D\n    const c := 2 + D.d\n  }\n  method Test() {\n    print A.a, \" \", B.b, \" \", C.c, \" \", D.d, \"\\n\";  // 6 1 5 3\n  }\n}\n\nmodule Outer.A {\n  import B\n  import C\n  const a := B.b + C.c\n}\n\nmodule Outer.B {\n  const b := 1\n}\n\nmodule Outer.D {\n  const d := 3\n}\n\nmodule Outer.E {\n  export\n    provides F\n\n  module F {\n    export G\n  }\n}\n\nmodule Outer.H {\n  import E\n  import E.F`G\n}\n\n// ----- Oreo\n\nmodule XY.X {\n  const m := 20\n  module M {\n    import Y\n    const n := Y.m - 5\n  }\n}\n\nmodule XY {\n  method Test() {\n    print X.m, \" \", X.M.n, \" \", Y.m, \"\\n\";  // 20 17 22\n  }\n}\n\nmodule XY.Y {\n  const m := 22\n}\n\n// ----- Triple\n\nmodule U.V.W.X {\n  const x0 := 12\n}\n\nmodule U.V {\n  const x2 := 14 + W.x1 + W.X.x0\n  method Test() {\n    print W.X.x0, \" \", W.x1, \" \", x2, \"\\n\";  // 12 144 170\n  }\n}\n\nmodule U.V.W {\n  const x1 := 12 * X.x0\n}\n\n// ----- Prefix-named modules in user-defined module\n\nmodule MyModule {\n  module Q.W.E.R.T {\n  }\n  module Q.W.E.R.T.Y {\n    const h := 2\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/formattingStdin.dfy", "dafny": "// RUN: %exits-with 1 %baredafny format --stdin 2> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/dafny0/DividedConstructors.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  var m := new M0.MyClass.Init(20);\n  print m.a, \", \", m.b, \", \", m.c, \"\\n\";\n  var r0 := new Regression.A.Make0();\n  var r1 := new Regression.A.Make1();\n  assert r0.b != r1.b;\n  print r0.b, \", \", r1.b, \"\\n\";\n}\n\nmodule M0 {\n  class MyClass {\n    var a: nat\n    const b := 17\n    var c: real\n\n    constructor Init(x: nat)\n    {\n      this.a := x;\n      c := 3.14;\n      new;\n      a := a + b;\n      assert c == 3.14;\n      assert this.a == 17 + x;\n    }\n\n    constructor (z: real)\n      ensures c <= 2.0 * z\n    {\n      a, c := 50, 2.0 * z;\n      new;\n    }\n\n    constructor Make()\n      ensures 10 <= a\n    {\n      new;\n      a := a + b;\n    }\n\n    constructor Create()\n      ensures 30 <= a\n    {\n      new;\n      a := a + 2*b;\n    }\n  }\n}\n\nmodule M1 refines M0 {\n  class MyClass ... {\n    const d := 'D'\n    var e: char\n\n    constructor Init...\n    {\n      e := 'e';\n      new;\n      e := 'x';\n      ...;\n      assert e == 'x';\n    }\n\n    constructor ...\n    {\n      e := 'y';\n      new;\n    }\n\n    constructor Make...\n    {\n      new;\n      e := 'z';\n    }\n\n    constructor Create...\n    {\n      e := 'w';\n    }\n  }\n}\n\nmodule TypeOfThis {\n  class LinkedList<T(0)> {\n    ghost var Repr: set<LinkedList<T>>\n    ghost var Rapr: set<LinkedList?<T>>\n    ghost var S: set<object>\n    ghost var T: set<object?>\n\n    constructor Init()\n    {\n      Repr := {this};  // regression test: this should pass, but once upon a time didn't\n    }\n\n    constructor Init'()\n    {\n      Rapr := {this};\n    }\n\n    constructor Create()\n    {\n      S := {this};  // regression test: this should pass, but once upon a time didn't\n    }\n\n    constructor Create'()\n    {\n      T := {this};\n    }\n\n    constructor Two()\n    {\n      new;\n      var ll: LinkedList? := this;\n      var o: object? := this;\n      if\n      case true =>  T := {o};\n      case true =>  S := {o};\n      case true =>  Repr := {ll};\n      case true =>  Rapr := {ll};\n      case true =>  S := {ll};\n      case true =>  T := {ll};\n    }\n\n    method Mutate()\n      modifies this\n    {\n      Repr := {this};\n      Rapr := {this};\n      S := {this};\n      T := {this};\n    }\n  }\n}\n\nmodule Regression {\n  class A {\n    var b: bool\n    var y: int\n\n    constructor Make0()\n      ensures b == false  // regression test: this didn't used to be provable :O\n    {\n      b := false;\n    }\n    constructor Make1()\n      ensures b == true\n    {\n      b := true;\n    }\n    constructor Make2()\n    {\n      b := false;\n      new;  // this sets \"alloc\" to \"true\", and the verifier previously was not\n            // able to distinguish the internal field \"alloc\" from other boolean\n            // fields\n      assert !b;  // regression test: this didn't used to be provable :O\n    }\n    constructor Make3()\n      ensures b == false && y == 65\n    {\n      b := false;\n      y := 65;\n      new;\n      assert !b;  // regression test: this didn't used to be provable :O\n      assert y == 65;\n    }\n    constructor Make4(bb: bool, yy: int)\n      ensures b == bb && y == yy\n    {\n      b, y := bb, yy;\n    }\n  }\n}\n\n"}
{"file": "../dafny/Test/dafny0/ModulePrint.dfy", "dafny": "// NONUNIFORM: Tests printing much more than compilation\n// RUN: %dafny /dafnyVerify:0 /compile:0 /env:0 /dprint:\"%t.dfy\" \"%s\" > \"%t\"\n// RUN: %dafny /dafnyVerify:0 /compile:0 /env:0 /printMode:DllEmbed /dprint:\"%t1.dfy\" \"%t.dfy\" >> \"%t\"\n// RUN: %dafny /env:0 /compile:3 /printMode:DllEmbed /dprint:\"%t2.dfy\" \"%t1.dfy\" >> \"%t\"\n// RUN: %diff \"%t1.dfy\" \"%t2.dfy\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nabstract module S {\n  class C {\n    var f: int\n    ghost var g: int\n    var h: int\n    method m()\n      modifies this\n  }\n}\n\nmodule T refines S {\n  class C ... {\n    ghost var h: int  // change from non-ghost to ghost\n    ghost var j: int\n    var k: int\n    constructor () { }\n    method m()\n      ensures h == h\n      ensures j == j\n    {\n      assert k == k;\n    }\n  }\n}\n\nmethod Main() {\n  var c := new T.C();\n  c.m();\n}\n"}
{"file": "../dafny/Test/dafny0/ForallCompilationNewSyntax.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --quantifier-syntax:4 --relax-definite-assignment\n\nmethod Main() {\n  var c := new MyClass;\n  c.arr := new int[10,20];\n  c.K0(3, 12);\n  c.K1(3, 12);\n  c.K2(3, 12);\n  c.K3(3, 12);\n  c.K4(12);\n  c.M();\n  c.N();\n  c.P();\n  c.Q();\n}\n\nclass MyClass\n{\n  var arr: array2<int>\n\n  method K0(i: int, j: int)\n    requires 0 <= i < arr.Length0 && 0 <= j < arr.Length1\n    modifies arr\n  {\n    forall k <- {-3, 4} {\n      arr[i,j] := 50;\n    }\n  }\n\n  method K1(i: int, j: int)\n    requires 0 <= i < arr.Length0 && 0 <= j < arr.Length1\n    // note the absence of a modifies clause\n  {\n    forall k <- {} {\n      arr[i,j] := k;  // fine, since control will never reach here\n    }\n  }\n\n  method K2(i: int, j: int)\n    requires 0 <= i < arr.Length0 && 0 <= j < arr.Length1\n    modifies arr\n  {\n    forall k <- {-3, 4} {\n      // The following would have been an error (since this test file tests\n      // compilation, we don't include the test here):\n      // arr[i,j] := k;  // error: k can take on more than one value\n    }\n  }\n\n  method K3(i: int, j: int)\n    requires 0 <= i < arr.Length0 && 0 <= j < arr.Length1\n    modifies arr\n  {\n    forall k: nat <- {-3, 4} | k <= i {\n      arr[k,j] := 50;  // fine, since k:nat is at least 0\n    }\n  }\n\n  method K4(j: int)\n    requires 0 <= j < arr.Length1\n    modifies arr\n  {\n    forall i | 0 <= i < arr.Length0, k: nat <- {-3, 4} {\n      arr[i,j] := k;  // fine, since k can only take on one value\n    }\n  }\n\n  method M()\n  {\n    var ar := new int [3,3];\n    var S: set<int> := {2,0};\n    forall k | k in S {\n      ar[k,1]:= 0;\n    }\n    forall k <- S, j <- S {\n      ar[k,j]:= 0;\n    }\n  }\n\n  method N() {\n    var ar := new int[3, 3];\n    ar[2,2] := 0;\n  }\n\n  method P() {\n    var ar := new int[3];\n    var prev := ar[..];\n    var S: set<int> := {};\n    forall k <- S {\n      ar[k] := 0;\n    }\n    assert ar[..] == prev;\n  }\n\n  method Q() {\n    var ar := new int[3,3];\n    var S: set<int> := {1,2};\n    forall k <- S {\n      ar[0,0] := 0;\n    }\n    assert ar[0,0] == 0;\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/SeqFromArray.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// /autoTriggers:1 added to suppress instabilities\n\nmethod Main() { }\n\nmethod H(a: array<int>, c: array<int>, n: nat, j: nat)\n  requires j < n == a.Length == c.Length\n{\n  var A := a[..];\n  var C := c[..];\n\n  if {\n    case A[j] == C[j] =>\n      assert a[j] == c[j];\n    case forall i :: 0 <= i < n ==> A[i] == C[i] =>\n      assert a[j] == c[j];\n    case forall i :: 0 <= i < n ==> A[i] == C[i] =>\n      assert forall i :: 0 <= i < n ==> a[i] == c[i];\n    case A == C =>\n      assert forall i :: 0 <= i < n ==> A[i] == C[i];\n    case A == C =>\n      assert forall i :: 0 <= i < n ==> a[i] == c[i];\n    case true =>\n  }\n}\n\nmethod K(a: array<int>, c: array<int>, n: nat)\n  requires n <= a.Length && n <= c.Length\n{\n  var A := a[..n];\n  var C := c[..n];\n  if {\n    case A == C =>\n      assert forall i :: 0 <= i < n ==> A[i] == C[i];\n    case A == C =>\n      assert forall i :: 0 <= i < n ==> a[i] == c[i];\n    case true =>\n  }\n}\n\nmethod L(a: array<int>, c: array<int>, n: nat)\n  requires n <= a.Length == c.Length\n{\n  var A := a[n..];\n  var C := c[n..];\n  var h := a.Length - n;\n  if {\n    case A == C =>\n      assert forall i :: 0 <= i < h ==> A[i] == C[i];\n    case A == C =>\n      assert forall i :: n <= i < n + h ==> a[i] == c[i];\n    case true =>\n  }\n}\n\nmethod M(a: array<int>, c: array<int>, m: nat, n: nat, k: nat, l: nat)\n  requires k + m <= a.Length\n  requires l + n <= c.Length\n{\n  var A := a[k..k+m];\n  var C := c[l..l+n];\n  if A == C {\n    if * {\n      assert m == n;\n    } else if * {\n      assert forall i :: 0 <= i < n ==> A[i] == C[i];\n    } else if * {\n      assert forall i {:nowarn} :: k <= i < k+n ==> A[i-k] == C[i-k];\n    } else if * {\n      assert forall i :: 0 <= i < n ==> A[i] == a[k+i];\n    } else if * {\n      assert forall i :: 0 <= i < n ==> C[i] == c[l+i];\n    } else if * {\n      assert forall i {:nowarn} :: 0 <= i < n ==> a[k+i] == c[l+i];\n    }\n  }\n}\n\nmethod M'(a: array<int>, c: array<int>, m: nat, n: nat, k: nat, l: nat)\n  requires k + m <= a.Length\n  requires l + n <= c.Length\n{\n  if {\n    case l+m <= c.Length && forall i :: 0 <= i < m ==> a[i] == c[l+i] =>\n      assert a[..m] == c[l..l+m];\n    case l+a.Length <= c.Length && forall i :: k <= i < a.Length ==> a[i] == c[l+i] =>\n      assert a[k..] == c[l+k..l+a.Length];\n    case l+k+m <= c.Length && forall i :: k <= i < k+m ==> a[i] == c[l+i] =>\n      assert a[k..k+m] == c[l+k..l+k+m];\n    case true =>\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/JustWarnings.dfy", "dafny": "// RUN: %testDafnyForEachResolver \"%s\" -- --warn-shadowing\n\n\n// This file tests the behavior where the Resolver reports some warnings\n// but no errors.  In the case of errors, resolution does not continue\n// to clone modules and resolve them, but the cloning does proceed if there\n// are only warnings.  Dafny should report only one copy of these warnings,\n// and warnings are therefore turned off when processing the clones.  This\n// test file makes sure the warnings don't appear twice.\n\nmethod M(x: int)\n{\n  var x := 10;  // warning: this shadows the parameter 'x'\n}\n\nclass C<T> {\n  var u: T\n  method P<T>(t: T)  // warning: this shadows the type parameter 'T'\n  constructor (t: T) {\n    u := t;\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/formatting2.dfy", "dafny": "// RUN: %exits-with 1 %baredafny format --use-basename-for-filename --print \"%S/unexisting.dfy\" > \"%t.raw\"\n// RUN: %sed 's#%S##g' \"%t.raw\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n}\n"}
{"file": "../dafny/Test/dafny0/NameclashesCompile.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  var r0, r1;\n\n  var d := Ctor(15);\n  r0 := d.ToString();\n  r1 := d.GetHashCode();\n  print r0, \" \", r1, \"\\n\";\n\n  var c := CoCtor(15);\n  r0 := c.ToString();\n  r1 := c.GetHashCode();\n  print c.c, \" \", c.d, \" \", c.Computer(), \" \";\n  print r0, \" \", r1, \"\\n\";\n\n  var n: NameclashNew := 3;\n  r0 := n.ToString();\n  r1 := n.GetHashCode();\n  print r0, \" \", r1, \"\\n\";\n}\n\ndatatype Nameclash = Ctor(x: int)\n{\n  method ToString() returns (o: real) { return 15.0; }\n  method GetHashCode() returns (o: real) { return 15.1; }\n}\n\ncodatatype NameclashCo = CoCtor(x: int)\n{\n  const c: int := 94\n  const d: int := 99\n  function Computer(): real { 0.8 }\n  method Get() returns (u: int) { return 79; }\n  method ToString() returns (o: real) { return 14.3; }\n  method GetHashCode() returns (o: real) { return 14.4; }\n}\n\nnewtype NameclashNew = x | -18 <= x < 20\n{\n  method ToString() returns (o: real) { return 18.9; }\n  method GetHashCode() returns (o: real) { return 18.92; }\n}\n"}
{"file": "../dafny/Test/dafny0/snapshots/Snapshots5.run.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /verifySnapshots:2 /traceCaching:1 %S/Inputs/Snapshots5.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/dafny0/snapshots/Snapshots8.run.dfy", "dafny": "\n// RUN: %exits-with 4 %dafny /compile:0 /verifySnapshots:3 /traceCaching:1 %S/Inputs/Snapshots8.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/dafny0/snapshots/Snapshots0.run.dfy", "dafny": "// RUN: %exits-with 4 %dafny /compile:0 /deprecation:0 /verifySnapshots:2 /traceCaching:1 %S/Inputs/Snapshots0.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/dafny0/snapshots/Snapshots4.run.dfy", "dafny": "// RUN: %exits-with 4 %dafny /compile:0 /verifySnapshots:2 /traceCaching:1 %S/Inputs/Snapshots4.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/dafny0/snapshots/Inputs/Snapshots1.v0.dfy", "dafny": "method M()\n{\n  N();\n  assert false;\n}\n\nmethod N()\n  ensures P();\n\npredicate P()\n{\n  false\n}\n"}
{"file": "../dafny/Test/dafny0/snapshots/Inputs/Snapshots5.v0.dfy", "dafny": "method M()\n{\n  N();\n  if (*)\n  {\n\n  }\n  else\n  {\n    assert (forall b: bool :: b || !b) || 0 != 0;\n  }\n  N();\n  assert (forall b: bool :: b || !b) || 3 != 3;\n  if (*)\n  {\n\n  }\n  else\n  {\n    assert (forall b: bool :: b || !b) || 1 != 1;\n  }\n}\n\n\nmethod N()\n  ensures (forall b: bool :: b || !b) || 2 != 2;\n"}
{"file": "../dafny/Test/dafny0/snapshots/Inputs/Snapshots5.v1.dfy", "dafny": "method M()\n{\n  N();\n  if (*)\n  {\n\n  }\n  else\n  {\n    assert (forall b: bool :: b || !b) || 0 != 0;\n  }\n  N();\n  assert (forall b: bool :: b || !b) || 3 != 3;\n  if (*)\n  {\n\n  }\n  else\n  {\n    assert (exists b: bool :: true) || 4 != 4;\n  }\n  assert (exists b: bool :: true) || 5 != 5;\n}\n\n\nmethod N()\n  ensures (forall b: bool :: b || !b) || 2 != 2;\n"}
{"file": "../dafny/Test/dafny0/snapshots/Inputs/Snapshots0.v0.dfy", "dafny": "method foo()\n{\n  bar();\n  assert false;\n}\n\nmethod bar()\n  ensures false;\n"}
{"file": "../dafny/Test/dafny0/snapshots/Inputs/Snapshots4.v0.dfy", "dafny": "method M()\n{\n  if (*)\n  {\n\n  }\n  else\n  {\n    assert 0 == 0;\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/snapshots/Inputs/Snapshots2.v0.dfy", "dafny": "method M()\n{\n  N();\n  assert false;\n}\n\nmethod N()\n  ensures P();\n\npredicate P()\n  ensures P() == Q();\n\npredicate Q()\n  ensures Q() == R();\n\npredicate R()\n{\n  false\n}\n"}
{"file": "../dafny/Test/dafny0/snapshots/Snapshots1.run.dfy", "dafny": "// RUN: %exits-with 4 %dafny /compile:0 /deprecation:0 /verifySnapshots:2 /traceCaching:1 %S/Inputs/Snapshots1.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/dafny0/snapshots/Snapshots2.run.dfy", "dafny": "// RUN: %exits-with 4 %dafny /compile:0 /deprecation:0 /verifySnapshots:2 /traceCaching:1 %S/Inputs/Snapshots2.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/dafny0/snapshots/Snapshots3.run.dfy", "dafny": "// RUN: %exits-with 4 %dafny /compile:0 /verifySnapshots:2 /traceCaching:1 %S/Inputs/Snapshots3.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/dafny0/snapshots/Snapshots7.run.dfy", "dafny": "// RUN: %dafny /compile:0 /verifySnapshots:2 /traceCaching:1 %S/Inputs/Snapshots7.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// XFAIL: *\n// FIXME - need to regenerate the snapshots\n"}
{"file": "../dafny/Test/dafny0/snapshots/Snapshots6.run.dfy", "dafny": "// RUN: %dafny /compile:0 /verifySnapshots:2 /traceCaching:1 %S/Inputs/Snapshots6.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// XFAIL: *\n// FIXME : Need to fix the snapshot\n"}
{"file": "../dafny/Test/dafny0/snapshots/Snapshots9.run.dfy", "dafny": "// RUN: %exits-with 4 %dafny /compile:0 /verifySnapshots:3 /traceCaching:1 %S/Inputs/Snapshots9.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/dafny0/ReturnTests.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass N\n{\n   var i: int;\n   method newN(n: N)\n      modifies this, n;\n   {\n      n.i := 1;\n      i := 1;\n   }\n   method safe(n: N)\n      modifies this;\n   {\n      i := n.i;\n   }\n}\n\nmethod m(v: int, n: N) returns (r: int)\n   modifies n;\n   ensures r == v;\n{\n   r := v; // implict return still works.\n}\n\nmethod testing1() returns (a: int, b: set<int>)\n{\n   return 1, {1, 2, 3}; // type checking\n}\nmethod testing2() returns (a: int, b: int)\n   ensures a == 1 && b == 2;\n{\n   a, b := 2, 1;\n   return b, a; // test of parallel assignment.\n}\nmethod testing3() returns (a: int, b: int)\n   ensures a == 1 && b == 2;\n{\n   a, b := 2, 1; // these are wrong\n   if (true)\n   {\n      var a, b := 3, 4;\n      return 1, 2;// return updates non-shadowed, formal parameters correctly\n   }\n}\n\nmethod testing4(nnn: N) returns (n: N)\n{\n   return new N.safe(nnn); // only modifies 'this', which is the fresh N\n}\n\nmethod testing5() returns (r: int)\n   ensures r == 2;\n{\n   r := 2;\n   return; // sanity check.\n}\n\niterator yieldTesting() yields (a: int, b: int)\n   yield ensures a == 1 && b == 2;\n{\n   a, b := 2, 1; // these are wrong\n   if (true)\n   {\n      var a, b := 3, 4;\n      yield 1, 2;// return updates non-shadowed, formal parameters correctly\n   }\n}\n"}
{"file": "../dafny/Test/dafny0/NoTypeArgs.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype List<T> = Nil | Cons(hd: T, tl: List)\n\nmethod M0() {\n  var l: List;\n  l := Cons(5, Nil);\n  assert l.hd == 5;\n\n  var k: MyClass<bool>;\n  k := new MyClass;\n  k.data := false;\n\n  var h := new MyClass;\n  h.data := false;\n\n  var y := new MyClass.Init(120);\n  var z: int := y.data;\n}\n\nmethod M1() {  // same thing as above, but with types filled in explicitly\n  var l: List<int>;\n  l := Cons(5, Nil);\n  assert l.hd == 5;\n\n  var k: MyClass<bool>;\n  k := new MyClass<bool>;\n  k.data := false;\n\n  var h := new MyClass<bool>;\n  h.data := false;\n\n  var y := new MyClass<int>.Init(120);\n  var z: int := y.data;\n}\n\nclass MyClass<G(0)> {\n  var data: G\n  method Init(g: G)\n    modifies this\n  {\n    data := g;\n  }\n}\n\n// ---------------------------------------------------\n\n// The followinng functions and methods are oblivious of the fact that\n// List takes a type parameter (except Lemma, which needs it).\n\nghost function concat(xs: List, ys: List): List\n{\n  match xs\n  case Nil => ys\n  case Cons(x, tail) => Cons(x, concat(tail, ys))\n}\n\nghost function reverse(xs: List): List\n{\n  match xs\n  case Nil => Nil\n  case Cons(t, rest) => concat(reverse(rest), Cons(t, Nil))\n}\n\nlemma Theorem(xs: List)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(t, rest) =>\n    Lemma(reverse(rest), Cons(t, Nil));\n}\n\nlemma Lemma<A>(xs: List, ys: List)\n  ensures reverse(concat(xs, ys)) == concat(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil =>\n    assert forall ws: List<A> {:induction} :: concat(ws, Nil) == ws;\n  case Cons(t, rest) =>\n    assert forall a: List<A>, b, c {:induction} :: concat(a, concat(b, c)) == concat(concat(a, b), c);\n}\n\n// ------ Here are some test cases where the inferred arguments will be a prefix of the given ones\n\nmethod DoAPrefix<A, B, C>(xs: List) returns (ys: List<A>)\n{\n  ys := xs;\n}\n\nghost function FDoAPrefix<A, B, C>(xs: List): List<A>\n{\n  xs\n}"}
{"file": "../dafny/Test/dafny0/InSetComprehension.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nlemma Tests<T>(t: T, uu: seq<T>) returns (z: bool)\n  requires 10 <= |uu| && uu[4] == t\n  ensures !z\n{\n  if {\n    case true =>\n      z := 72 in set i | 0 <= i < 10;\n    case true =>\n      z := -8 in set k: nat | k < 10;\n    case true =>\n      z := 6 in set m | 0 <= m < 10 && Even(m) :: m + 1;\n    case true =>\n      z := t !in set u | u in uu;\n    case true =>\n      z := t !in set u {:autotriggers false} | u in uu :: Id(u);\n  }\n}\n\nlemma TestsWhereTriggersMatter<T>(t: T, uu: seq<T>) returns (z: bool)\n  requires 10 <= |uu| && uu[4] == t\n  ensures z\n{\n  if {\n    case true =>\n      z := 7 in set i | 0 <= i < 10;\n    case true =>\n      z := 8 in set k: nat | k < 10;\n    case true =>\n      // In the line below, auto-triggers should pick Even(m)\n      z := 5 in set m | 0 <= m < 10 && Even(m) :: m + 1;\n      // a necessary lemma:\n      assert Even(4);\n    case true =>\n      z := t in set u | u in uu;\n    case true =>\n      z := t in set u {:autotriggers false} | u in uu :: Id(u);\n  }\n}\n\nghost function Id<T>(t: T): T { t }\nghost predicate Even(x: int) { x % 2 == 0 }\n\nclass Container<T> {\n  ghost var Contents: set<T>\n  var elems: seq<T>\n\n  method Add(t: T)\n    requires Contents == set x | x in elems\n    modifies this\n    ensures Contents == set x | x in elems\n  {\n    elems := elems + [t];\n    Contents := Contents + {t};\n  }\n}\n\nclass IntContainer {\n  ghost var Contents: set<int>\n  var elems: seq<int>\n\n  method Add(t: int)\n    requires Contents == set x | x in elems\n    modifies this\n    ensures Contents == set x | x in elems\n  {\n    elems := elems + [t];\n    Contents := Contents + {t};\n  }\n}\n\nmethod UnboxedBoundVariables(si: seq<int>)\n{\n  var iii := set x | x in si;\n  var ti := si + [115];\n  var jjj := set y | y in ti;\n  assert iii + {115} == jjj;\n\n  var nnn := set n: nat | n in si;\n  if forall i :: 0 <= i < |si| ==> 0 <= si[i] {\n    assert nnn == iii;\n  }\n}\n\n"}
{"file": "../dafny/Test/dafny0/RangeCompilation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nnewtype Byte = x | 0 <= x < 256\npredicate GoodByte(b: Byte) {\n  b % 3 == 2\n}\npredicate GoodInteger(i: int) {\n  i % 5 == 4\n}\n\nmethod Main() {\n  assert GoodByte(11) && GoodInteger(24);\n  var b: Byte :| GoodByte(b);\n  var i: int :| 0 <= i < 256 && GoodInteger(i);\n  print \"b=\", b, \"  i=\", i, \"\\n\";\n  var m0 := new MyClass;\n  var m17 := new M17.AnotherClass();\n}\n\nclass MyClass { }\n\nmodule M17 {\n  class AnotherClass {\n    constructor () { }\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/EqualityTypesCompile.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype List<A> = Nil | Cons(A, List) | ICons(int, List)\ndatatype TwoLists<A> = Two(List, List)\ncodatatype Co<A> = Atom(A) | CoCons(int, Co) | CoConsA(A, Co)\n\nmethod M<A>(xs: List, a: A) returns (r: bool)\n{\n  var u := 6;\n  r := xs == Nil;\n  r := xs == ICons(4, ICons(2, Nil));\n  r := xs == ICons(2, ICons(u, Nil));\n}\n\nmethod N<A>(pr: (A, List<A>), a: A, pair: TwoLists<A>) returns (r: bool)\n{\n  r := pair == Two(ICons(4, Nil), Nil);\n}\n\nmethod H<A,B(==)>(c: Co<A>, d: Co<B>, a: A, b: B) returns (r: bool)\n{\n  r := d == Atom(b);\n  r := d == CoCons(10, CoCons(8, Atom(b)));\n}\n\nfunction CoValue<A>(x: A): Co<A>\n{\n  CoConsA(x, CoValue(x))\n}\n\nmethod Main() {\n  // the following tests mainly check that all comparisons terminate\n  // and don't crash\n  var co := CoValue(3.14);\n  var xs := Cons(co, Nil);\n  var r;\n  r := M(xs, co);\n  print \"from M: \", r, \"\\n\";\n  r := N((co, xs), co, Two(xs, xs));\n  print \"from N: \", r, \"\\n\";\n  r := H(co, co, 2.7, 2.7);\n  print \"from H: \", r, \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny0/DafnyLib.dfy", "dafny": "// RUN: echo Compiled elsewhere\n// This file is part of the test suite. It is compiled by DafnyLibClient.dfy,\n// since the DLL from this file is a dependency of DafnyLibClient.\n\n// Regression test for the way the compiler used to disambiguate modules with the same\n// name, but in different locations in the nested module tree: it added a _##_ prefix\n// with the index of the module in the topographical sorted list of modules.\n// That index would change based on what other modules where in scope, though, so\n// it wouldn't be the same across DLLs. The abstract compiler now passed the fully-qualified\n// name, separated with periods. It's up to the target language compiler to create valid\n// module identifiers from that somehow.\n// This module is here and specifically BEFORE the nested one so that it makes the\n// module index different between the DLL and the client.\nmodule AmbiguousNestedModule {}\n\nmodule Library {\n  import OpaqueFunctions\n  import AutoGhostRegression\n  import ExternCode\n\n  method EntryPoint() {\n    print \"hello from the library\\n\";\n\n    OpaqueFunctions.IsFive();\n    AutoGhostRegression.Q();\n    ExternCode.C();\n  }\n\n  module AmbiguousNestedModule {\n    method EntryPoint() {\n      print \"hello from a nested module\\n\";\n    }\n  }\n}\n\nmodule {:extern \"ExternCode\"} ExternCode {\n  method {:extern} C()\n}\n\n// ---------- regression tests ---------------\n\nmodule OpaqueFunctions {\n  // At one time, the Dafny program stashed into the DLL as metadata\n  // had included the reveal_ functions, which resulted in duplicate-definition\n  // errors when the DLL was read back in.\n  ghost function {:opaque} Five(): int { 5 }\n  lemma IsFive()\n    ensures Five() == 5\n  {\n    reveal Five();\n  }\n}\n\nmodule AutoGhostRegression {\n  method P() returns (a: int, ghost b: int) {\n    a, b := 9, 11;\n  }\n  method NeedsNonGhost(u: int) {\n  }\n  method Q() {\n    var u, v := P();  // this auto-declares \"v\" as ghost\n    // At one time, the line above would pretty print as\n    //     ghost var u, v := P();\n    // because _at least_ one of the local variables declared\n    // was ghost. That results in Dafny code that won't resolve.\n    // Instead, the \"ghost\" keyword should be printed only when\n    // _all_ of the local variables declared are ghost.\n    NeedsNonGhost(u);\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/AllLiteralsAxiom.dfy", "dafny": "// RUN: %dafny /compile:0 /proverOpt:O:smt.qi.eager_threshold=30 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule NeedsAllLiteralsAxiom {\n  // The following test shows that there exist an example that\n  // benefits from the all-literals axiom.  (It's not clear how\n  // important such an example is, nor is it clear what the cost\n  // of including the all-literals axiom is.)\n\n  function trick(n: nat, m: nat): nat\n    decreases n  // note that m is not included\n  {\n    if n < m || m==0 then n else trick(n-m, m) + m\n  }\n\n  lemma lemma_trick(n: nat, m: nat)\n    ensures trick(n, m) == n\n  {\n  }\n\n  lemma calc_trick(n: nat, m: nat)\n    ensures trick(100, 10) == 100\n  {\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/TypeMembers.dfy", "dafny": "// RUN: %testDafnyForEachCompiler --refresh-exit-code=0 \"%s\" -- --relax-definite-assignment\n\nmethod Main() {\n  BasicTests();\n  MoreTests();\n}\n\n// ---------- basic tests ----------\n\nmethod BasicTests() {\n  var t := Yes;\n  var r := t.W();  // 10\n  var q := t.Q() + DaTy.Q();  // 13 + 13\n  print t, \" \", r, \" \", q, \"\\n\";\n\n  var p: Pos := 8; print p, \" \";\n  var u := Pos.Func(p); assert u == 11; print u, \" \";\n  var v := p.Gittit(); assert v == 10; print v, \" \";\n  var w := Pos.Method(p); assert w == 11; print w, \" \";\n  var x := p.Collect(); assert x == 10; print x, \" \";\n  print \"\\n\";\n}\n\ndatatype DaTy = Yes {\n  function W(): int { 10 }\n  static function Q(): int { 13 }\n}\n\nnewtype Pos = x | 0 < x witness 1\n{\n  static function Func(y: Pos): int { (y + 3) as int }\n  function Gittit(): int { (this + 2) as int }\n  static method Method(y: Pos) returns (r: int) ensures r == (y + 3) as int { return (y + 3) as int; }\n  method Collect() returns (r: int) ensures r == (this + 2) as int { return (this + 2) as int; }\n}\n\n// ---------- more comprehensive tests ----------\n\nmethod MoreTests() {\n  var d := Business(true, 5);\n  var v := d.G(5);  // 10\n  var u := Dt<int>.G(7);  // 14\n  print d.F(10), \" \", v, \" \", u, \"\\n\";  // 35 10 14\n  print Dt<real>.g, \" \", d.g, \"\\n\";  // 22 22\n  var yy, dd := d.M(93);\n  print yy, \" \", dd, \"\\n\";  // 9 Business(false, 5)\n  var a0 := d.P(54);\n  var a1 := Dt<bool>.P(55);\n  print a0, \" \", a1, \"\\n\";  // 76 77\n  print d.c, \"\\n\";  // 19\n\n  var c: Co<real> := Cobalt;\n  print Co<bv11>.g, \" \", c.g, \"\\n\";  // 0 0\n  print c.F(2), \" \", Co<bv11>.G(70), \" \", c.G(71), \"\\n\";  // 19 82 83\n  var c';\n  yy, c' := c.M(93);\n  print yy, \" \", c, \"\\n\";  // 93 Cobalt\n  a0 := c.P(54);\n  a1 := Co<bool>.P(55);\n  print a0, \" \", a1, \"\\n\";  // 27 27\n  print c.c, \"\\n\";  // 18\n\n  var pr: Primes := 11;\n  print pr, \" \", Primes.g, \" \", pr.g, \" \", pr.c, \"\\n\";  // 11 18 18 22\n  print pr.F(2), \" \", Primes.G(70), \" \", pr.G(71), \"\\n\";  // 15 30 29\n  yy, pr := pr.M(95);\n  print yy, \" \", pr, \"\\n\";  // 95 11\n  a0 := pr.P(54);\n  a1 := Primes.P(55);\n  print a0, \" \", a1, \"\\n\";  // 162 165\n\n  var sm: Small := 11;\n  print sm, \" \", Small.g, \" \", sm.g, \" \", sm.c, \"\\n\";  // 11 18 18 3\n  print sm.F(2), \" \", Small.G(70), \" \", sm.G(71), \"\\n\";  // 15 30 29\n  yy, sm := sm.M(95);\n  print yy, \" \", sm, \"\\n\";  // 95 11\n  a0 := sm.P(54);\n  a1 := Small.P(55);\n  print a0, \" \", a1, \"\\n\";  // 162 165\n}\n\ndatatype Dt<A> = Blue | Bucket(diameter: real) | Business(trendy: bool, a: A)\n{\n  const c: int := if this.Blue? then 18 else 19\n  static const g: int := 22\n  function F(x: int): int {\n    x + if this.Bucket? then this.diameter.Floor else 25\n  }\n  static function G(x: int): int {\n    2 * x\n  }\n  method M(x: int) returns (y: int, d: Dt<A>) {\n    if this == Blue {\n      y := x;\n    } else {\n      y := 9;\n    }\n    var z := RecursiveZero(3);\n    y := y + z;\n    z := StaticRecursiveZero(3);\n    y := y + z;\n    match this\n    case Blue =>\n      assert y == x;\n      d := Bucket(0.0);\n    case Bucket(dm) =>\n      d := this.(diameter := this.diameter + 2.0);\n    case Business(t, a) =>\n      d := this.(trendy := !t);\n  }\n  static method P(x: int) returns (y: int) {\n    y := x + g;\n  }\n  twostate predicate Toop() { old(this) == this } // warning: old has no effect\n  twostate lemma Tool() { }\n  least predicate IndP() { true }\n  greatest predicate CoP() { true }\n  method RecursiveZero(x: int) returns (z: int) ensures z == 0 decreases x != 0 {\n    if x == 0 { return 0; } else { z := RecursiveZero(0); }\n  }\n  static method StaticRecursiveZero(x: int) returns (z: int) ensures z == 0 decreases x != 0 {\n    if x == 0 { return 0; } else { z := StaticRecursiveZero(0); }\n  }\n}\ncodatatype Co<A> = Cobalt | Continues(next: Co<A>)\n{\n  const c: int := if this.Cobalt? then 18 else 19\n  static const g: int\n  function F(x: int): int { 19 }\n  static function G(x: int): int { x + 12 }\n  method M(x: int) returns (y: int, d: Co<int>) {\n    if this == Cobalt {\n      y := x;\n    } else {\n      y := 9;\n    }\n    var z := RecursiveZero(3);\n    y := y + z;\n    z := StaticRecursiveZero(3);\n    y := y + z;\n    d := Cobalt;\n  }\n  static method P(x: int) returns (y: int) {\n    y := x / 2;\n  }\n  method RecursiveZero(x: int) returns (z: int) ensures z == 0 decreases x != 0 {\n    if x == 0 { return 0; } else { z := RecursiveZero(0); }\n  }\n  static method StaticRecursiveZero(x: int) returns (z: int) ensures z == 0 decreases x != 0 {\n    if x == 0 { return 0; } else { z := StaticRecursiveZero(0); }\n  }\n}\n\nnewtype Primes = x | 2 <= x && forall y :: 2 <= y < x ==> x % y != 0 witness 2\n{\n  const c: int := this as int * 2\n  static const g: int := 18\n  function F(x: int): int { 2 * x + this as int }\n  static function G(x: int): int { 100 - x }\n  method M(x: int) returns (y: int, d: Primes) {\n    var z := RecursiveZero(3);\n    return x + z, this;\n  }\n  static method P(x: int) returns (y: int) {\n    var z := StaticRecursiveZero(3);\n    y := 3*x + z;\n  }\n  method RecursiveZero(x: int) returns (z: int) ensures z == 0 decreases x != 0 {\n    if x == 0 { return 0; } else { z := RecursiveZero(0); }\n  }\n  static method StaticRecursiveZero(x: int) returns (z: int) ensures z == 0 decreases x != 0 {\n    if x == 0 { return 0; } else { z := StaticRecursiveZero(0); }\n  }\n}\n\nnewtype Small = x | 0 <= x < 25\n{\n  const c := this as int % 4\n  static const g: int := 18\n  function F(x: int): int { 2 * x + this as int }\n  static function G(x: int): int { 100 - x }\n  method M(x: int) returns (y: int, d: Small) {\n    var z := RecursiveZero(3);\n    return x + z, this;\n  }\n  static method P(x: int) returns (y: int) {\n    var z := StaticRecursiveZero(3);\n    y := 3*x + z;\n  }\n  method RecursiveZero(x: int) returns (z: int) ensures z == 0 decreases x != 0 {\n    if x == 0 { return 0; } else { z := RecursiveZero(0); }\n  }\n  static method StaticRecursiveZero(x: int) returns (z: int) ensures z == 0 decreases x != 0 {\n    if x == 0 { return 0; } else { z := StaticRecursiveZero(0); }\n  }\n}\n\n// TODO: test recursive dependencies\n"}
{"file": "../dafny/Test/dafny0/GhostPrint.dfy", "dafny": "// RUN: %dafny /dafnyVerify:0 /compile:0 /env:0 /dprint:\"%t.dprint.dfy\" \"%s\"\n// RUN: %dafny /dafnyVerify:0 /compile:0 /env:0 \"%t.dprint.dfy\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod M() {\n  ghost var h := var ta := F(); 5;\n  var j := ghost var tb := F(); 5;\n  assert h == j;\n}\n\nghost function F(): int { 5 }\n\n"}
{"file": "../dafny/Test/dafny0/RuntimeTypeTests2.dfy", "dafny": "// RUN: %exits-with 3 %dafny /compile:3 \"%s\" /compileTarget:cs > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// The errors in this file are produced by the compiler\n\npredicate ItWasReal(r: real)\n{\n  r == 44.1985\n}\n\nmethod AssignSuchThat() returns (a: int, b: real)\n{\n  a :| a % 5 == 0 && a % 7 == 0;\n  assert ItWasReal(44.1985);\n  b :| ItWasReal(b);  // error: compile doesn't know how to compile this, even though the verifier can check there's a value\n}\n\nmethod LetSuchThat() returns (x: int, y: real)\n{\n  x := var a :| a % 5 == 0 && a % 7 == 0 && 0 <= a && a < 30; a;\n  assert ItWasReal(44.1985);\n  y := var b :| ItWasReal(b); b;  // error: compile doesn't know how to compile this, even though the verifier can check there's a value\n}\n"}
{"file": "../dafny/Test/dafny0/JavaUseRuntimeLib.dfy", "dafny": "// RUN: %dafny \"%s\" /useRuntimeLib /out:%S/Output/DafnyConsole.jar /compileTarget:java > \"%t\"\n// RUN: java -cp %binaryDir/DafnyRuntime.jar%{pathsep}%S/Output/DafnyConsole.jar DafnyConsole >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule DafnyConsoleMod { // TODO if we name this DafnyConsole, then Java compilation fails\n  method Main() {\n    print \"bye\\n\";\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/ForbidNondeterminismCompile.dfy", "dafny": "// RUN: ! %baredafny build %args --enforce-determinism \"%s\" --target cs > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass C { // error: constructor-less class not allowed by determinism rules\n  var f: real\n}\n\npredicate P(z: int) { true }\n\nmethod M(c: C)\n  modifies c\n  decreases *\n{\n  var x := 3;  // fine\n  var y;  // this statement by itself is nondeterministic, but the verifier catches bad uses of \"y\"\n  y := 4;\n  y := *;  // error: nondeterministic\n  x, y := x, *;  // error: nondeterministic\n  y :| true;  // error: nondeterministic\n  if * {  // error: nondeterministic\n    x := x + 1;\n  }\n  if {  // error: nondeterministic\n    case true =>  x := x + 1;\n    case true =>  x := x + 2;\n  }\n  if c.f < 500.0 {\n    if {  // a one-case if is always deterministic\n      case c.f < 1000.0 => x := x + 1;\n    }\n  }\n  if z :| 10 <= z < 15 && P(z) {  // error: nondeterministic\n    x := z;\n  }\n  while *  // error: nondeterministic\n    decreases *\n  {\n    x := x + 1;\n  }\n  while  // error: nondeterministic\n    decreases if x <= 100 then 100-x else x\n  {\n    case x < 100 => x := x + 1;\n    case 100 < x => x := x - 1;\n  }\n  var a := new int[100](_ => 750);\n  forall i | 0 <= i < a.Length {\n    a[i] := *;  // error: nondeterministic\n  }\n  modify c;  // error: nondeterministic\n  modify c {  // fine (except that a modify statement with a block statement is deprecated)\n  }\n}\n\nmethod OutputParameters0(x: int) returns (s: int, t: int)\n{\n  return x, x+45;  // yes, this is legal\n}\n\n\nmethod DeclWithHavoc(yes: bool)\n  requires yes\n{\n  var b: int := *;  // error: assignment is nondeterministic (despite the fact that b is never used)\n  var c: int; // fine, since the declaration alone is not forbidden\n  var d: int;\n  if yes {\n    var e := b; // error: use of b before it has been assigned\n  } else {\n    // the verifier would complain about the next statement, but it knows the statement isn't reachable\n    var e := d;\n  }\n}\n\niterator IterWeird() yields ()  // no yields parameters, so allowed\n{\n}\n\niterator Iter() yields (x: int)  // error: not allowed by determinism rules\n{\n}\n\nclass C' { // fine, since there are no fields\n}\n\nclass C'' { // fine, since the const has a RHS\n  const u := 15\n}\n\nclass C''' { // error: constructor-less class not allowed by determinism rules\n  const u: int\n}\n\nclass D {\n  var f: real // fine, since the class has a constructor\n  const u: int // fine, since the class has a constructor\n  const w := 15\n\n  constructor D() {\n    f := 0.9;\n    u := 90;\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/GhostITECompilation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --function-syntax:4 --relax-definite-assignment\n\nfunction F(x: nat, ghost y: nat): nat\n{\n  if x == 0 then\n    0\n  else if y != 0 then\n    F(x, y - 1) // this branch is not compiled (which even makes F auto-accumulator tail recursive)\n  else\n    F(x - 1, 60) + 13\n}\n\nlemma AboutF(x: nat, y: nat)\n  ensures F(x, y) == 13 * x\n{\n}\n\nfunction G(x: nat, ghost y: nat): nat\n{\n  if x == 0 then\n    0\n  else if y != 0 then\n    var z := x + x;\n    var a, b, c := 100, if x < z then G(x, y - 1) else G(x, y - 1), 200;\n    assert a + b + c == G(x, y - 1) + 300;\n    b // this branch is not compiled (which even makes G auto-accumulator tail recursive)\n  else\n    G(x - 1, 60) + 13\n}\n\n// Ostensibly, the following function is tail recursive. But the ghost-ITE optimization\n// removes the tail call. This test ensures that the unused setup for the tail optimization\n// does not cause problems.\nfunction H(x: int, ghost y: nat): int {\n  if y == 0 then\n    x\n  else\n    H(x, y - 1)\n}\n\n// Like function H, function J looks like it's tail recursive. The compiler probably will\n// emit the tail-call label, even though the tail-call is never taken.\nfunction J(x: int): int {\n  if true then\n    x\n  else\n    J(x)\n}\n\n// The following function would never verify, and its execution wouldn't terminate.\n// Nevertheless, we'll test here that it compiles into legal target code.\nfunction {:verify false} K(x: int, ghost y: nat): int {\n  K(x, y - 1)\n}\n\nmethod Main() {\n  print F(5, 3), \"\\n\"; // 65\n  print G(5, 3), \"\\n\"; // 65\n  print H(65, 3), \"\\n\"; // 65\n  print J(65), \"\\n\"; // 65\n}\n"}
{"file": "../dafny/Test/dafny0/Constant.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nconst one:int := 1\nconst two:int := one * 2\nconst three:int := one + two\nconst Pi:real := 3.14\n\nclass Calendar {\n  static const months:int := 12\n  static const weeks:int := 52\n}\n\nmethod Main() {\n  print \"one := \", one, \"\\n\";\n  print \"two := \", two, \"\\n\";\n  print \"three := \", three, \"\\n\";\n  assert three == 3;\n  print \"Pi := \", Pi, \"\\n\";\n  assert Pi == 3.14;\n  var weeks := Calendar.weeks;\n  print \"months := \", Calendar.months, \"\\n\";\n  print \"weeks := \", weeks, \"\\n\";\n  assert weeks == 52;\n\n  var c := new C;\n  var tu := c.M();  // 11\n  print tu, \" \";\n  print c.G(c), \" \";  // 16\n  print c.H(c), \" \";  // 173\n  print C.x, \" \";  // 6\n  var g := new Generic<real>;\n  var putItHere := g.y;\n  print putItHere, \" \";  // 63\n  var go := g.M();\n  print go, \"\\n\";  // 63\n\n  var noRhs := new NoRHS;\n  print \"noRhs.y = \", noRhs.y, \"\\n\";\n\n  var cl := new Class;\n  cl.Test();\n  var ii := new InstanceInit(13);\n  print ii.x0, \" \", ii.x1, \" \", ii.y2, \" \", ii.y3, \" \", ii.r, \"\\n\";  // 93, 7, 89, 12, 8.54\n\n  print mmgg, \" \", UninterpretedStaticsTrait.mmtt, \" \", UninterpretedStaticsClass.mmcc, \"\\n\";\n\n  InitializationDependencies.PrintEm();\n}\n\nclass C {\n  static const x: int := y+1\n  static const y: int := 5\n  var z: int\n  static function G(c: C): int\n    ensures G(c) == 16\n  {\n    x + y + c.y\n  }\n\n  const a: int := b+2\n  const b: int := 50\n  function H(c: C): int\n    ensures H(c) == 50 + 52 + 50 + 6 + 5 + 5 + 5 == 173\n  {\n    a + b + c.b + x + y + c.y + C.y\n  }\n\n  method M() returns (r: int)\n    ensures r == 11\n  {\n    r := x + y;\n  }\n}\n\nclass Generic<G> {\n  const y: int := 63\n  method M() returns (q: int)\n    ensures q == 63\n  {\n    q := this.y;\n  }\n}\n\nnewtype Six = x | 6 <= x witness 6\n\nclass NoRHS {\n  const y: Six\n}\n\n// ---------- traits --------------------\n\ntrait Trait {\n  const x0: Six\n  const x1: Six := 7\n\n  static const y: Six := 7\n}\n\nclass Class extends Trait {\n  method Test() {\n    assert x1 == 7 && y == 7;\n    print x0, \" \", x1, \" \", y, \"\\n\";\n  }\n}\n\nmethod MMethod(tr: Trait?) {\n  assert Trait.y == 7;\n  assert tr.y == 7;\n  assert tr == null || tr.x1 == 7;\n}\n\n// ---------- instanced-based initialization --------\n\nclass InstanceInit extends Trait {\n  const y2: Six\n  const y3: Six := 12\n  const N: int := 20\n\n  var r: real\n\n  constructor (u: Six)\n    requires 10 <= u\n  {\n    x0 := 80 + u;\n    var arr := new real[N];\n    arr[8] := 2.7;\n    r := arr[8];\n    y2 := 77 + y3;\n    new;\n    assert x0 == u + 80 && x1 ==7;\n    assert y2 == 89 && y3 == 12;\n    assert arr.Length == 20;\n    arr[9] := 3.14;\n    r := r + arr[8] + arr[9];  // 8.54\n  }\n}\n\n// ---------- class- and module-level const's without RHS --------\n\nconst mmgg: Six\n\ntrait UninterpretedStaticsTrait {\n  static const mmtt: Six\n}\n\nclass UninterpretedStaticsClass extends UninterpretedStaticsTrait {\n  static const mmcc: Six\n}\n\n// ---------- test type/allocation axiom of const fields --------\n\ntype byte = x | 0 <= x < 256\n\nclass MyClass {\n  const B: array<byte>\n\n  method M()\n  {\n    var x: array?<byte> := B;\n    var y: array<byte> := x;  // this line generates a proof obligation, but it should pass\n  }\n}\n\n// ---------- static const fields in a generic class have its own axioms --------\n\nclass MyOnePurposeClass {\n  static const z: int\n  static const w: int := 76\n  static const self: MyOnePurposeClass?\n}\n\nclass MyGenericClass<X(00), Y(00)> {\n  ghost static const x: X\n  ghost static const y: Y\n  static const z: int\n  static const w: int := 76\n  static const self: MyGenericClass?<X,Y>\n  static const almostSelf: MyGenericClass?<Y,X>\n  static const another: MyGenericClass?<byte,seq<X>>\n}\n\n// ---------- initialization dependencies --------\n\nmodule InitializationDependencies {\n  class C {\n    static const a: int := b\n    static const b: int := D.m\n    static const c: int := b\n  }\n\n  class D {\n    static const m: int := 20\n  }\n\n  class R {\n    const a: int := b + b\n    const b: int := this.m\n    const c: int := b\n\n    const m: int := 21\n\n    const n: int := F(b)\n    function F(nn: int): int {\n      2 * nn + C.b\n    }\n  }\n\n  method PrintEm()\n  {\n    print C.a, \" \";\n    print C.b, \" \";\n    print C.c, \"\\n\";\n    print D.m, \"\\n\";\n    var r := new R;\n    print r.a, \" \";\n    print r.b, \" \";\n    print r.c, \" \";\n    print r.m, \"\\n\";\n    print r.n, \"\\n\";\n  }\n}\n\nmodule A {\n  const x: int := 100\n}\nmodule B refines A {\n  ghost const x: int\n  lemma TestRhsIsInherited() {\n    assert x == 100;\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/ImplicitTypeParamPrint.dfy", "dafny": "// NONUNIFORM: Multiple tests in one, fairly C# specific\n// RUN: %dafny /dafnyVerify:0 /compile:0 /env:0 /rprint:\"%t.dfy\" \"%s\"\n// RUN: %dafny /dafnyVerify:0 /compile:0 /env:0 /printMode:DllEmbed /rprint:\"%t1.dfy\" \"%t.dfy\"\n// RUN: %dafny /env:0 /compile:3 /printMode:DllEmbed /rprint:\"%t2.dfy\" \"%t1.dfy\" > \"%t\"\n// RUN: %diff \"%t1.dfy\" \"%t2.dfy\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype List<T> = Nil | Cons(car: T, cdr: List)\n\nfunction funkyNil(l: List): List\n{\n  match l\n  case Cons(x, y) => funkyNil(y)\n  case Nil => l\n}\n\nmethod H(a: array, l: List)\n{\n  match l\n  case Cons(x, y) =>\n    if a.Length > 0 && a[0] == x {\n    }\n  case Nil =>\n}\n\nmethod Main() {\n  var xs := Cons(28, Cons(22, Cons(28, Cons(5, Nil))));\n  var a := new [][60, 60];\n  var nil := funkyNil(xs);\n  H(a, xs);\n  print nil, \"\\n\";\n  print nonExtendedPrintExpr(xs), \"\\n\";\n}\n\nfunction nonExtendedPrintExpr(l: List): int\n{\n  25 +\n  match l\n  case Cons(x, y) => 10\n  case Nil => 11\n}\n"}
{"file": "../dafny/Test/dafny0/TypeConversionsCompile.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// Note the difference in output in Java's case is due to\n// https://github.com/dafny-lang/dafny/issues/4152\n\nnewtype Handful = x | 0 <= x < 0x8000  // this type turns native\nnewtype Abundance = y | -20 <= y < 0x200_0000_0000  // still fits inside a \"long\"\nnewtype int64 = y | -0x8000_0000_0000_0000 <= y < 0x8000_0000_0000_0000  // exactly a \"long\"\nnewtype EvenInt = x | x % 2 == 0\nnewtype SmallReal = r | -4.0 <= r < 300.0\n\nmethod Print(x: int, n: nat, r: real, handful: Handful, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, noll: bv0)\n{\n  print x, \" \", n, \" \", r, \" \", handful, \" \", even, \" \", small, \" \", b67, \" \", w, \" \", seven, \" \", noll, \"\\n\";\n}\n\nmethod PrintExpected<T>(got: T, expected: T) {\n  print \"got \", got, \", expected \", expected, \"\\n\";\n}\n\nmethod Main()\n{\n  var x: int, n: nat, r: real := 3, 4, 5.0;\n  var handful: Handful, even: EvenInt, small: SmallReal := 5, 6, -1.0;\n  var b67: bv67, w: bv32, seven: bv7, noll: bv0 := 0x7_FFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF, 127, 0;\n  Print(x, n, r, handful, even, small, b67, w, seven, noll);\n\n  //PrintExpected(x as bv67, 3); // disabled because it does not terminate with 4.4.2 Z3\n  PrintExpected(x as bv7, 3);\n  PrintExpected(0 as bv0, 0);\n  PrintExpected(r as int, 5);\n  PrintExpected((2.0*r) as EvenInt, 10);\n  PrintExpected(x as real, 3.0);\n  PrintExpected(even as real, 6.0);\n  PrintExpected((small + 3.0) as Handful, 2);\n  PrintExpected(noll as Handful, 0);\n  PrintExpected(noll as SmallReal, 0.0);\n  PrintExpected(w as real, 4294967295.0);\n  PrintExpected(seven as real, 127.0);\n  PrintExpected(noll as bv32, 0);\n  PrintExpected(noll as bv67, 0);\n  PrintExpected(seven as bv32, 127);\n  PrintExpected(seven as bv67, 127);\n  b67 := 50;\n  //PrintExpected(b67 as bv32, 50); // disabled because it does not terminate with 4.4.2 Z3\n  //PrintExpected(b67 as bv7, 50); // disabled because it does not terminate with 4.4.2 Z3\n  PrintExpected(r as bv67, 5);\n  PrintExpected(r as bv32, 5);\n  PrintExpected(w as bv67, 0xFFFF_FFFF);\n  PrintExpected(r as bv7, 5);\n  PrintExpected(0.0 as bv0, 0);\n  PrintExpected(handful as bv67, 5);\n  PrintExpected(handful as bv32, 5);\n  PrintExpected(handful as bv7, 5);\n  PrintExpected(handful as int, 5);\n  PrintExpected(noll as bv32 as bv0, 0);\n  PrintExpected(noll as bv67 as bv0, 0);\n  PrintExpected(seven as bv32 as bv7, 127);\n  PrintExpected(seven as bv67 as bv7, 127);\n  PrintExpected(handful as real, 5.0);\n  Difficult();\n  // here are some cases whose compilation are optimized\n  var a0: Abundance, a1: Abundance, a2: Abundance, lng: int64;\n  var s := {4.0, 6.3, r, 1000.2};\n  var a := new char[68];\n  handful := 120 as Handful;\n  a0, a1 := -1 as Abundance, 4 as Abundance;\n  a2 := 0x2_0000_0000 as Abundance;\n  w, lng := 634_5789 as bv32, -0x8000_0000_0000_0000 as int64;\n  print handful, \" \", a0, \" \", a1, \" \", a2, \" \", w, \" \", lng, \"\\n\";\n  x, handful, a0, w := |s|, |s| as Handful, |s| as Abundance, |s| as bv32;\n  print x, \" \", handful, \" \", a0, \" \", w, \"\\n\";\n  x, handful, a0, w := a.Length, a.Length as Handful, a.Length as Abundance, a.Length as bv32;\n  print x, \" \", handful, \" \", a0, \" \", w, \"\\n\";\n\n  OrdinalTests();\n}\n\nmethod Difficult() {  // this has been made a separate method, because it was taking too long with /allocated:1\n  if 14 as real as int as bv67 == 14 {  // help the verifier out, because Z3 doesn't know much about int/bv conversions\n    PrintExpected(14 as real as int as bv67 as EvenInt as SmallReal as Handful as bv7 as bv32 as int, 14);  // take that!\n  }\n}\n\nmethod OrdinalTests() {\n  var ord: ORDINAL := 143;\n  var iord := ord as int;\n  var oord := iord as ORDINAL;\n  print \"Something about ORDINAL: \", ord, \" \", iord, \" \", oord, \" \", ord + 4, \" \", ord - 100, \"\\n\";\n  print \"ORDINAL and bitvectors: \", 20 as bv32 as ORDINAL, \" \", 20 as bv300 as ORDINAL, \"\\n\";\n  print ord.IsLimit, \" \", ord.Offset, \" \", ord.IsNat, \"\\n\";\n  ord := 0;\n  print ord.IsLimit, \" \", ord.Offset, \" \", ord.IsNat, \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny0/Deprecation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// This file contains tests for messags about various deprecated features.\n// As those features go away completely, so can the corresponding tests.\n\nmethod Main() {\n  // Test that we get all the way to compilation, despite the deprecation warnings below\n  print \"yet here we are\\n\";\n}\n\n// ----------\n\nclass C {\n  constructor ()\n    modifies this  // deprecation warning: \"this\" is no longer needed in modifies of a constructor\n  {\n  }\n}\n\n// ----------\n\ninductive predicate InductivePredicate()  // deprecation warning: \"inductive predicate\" has been renamed to \"least predicate\"\n{ true }\n\ncopredicate CoPredicate()  // deprecation warning: \"copredicate\" has been renamed to \"greatest predicate\"\n{ true }\n\ninductive lemma InductiveLemma()  // deprecation warning: \"inductive lemma\" has been renamed to \"least lemma\"\n{ }\n\ncolemma CoLemma()  // deprecation warning: \"colemma\" has been renamed to \"greatest lemma\"\n{ }\n\n"}
{"file": "../dafny/Test/dafny0/MoForallCompilation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  TestAggregateArrayUpdate();\n  TestAggregateMultiArrayUpdate();\n  TestAggregateFieldUpdate();\n}\n\n// ------------------------------------------------------------\n\nmethod TestAggregateArrayUpdate() {\n  var a := new real[8](i => i as real - 4.0);\n  var b := new real[8];\n  var c := new bool[8];\n  forall i | 2-i <= 2 && i < a.Length {\n    b[7-i] := a[i] + 4.0;\n  }\n  forall i | 0 <= i < a.Length {\n    c[i] := a[i] < b[i];\n  }\n  PrintArray(a);  // -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0\n  PrintArray(b);  // 7.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0\n  PrintArray(c);  // true true true true true true false false\n}\n\nmethod PrintArray(a: array) {\n  var i := 0;\n  while i < a.Length {\n    print a[i], \" \";\n    i := i + 1;\n  }\n  print \"\\n\";\n}\n\n// ------------------------------------------------------------\n\nmethod TestAggregateMultiArrayUpdate() {\n  var matrix := new int[12,3]((i,j) => i+j);\n  PrintMatrix(matrix);\n\n  // various ways of computing the transpose:\n  var m' := new int[matrix.Length1, matrix.Length0](\n    (i,j) requires 0 <= i < matrix.Length1 && 0 <= j < matrix.Length0 reads matrix => matrix[j,i]);\n  var m0, m1, m2 := Transpose(matrix);\n  PrintMatrix(m');\n  PrintMatrix(m0);\n  PrintMatrix(m1);\n  PrintMatrix(m2);\n\n  print MatrixEqual(m0, m'), \"\\n\";  // true\n  m'[2,2] := 87;\n  print MatrixEqual(m0, m'), \"\\n\";  // false\n}\n\nmethod PrintMatrix(m: array2<int>) {\n  var i := 0;\n  while i < m.Length0 {\n    var j := 0;\n    while j < m.Length1 {\n      print m[i,j], \" \";\n      j := j + 1;\n    }\n    print \"\\n\";\n    i := i + 1;\n  }\n}\n\nmethod Transpose<T(0)>(m: array2<T>) returns (m0: array2<T>, m1: array2<T>, m2: array2<T>)\n  ensures fresh(m0) && fresh(m1) && fresh(m2)\n  ensures MatrixEqual(m0, m1) && MatrixEqual(m0, m2)\n{\n  var X, Y := m.Length1, m.Length0;\n  m0, m1, m2 := new T[X, Y], new T[X, Y], new T[X, Y];\n  forall i,j | 0 <= i < X && 0 <= j < Y {\n    m0[i,j] := m[j,i];\n  }\n  forall i: nat, j: nat | i < X && j < Y {\n    m1[i,j] := m[j,i];\n  }\n  forall i: nat, j | -Y < -j && 3+i < X+3 && j >= 0 {\n    m2[i,j] := m[j,i];\n  }\n}\n\npredicate MatrixEqual<T(==)>(m: array2, m': array2)\n  reads m, m'\n{\n  (m.Length0, m.Length1) == (m'.Length0, m'.Length1) &&\n  forall i,j :: 0 <= i < m.Length0 && 0 <= j < m.Length1 ==> m[i,j] == m'[i,j]\n}\n\n// ------------------------------------------------------------\n\nmethod TestAggregateFieldUpdate() {\n  var a := Node.Create(4);\n  var b := Node.Create(7);\n  a.Print();\n  b.Print();\n\n  print b.StartsWith(a), \"\\n\";  // false\n\n  a.IncEverything(3);\n  a.Print();\n  print b.StartsWith(a), \"\\n\";  // false\n}\n\nclass Node {\n  var Repr: set<Node>  // for the purpose of this test, Repr is non-ghost\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    (next != null ==>\n      next in Repr && next.Repr <= Repr && this !in next.Repr && next.Valid())\n  }\n\n  var val: int\n  var next: Node?\n\n  constructor (val: int, next: Node?)\n    requires next != null ==> next.Valid()\n    ensures Valid() && fresh(Repr - if next == null then {} else next.Repr)\n  {\n    this.val, this.next := val, next;\n    Repr := {this} + if next == null then {} else next.Repr;\n  }\n\n  static method Create(n: nat) returns (d: Node)\n    ensures d.Valid() && fresh(d.Repr)\n  {\n    d := new Node(0, null);\n    var i := 1;\n    while i < n\n      invariant d.Valid() && fresh(d.Repr)\n    {\n      d := new Node(i, d);\n      i := i + 1;\n    }\n  }\n\n  method Print()\n    requires Valid()\n  {\n    var d := this;\n    while d != null\n      invariant d != null ==> d.Valid()\n      decreases if d == null then {} else d.Repr\n    {\n      print d.val, \" \";\n      d := d.next;\n    }\n    print \"\\n\";\n  }\n\n  predicate StartsWith(that: Node?)\n    requires Valid() && (that != null ==> that.Valid())\n    reads Repr, if that == null then {} else that.Repr\n    decreases Repr\n  {\n    that != null ==>\n      val == that.val && next != null && next.StartsWith(that.next)\n  }\n\n  method IncEverything(n: int)\n    requires Valid()\n    modifies Repr\n    ensures Valid()\n  {\n    forall d | d in Repr {\n      d.val := d.val + n;\n    }\n    StillValidAfterValChanges();\n  }\n\n  twostate lemma StillValidAfterValChanges()\n    requires old(Valid())\n    requires forall d :: d in old(Repr) ==> unchanged(d`next, d`Repr)\n    ensures Valid()\n    decreases old(Repr)\n  {\n    if next != null {\n      next.StillValidAfterValChanges();\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/SiblingImports.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  ClientA.Test();\n  ClientB.Test();\n  ClientC.Test();\n  ClientD.Test();\n  ClientE.Test();\n  ClientF.Test();\n  ClientG.Test();\n  Kevin.Test();\n}\n\nmodule Library {\n  export reveals Max\n  export X reveals More\n  export Y reveals Less\n  export Z extends Library, X\n  function Max(x: int, y: int): int {\n    if x < y then y else x\n  }\n  function More(x: int): int { x + 2 }\n  function Less(x: int): int { x - 2 }\n}\n\nmodule ClientA {\n  import Library\n  module Inner {\n    import Library\n    function Five(): int {\n      Library.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientA.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientB {\n  import Library\n  module Inner {\n    import L = Library\n    function Five(): int {\n      L.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientB.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientC {\n  import L = Library\n  module Inner {\n    import K = Library\n    function Five(): int {\n      K.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientC.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientD {\n  import L = Library`X\n  module Inner {\n    import K = Library`Y\n    function Five(): int {\n      K.Less(7)\n    }\n  }\n  method Test() {\n    print \"ClientD.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientE {\n  import L = Library`Z\n  module Inner {\n    import K = Library\n    function Five(): int {\n      K.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientE.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientF {\n  import opened L = Library`Z\n  module Inner {\n    import K = Library\n    function Five(): int {\n      K.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientF.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientG {\n  import Library\n  module Inner {\n    import opened K = Library\n    function Five(): int {\n      Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientG.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule Kevin {\n  module Joe {\n    module Nick {\n      import Frankie\n      function g(): int {\n        Frankie.x\n      }\n    }\n  }\n  method Test() {\n    print \"Frankie: \", Joe.Nick.g(), \"\\n\";\n  }\n}\n\nmodule Frankie {\n  const x := 3\n}\n"}
{"file": "../dafny/Test/dafny0/GhostITECompilation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --function-syntax:4 --relax-definite-assignment\n\nfunction F(x: nat, ghost y: nat): nat\n{\n  if x == 0 then\n    0\n  else if y != 0 then\n    F(x, y - 1) // this branch is not compiled (which even makes F auto-accumulator tail recursive)\n  else\n    F(x - 1, 60) + 13\n}\n\nlemma AboutF(x: nat, y: nat)\n  ensures F(x, y) == 13 * x\n{\n}\n\nfunction G(x: nat, ghost y: nat): nat\n{\n  if x == 0 then\n    0\n  else if y != 0 then\n    var z := x + x;\n    var a, b, c := 100, if x < z then G(x, y - 1) else G(x, y - 1), 200;\n    assert a + b + c == G(x, y - 1) + 300;\n    b // this branch is not compiled (which even makes G auto-accumulator tail recursive)\n  else\n    G(x - 1, 60) + 13\n}\n\n// Ostensibly, the following function is tail recursive. But the ghost-ITE optimization\n// removes the tail call. This test ensures that the unused setup for the tail optimization\n// does not cause problems.\nfunction H(x: int, ghost y: nat): int {\n  if y == 0 then\n    x\n  else\n    H(x, y - 1)\n}\n\n// Like function H, function J looks like it's tail recursive. The compiler probably will\n// emit the tail-call label, even though the tail-call is never taken.\nfunction J(x: int): int {\n  if true then\n    x\n  else\n    J(x)\n}\n\n// The following function would never verify, and its execution wouldn't terminate.\n// Nevertheless, we'll test here that it compiles into legal target code.\nfunction {:verify false} K(x: int, ghost y: nat): int {\n  K(x, y - 1)\n}\n\nmethod Main() {\n  print F(5, 3), \"\\n\"; // 65\n  print G(5, 3), \"\\n\"; // 65\n  print H(65, 3), \"\\n\"; // 65\n  print J(65), \"\\n\"; // 65\n}\n"}
{"file": "../dafny/Test/dafny0/Constant.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nconst one:int := 1\nconst two:int := one * 2\nconst three:int := one + two\nconst Pi:real := 3.14\n\nclass Calendar {\n  static const months:int := 12\n  static const weeks:int := 52\n}\n\nmethod Main() {\n  print \"one := \", one, \"\\n\";\n  print \"two := \", two, \"\\n\";\n  print \"three := \", three, \"\\n\";\n  assert three == 3;\n  print \"Pi := \", Pi, \"\\n\";\n  assert Pi == 3.14;\n  var weeks := Calendar.weeks;\n  print \"months := \", Calendar.months, \"\\n\";\n  print \"weeks := \", weeks, \"\\n\";\n  assert weeks == 52;\n\n  var c := new C;\n  var tu := c.M();  // 11\n  print tu, \" \";\n  print c.G(c), \" \";  // 16\n  print c.H(c), \" \";  // 173\n  print C.x, \" \";  // 6\n  var g := new Generic<real>;\n  var putItHere := g.y;\n  print putItHere, \" \";  // 63\n  var go := g.M();\n  print go, \"\\n\";  // 63\n\n  var noRhs := new NoRHS;\n  print \"noRhs.y = \", noRhs.y, \"\\n\";\n\n  var cl := new Class;\n  cl.Test();\n  var ii := new InstanceInit(13);\n  print ii.x0, \" \", ii.x1, \" \", ii.y2, \" \", ii.y3, \" \", ii.r, \"\\n\";  // 93, 7, 89, 12, 8.54\n\n  print mmgg, \" \", UninterpretedStaticsTrait.mmtt, \" \", UninterpretedStaticsClass.mmcc, \"\\n\";\n\n  InitializationDependencies.PrintEm();\n}\n\nclass C {\n  static const x: int := y+1\n  static const y: int := 5\n  var z: int\n  static function G(c: C): int\n    ensures G(c) == 16\n  {\n    x + y + c.y\n  }\n\n  const a: int := b+2\n  const b: int := 50\n  function H(c: C): int\n    ensures H(c) == 50 + 52 + 50 + 6 + 5 + 5 + 5 == 173\n  {\n    a + b + c.b + x + y + c.y + C.y\n  }\n\n  method M() returns (r: int)\n    ensures r == 11\n  {\n    r := x + y;\n  }\n}\n\nclass Generic<G> {\n  const y: int := 63\n  method M() returns (q: int)\n    ensures q == 63\n  {\n    q := this.y;\n  }\n}\n\nnewtype Six = x | 6 <= x witness 6\n\nclass NoRHS {\n  const y: Six\n}\n\n// ---------- traits --------------------\n\ntrait Trait {\n  const x0: Six\n  const x1: Six := 7\n\n  static const y: Six := 7\n}\n\nclass Class extends Trait {\n  method Test() {\n    assert x1 == 7 && y == 7;\n    print x0, \" \", x1, \" \", y, \"\\n\";\n  }\n}\n\nmethod MMethod(tr: Trait?) {\n  assert Trait.y == 7;\n  assert tr.y == 7;\n  assert tr == null || tr.x1 == 7;\n}\n\n// ---------- instanced-based initialization --------\n\nclass InstanceInit extends Trait {\n  const y2: Six\n  const y3: Six := 12\n  const N: int := 20\n\n  var r: real\n\n  constructor (u: Six)\n    requires 10 <= u\n  {\n    x0 := 80 + u;\n    var arr := new real[N];\n    arr[8] := 2.7;\n    r := arr[8];\n    y2 := 77 + y3;\n    new;\n    assert x0 == u + 80 && x1 ==7;\n    assert y2 == 89 && y3 == 12;\n    assert arr.Length == 20;\n    arr[9] := 3.14;\n    r := r + arr[8] + arr[9];  // 8.54\n  }\n}\n\n// ---------- class- and module-level const's without RHS --------\n\nconst mmgg: Six\n\ntrait UninterpretedStaticsTrait {\n  static const mmtt: Six\n}\n\nclass UninterpretedStaticsClass extends UninterpretedStaticsTrait {\n  static const mmcc: Six\n}\n\n// ---------- test type/allocation axiom of const fields --------\n\ntype byte = x | 0 <= x < 256\n\nclass MyClass {\n  const B: array<byte>\n\n  method M()\n  {\n    var x: array?<byte> := B;\n    var y: array<byte> := x;  // this line generates a proof obligation, but it should pass\n  }\n}\n\n// ---------- static const fields in a generic class have its own axioms --------\n\nclass MyOnePurposeClass {\n  static const z: int\n  static const w: int := 76\n  static const self: MyOnePurposeClass?\n}\n\nclass MyGenericClass<X(00), Y(00)> {\n  ghost static const x: X\n  ghost static const y: Y\n  static const z: int\n  static const w: int := 76\n  static const self: MyGenericClass?<X,Y>\n  static const almostSelf: MyGenericClass?<Y,X>\n  static const another: MyGenericClass?<byte,seq<X>>\n}\n\n// ---------- initialization dependencies --------\n\nmodule InitializationDependencies {\n  class C {\n    static const a: int := b\n    static const b: int := D.m\n    static const c: int := b\n  }\n\n  class D {\n    static const m: int := 20\n  }\n\n  class R {\n    const a: int := b + b\n    const b: int := this.m\n    const c: int := b\n\n    const m: int := 21\n\n    const n: int := F(b)\n    function F(nn: int): int {\n      2 * nn + C.b\n    }\n  }\n\n  method PrintEm()\n  {\n    print C.a, \" \";\n    print C.b, \" \";\n    print C.c, \"\\n\";\n    print D.m, \"\\n\";\n    var r := new R;\n    print r.a, \" \";\n    print r.b, \" \";\n    print r.c, \" \";\n    print r.m, \"\\n\";\n    print r.n, \"\\n\";\n  }\n}\n\nmodule A {\n  const x: int := 100\n}\nmodule B refines A {\n  ghost const x: int\n  lemma TestRhsIsInherited() {\n    assert x == 100;\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/ImplicitTypeParamPrint.dfy", "dafny": "// NONUNIFORM: Multiple tests in one, fairly C# specific\n// RUN: %dafny /dafnyVerify:0 /compile:0 /env:0 /rprint:\"%t.dfy\" \"%s\"\n// RUN: %dafny /dafnyVerify:0 /compile:0 /env:0 /printMode:DllEmbed /rprint:\"%t1.dfy\" \"%t.dfy\"\n// RUN: %dafny /env:0 /compile:3 /printMode:DllEmbed /rprint:\"%t2.dfy\" \"%t1.dfy\" > \"%t\"\n// RUN: %diff \"%t1.dfy\" \"%t2.dfy\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype List<T> = Nil | Cons(car: T, cdr: List)\n\nfunction funkyNil(l: List): List\n{\n  match l\n  case Cons(x, y) => funkyNil(y)\n  case Nil => l\n}\n\nmethod H(a: array, l: List)\n{\n  match l\n  case Cons(x, y) =>\n    if a.Length > 0 && a[0] == x {\n    }\n  case Nil =>\n}\n\nmethod Main() {\n  var xs := Cons(28, Cons(22, Cons(28, Cons(5, Nil))));\n  var a := new [][60, 60];\n  var nil := funkyNil(xs);\n  H(a, xs);\n  print nil, \"\\n\";\n  print nonExtendedPrintExpr(xs), \"\\n\";\n}\n\nfunction nonExtendedPrintExpr(l: List): int\n{\n  25 +\n  match l\n  case Cons(x, y) => 10\n  case Nil => 11\n}\n"}
{"file": "../dafny/Test/dafny0/TypeConversionsCompile.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// Note the difference in output in Java's case is due to\n// https://github.com/dafny-lang/dafny/issues/4152\n\nnewtype Handful = x | 0 <= x < 0x8000  // this type turns native\nnewtype Abundance = y | -20 <= y < 0x200_0000_0000  // still fits inside a \"long\"\nnewtype int64 = y | -0x8000_0000_0000_0000 <= y < 0x8000_0000_0000_0000  // exactly a \"long\"\nnewtype EvenInt = x | x % 2 == 0\nnewtype SmallReal = r | -4.0 <= r < 300.0\n\nmethod Print(x: int, n: nat, r: real, handful: Handful, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, noll: bv0)\n{\n  print x, \" \", n, \" \", r, \" \", handful, \" \", even, \" \", small, \" \", b67, \" \", w, \" \", seven, \" \", noll, \"\\n\";\n}\n\nmethod PrintExpected<T>(got: T, expected: T) {\n  print \"got \", got, \", expected \", expected, \"\\n\";\n}\n\nmethod Main()\n{\n  var x: int, n: nat, r: real := 3, 4, 5.0;\n  var handful: Handful, even: EvenInt, small: SmallReal := 5, 6, -1.0;\n  var b67: bv67, w: bv32, seven: bv7, noll: bv0 := 0x7_FFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF, 127, 0;\n  Print(x, n, r, handful, even, small, b67, w, seven, noll);\n\n  //PrintExpected(x as bv67, 3); // disabled because it does not terminate with 4.4.2 Z3\n  PrintExpected(x as bv7, 3);\n  PrintExpected(0 as bv0, 0);\n  PrintExpected(r as int, 5);\n  PrintExpected((2.0*r) as EvenInt, 10);\n  PrintExpected(x as real, 3.0);\n  PrintExpected(even as real, 6.0);\n  PrintExpected((small + 3.0) as Handful, 2);\n  PrintExpected(noll as Handful, 0);\n  PrintExpected(noll as SmallReal, 0.0);\n  PrintExpected(w as real, 4294967295.0);\n  PrintExpected(seven as real, 127.0);\n  PrintExpected(noll as bv32, 0);\n  PrintExpected(noll as bv67, 0);\n  PrintExpected(seven as bv32, 127);\n  PrintExpected(seven as bv67, 127);\n  b67 := 50;\n  //PrintExpected(b67 as bv32, 50); // disabled because it does not terminate with 4.4.2 Z3\n  //PrintExpected(b67 as bv7, 50); // disabled because it does not terminate with 4.4.2 Z3\n  PrintExpected(r as bv67, 5);\n  PrintExpected(r as bv32, 5);\n  PrintExpected(w as bv67, 0xFFFF_FFFF);\n  PrintExpected(r as bv7, 5);\n  PrintExpected(0.0 as bv0, 0);\n  PrintExpected(handful as bv67, 5);\n  PrintExpected(handful as bv32, 5);\n  PrintExpected(handful as bv7, 5);\n  PrintExpected(handful as int, 5);\n  PrintExpected(noll as bv32 as bv0, 0);\n  PrintExpected(noll as bv67 as bv0, 0);\n  PrintExpected(seven as bv32 as bv7, 127);\n  PrintExpected(seven as bv67 as bv7, 127);\n  PrintExpected(handful as real, 5.0);\n  Difficult();\n  // here are some cases whose compilation are optimized\n  var a0: Abundance, a1: Abundance, a2: Abundance, lng: int64;\n  var s := {4.0, 6.3, r, 1000.2};\n  var a := new char[68];\n  handful := 120 as Handful;\n  a0, a1 := -1 as Abundance, 4 as Abundance;\n  a2 := 0x2_0000_0000 as Abundance;\n  w, lng := 634_5789 as bv32, -0x8000_0000_0000_0000 as int64;\n  print handful, \" \", a0, \" \", a1, \" \", a2, \" \", w, \" \", lng, \"\\n\";\n  x, handful, a0, w := |s|, |s| as Handful, |s| as Abundance, |s| as bv32;\n  print x, \" \", handful, \" \", a0, \" \", w, \"\\n\";\n  x, handful, a0, w := a.Length, a.Length as Handful, a.Length as Abundance, a.Length as bv32;\n  print x, \" \", handful, \" \", a0, \" \", w, \"\\n\";\n\n  OrdinalTests();\n}\n\nmethod Difficult() {  // this has been made a separate method, because it was taking too long with /allocated:1\n  if 14 as real as int as bv67 == 14 {  // help the verifier out, because Z3 doesn't know much about int/bv conversions\n    PrintExpected(14 as real as int as bv67 as EvenInt as SmallReal as Handful as bv7 as bv32 as int, 14);  // take that!\n  }\n}\n\nmethod OrdinalTests() {\n  var ord: ORDINAL := 143;\n  var iord := ord as int;\n  var oord := iord as ORDINAL;\n  print \"Something about ORDINAL: \", ord, \" \", iord, \" \", oord, \" \", ord + 4, \" \", ord - 100, \"\\n\";\n  print \"ORDINAL and bitvectors: \", 20 as bv32 as ORDINAL, \" \", 20 as bv300 as ORDINAL, \"\\n\";\n  print ord.IsLimit, \" \", ord.Offset, \" \", ord.IsNat, \"\\n\";\n  ord := 0;\n  print ord.IsLimit, \" \", ord.Offset, \" \", ord.IsNat, \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny0/Deprecation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// This file contains tests for messags about various deprecated features.\n// As those features go away completely, so can the corresponding tests.\n\nmethod Main() {\n  // Test that we get all the way to compilation, despite the deprecation warnings below\n  print \"yet here we are\\n\";\n}\n\n// ----------\n\nclass C {\n  constructor ()\n    modifies this  // deprecation warning: \"this\" is no longer needed in modifies of a constructor\n  {\n  }\n}\n\n// ----------\n\ninductive predicate InductivePredicate()  // deprecation warning: \"inductive predicate\" has been renamed to \"least predicate\"\n{ true }\n\ncopredicate CoPredicate()  // deprecation warning: \"copredicate\" has been renamed to \"greatest predicate\"\n{ true }\n\ninductive lemma InductiveLemma()  // deprecation warning: \"inductive lemma\" has been renamed to \"least lemma\"\n{ }\n\ncolemma CoLemma()  // deprecation warning: \"colemma\" has been renamed to \"greatest lemma\"\n{ }\n\n"}
{"file": "../dafny/Test/dafny0/MoForallCompilation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  TestAggregateArrayUpdate();\n  TestAggregateMultiArrayUpdate();\n  TestAggregateFieldUpdate();\n}\n\n// ------------------------------------------------------------\n\nmethod TestAggregateArrayUpdate() {\n  var a := new real[8](i => i as real - 4.0);\n  var b := new real[8];\n  var c := new bool[8];\n  forall i | 2-i <= 2 && i < a.Length {\n    b[7-i] := a[i] + 4.0;\n  }\n  forall i | 0 <= i < a.Length {\n    c[i] := a[i] < b[i];\n  }\n  PrintArray(a);  // -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0\n  PrintArray(b);  // 7.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0\n  PrintArray(c);  // true true true true true true false false\n}\n\nmethod PrintArray(a: array) {\n  var i := 0;\n  while i < a.Length {\n    print a[i], \" \";\n    i := i + 1;\n  }\n  print \"\\n\";\n}\n\n// ------------------------------------------------------------\n\nmethod TestAggregateMultiArrayUpdate() {\n  var matrix := new int[12,3]((i,j) => i+j);\n  PrintMatrix(matrix);\n\n  // various ways of computing the transpose:\n  var m' := new int[matrix.Length1, matrix.Length0](\n    (i,j) requires 0 <= i < matrix.Length1 && 0 <= j < matrix.Length0 reads matrix => matrix[j,i]);\n  var m0, m1, m2 := Transpose(matrix);\n  PrintMatrix(m');\n  PrintMatrix(m0);\n  PrintMatrix(m1);\n  PrintMatrix(m2);\n\n  print MatrixEqual(m0, m'), \"\\n\";  // true\n  m'[2,2] := 87;\n  print MatrixEqual(m0, m'), \"\\n\";  // false\n}\n\nmethod PrintMatrix(m: array2<int>) {\n  var i := 0;\n  while i < m.Length0 {\n    var j := 0;\n    while j < m.Length1 {\n      print m[i,j], \" \";\n      j := j + 1;\n    }\n    print \"\\n\";\n    i := i + 1;\n  }\n}\n\nmethod Transpose<T(0)>(m: array2<T>) returns (m0: array2<T>, m1: array2<T>, m2: array2<T>)\n  ensures fresh(m0) && fresh(m1) && fresh(m2)\n  ensures MatrixEqual(m0, m1) && MatrixEqual(m0, m2)\n{\n  var X, Y := m.Length1, m.Length0;\n  m0, m1, m2 := new T[X, Y], new T[X, Y], new T[X, Y];\n  forall i,j | 0 <= i < X && 0 <= j < Y {\n    m0[i,j] := m[j,i];\n  }\n  forall i: nat, j: nat | i < X && j < Y {\n    m1[i,j] := m[j,i];\n  }\n  forall i: nat, j | -Y < -j && 3+i < X+3 && j >= 0 {\n    m2[i,j] := m[j,i];\n  }\n}\n\npredicate MatrixEqual<T(==)>(m: array2, m': array2)\n  reads m, m'\n{\n  (m.Length0, m.Length1) == (m'.Length0, m'.Length1) &&\n  forall i,j :: 0 <= i < m.Length0 && 0 <= j < m.Length1 ==> m[i,j] == m'[i,j]\n}\n\n// ------------------------------------------------------------\n\nmethod TestAggregateFieldUpdate() {\n  var a := Node.Create(4);\n  var b := Node.Create(7);\n  a.Print();\n  b.Print();\n\n  print b.StartsWith(a), \"\\n\";  // false\n\n  a.IncEverything(3);\n  a.Print();\n  print b.StartsWith(a), \"\\n\";  // false\n}\n\nclass Node {\n  var Repr: set<Node>  // for the purpose of this test, Repr is non-ghost\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    (next != null ==>\n      next in Repr && next.Repr <= Repr && this !in next.Repr && next.Valid())\n  }\n\n  var val: int\n  var next: Node?\n\n  constructor (val: int, next: Node?)\n    requires next != null ==> next.Valid()\n    ensures Valid() && fresh(Repr - if next == null then {} else next.Repr)\n  {\n    this.val, this.next := val, next;\n    Repr := {this} + if next == null then {} else next.Repr;\n  }\n\n  static method Create(n: nat) returns (d: Node)\n    ensures d.Valid() && fresh(d.Repr)\n  {\n    d := new Node(0, null);\n    var i := 1;\n    while i < n\n      invariant d.Valid() && fresh(d.Repr)\n    {\n      d := new Node(i, d);\n      i := i + 1;\n    }\n  }\n\n  method Print()\n    requires Valid()\n  {\n    var d := this;\n    while d != null\n      invariant d != null ==> d.Valid()\n      decreases if d == null then {} else d.Repr\n    {\n      print d.val, \" \";\n      d := d.next;\n    }\n    print \"\\n\";\n  }\n\n  predicate StartsWith(that: Node?)\n    requires Valid() && (that != null ==> that.Valid())\n    reads Repr, if that == null then {} else that.Repr\n    decreases Repr\n  {\n    that != null ==>\n      val == that.val && next != null && next.StartsWith(that.next)\n  }\n\n  method IncEverything(n: int)\n    requires Valid()\n    modifies Repr\n    ensures Valid()\n  {\n    forall d | d in Repr {\n      d.val := d.val + n;\n    }\n    StillValidAfterValChanges();\n  }\n\n  twostate lemma StillValidAfterValChanges()\n    requires old(Valid())\n    requires forall d :: d in old(Repr) ==> unchanged(d`next, d`Repr)\n    ensures Valid()\n    decreases old(Repr)\n  {\n    if next != null {\n      next.StillValidAfterValChanges();\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/SiblingImports.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  ClientA.Test();\n  ClientB.Test();\n  ClientC.Test();\n  ClientD.Test();\n  ClientE.Test();\n  ClientF.Test();\n  ClientG.Test();\n  Kevin.Test();\n}\n\nmodule Library {\n  export reveals Max\n  export X reveals More\n  export Y reveals Less\n  export Z extends Library, X\n  function Max(x: int, y: int): int {\n    if x < y then y else x\n  }\n  function More(x: int): int { x + 2 }\n  function Less(x: int): int { x - 2 }\n}\n\nmodule ClientA {\n  import Library\n  module Inner {\n    import Library\n    function Five(): int {\n      Library.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientA.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientB {\n  import Library\n  module Inner {\n    import L = Library\n    function Five(): int {\n      L.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientB.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientC {\n  import L = Library\n  module Inner {\n    import K = Library\n    function Five(): int {\n      K.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientC.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientD {\n  import L = Library`X\n  module Inner {\n    import K = Library`Y\n    function Five(): int {\n      K.Less(7)\n    }\n  }\n  method Test() {\n    print \"ClientD.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientE {\n  import L = Library`Z\n  module Inner {\n    import K = Library\n    function Five(): int {\n      K.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientE.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientF {\n  import opened L = Library`Z\n  module Inner {\n    import K = Library\n    function Five(): int {\n      K.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientF.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientG {\n  import Library\n  module Inner {\n    import opened K = Library\n    function Five(): int {\n      Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientG.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule Kevin {\n  module Joe {\n    module Nick {\n      import Frankie\n      function g(): int {\n        Frankie.x\n      }\n    }\n  }\n  method Test() {\n    print \"Frankie: \", Joe.Nick.g(), \"\\n\";\n  }\n}\n\nmodule Frankie {\n  const x := 3\n}\n"}
{"file": "../dafny/Test/dafny0/ISets.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost method M()\n{\n   ghost var s := iset{2};\n   // test \"in\"\n   if(2 in s)\n   {\n   }\n   else\n   { assert false; }\n   // test \"!in\"\n   if(3 !in s)\n   {\n   }\n   else\n   { assert false; }\n\n   if(s == iset{2})\n   {\n   }\n   else\n   { assert false; }\n}\n\nghost method m1() {\n var s1:iset<int> := iset{}; // the empty set\n var s2 := iset{1, 2, 3}; // set contains exactly 1, 2, and 3\n assert s2 == iset{1,1,2,3,3,3,3}; // same as before\n var s3, s4 := iset{1,2}, iset{1,4};\n\n assert s2 + s4 == iset{1,2,3,4}; // set union\n assert s2 * s3 == iset{1,2} && s2 * s4 == iset{1}; // set intersection\n assert s2 - s3 == iset{3}; // set difference\n\n assert (iset x | x in s2 :: x+1) == iset{2,3,4}; // set comprehension\n assert 17 in (iset x: int | true :: x); // set comprehension\n\n assert (imap x: int | true :: x+1)[14] == 15;\n}\n\n\n"}
{"file": "../dafny/Test/dafny0/warnings-as-errors.dfy", "dafny": "// RUN: %exits-with 2 %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /warnShadowing /warningsAsErrors \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\nmethod f(x: int) {\n  var x := 0;\n}\n"}
{"file": "../dafny/Test/dafny0/CharLiteralParseErrors.dfy", "dafny": "// RUN: %exits-with 2 %dafny /compile:0 /unicodeChar:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Ensuring that the special support for surrogate pairs in character literals\n// doesn't allow character literals with multiple Unicode scalar values\n// (which is a real danger given the complexity in allowing ' characters in identifiers).\n\nmodule UnicodeCharSupport {\n  const goodLiteral := '$'\n  const goodNonASCIILiteral := '€'\n  const badNonBMPLiteral := '💰' // error: too many characters in character literal\n}\n"}
{"file": "../dafny/Test/VSComp2010/Problem3-FindZero.dfy", "dafny": "// RUN: %testDafnyForEachResolver \"%s\"\n\n// VSComp 2010, problem 3, find a 0 in a linked list and return how many nodes were skipped\n// until the first 0 (or end-of-list) was found.\n// Rustan Leino, 18 August 2010.\n//\n// The difficulty in this problem lies in specifying what the return value 'r' denotes and in\n// proving that the program terminates.  Both of these are addressed by declaring a ghost\n// field 'List' in each linked-list node, abstractly representing the linked-list elements\n// from the node to the end of the linked list.  The specification can now talk about that\n// sequence of elements and can use 'r' as an index into the sequence, and termination can\n// be proved from the fact that all sequences in Dafny are finite.\n//\n// We only want to deal with linked lists whose 'List' field is properly filled in (which\n// can only happen in an acyclic list, for example).  To that avail, the standard idiom in\n// Dafny is to declare a predicate 'Valid()' that is true of an object when the data structure\n// representing object's abstract value is properly formed.  The definition of 'Valid()'\n// is what one intuitively would think of as the ''object invariant'', and it is mentioned\n// explicitly in method pre- and postconditions.  As part of this standard idiom, one also\n// declared a ghost variable 'Repr' that is maintained as the set of objects that make up\n// the representation of the aggregate object--in this case, the Node itself and all its\n// successors.\n\nclass Node {\n  ghost var List: seq<int>\n  ghost var Repr: set<Node>\n  var head: int\n  var next: Node?\n\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr &&\n    1 <= |List| && List[0] == head &&\n    (next == null ==> |List| == 1) &&\n    (next != null ==>\n      next in Repr && next.Repr <= Repr && this !in next.Repr && next.Valid() && next.List == List[1..])\n  }\n\n  static method Cons(x: int, tail: Node?) returns (n: Node)\n    requires tail == null || tail.Valid()\n    ensures n.Valid()\n    ensures if tail == null then n.List == [x] else n.List == [x] + tail.List\n  {\n    n := new Node;\n    n.head := x;\n    n.next := tail;\n    if (tail == null) {\n      n.List := [x];\n      n.Repr := {n};\n    } else {\n      n.List := [x] + tail.List;\n      n.Repr := {n} + tail.Repr;\n    }\n  }\n}\n\nmethod Search(ll: Node?) returns (r: int)\n  requires ll == null || ll.Valid()\n  ensures ll == null ==> r == 0\n  ensures ll != null ==>\n            0 <= r && r <= |ll.List| &&\n            (r < |ll.List| ==> ll.List[r] == 0 && 0 !in ll.List[..r]) &&\n            (r == |ll.List| ==> 0 !in ll.List)\n{\n  if ll == null {\n    r := 0;\n  } else {\n    var jj := ll;\n    var i := 0;\n    while jj != null && jj.head != 0\n      invariant jj != null ==> jj.Valid() && i + |jj.List| == |ll.List| && ll.List[i..] == jj.List\n      invariant jj == null ==> i == |ll.List|\n      invariant 0 !in ll.List[..i]\n      decreases |ll.List| - i\n    {\n      jj := jj.next;\n      i := i + 1;\n    }\n    r := i;\n  }\n}\n\nmethod Main()\n{\n  var list: Node? := null;\n  list := Node.Cons(0, list);\n  list := Node.Cons(5, list);\n  list := Node.Cons(0, list);\n  list := Node.Cons(8, list);\n  var r := Search(list);\n  print \"Search returns \", r, \"\\n\";\n  assert r == 1;\n}\n"}
{"file": "../dafny/Test/VSComp2010/Problem1-SumMax.dfy", "dafny": "// RUN: %testDafnyForEachResolver \"%s\"\n\n// VSComp 2010, problem 1, compute the sum and max of the elements of an array and prove\n// that 'sum <= N * max'.\n// Rustan Leino, 18 August 2010.\n//\n// The problem statement gave the pseudo-code for the method, but did not ask to prove\n// that 'sum' or 'max' return as the sum and max, respectively, of the array.  The\n// given assumption that the array's elements are non-negative is not needed to establish\n// the requested postcondition.\n\nmethod M(N: int, a: array<int>) returns (sum: int, max: int)\n  requires 0 <= N && a.Length == N && (forall k :: 0 <= k && k < N ==> 0 <= a[k])\n  ensures sum <= N * max\n{\n  sum := 0;\n  max := 0;\n  var i := 0;\n  while (i < N)\n    invariant i <= N && sum <= i * max\n  {\n    if (max < a[i]) {\n      max := a[i];\n    }\n    sum := sum + a[i];\n    i := i + 1;\n  }\n}\n\nmethod Main()\n{\n  var a := new int[10];\n  a[0] := 9;\n  a[1] := 5;\n  a[2] := 0;\n  a[3] := 2;\n  a[4] := 7;\n  a[5] := 3;\n  a[6] := 2;\n  a[7] := 1;\n  a[8] := 10;\n  a[9] := 6;\n  var s, m := M(10, a);\n  print \"N = \", a.Length, \"  sum = \", s, \"  max = \", m, \"\\n\";\n}\n"}
{"file": "../dafny/Test/VSComp2010/Problem2-Invert.dfy", "dafny": "// RUN: %testDafnyForEachResolver \"%s\"\n\n// VSComp 2010, problem 2, compute the inverse 'B' of a permutation 'A' and prove that 'B' is\n// indeed an inverse of 'A' (or at least prove that 'B' is injective).\n// Rustan Leino, 31 August 2010.\n//\n// In the version of this program that I wrote during the week of VSTTE 2010, I had\n// used a lemma (stated as a ghost method) that I proved inductively (using a loop and\n// a loop invariant).  Here, I have simplified that version by just including an\n// assertion of the crucial property, which follows from the surjectivity of 'A'.\n//\n// The difficulty in proving this program with an SMT solver stems from the fact that\n// the quantifier that states the surjectivity property has no good matching trigger\n// (because there are no function symbols mentioned in the antecedent of that quantifier,\n// only built-in predicates).  Therefore, I introduced a dummy function 'inImage' and\n// defined it always to equal 'true'.  I can then mention this function in the crucial\n// assertion, which causes the appropriate triggering to take place.\n//\n// A slight annoyance is that the loop's modifications of the heap, which is checked\n// to include only the elements of 'B'.  Since 'A' and 'B' are arrays stored at different\n// locations in the heap, it then follows that the elements of 'A' are not modified.\n// However, the fact that the heap has changed at all makes the symbolic expressions\n// denoting the elements of 'A' look different before and after the heap.  The\n// assertion after the loop (which, like all assertions, is proved) is needed to\n// connect the two.\n\nmethod M(N: int, A: array<int>, B: array<int>)\n  requires 0 <= N && N == A.Length && N == B.Length && A != B\n  requires forall k :: 0 <= k < N ==> 0 <= A[k] < N\n  requires forall j, k :: 0 <= j < k < N ==> A[j] != A[k] // A is injective\n  requires forall m :: 0 <= m < N && inImage(m) ==> exists k :: 0 <= k < N && A[k] == m // A is surjective\n  modifies B\n  ensures forall k :: 0 <= k < N ==> 0 <= B[k] < N\n  ensures forall k :: 0 <= k < N ==> B[A[k]] == k == A[B[k]] // A and B are each other's inverses\n  ensures forall j, k :: 0 <= j < k < N ==> B[j] != B[k] // (which means that) B is injective\n{\n  for n := 0 to N\n    invariant forall k :: 0 <= k < n ==> B[A[k]] == k\n  {\n    B[A[n]] := n;\n  }\n\n  // it now follows from the surjectivity of A that A is the inverse of B:\n  assert forall j :: 0 <= j < N && inImage(j) ==> 0 <= B[j] < N && A[B[j]] == j;\n}\n\nghost function inImage(i: int): bool { true }  // this function is used to trigger the surjective quantification\n\nmethod Main()\n{\n  var a := new int[] [9, 3, 8, 2, 7, 4, 0, 1, 5, 6];\n  assert a[0] == 9;\n  assert a[1] == 3;\n  assert a[2] == 8;\n  assert a[3] == 2;\n  assert a[4] == 7;\n  assert a[5] == 4;\n  assert a[6] == 0;\n  assert a[7] == 1;\n  assert a[8] == 5;\n  assert a[9] == 6;\n\n  var b := new int[10];\n\n  M(10, a, b);\n  print \"a: \", a[..], \"\\n\";\n  print \"b: \", b[..], \"\\n\";\n}\n"}
{"file": "../dafny/Test/DafnyTestGeneration/TestGeneration.dfy", "dafny": "// NONUNIFORM: Multiple build steps (although could we use `dafny test` instead?)\n\n// Generating tests:\n// RUN: cp %S/TestGeneration.dfy %t.dfy\n// RUN: %baredafny generate-tests %args Block %t.dfy > %t-tests.dfy\n// RUN: %baredafny translate cs %args --include-runtime --verbose --no-verify \"%t-tests.dfy\" > \"%t\"\n// RUN: dotnet test -v:q %S >> %t\n\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK: .*Passed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3*\n\nmodule M {\n  datatype Value = Value(v:int)\n  method {:testEntry} compareToZero(v:Value) returns (i:int) {\n    if (v.v == 0) {\n      return 0;\n    } else if (v.v > 0) {\n      return 1;\n    }\n    return -1;\n  }\n}\n"}
{"file": "../dafny/Test/patterns/OrPatterns.dfy", "dafny": "// RUN: %testDafnyForEachCompiler --refresh-exit-code=0 \"%s\" -- --relax-definite-assignment\n\ndatatype Enum = One | Two | Three {\n  predicate Even() {\n    this.Two?\n  }\n\n  predicate Even'() {\n    match this\n      case One | Three => false\n      case Two => true\n  }\n\n  predicate Even''() {\n    match this\n      case Two => true\n      case One | Three => false\n  }\n\n  lemma EvenOk() ensures Even() == Even'() == Even''() {}\n}\n\nmodule Constants {\n  const ONE := 1\n  const TWO := 2\n\n  method M(i: int) {\n    match i\n      case | ONE | TWO => return; // `ONE` and `TWO` are not variables here\n      case | _ => // Not redundant\n  }\n}\n\nmodule Lists {\n  datatype List<T> = Nil | Cons(car: T, cdr: List<T>) {\n    ghost function {:fuel 5} Length(): nat {\n      match this\n        case Nil => 0\n        case Cons(_, t) => 1 + t.Length()\n    }\n  }\n\n  predicate ContainsOne(l: List<int>)\n    requires l.Length() == 3\n  {\n    l.car == 1 || l.cdr.car == 1 || l.cdr.cdr.car == 1\n  }\n\n  predicate ContainsOne'(l: List<int>)\n    requires l.Length() == 3\n  {\n    match l\n      case Cons(1, Cons(_, Cons(_, Nil)))\n         | Cons(_, Cons(1, Cons(_, Nil)))\n         | Cons(_, Cons(_, Cons(1, Nil))) =>\n       true\n      case Cons(_, Cons(_, Cons(_, Nil))) =>\n        false\n  }\n\n  lemma ContainsOneOK(l: List<int>)\n    requires l.Length() == 3\n    ensures ContainsOne(l) == ContainsOne'(l)\n  {}\n}\n\nimport opened Lists\n\nmodule TestVariables {\n  datatype DT = A | B | C\n\n  method M(dt: DT) returns (j: int) {\n    match dt {\n      case C => return 0;\n      case A | B => var x := (y => y)(1); assert x == 1;\n        return x;\n    }\n  }\n\n  method M2(dt: DT) returns (j: int) {\n    match dt {\n      case C => return 0;\n      case _ => var x := (y => y)(1); assert x == 1;\n        return x;\n    }\n  }\n\n  function F(dt: DT): int {\n    match dt {\n      case C => 0\n      case A | B => var x := (y => y)(1); assert x == 1; x\n    }\n  }\n  function F2(dt: DT): int {\n    match dt {\n      case C => 0\n      case _ => var x := (y => y)(1); assert x == 1; x\n    }\n  }\n}\nimport opened TestVariables\n\nmethod Main() {\n  expect One.Even() == One.Even'() == One.Even''() == false;\n  expect Two.Even() == Two.Even'() == Two.Even''() == true;\n  expect Three.Even() == Three.Even'() == Three.Even''() == false;\n\n  var a0 := Cons(0, Cons(0, Cons(0, Nil)));\n  expect ContainsOne(a0) == ContainsOne'(a0) == false;\n  var a1 := Cons(1, Cons(0, Cons(0, Nil)));\n  expect ContainsOne(a1) == ContainsOne'(a1) == true;\n  var a2 := Cons(0, Cons(1, Cons(0, Nil)));\n  expect ContainsOne(a2) == ContainsOne'(a2) == true;\n  var a3 := Cons(0, Cons(0, Cons(1, Nil)));\n  expect ContainsOne(a3) == ContainsOne'(a3) == true;\n  \n  var b0 := M(A);\n  var b1 := M(B);\n  var b2 := M2(A);\n  var b3 := M2(B);\n  var b4 := F(A);\n  var b5 := F(B);\n  var b6 := F2(A);\n  var b7 := F2(B);\n  expect 1 == b0 == b1 == b2 == b3 == b4 == b5 == b6 == b7;\n  \n  print \"OK\\n\";\n}\n"}
{"file": "../dafny/Test/examples/maximum.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file shows how to specify and implement a function to compute the\n// largest element of a list. The function is fully specified by two\n// preconditions, as proved by the MaximumIsUnique lemma below.\n\nmethod Maximum(values: seq<int>) returns (max: int)\n  requires values != []\n  ensures max in values\n  ensures forall i | 0 <= i < |values| :: values[i] <= max\n{\n  max := values[0];\n  for idx := 0 to |values|\n    invariant max in values\n    invariant forall j | 0 <= j < idx :: values[j] <= max\n  {\n    if max < values[idx] {\n      max := values[idx];\n    }\n  }\n}\n\nlemma MaximumIsUnique(values: seq<int>, m1: int, m2: int)\n  requires m1 in values && forall i | 0 <= i < |values| :: values[i] <= m1\n  requires m2 in values && forall i | 0 <= i < |values| :: values[i] <= m2\n  ensures m1 == m2 {\n    // This lemma does not need a body: Dafny is able to prove it correct entirely automatically.\n}\n"}
{"file": "../dafny/Test/examples/induction-principle-code/Utils.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Utils {\n  function Max(x: int, y: int): int\n  {\n    if x > y then x else y\n  }\n\n  function {:opaque} MaxF<T(!new)>(f: T ~> int, ts: seq<T>, default: int) : (m: int)\n    reads set x, y | x in ts && y in f.reads(x) :: y\n    requires forall t : T | t in ts :: f.requires(t)\n    requires forall t | t in ts :: default <= f(t)\n    ensures if ts == [] then m == default else exists t | t in ts :: f(t) == m\n    ensures forall t | t in ts :: f(t) <= m\n    ensures default <= m\n  {\n    if ts == [] then default\n    else\n      Max(f(ts[0]), MaxF(f, ts[1..], default))\n  }\n\n  datatype Result<T> = | Success(value: T) | Failure\n  {\n    predicate IsFailure() {\n      Failure?\n    }\n\n    function PropagateFailure<U>(): Result<U>\n      requires Failure?\n    {\n      Failure\n    }\n\n    function Extract(): T\n      requires Success?\n    {\n      value\n    }\n  }\n\n  datatype Option<T> = Some(value: T) | None\n}\n"}
{"file": "../dafny/Test/benchmarks/sequence-race/SequenceRace.dfy", "dafny": "// Only because we're calling gradlew rather than gradlew.bat\n// UNSUPPORTED: windows\n\n// Ensure trying to use an unsupported compilation target results in a clean error message.\n// RUN: %exits-with 3 %baredafny translate cs %args \"%s\" --plugin:DafnyBenchmarkingPlugin.dll > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// RUN: %baredafny translate java %args \"%s\" --plugin:DafnyBenchmarkingPlugin.dll\n// RUN: rm -rf %S/java/src/jmh\n// RUN: mkdir -p %S/java/src/jmh\n// RUN: cp -r %S/SequenceRace-java %S/java/src/jmh/java\n\n// Note the intentional \">\" as opposed to \">>\", so we can check just the benchmark run output.\n// RUN: %S/java/gradlew jmh -p %S/java > \"%t\"\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n\n// Verify the benchmark actually ran and did not hit any exceptions.\n// CHECK: # Benchmark: _System.SequenceRace.LazyRace\n// CHECK-NOT: <failure>\n// Verify the teardown is only run once per iteration\n// CHECK: Iteration   1: That's all folks!\n// CHECK: Iteration   2: That's all folks!\n// CHECK: # Run complete.\n\n//\n// Sanity test of the benchmarking plugin,\n// and a regression test for https://github.com/dafny-lang/dafny/issues/1454.\n//\n// A class with {:benchmarks} will be translated to a form that target language\n// benchmarking frameworks can integrate with relatively easily.\n// For each method on such classes,\n// a single instance of the class will be instantiated using the no-argument constructor,\n// and then one or more concurrent executions of the method will be triggered.\n// \nclass {:benchmarks} SequenceRace {\n\n  const s: seq<int>\n\n  constructor() {\n    s := [];\n    for x := 0 to 1000 {\n      s := s + [x];\n    }\n  }\n\n  method LazyRace() {\n    // Using expect means compilers can't optimize calculations away\n    // since they could lead to throwing exceptions.\n    expect 0 < |s|;\n    expect s[0] == 0;\n  }\n\n  method {:benchmarkTearDown} TearDown() {\n    print \"That's all folks!\\n\";\n  }\n}"}
{"file": "../dafny/Test/wishlist/FuelTriggers.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// THIS USED TO BE THE CASE:\n//\n//     With the default version of opaque + fuel, the following fails to verify\n//     because the quantifier in the requires used a trigger that included\n//     StartFuel_P, while the assert used StartFuelAssert_P.  Since P is\n//     opaque, we can't tell that those fuels are the same, and hence the\n//     trigger never fires. A wish would be to fix this.\n//\n// This has been fixed, so the test assertion is now passing.\n\nghost predicate {:opaque} P(x:int)\n\nmethod test(y:int)\n  requires forall x :: P(x)\n{\n  assert P(y);\n}\n"}
{"file": "../dafny/Test/wishlist/GoModule.dfy", "dafny": "// NONUNIFORM: Go-specific extern test\n// RUN: %exits-with 3 %dafny /compile:3 /unicodeChar:0 /spillTargetCode:2 \"%s\" /compileTarget:go 2> \"%t\"\n// note: putting /compileTarget:go after \"%s\" overrides user-provided option\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK: GoModuleConversions.go:10:3: \"net/url\" imported and not used\n\n// This test used to work only because of a questionable Go-only feature\n// of mapping a Dafny string directly to a Go string when passed in or out of\n// an extern method. It barely worked in one direction and not in the other\n// (see https://github.com/dafny-lang/dafny/issues/2989),\n// and even when it did, equating these two types was not actually sound in all cases anyway.\n// This feature has been disabled since Dafny 4.0,\n// and unfortunately I found that rewriting the test to work without it was very\n// difficult for unrelated reasons.\n// In particular this version should work but produces unused imports\n// which the Go compiler complains about\n// (see https://github.com/dafny-lang/dafny/issues/2953).\n// Instead I've converted this into a negative test.\n\n// \"url\" is a built-in package, so it should be accessible to the\n// test suite without further requirements on the setup.\nmodule {:extern \"url\", \"net/url\"} URL {\n\n  class URL {\n    var {:extern \"Host\"} host: string\n    var {:extern \"Path\"} pathname: string\n    var {:extern \"RawQuery\"} search: string\n  }\n\n  trait {:extern \"\", \"error\"} Error { }\n}\n\nmodule {:extern \"GoModuleConversions\"} GoModuleConversions {\n  import opened URL\n  method {:extern \"ParseURL\"} Parse(address: string) returns (url: URL, error: Error?)\n}\n\nmodule Test {\n\n  import GoModuleConversions\n\n  method TryUrl(address: string) {\n    var u, e := GoModuleConversions.Parse(address);\n    if (e != null) {\n      print \"Parse error: \", e, \"\\n\";\n    } else {\n      print \"The address \", address, \"\\n\";\n      print \"has the following parts:\\n\";\n      print \"host: \", u.host, \"\\n\";\n      print \"pathname: \", u.pathname, \"\\n\";\n      print \"search: \", u.search, \"\\n\";\n    }\n  }\n\n  method Main() {\n    TryUrl(\"http://localhost:8080/default.htm?year=1915&month=august&day=29\");\n    TryUrl(\"http://localhost:8080/default.htm%\");\n  }\n}\n"}
{"file": "../dafny/Test/wishlist/we-should-always-print-tooltips.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips %S/we-should-always-print-tooltips.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// WISH it would be great to add /printTooltips to all tests\n"}
{"file": "../dafny/Test/wishlist/granted/strings.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod EqualityOfStrings() {\n  assert \"a\" != \"b\"; // WISH -- granted\n}\n"}
{"file": "../dafny/Test/wishlist/granted/useless-casts-in-decreases-clauses.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod M() {\n  var pos := 10;\n  while (pos > 0) { // This shouldn't print int(pos) - int(0); pos - 0 would be better\n    pos := pos - 1;\n  }\n}\n"}
{"file": "../dafny/Test/VerifyThis2015/Problem3.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n// Rustan Leino\n// 12 April 2015\n// VerifyThis 2015\n// Problem 3 -- Dancing Links\n\n\n// The following method demonstrates that Remove and PutBack (defined below) have the desired properties\nmethod Test(dd: DoublyLinkedList, x: Node)\n  requires dd.Valid()\n  requires x in dd.Nodes && x != dd.Nodes[0] && x != dd.Nodes[|dd.Nodes|-1]\n  modifies dd, dd.Nodes\n  ensures dd.Valid() && dd.Nodes == old(dd.Nodes)\n{\n  ghost var k := dd.Remove(x);\n  dd.PutBack(x, k);\n}\n// It is also possible to remove and put back any number of elements, provided these operations are\n// done in a FOLI order.\nmethod TestMany(dd: DoublyLinkedList, xs: seq<Node>)\n  requires dd.Valid()\n  requires forall x :: x in xs ==> x in dd.Nodes && x != dd.Nodes[0] && x != dd.Nodes[|dd.Nodes|-1]\n  requires forall i,j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n  modifies dd, dd.Nodes\n  ensures dd.Valid() && dd.Nodes == old(dd.Nodes)\n{\n  if xs != [] {\n    var x := xs[0];\n    ghost var k := dd.Remove(x);\n    forall y | y in xs[1..]\n      ensures y in dd.Nodes && y != dd.Nodes[0] && y != dd.Nodes[|dd.Nodes|-1]\n    {\n      assert forall z :: z in old(dd.Nodes) ==> z in dd.Nodes || z == x;\n      assert x == old(dd.Nodes)[k];\n    }\n    TestMany(dd, xs[1..]);\n    dd.PutBack(x, k);\n  }\n}\n\n// And here's a Main program that shows that doubly linked lists do exist (well, at least there is one :))\nmethod Main()\n{\n  var a0 := new Node;\n  var a1 := new Node;\n  var a2 := new Node;\n  var a3 := new Node;\n  var a4 := new Node;\n  var a5 := new Node;\n  var dd := new DoublyLinkedList([a0, a1, a2, a3, a4, a5]);\n  Test(dd, a3);\n  TestMany(dd, [a2, a4, a3]);\n}\n\nclass Node {\n  var L: Node?\n  var R: Node?\n}\n\nclass DoublyLinkedList {\n  ghost var Nodes: seq<Node>  // sequence of nodes in the linked list\n  // Valid() says that the data structure is a proper doubly linked list\n  ghost predicate Valid()\n    reads this, Nodes\n  {\n    (|Nodes| > 0 ==>\n      Nodes[0].L == null && (forall i {:trigger Nodes[i].L} :: 1 <= i < |Nodes| ==> Nodes[i].L == Nodes[i-1]) &&\n      (forall i {:trigger Nodes[i].R} :: 0 <= i < |Nodes|-1 ==> Nodes[i].R == Nodes[i+1]) && Nodes[|Nodes|-1].R == null\n    ) &&\n    forall i,j :: 0 <= i < j < |Nodes| ==> Nodes[i] != Nodes[j]  // this is actually a consequence of the previous conditions\n  }\n  // This constructor just shows that there is a way to create a doubly linked list.  It accepts\n  // as an argument the sequences of Nodes to construct the doubly linked list from.  The constructor\n  // will change all the .L and .R pointers of the given nodes in order to create a properly\n  // formed list.\n  constructor (nodes: seq<Node>)\n    requires forall i,j :: 0 <= i < j < |nodes| ==> nodes[i] != nodes[j]\n    modifies nodes\n    ensures Valid() && Nodes == nodes\n  {\n    if nodes != [] {\n      var prev, n := nodes[0], 1;\n      prev.L, prev.R := null, null;\n      while n < |nodes|\n        invariant 1 <= n <= |nodes|\n        invariant nodes[0].L == null\n        invariant prev == nodes[n-1] && prev.R == null\n        invariant forall i :: 1 <= i < n ==> nodes[i].L == nodes[i-1]\n        invariant forall i :: 0 <= i < n-1 ==> nodes[i].R == nodes[i+1]\n      {\n        nodes[n].L, prev.R, prev := prev, nodes[n], nodes[n];\n        prev.R := null;\n        n := n + 1;\n      }\n    }\n    Nodes := nodes;\n  }\n\n  ghost function PopMiddle<T>(s: seq<T>, k: nat) : seq<T>\n    requires k < |s| {\n      s[..k] + s[k+1..]\n  }\n\n  ghost predicate Injective<T>(s: seq<T>) {\n    forall j, k :: 0 <= j < k < |s| ==> s[j] != s[k]\n  }\n\n  lemma InjectiveAfterPop<T>(s: seq<T>, k: nat)\n    requires k < |s|\n    requires Injective(s)\n    ensures  Injective(PopMiddle(s, k))\n  {\n  }\n\n  method Remove(x: Node) returns (ghost k: int)\n    requires Valid()\n    requires x in Nodes && x != Nodes[0] && x != Nodes[|Nodes|-1]  // not allowed to remove end nodes; you may think of them as a sentinel nodes\n    modifies this, Nodes\n    ensures Valid()\n    ensures 0 <= k < |old(Nodes)| && x == old(Nodes)[k]\n    ensures Nodes == old(Nodes)[..k] + old(Nodes)[k+1..] && x.L == old(x.L) && x.R == old(x.R)\n  {\n    k :| 1 <= k < |Nodes|-1 && Nodes[k] == x;\n    x.R.L := x.L;\n    x.L.R := x.R;\n\n    Nodes := Nodes[..k] + Nodes[k+1..];\n    assert |Nodes| > 0;\n  }\n\n  // One might consider have a precondition that says there exists a \"k\" with the properties given here.\n  // However, we want to be able to refer to \"k\" in the postcondition as well, so it's convenient to\n  // burden the client with having to pass in \"k\" as a ghost parameter.  This, however, is really no\n  // extra burden on the client, because if the client would have been able to show the existence of\n  // such a \"k\", then the client can easily just use an assign-such-that statement to obtain such a\n  // value \"k\".\n  method PutBack(x: Node, ghost k: int)\n    requires Valid()\n    requires 1 <= k < |Nodes| && x.L == Nodes[k-1] && x.R == Nodes[k]\n    modifies this, Nodes, x\n    ensures Valid()\n    ensures Nodes == old(Nodes)[..k] + [x] + old(Nodes)[k..]\n  {\n    x.R.L := x;\n    x.L.R := x;\n    Nodes := Nodes[..k] + [x] + Nodes[k..];\n  }\n}\n\n// --------------------------------------------------------\n// If it were not required to build a data structure (like the class above) that supports the\n// Remove and PutBack operations, the operations can easily be verified to compose into the\n// identity transformation.  The following method shows that the two operations, under a suitable\n// precondition, have no net effect on any .L or .R field.\n\nmethod Alt(x: Node)\n  requires x.L != null && x.R != null\n  requires x.L.R == x && x.R.L == x  // links are mirrored\n  modifies x, x.L, x.R\n  ensures forall y: Node :: old(allocated(y)) ==> y.L == old(y.L) && y.R == old(y.R)\n{\n  // remove\n  x.R.L := x.L;\n  x.L.R := x.R;\n  // put back\n  x.R.L := x;\n  x.L.R := x;\n}\n"}
{"file": "../dafny/Test/linters/constructorCaseWithoutParentheses.dfy", "dafny": "// RUN: %baredafny verify %args --warn-missing-constructor-parentheses \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule WithWarning {\n  datatype Color = Red | Green | ShadesOfGray(nat)\n  datatype Identity<T> = Identity(value: T)\n  datatype Colors = Yellow | Blue\n  datatype T = A | B\n  method M(t: T) { \n    match t\n      case A => print \"A\";\n      case B => print \"B\";\n  }\n  function Foo(value: Identity<Colors>): bool {\n    match value {\n      case Identity(Yellow()) => true\n      case Identity(Blue) => false\n    }\n  }\n  method MonochromaticMethod(c: Color) returns (x: bool) {\n    return match c\n      case ShadesOfGray => true\n      case Green => true\n      case anythingElse => false;\n  }\n  function MonochromaticFunction(c: Color) : bool {\n    match c\n      case ShadesOfGray => true\n      case Green => true\n      case anythingElse => false      \n  }\n  method MonochromaticMethodloop(c: Color) returns (x: bool)  {\n    var test := false;\n    while test    \n    {\n       test := match c\n         case ShadesOfGray => true\n         case Green => true      \n         case anythingElse => false;\n    }\n    return false; \n  }\n   \n}\n\nmodule WithoutWarning {\n  datatype Color = Red | Green | ShadesOfGray(nat)\n  datatype Identity<T> = Identity(value: T)\n  datatype Colors = Yellow | Blue\n  datatype T = A | B\n    method M(t: T) { \n      match t\n        case A() => print \"A\";\n        case B() => print \"B\";\n    }\n  function Foo(value: Identity<Colors>): bool {\n    match value {\n      case Identity(Yellow()) => true\n      case Identity(Blue()) => false\n    }\n  }\n  method MonochromaticMethod(c: Color) returns (x: bool) {\n        return match c\n          case ShadesOfGray(_) => true\n          case Green() => true\n          case anythingElse => false;\n  }\n  function MonochromaticFunction(c: Color) : bool {\n        match c\n          case ShadesOfGray(_) => true\n          case Green() => true\n          case anythingElse => false\n  }\n  method MonochromaticMethodloop(c: Color) returns (x: bool)  {\n        while false {\n          x := match c\n              case ShadesOfGray(_) => true\n              case Green() => true\n              case anythingElse => false;\n        }\n      return false; \n  }\n  method Main() {\n        var x := MonochromaticMethod(Green); \n        print MonochromaticFunction(Green);\n        var y := MonochromaticMethodloop(Green);\n        print Foo(Identity(Blue));\n      }\n}\n\n\n\n"}
{"file": "../dafny/Test/dafny0/MoForallCompilation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  TestAggregateArrayUpdate();\n  TestAggregateMultiArrayUpdate();\n  TestAggregateFieldUpdate();\n}\n\n// ------------------------------------------------------------\n\nmethod TestAggregateArrayUpdate() {\n  var a := new real[8](i => i as real - 4.0);\n  var b := new real[8];\n  var c := new bool[8];\n  forall i | 2-i <= 2 && i < a.Length {\n    b[7-i] := a[i] + 4.0;\n  }\n  forall i | 0 <= i < a.Length {\n    c[i] := a[i] < b[i];\n  }\n  PrintArray(a);  // -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0\n  PrintArray(b);  // 7.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0\n  PrintArray(c);  // true true true true true true false false\n}\n\nmethod PrintArray(a: array) {\n  var i := 0;\n  while i < a.Length {\n    print a[i], \" \";\n    i := i + 1;\n  }\n  print \"\\n\";\n}\n\n// ------------------------------------------------------------\n\nmethod TestAggregateMultiArrayUpdate() {\n  var matrix := new int[12,3]((i,j) => i+j);\n  PrintMatrix(matrix);\n\n  // various ways of computing the transpose:\n  var m' := new int[matrix.Length1, matrix.Length0](\n    (i,j) requires 0 <= i < matrix.Length1 && 0 <= j < matrix.Length0 reads matrix => matrix[j,i]);\n  var m0, m1, m2 := Transpose(matrix);\n  PrintMatrix(m');\n  PrintMatrix(m0);\n  PrintMatrix(m1);\n  PrintMatrix(m2);\n\n  print MatrixEqual(m0, m'), \"\\n\";  // true\n  m'[2,2] := 87;\n  print MatrixEqual(m0, m'), \"\\n\";  // false\n}\n\nmethod PrintMatrix(m: array2<int>) {\n  var i := 0;\n  while i < m.Length0 {\n    var j := 0;\n    while j < m.Length1 {\n      print m[i,j], \" \";\n      j := j + 1;\n    }\n    print \"\\n\";\n    i := i + 1;\n  }\n}\n\nmethod Transpose<T(0)>(m: array2<T>) returns (m0: array2<T>, m1: array2<T>, m2: array2<T>)\n  ensures fresh(m0) && fresh(m1) && fresh(m2)\n  ensures MatrixEqual(m0, m1) && MatrixEqual(m0, m2)\n{\n  var X, Y := m.Length1, m.Length0;\n  m0, m1, m2 := new T[X, Y], new T[X, Y], new T[X, Y];\n  forall i,j | 0 <= i < X && 0 <= j < Y {\n    m0[i,j] := m[j,i];\n  }\n  forall i: nat, j: nat | i < X && j < Y {\n    m1[i,j] := m[j,i];\n  }\n  forall i: nat, j | -Y < -j && 3+i < X+3 && j >= 0 {\n    m2[i,j] := m[j,i];\n  }\n}\n\npredicate MatrixEqual<T(==)>(m: array2, m': array2)\n  reads m, m'\n{\n  (m.Length0, m.Length1) == (m'.Length0, m'.Length1) &&\n  forall i,j :: 0 <= i < m.Length0 && 0 <= j < m.Length1 ==> m[i,j] == m'[i,j]\n}\n\n// ------------------------------------------------------------\n\nmethod TestAggregateFieldUpdate() {\n  var a := Node.Create(4);\n  var b := Node.Create(7);\n  a.Print();\n  b.Print();\n\n  print b.StartsWith(a), \"\\n\";  // false\n\n  a.IncEverything(3);\n  a.Print();\n  print b.StartsWith(a), \"\\n\";  // false\n}\n\nclass Node {\n  var Repr: set<Node>  // for the purpose of this test, Repr is non-ghost\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    (next != null ==>\n      next in Repr && next.Repr <= Repr && this !in next.Repr && next.Valid())\n  }\n\n  var val: int\n  var next: Node?\n\n  constructor (val: int, next: Node?)\n    requires next != null ==> next.Valid()\n    ensures Valid() && fresh(Repr - if next == null then {} else next.Repr)\n  {\n    this.val, this.next := val, next;\n    Repr := {this} + if next == null then {} else next.Repr;\n  }\n\n  static method Create(n: nat) returns (d: Node)\n    ensures d.Valid() && fresh(d.Repr)\n  {\n    d := new Node(0, null);\n    var i := 1;\n    while i < n\n      invariant d.Valid() && fresh(d.Repr)\n    {\n      d := new Node(i, d);\n      i := i + 1;\n    }\n  }\n\n  method Print()\n    requires Valid()\n  {\n    var d := this;\n    while d != null\n      invariant d != null ==> d.Valid()\n      decreases if d == null then {} else d.Repr\n    {\n      print d.val, \" \";\n      d := d.next;\n    }\n    print \"\\n\";\n  }\n\n  predicate StartsWith(that: Node?)\n    requires Valid() && (that != null ==> that.Valid())\n    reads Repr, if that == null then {} else that.Repr\n    decreases Repr\n  {\n    that != null ==>\n      val == that.val && next != null && next.StartsWith(that.next)\n  }\n\n  method IncEverything(n: int)\n    requires Valid()\n    modifies Repr\n    ensures Valid()\n  {\n    forall d | d in Repr {\n      d.val := d.val + n;\n    }\n    StillValidAfterValChanges();\n  }\n\n  twostate lemma StillValidAfterValChanges()\n    requires old(Valid())\n    requires forall d :: d in old(Repr) ==> unchanged(d`next, d`Repr)\n    ensures Valid()\n    decreases old(Repr)\n  {\n    if next != null {\n      next.StillValidAfterValChanges();\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny0/SiblingImports.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  ClientA.Test();\n  ClientB.Test();\n  ClientC.Test();\n  ClientD.Test();\n  ClientE.Test();\n  ClientF.Test();\n  ClientG.Test();\n  Kevin.Test();\n}\n\nmodule Library {\n  export reveals Max\n  export X reveals More\n  export Y reveals Less\n  export Z extends Library, X\n  function Max(x: int, y: int): int {\n    if x < y then y else x\n  }\n  function More(x: int): int { x + 2 }\n  function Less(x: int): int { x - 2 }\n}\n\nmodule ClientA {\n  import Library\n  module Inner {\n    import Library\n    function Five(): int {\n      Library.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientA.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientB {\n  import Library\n  module Inner {\n    import L = Library\n    function Five(): int {\n      L.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientB.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientC {\n  import L = Library\n  module Inner {\n    import K = Library\n    function Five(): int {\n      K.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientC.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientD {\n  import L = Library`X\n  module Inner {\n    import K = Library`Y\n    function Five(): int {\n      K.Less(7)\n    }\n  }\n  method Test() {\n    print \"ClientD.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientE {\n  import L = Library`Z\n  module Inner {\n    import K = Library\n    function Five(): int {\n      K.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientE.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientF {\n  import opened L = Library`Z\n  module Inner {\n    import K = Library\n    function Five(): int {\n      K.Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientF.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule ClientG {\n  import Library\n  module Inner {\n    import opened K = Library\n    function Five(): int {\n      Max(2, 5)\n    }\n  }\n  method Test() {\n    print \"ClientG.Inner.Five: \", Inner.Five(), \"\\n\";\n  }\n}\n\nmodule Kevin {\n  module Joe {\n    module Nick {\n      import Frankie\n      function g(): int {\n        Frankie.x\n      }\n    }\n  }\n  method Test() {\n    print \"Frankie: \", Joe.Nick.g(), \"\\n\";\n  }\n}\n\nmodule Frankie {\n  const x := 3\n}\n"}
{"file": "../dafny/Test/dafny0/ISets.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost method M()\n{\n   ghost var s := iset{2};\n   // test \"in\"\n   if(2 in s)\n   {\n   }\n   else\n   { assert false; }\n   // test \"!in\"\n   if(3 !in s)\n   {\n   }\n   else\n   { assert false; }\n\n   if(s == iset{2})\n   {\n   }\n   else\n   { assert false; }\n}\n\nghost method m1() {\n var s1:iset<int> := iset{}; // the empty set\n var s2 := iset{1, 2, 3}; // set contains exactly 1, 2, and 3\n assert s2 == iset{1,1,2,3,3,3,3}; // same as before\n var s3, s4 := iset{1,2}, iset{1,4};\n\n assert s2 + s4 == iset{1,2,3,4}; // set union\n assert s2 * s3 == iset{1,2} && s2 * s4 == iset{1}; // set intersection\n assert s2 - s3 == iset{3}; // set difference\n\n assert (iset x | x in s2 :: x+1) == iset{2,3,4}; // set comprehension\n assert 17 in (iset x: int | true :: x); // set comprehension\n\n assert (imap x: int | true :: x+1)[14] == 15;\n}\n\n\n"}
{"file": "../dafny/Test/dafny0/warnings-as-errors.dfy", "dafny": "// RUN: %exits-with 2 %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /warnShadowing /warningsAsErrors \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\nmethod f(x: int) {\n  var x := 0;\n}\n"}
{"file": "../dafny/Test/dafny0/CharLiteralParseErrors.dfy", "dafny": "// RUN: %exits-with 2 %dafny /compile:0 /unicodeChar:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Ensuring that the special support for surrogate pairs in character literals\n// doesn't allow character literals with multiple Unicode scalar values\n// (which is a real danger given the complexity in allowing ' characters in identifiers).\n\nmodule UnicodeCharSupport {\n  const goodLiteral := '$'\n  const goodNonASCIILiteral := '€'\n  const badNonBMPLiteral := '💰' // error: too many characters in character literal\n}\n"}
{"file": "../dafny/Test/VSComp2010/Problem3-FindZero.dfy", "dafny": "// RUN: %testDafnyForEachResolver \"%s\"\n\n// VSComp 2010, problem 3, find a 0 in a linked list and return how many nodes were skipped\n// until the first 0 (or end-of-list) was found.\n// Rustan Leino, 18 August 2010.\n//\n// The difficulty in this problem lies in specifying what the return value 'r' denotes and in\n// proving that the program terminates.  Both of these are addressed by declaring a ghost\n// field 'List' in each linked-list node, abstractly representing the linked-list elements\n// from the node to the end of the linked list.  The specification can now talk about that\n// sequence of elements and can use 'r' as an index into the sequence, and termination can\n// be proved from the fact that all sequences in Dafny are finite.\n//\n// We only want to deal with linked lists whose 'List' field is properly filled in (which\n// can only happen in an acyclic list, for example).  To that avail, the standard idiom in\n// Dafny is to declare a predicate 'Valid()' that is true of an object when the data structure\n// representing object's abstract value is properly formed.  The definition of 'Valid()'\n// is what one intuitively would think of as the ''object invariant'', and it is mentioned\n// explicitly in method pre- and postconditions.  As part of this standard idiom, one also\n// declared a ghost variable 'Repr' that is maintained as the set of objects that make up\n// the representation of the aggregate object--in this case, the Node itself and all its\n// successors.\n\nclass Node {\n  ghost var List: seq<int>\n  ghost var Repr: set<Node>\n  var head: int\n  var next: Node?\n\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr &&\n    1 <= |List| && List[0] == head &&\n    (next == null ==> |List| == 1) &&\n    (next != null ==>\n      next in Repr && next.Repr <= Repr && this !in next.Repr && next.Valid() && next.List == List[1..])\n  }\n\n  static method Cons(x: int, tail: Node?) returns (n: Node)\n    requires tail == null || tail.Valid()\n    ensures n.Valid()\n    ensures if tail == null then n.List == [x] else n.List == [x] + tail.List\n  {\n    n := new Node;\n    n.head := x;\n    n.next := tail;\n    if (tail == null) {\n      n.List := [x];\n      n.Repr := {n};\n    } else {\n      n.List := [x] + tail.List;\n      n.Repr := {n} + tail.Repr;\n    }\n  }\n}\n\nmethod Search(ll: Node?) returns (r: int)\n  requires ll == null || ll.Valid()\n  ensures ll == null ==> r == 0\n  ensures ll != null ==>\n            0 <= r && r <= |ll.List| &&\n            (r < |ll.List| ==> ll.List[r] == 0 && 0 !in ll.List[..r]) &&\n            (r == |ll.List| ==> 0 !in ll.List)\n{\n  if ll == null {\n    r := 0;\n  } else {\n    var jj := ll;\n    var i := 0;\n    while jj != null && jj.head != 0\n      invariant jj != null ==> jj.Valid() && i + |jj.List| == |ll.List| && ll.List[i..] == jj.List\n      invariant jj == null ==> i == |ll.List|\n      invariant 0 !in ll.List[..i]\n      decreases |ll.List| - i\n    {\n      jj := jj.next;\n      i := i + 1;\n    }\n    r := i;\n  }\n}\n\nmethod Main()\n{\n  var list: Node? := null;\n  list := Node.Cons(0, list);\n  list := Node.Cons(5, list);\n  list := Node.Cons(0, list);\n  list := Node.Cons(8, list);\n  var r := Search(list);\n  print \"Search returns \", r, \"\\n\";\n  assert r == 1;\n}\n"}
{"file": "../dafny/Test/VSComp2010/Problem1-SumMax.dfy", "dafny": "// RUN: %testDafnyForEachResolver \"%s\"\n\n// VSComp 2010, problem 1, compute the sum and max of the elements of an array and prove\n// that 'sum <= N * max'.\n// Rustan Leino, 18 August 2010.\n//\n// The problem statement gave the pseudo-code for the method, but did not ask to prove\n// that 'sum' or 'max' return as the sum and max, respectively, of the array.  The\n// given assumption that the array's elements are non-negative is not needed to establish\n// the requested postcondition.\n\nmethod M(N: int, a: array<int>) returns (sum: int, max: int)\n  requires 0 <= N && a.Length == N && (forall k :: 0 <= k && k < N ==> 0 <= a[k])\n  ensures sum <= N * max\n{\n  sum := 0;\n  max := 0;\n  var i := 0;\n  while (i < N)\n    invariant i <= N && sum <= i * max\n  {\n    if (max < a[i]) {\n      max := a[i];\n    }\n    sum := sum + a[i];\n    i := i + 1;\n  }\n}\n\nmethod Main()\n{\n  var a := new int[10];\n  a[0] := 9;\n  a[1] := 5;\n  a[2] := 0;\n  a[3] := 2;\n  a[4] := 7;\n  a[5] := 3;\n  a[6] := 2;\n  a[7] := 1;\n  a[8] := 10;\n  a[9] := 6;\n  var s, m := M(10, a);\n  print \"N = \", a.Length, \"  sum = \", s, \"  max = \", m, \"\\n\";\n}\n"}
{"file": "../dafny/Test/VSComp2010/Problem2-Invert.dfy", "dafny": "// RUN: %testDafnyForEachResolver \"%s\"\n\n// VSComp 2010, problem 2, compute the inverse 'B' of a permutation 'A' and prove that 'B' is\n// indeed an inverse of 'A' (or at least prove that 'B' is injective).\n// Rustan Leino, 31 August 2010.\n//\n// In the version of this program that I wrote during the week of VSTTE 2010, I had\n// used a lemma (stated as a ghost method) that I proved inductively (using a loop and\n// a loop invariant).  Here, I have simplified that version by just including an\n// assertion of the crucial property, which follows from the surjectivity of 'A'.\n//\n// The difficulty in proving this program with an SMT solver stems from the fact that\n// the quantifier that states the surjectivity property has no good matching trigger\n// (because there are no function symbols mentioned in the antecedent of that quantifier,\n// only built-in predicates).  Therefore, I introduced a dummy function 'inImage' and\n// defined it always to equal 'true'.  I can then mention this function in the crucial\n// assertion, which causes the appropriate triggering to take place.\n//\n// A slight annoyance is that the loop's modifications of the heap, which is checked\n// to include only the elements of 'B'.  Since 'A' and 'B' are arrays stored at different\n// locations in the heap, it then follows that the elements of 'A' are not modified.\n// However, the fact that the heap has changed at all makes the symbolic expressions\n// denoting the elements of 'A' look different before and after the heap.  The\n// assertion after the loop (which, like all assertions, is proved) is needed to\n// connect the two.\n\nmethod M(N: int, A: array<int>, B: array<int>)\n  requires 0 <= N && N == A.Length && N == B.Length && A != B\n  requires forall k :: 0 <= k < N ==> 0 <= A[k] < N\n  requires forall j, k :: 0 <= j < k < N ==> A[j] != A[k] // A is injective\n  requires forall m :: 0 <= m < N && inImage(m) ==> exists k :: 0 <= k < N && A[k] == m // A is surjective\n  modifies B\n  ensures forall k :: 0 <= k < N ==> 0 <= B[k] < N\n  ensures forall k :: 0 <= k < N ==> B[A[k]] == k == A[B[k]] // A and B are each other's inverses\n  ensures forall j, k :: 0 <= j < k < N ==> B[j] != B[k] // (which means that) B is injective\n{\n  for n := 0 to N\n    invariant forall k :: 0 <= k < n ==> B[A[k]] == k\n  {\n    B[A[n]] := n;\n  }\n\n  // it now follows from the surjectivity of A that A is the inverse of B:\n  assert forall j :: 0 <= j < N && inImage(j) ==> 0 <= B[j] < N && A[B[j]] == j;\n}\n\nghost function inImage(i: int): bool { true }  // this function is used to trigger the surjective quantification\n\nmethod Main()\n{\n  var a := new int[] [9, 3, 8, 2, 7, 4, 0, 1, 5, 6];\n  assert a[0] == 9;\n  assert a[1] == 3;\n  assert a[2] == 8;\n  assert a[3] == 2;\n  assert a[4] == 7;\n  assert a[5] == 4;\n  assert a[6] == 0;\n  assert a[7] == 1;\n  assert a[8] == 5;\n  assert a[9] == 6;\n\n  var b := new int[10];\n\n  M(10, a, b);\n  print \"a: \", a[..], \"\\n\";\n  print \"b: \", b[..], \"\\n\";\n}\n"}
{"file": "../dafny/Test/DafnyTestGeneration/TestGeneration.dfy", "dafny": "// NONUNIFORM: Multiple build steps (although could we use `dafny test` instead?)\n\n// Generating tests:\n// RUN: cp %S/TestGeneration.dfy %t.dfy\n// RUN: %baredafny generate-tests %args Block %t.dfy > %t-tests.dfy\n// RUN: %baredafny translate cs %args --include-runtime --verbose --no-verify \"%t-tests.dfy\" > \"%t\"\n// RUN: dotnet test -v:q %S >> %t\n\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK: .*Passed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3*\n\nmodule M {\n  datatype Value = Value(v:int)\n  method {:testEntry} compareToZero(v:Value) returns (i:int) {\n    if (v.v == 0) {\n      return 0;\n    } else if (v.v > 0) {\n      return 1;\n    }\n    return -1;\n  }\n}\n"}
{"file": "../dafny/Test/patterns/OrPatterns.dfy", "dafny": "// RUN: %testDafnyForEachCompiler --refresh-exit-code=0 \"%s\" -- --relax-definite-assignment\n\ndatatype Enum = One | Two | Three {\n  predicate Even() {\n    this.Two?\n  }\n\n  predicate Even'() {\n    match this\n      case One | Three => false\n      case Two => true\n  }\n\n  predicate Even''() {\n    match this\n      case Two => true\n      case One | Three => false\n  }\n\n  lemma EvenOk() ensures Even() == Even'() == Even''() {}\n}\n\nmodule Constants {\n  const ONE := 1\n  const TWO := 2\n\n  method M(i: int) {\n    match i\n      case | ONE | TWO => return; // `ONE` and `TWO` are not variables here\n      case | _ => // Not redundant\n  }\n}\n\nmodule Lists {\n  datatype List<T> = Nil | Cons(car: T, cdr: List<T>) {\n    ghost function {:fuel 5} Length(): nat {\n      match this\n        case Nil => 0\n        case Cons(_, t) => 1 + t.Length()\n    }\n  }\n\n  predicate ContainsOne(l: List<int>)\n    requires l.Length() == 3\n  {\n    l.car == 1 || l.cdr.car == 1 || l.cdr.cdr.car == 1\n  }\n\n  predicate ContainsOne'(l: List<int>)\n    requires l.Length() == 3\n  {\n    match l\n      case Cons(1, Cons(_, Cons(_, Nil)))\n         | Cons(_, Cons(1, Cons(_, Nil)))\n         | Cons(_, Cons(_, Cons(1, Nil))) =>\n       true\n      case Cons(_, Cons(_, Cons(_, Nil))) =>\n        false\n  }\n\n  lemma ContainsOneOK(l: List<int>)\n    requires l.Length() == 3\n    ensures ContainsOne(l) == ContainsOne'(l)\n  {}\n}\n\nimport opened Lists\n\nmodule TestVariables {\n  datatype DT = A | B | C\n\n  method M(dt: DT) returns (j: int) {\n    match dt {\n      case C => return 0;\n      case A | B => var x := (y => y)(1); assert x == 1;\n        return x;\n    }\n  }\n\n  method M2(dt: DT) returns (j: int) {\n    match dt {\n      case C => return 0;\n      case _ => var x := (y => y)(1); assert x == 1;\n        return x;\n    }\n  }\n\n  function F(dt: DT): int {\n    match dt {\n      case C => 0\n      case A | B => var x := (y => y)(1); assert x == 1; x\n    }\n  }\n  function F2(dt: DT): int {\n    match dt {\n      case C => 0\n      case _ => var x := (y => y)(1); assert x == 1; x\n    }\n  }\n}\nimport opened TestVariables\n\nmethod Main() {\n  expect One.Even() == One.Even'() == One.Even''() == false;\n  expect Two.Even() == Two.Even'() == Two.Even''() == true;\n  expect Three.Even() == Three.Even'() == Three.Even''() == false;\n\n  var a0 := Cons(0, Cons(0, Cons(0, Nil)));\n  expect ContainsOne(a0) == ContainsOne'(a0) == false;\n  var a1 := Cons(1, Cons(0, Cons(0, Nil)));\n  expect ContainsOne(a1) == ContainsOne'(a1) == true;\n  var a2 := Cons(0, Cons(1, Cons(0, Nil)));\n  expect ContainsOne(a2) == ContainsOne'(a2) == true;\n  var a3 := Cons(0, Cons(0, Cons(1, Nil)));\n  expect ContainsOne(a3) == ContainsOne'(a3) == true;\n  \n  var b0 := M(A);\n  var b1 := M(B);\n  var b2 := M2(A);\n  var b3 := M2(B);\n  var b4 := F(A);\n  var b5 := F(B);\n  var b6 := F2(A);\n  var b7 := F2(B);\n  expect 1 == b0 == b1 == b2 == b3 == b4 == b5 == b6 == b7;\n  \n  print \"OK\\n\";\n}\n"}
{"file": "../dafny/Test/examples/maximum.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file shows how to specify and implement a function to compute the\n// largest element of a list. The function is fully specified by two\n// preconditions, as proved by the MaximumIsUnique lemma below.\n\nmethod Maximum(values: seq<int>) returns (max: int)\n  requires values != []\n  ensures max in values\n  ensures forall i | 0 <= i < |values| :: values[i] <= max\n{\n  max := values[0];\n  for idx := 0 to |values|\n    invariant max in values\n    invariant forall j | 0 <= j < idx :: values[j] <= max\n  {\n    if max < values[idx] {\n      max := values[idx];\n    }\n  }\n}\n\nlemma MaximumIsUnique(values: seq<int>, m1: int, m2: int)\n  requires m1 in values && forall i | 0 <= i < |values| :: values[i] <= m1\n  requires m2 in values && forall i | 0 <= i < |values| :: values[i] <= m2\n  ensures m1 == m2 {\n    // This lemma does not need a body: Dafny is able to prove it correct entirely automatically.\n}\n"}
{"file": "../dafny/Test/examples/induction-principle-code/Utils.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Utils {\n  function Max(x: int, y: int): int\n  {\n    if x > y then x else y\n  }\n\n  function {:opaque} MaxF<T(!new)>(f: T ~> int, ts: seq<T>, default: int) : (m: int)\n    reads set x, y | x in ts && y in f.reads(x) :: y\n    requires forall t : T | t in ts :: f.requires(t)\n    requires forall t | t in ts :: default <= f(t)\n    ensures if ts == [] then m == default else exists t | t in ts :: f(t) == m\n    ensures forall t | t in ts :: f(t) <= m\n    ensures default <= m\n  {\n    if ts == [] then default\n    else\n      Max(f(ts[0]), MaxF(f, ts[1..], default))\n  }\n\n  datatype Result<T> = | Success(value: T) | Failure\n  {\n    predicate IsFailure() {\n      Failure?\n    }\n\n    function PropagateFailure<U>(): Result<U>\n      requires Failure?\n    {\n      Failure\n    }\n\n    function Extract(): T\n      requires Success?\n    {\n      value\n    }\n  }\n\n  datatype Option<T> = Some(value: T) | None\n}\n"}
{"file": "../dafny/Test/benchmarks/sequence-race/SequenceRace.dfy", "dafny": "// Only because we're calling gradlew rather than gradlew.bat\n// UNSUPPORTED: windows\n\n// Ensure trying to use an unsupported compilation target results in a clean error message.\n// RUN: %exits-with 3 %baredafny translate cs %args \"%s\" --plugin:DafnyBenchmarkingPlugin.dll > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// RUN: %baredafny translate java %args \"%s\" --plugin:DafnyBenchmarkingPlugin.dll\n// RUN: rm -rf %S/java/src/jmh\n// RUN: mkdir -p %S/java/src/jmh\n// RUN: cp -r %S/SequenceRace-java %S/java/src/jmh/java\n\n// Note the intentional \">\" as opposed to \">>\", so we can check just the benchmark run output.\n// RUN: %S/java/gradlew jmh -p %S/java > \"%t\"\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n\n// Verify the benchmark actually ran and did not hit any exceptions.\n// CHECK: # Benchmark: _System.SequenceRace.LazyRace\n// CHECK-NOT: <failure>\n// Verify the teardown is only run once per iteration\n// CHECK: Iteration   1: That's all folks!\n// CHECK: Iteration   2: That's all folks!\n// CHECK: # Run complete.\n\n//\n// Sanity test of the benchmarking plugin,\n// and a regression test for https://github.com/dafny-lang/dafny/issues/1454.\n//\n// A class with {:benchmarks} will be translated to a form that target language\n// benchmarking frameworks can integrate with relatively easily.\n// For each method on such classes,\n// a single instance of the class will be instantiated using the no-argument constructor,\n// and then one or more concurrent executions of the method will be triggered.\n// \nclass {:benchmarks} SequenceRace {\n\n  const s: seq<int>\n\n  constructor() {\n    s := [];\n    for x := 0 to 1000 {\n      s := s + [x];\n    }\n  }\n\n  method LazyRace() {\n    // Using expect means compilers can't optimize calculations away\n    // since they could lead to throwing exceptions.\n    expect 0 < |s|;\n    expect s[0] == 0;\n  }\n\n  method {:benchmarkTearDown} TearDown() {\n    print \"That's all folks!\\n\";\n  }\n}"}
{"file": "../dafny/Test/wishlist/FuelTriggers.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// THIS USED TO BE THE CASE:\n//\n//     With the default version of opaque + fuel, the following fails to verify\n//     because the quantifier in the requires used a trigger that included\n//     StartFuel_P, while the assert used StartFuelAssert_P.  Since P is\n//     opaque, we can't tell that those fuels are the same, and hence the\n//     trigger never fires. A wish would be to fix this.\n//\n// This has been fixed, so the test assertion is now passing.\n\nghost predicate {:opaque} P(x:int)\n\nmethod test(y:int)\n  requires forall x :: P(x)\n{\n  assert P(y);\n}\n"}
{"file": "../dafny/Test/wishlist/GoModule.dfy", "dafny": "// NONUNIFORM: Go-specific extern test\n// RUN: %exits-with 3 %dafny /compile:3 /unicodeChar:0 /spillTargetCode:2 \"%s\" /compileTarget:go 2> \"%t\"\n// note: putting /compileTarget:go after \"%s\" overrides user-provided option\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK: GoModuleConversions.go:10:3: \"net/url\" imported and not used\n\n// This test used to work only because of a questionable Go-only feature\n// of mapping a Dafny string directly to a Go string when passed in or out of\n// an extern method. It barely worked in one direction and not in the other\n// (see https://github.com/dafny-lang/dafny/issues/2989),\n// and even when it did, equating these two types was not actually sound in all cases anyway.\n// This feature has been disabled since Dafny 4.0,\n// and unfortunately I found that rewriting the test to work without it was very\n// difficult for unrelated reasons.\n// In particular this version should work but produces unused imports\n// which the Go compiler complains about\n// (see https://github.com/dafny-lang/dafny/issues/2953).\n// Instead I've converted this into a negative test.\n\n// \"url\" is a built-in package, so it should be accessible to the\n// test suite without further requirements on the setup.\nmodule {:extern \"url\", \"net/url\"} URL {\n\n  class URL {\n    var {:extern \"Host\"} host: string\n    var {:extern \"Path\"} pathname: string\n    var {:extern \"RawQuery\"} search: string\n  }\n\n  trait {:extern \"\", \"error\"} Error { }\n}\n\nmodule {:extern \"GoModuleConversions\"} GoModuleConversions {\n  import opened URL\n  method {:extern \"ParseURL\"} Parse(address: string) returns (url: URL, error: Error?)\n}\n\nmodule Test {\n\n  import GoModuleConversions\n\n  method TryUrl(address: string) {\n    var u, e := GoModuleConversions.Parse(address);\n    if (e != null) {\n      print \"Parse error: \", e, \"\\n\";\n    } else {\n      print \"The address \", address, \"\\n\";\n      print \"has the following parts:\\n\";\n      print \"host: \", u.host, \"\\n\";\n      print \"pathname: \", u.pathname, \"\\n\";\n      print \"search: \", u.search, \"\\n\";\n    }\n  }\n\n  method Main() {\n    TryUrl(\"http://localhost:8080/default.htm?year=1915&month=august&day=29\");\n    TryUrl(\"http://localhost:8080/default.htm%\");\n  }\n}\n"}
{"file": "../dafny/Test/wishlist/we-should-always-print-tooltips.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips %S/we-should-always-print-tooltips.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// WISH it would be great to add /printTooltips to all tests\n"}
{"file": "../dafny/Test/wishlist/granted/strings.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod EqualityOfStrings() {\n  assert \"a\" != \"b\"; // WISH -- granted\n}\n"}
{"file": "../dafny/Test/wishlist/granted/useless-casts-in-decreases-clauses.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod M() {\n  var pos := 10;\n  while (pos > 0) { // This shouldn't print int(pos) - int(0); pos - 0 would be better\n    pos := pos - 1;\n  }\n}\n"}
{"file": "../dafny/Test/VerifyThis2015/Problem3.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n// Rustan Leino\n// 12 April 2015\n// VerifyThis 2015\n// Problem 3 -- Dancing Links\n\n\n// The following method demonstrates that Remove and PutBack (defined below) have the desired properties\nmethod Test(dd: DoublyLinkedList, x: Node)\n  requires dd.Valid()\n  requires x in dd.Nodes && x != dd.Nodes[0] && x != dd.Nodes[|dd.Nodes|-1]\n  modifies dd, dd.Nodes\n  ensures dd.Valid() && dd.Nodes == old(dd.Nodes)\n{\n  ghost var k := dd.Remove(x);\n  dd.PutBack(x, k);\n}\n// It is also possible to remove and put back any number of elements, provided these operations are\n// done in a FOLI order.\nmethod TestMany(dd: DoublyLinkedList, xs: seq<Node>)\n  requires dd.Valid()\n  requires forall x :: x in xs ==> x in dd.Nodes && x != dd.Nodes[0] && x != dd.Nodes[|dd.Nodes|-1]\n  requires forall i,j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n  modifies dd, dd.Nodes\n  ensures dd.Valid() && dd.Nodes == old(dd.Nodes)\n{\n  if xs != [] {\n    var x := xs[0];\n    ghost var k := dd.Remove(x);\n    forall y | y in xs[1..]\n      ensures y in dd.Nodes && y != dd.Nodes[0] && y != dd.Nodes[|dd.Nodes|-1]\n    {\n      assert forall z :: z in old(dd.Nodes) ==> z in dd.Nodes || z == x;\n      assert x == old(dd.Nodes)[k];\n    }\n    TestMany(dd, xs[1..]);\n    dd.PutBack(x, k);\n  }\n}\n\n// And here's a Main program that shows that doubly linked lists do exist (well, at least there is one :))\nmethod Main()\n{\n  var a0 := new Node;\n  var a1 := new Node;\n  var a2 := new Node;\n  var a3 := new Node;\n  var a4 := new Node;\n  var a5 := new Node;\n  var dd := new DoublyLinkedList([a0, a1, a2, a3, a4, a5]);\n  Test(dd, a3);\n  TestMany(dd, [a2, a4, a3]);\n}\n\nclass Node {\n  var L: Node?\n  var R: Node?\n}\n\nclass DoublyLinkedList {\n  ghost var Nodes: seq<Node>  // sequence of nodes in the linked list\n  // Valid() says that the data structure is a proper doubly linked list\n  ghost predicate Valid()\n    reads this, Nodes\n  {\n    (|Nodes| > 0 ==>\n      Nodes[0].L == null && (forall i {:trigger Nodes[i].L} :: 1 <= i < |Nodes| ==> Nodes[i].L == Nodes[i-1]) &&\n      (forall i {:trigger Nodes[i].R} :: 0 <= i < |Nodes|-1 ==> Nodes[i].R == Nodes[i+1]) && Nodes[|Nodes|-1].R == null\n    ) &&\n    forall i,j :: 0 <= i < j < |Nodes| ==> Nodes[i] != Nodes[j]  // this is actually a consequence of the previous conditions\n  }\n  // This constructor just shows that there is a way to create a doubly linked list.  It accepts\n  // as an argument the sequences of Nodes to construct the doubly linked list from.  The constructor\n  // will change all the .L and .R pointers of the given nodes in order to create a properly\n  // formed list.\n  constructor (nodes: seq<Node>)\n    requires forall i,j :: 0 <= i < j < |nodes| ==> nodes[i] != nodes[j]\n    modifies nodes\n    ensures Valid() && Nodes == nodes\n  {\n    if nodes != [] {\n      var prev, n := nodes[0], 1;\n      prev.L, prev.R := null, null;\n      while n < |nodes|\n        invariant 1 <= n <= |nodes|\n        invariant nodes[0].L == null\n        invariant prev == nodes[n-1] && prev.R == null\n        invariant forall i :: 1 <= i < n ==> nodes[i].L == nodes[i-1]\n        invariant forall i :: 0 <= i < n-1 ==> nodes[i].R == nodes[i+1]\n      {\n        nodes[n].L, prev.R, prev := prev, nodes[n], nodes[n];\n        prev.R := null;\n        n := n + 1;\n      }\n    }\n    Nodes := nodes;\n  }\n\n  ghost function PopMiddle<T>(s: seq<T>, k: nat) : seq<T>\n    requires k < |s| {\n      s[..k] + s[k+1..]\n  }\n\n  ghost predicate Injective<T>(s: seq<T>) {\n    forall j, k :: 0 <= j < k < |s| ==> s[j] != s[k]\n  }\n\n  lemma InjectiveAfterPop<T>(s: seq<T>, k: nat)\n    requires k < |s|\n    requires Injective(s)\n    ensures  Injective(PopMiddle(s, k))\n  {\n  }\n\n  method Remove(x: Node) returns (ghost k: int)\n    requires Valid()\n    requires x in Nodes && x != Nodes[0] && x != Nodes[|Nodes|-1]  // not allowed to remove end nodes; you may think of them as a sentinel nodes\n    modifies this, Nodes\n    ensures Valid()\n    ensures 0 <= k < |old(Nodes)| && x == old(Nodes)[k]\n    ensures Nodes == old(Nodes)[..k] + old(Nodes)[k+1..] && x.L == old(x.L) && x.R == old(x.R)\n  {\n    k :| 1 <= k < |Nodes|-1 && Nodes[k] == x;\n    x.R.L := x.L;\n    x.L.R := x.R;\n\n    Nodes := Nodes[..k] + Nodes[k+1..];\n    assert |Nodes| > 0;\n  }\n\n  // One might consider have a precondition that says there exists a \"k\" with the properties given here.\n  // However, we want to be able to refer to \"k\" in the postcondition as well, so it's convenient to\n  // burden the client with having to pass in \"k\" as a ghost parameter.  This, however, is really no\n  // extra burden on the client, because if the client would have been able to show the existence of\n  // such a \"k\", then the client can easily just use an assign-such-that statement to obtain such a\n  // value \"k\".\n  method PutBack(x: Node, ghost k: int)\n    requires Valid()\n    requires 1 <= k < |Nodes| && x.L == Nodes[k-1] && x.R == Nodes[k]\n    modifies this, Nodes, x\n    ensures Valid()\n    ensures Nodes == old(Nodes)[..k] + [x] + old(Nodes)[k..]\n  {\n    x.R.L := x;\n    x.L.R := x;\n    Nodes := Nodes[..k] + [x] + Nodes[k..];\n  }\n}\n\n// --------------------------------------------------------\n// If it were not required to build a data structure (like the class above) that supports the\n// Remove and PutBack operations, the operations can easily be verified to compose into the\n// identity transformation.  The following method shows that the two operations, under a suitable\n// precondition, have no net effect on any .L or .R field.\n\nmethod Alt(x: Node)\n  requires x.L != null && x.R != null\n  requires x.L.R == x && x.R.L == x  // links are mirrored\n  modifies x, x.L, x.R\n  ensures forall y: Node :: old(allocated(y)) ==> y.L == old(y.L) && y.R == old(y.R)\n{\n  // remove\n  x.R.L := x.L;\n  x.L.R := x.R;\n  // put back\n  x.R.L := x;\n  x.L.R := x;\n}\n"}
{"file": "../dafny/Test/linters/constructorCaseWithoutParentheses.dfy", "dafny": "// RUN: %baredafny verify %args --warn-missing-constructor-parentheses \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule WithWarning {\n  datatype Color = Red | Green | ShadesOfGray(nat)\n  datatype Identity<T> = Identity(value: T)\n  datatype Colors = Yellow | Blue\n  datatype T = A | B\n  method M(t: T) { \n    match t\n      case A => print \"A\";\n      case B => print \"B\";\n  }\n  function Foo(value: Identity<Colors>): bool {\n    match value {\n      case Identity(Yellow()) => true\n      case Identity(Blue) => false\n    }\n  }\n  method MonochromaticMethod(c: Color) returns (x: bool) {\n    return match c\n      case ShadesOfGray => true\n      case Green => true\n      case anythingElse => false;\n  }\n  function MonochromaticFunction(c: Color) : bool {\n    match c\n      case ShadesOfGray => true\n      case Green => true\n      case anythingElse => false      \n  }\n  method MonochromaticMethodloop(c: Color) returns (x: bool)  {\n    var test := false;\n    while test    \n    {\n       test := match c\n         case ShadesOfGray => true\n         case Green => true      \n         case anythingElse => false;\n    }\n    return false; \n  }\n   \n}\n\nmodule WithoutWarning {\n  datatype Color = Red | Green | ShadesOfGray(nat)\n  datatype Identity<T> = Identity(value: T)\n  datatype Colors = Yellow | Blue\n  datatype T = A | B\n    method M(t: T) { \n      match t\n        case A() => print \"A\";\n        case B() => print \"B\";\n    }\n  function Foo(value: Identity<Colors>): bool {\n    match value {\n      case Identity(Yellow()) => true\n      case Identity(Blue()) => false\n    }\n  }\n  method MonochromaticMethod(c: Color) returns (x: bool) {\n        return match c\n          case ShadesOfGray(_) => true\n          case Green() => true\n          case anythingElse => false;\n  }\n  function MonochromaticFunction(c: Color) : bool {\n        match c\n          case ShadesOfGray(_) => true\n          case Green() => true\n          case anythingElse => false\n  }\n  method MonochromaticMethodloop(c: Color) returns (x: bool)  {\n        while false {\n          x := match c\n              case ShadesOfGray(_) => true\n              case Green() => true\n              case anythingElse => false;\n        }\n      return false; \n  }\n  method Main() {\n        var x := MonochromaticMethod(Green); \n        print MonochromaticFunction(Green);\n        var y := MonochromaticMethodloop(Green);\n        print Foo(Identity(Blue));\n      }\n}\n\n\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-2747.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function AnotherBrokenFunction(): nat {\n  var y := 0;\n  assert true by {\n    if\n    case x: bool :| true =>\n      assert true || x;\n  }\n  0\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-4483.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\nconst TWO_TO_THE_64:  int := 0x1_00000000_00000000\nnewtype uint64 = x: int | 0 <= x < TWO_TO_THE_64\n\nmethod Foo() returns (tuple: (uint64, uint64)) {\n  var s := [1,2,3];\n  var (foo, length) := (0, |s| as uint64);\n  return (foo, length);\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-2989.dfy", "dafny": "// NONUNIFORM: Go-specific regression test\n// RUN: %baredafny translate go %args --unicode-char:false \"%s\" > \"%t\"\n// RUN: %baredafny translate go %args --unicode-char:true \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\" \n\nmethod Main() {\n  var s := Foo();\n}\n\n// An extern method that returned a string used to cause\n// an internal contract violation and nonsensical errors like\n// \"Error: Cannot convert from string to seq<char>\"\n\nmethod {:extern \"foo\"} Foo() returns (s: string)\n\nmethod Bar() returns (s: string) {\n  return \"hello\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-588.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmodule myclass {\n  class MyClass {\n    var num: int\n\n    constructor (x: int) {\n      num := x;\n    }\n  }\n\n  method Main() {\n    var c_obj := new MyClass(2);\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-446a.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\ndatatype Result<T> = Success(value: T) | Failure(error: string)\n{\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): Result<U>\n    requires Failure?\n  {\n    Failure(this.error)\n  }\n}\nclass A {\n  method mn() returns (r: Result<int>, out: int)\n    ensures out == -2 && r.Failure?\n  {\n    var o :- m(1);\n    assert o == 3;\n    print \"OK\\n\";\n    out :- this.m(-1); // Should exit with failure\n    return Success(0), 4;\n  }\n\n  method mn1() returns (r: Result<int>)\n    ensures r.Failure?\n  {\n    :- m1(1);\n    print \"OK\\n\";\n    :- m1(-1); // SHould exit with failure\n    return Success(0);\n  }\n\n  method m(i: int) returns (r: Result<int>, o: int)\n    ensures 0 <= i ==> r.Success? && r.value == i && o == i+i+i\n    ensures i < 0 ==> r.Failure? && o == i+i\n  {\n    if i < 0 { return Failure(\"negative\"), i+i; }\n    return Success(i), i+i+i;\n  }\n\n  method m1(i: int) returns (r: Result<int>)\n    ensures 0 <= i ==> r.Success? && r.value == i\n    ensures i < 0 ==> r.Failure?\n  {\n    if i < 0 { return Failure(\"negative\"); }\n    return Success(i);\n  }\n\n  method mexp() returns (r: Result<int>, k: int)\n    ensures r.IsFailure() && k == 100\n  {\n    k :- Result<int>.Failure(\"always\"), 100;\n    k := 101; // Not executed\n    return Success(0), k;\n  }\n}\n\nmethod Main() {\n  var a: A := new A;\n  var x := a.mn1();\n  print x.Failure?, \" \";\n  var out;\n  x, out := a.mn();\n  print x.Failure?, \" \", out, \" \";\n  print \"End\\n\";\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-286.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Option<T> = None | Some(t:T)\n\nclass C {\n  method m(x: Option<bool>) {\n    var a := match x { case Some(true) => false case _ => true };\n  }\n}\n\nclass D<T> {\n  method mm(x: Option<int>) {\n    var b := match x { case Some(5) => false case _ => true };\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-276r.dfy", "dafny": "// RUN: %dafny /compile:0 /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Testing constant folding of real operations\nmodule Main {\n  newtype b0 = x | 0 <= x < (2.0+3.0) as int\n  newtype b1 = x | 0 <= x < (3.0-2.0) as int\n  newtype b2 = x | 0 <= x < (3.0*2.0) as int\n  newtype b3 = x | 0 <= x < (4.0/2.0) as int\n  newtype b4 = x | 0 <= x < (4.0 + (-2.0)) as int\n  newtype b5 = x | 0 <= x < 1000 as real as int\n  newtype b6 = x | 0 <= x < 'c' as real as int\n  newtype b7 = x | 0 <= x < 2000 as bv16 as real as int\n  newtype b8 = x | 0 <= x < 20 as char as int\n  newtype b9 = x | 0 <= x < 20 as bv8 as int\n  newtype b10 = x | 0 <= x < 30.0 as real as int\n  newtype b11 = x | 0 <= x < (if 2.0<3.0 then 35 else 40)\n  newtype b12 = x | 0 <= x < (if 3.0<=3.0 then 35 else 40)\n  newtype b13 = x | 0 <= x < (if 2.0>3.0 then 35 else 40)\n  newtype b14 = x | 0 <= x < (if 2.0>=3.0 then 35 else 40)\n  newtype b15 = x | 0 <= x < (if 2.0==3.0 then 35 else 40)\n  newtype b16 = x | 0 <= x < (if 2.0!=3.0 then 35 else 40)\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-697e.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\ndatatype Cell = Cell(x: int)\ntype EvenCell = c: Cell | c.x % 2 == 0 witness Cell(0)\n\nfunction doubleEvenCell(f: EvenCell): int\n{\n  if f.x % 2 == 1 then 1/0 else f.x * 2\n}\n\nmethod Main() {\n  var x: set<Cell> := { Cell(1), Cell(2), Cell(3), Cell(4) };\n  var b := forall g :: g in x ==> doubleEvenCell(g) > 0;\n  assert b;\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-849a.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule B {\n  datatype Test = Test(v: nat, w: nat)\n  method m(oldTest: Test) {\n    var newTest2: Test := oldTest.(v := 1, w := 2);\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2581.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\nmethod Main() {\n  expect IsEmpty(\"\");\n}\n\npredicate IsEmpty<T>(s: seq<T>) {\n  s == []\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2959.dfy", "dafny": "// RUN: %exits-with 3 %baredafny build --show-snippets:false --use-basename-for-filename --enforce-determinism \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod NondetIf() returns (x: int) {\n  if * {\n    x := 0;\n  } else {\n    x := 1;\n  }\n}\n\nmethod NondetAssign() returns (x: int) {\n  x := *;\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-2230.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\nlemma MergeLShift(v: bv128, i: nat, j: nat)\n  requires i <= 128 && j <= 128 && i + j <= 128\n  ensures v << i << j == v << i + j\n\nmethod M2(i: nat)\n  requires i <= 64\n{\n  ghost var half: bv128 := 0xffff_ffff_ffff_ffff;\n  MergeLShift(half, 64, 64 - i);\n  assert half << 64 - i << 64 == half << (128 - i);\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1875.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n/// This file checks whether sufficient axioms are generated to compare\n/// datatypes constructed using subset types over sequences.\n\nmodule Datatype {\n  datatype Box_<T> = Box(t: T)\n  type Box<T> = b: Box_<T> | true witness *\n\n  datatype List<T> = Nil | Cons(t: T, Box<List<T>>)\n\n  ghost function Length<T>(l: List<T>): int {\n    match l {\n      case Nil => 0\n      case Cons(t, q) => 1 + Length(q.t)\n    }\n  }\n}\n\nmodule Seq {\n  type Box_<T> = seq<T>\n  type Box<T> = b: Box_<T> | |b| == 1 witness *\n\n  datatype List<T> = Nil | Cons(t: T, Box<List<T>>)\n\n  ghost function Length<T>(l: List<T>): int {\n    match l {\n      case Nil => 0\n      case Cons(t, q) =>\n        assert q[0] in q;\n        var l :| l in q;\n        Length(l)\n    }\n  }\n}\n\nmodule Set {\n  type Box_<T> = set<T>\n  type Box<T> = b: Box_<T> | |b| == 1 witness *\n\n  datatype List<T(==)> = Nil | Cons(t: T, Box<List<T>>)\n\n  ghost function Length<T>(l: List<T>): int {\n    match l {\n      case Nil => 0\n      case Cons(t, q) =>\n        var l :| l in q;\n        Length(l)\n    }\n  }\n}\n\nmodule Multiset {\n  type Box_<T> = multiset<T>\n  type Box<T> = b: Box_<T> | |b| == 1 witness *\n\n  datatype List<T(==)> = Nil | Cons(t: T, Box<List<T>>)\n\n  ghost function Length<T>(l: List<T>): int {\n    match l {\n      case Nil => 0\n      case Cons(t, q) =>\n        var l :| l in q;\n        Length(l)\n    }\n  }\n}\n\nmodule Map {\n  type Box_<T> = map<T, bool>\n  type Box<T> = b: Box_<T> | |b| == 1 witness *\n\n  datatype List<T(==)> = Nil | Cons(t: T, Box<List<T>>)\n\n  ghost function Length<T>(l: List<T>): int {\n    match l {\n      case Nil => 0\n      case Cons(t, q) =>\n        var l :| l in q.Keys;\n        Length(l)\n    }\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3482.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype X = X\nlemma Foo(x: X) returns (y: bool) {\n  match x {\n    case X => return old(x) == x;\n    case _ =>\n  }\n  return false;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-401.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %dafny /compile:0 /proverOpt:PROVER_PATH=\"%z3\" \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// UNSUPPORTED: windows\nmethod m() {\n  assert 1 + 1 == 2;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3995.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntrait Animal {\n    function           not_opaque() : ( rv : int)\n    function {:opaque} iam_opaque() : ( rv : int) \n\n    predicate depends_on_not_opaque() \n       ensures  not_opaque() == 42 \n    predicate depends_on_iam_opaque() \n       ensures  iam_opaque() == 42 \n}\n\nclass Cat extends Animal {\n    function           not_opaque() : ( rv : int) { 42 } \n    function {:opaque} iam_opaque() : ( rv : int) \n         //ensures rv == 42\n         { reveal iam_opaque();  42 } \n\n    predicate depends_on_not_opaque() \n       ensures not_opaque() == 42 {true}\n    predicate depends_on_iam_opaque() \n       ensures iam_opaque() == 42 {reveal iam_opaque(); true}\n}\n\ntrait T {\n  predicate Valid(x: int)\n  method MyMethod(x: int) requires Valid(x)\n}\n\nclass C extends T {\n  predicate {:opaque} Valid(x: int) { true }\n  method MyMethod(x: int) requires Valid(x) {\n  }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-3908.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype List<T> = Nil | Cons(T, List<T>)\n\nmethod UnexpectedError<G>(l: List<G>)\n{\n  var x0: real;\n  match l\n  case Cons(x: G, y) =>\n    x0 := 31.4; // this once generated a bogus error that real cannot be assigned to G\n  case Nil =>\n}\n\nmethod UnexpectedDuplicateName<G>(l: List<G>)\n{\n  match l\n  case Cons(x: G, y) =>\n    var x0: real; // this once generated a bogus error that name of local variable x0 is a duplicate\n  case Nil =>\n}\n\nfunction UnexpectedErrorInFunction<G>(l: List<G>): int\n{\n  var x0: real := 3.14;\n  match l\n  case Cons(x: G, y) =>\n    var a: real := x0; // this once generated a bogus error that G cannot be assigned to real\n    10\n  case Nil =>\n    11\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-817a.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\ndatatype Result<T> = Failure(msg: string) | Success(value: T) {\n  predicate IsFailure() { Failure? }\n  function PropagateFailure(): Result<T> requires IsFailure() { this }\n  function Extract(): (t: T) requires !IsFailure() ensures t == this.value { this.value }\n}\n\nclass Cell {\n  var data: int\n}\n\nmethod M(a: array<int>, c: Cell) returns (r: Result<int>)\n  requires a.Length == 10\n  modifies a, c\n  ensures r.Success? ==> r.value == 200\n  ensures c.data == 9\n{\n  a[7] := 180;\n  c.data := 9;\n  r := Success(200);\n}\n\nmethod P() returns (r: Result<int>){\n  var a := new int[10];\n  a[7] := 321;\n  a[9] := 142;\n  var c := new Cell;\n  c.data := 7;\n  // The following statement should first compute the l-value for a[c.data], namely a[7].\n  // Then it should call M, which has side effects on a,c.\n  // Then, if M is successful, it should set a[7] to 200.\n  a[c.data] :- M(a, c);\n  assert a.Length == 10;\n  assert a[7] == 200;\n  assert c.data == 9;\n  print c.data, \" \", a[7], \" \", a[9], \"\\n\"; // 9 200 142\n  r := *;\n}\n\nmethod Main() {\n  var _ := P();\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-336.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nlemma TestMap(a: map<int, (int,int)>) {\n  // The following assertion used to not prove automatically\n  assert (map k | k in a :: k := a[k].0)\n         // the following map comprehension implicitly uses k as the key\n      == (map k | k in a :: a[k].0);\n}\n\nlemma TestSet0(a: set<int>) {\n  assert (set k | k in a && k < 7 :: k)\n         // the following set comprehension implicitly uses k as the term\n      == (set k | k in a && k < 7);\n}\n\nlemma TestSet1(a: set<int>, m: int) {\n  assert (set k | k in a && k < 7 :: k)\n      == (set k | k in a && k < 7 :: m + (k - m));\n}\n\nlemma TestSet2(a: set<int>, m: int)\n  requires m in a && m < 7\n{\n  assert (set k | k < 7 && k in a)\n      == (set k | k in a :: if k < 7 then k else m);\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2708.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() {\n  Sequences();\n  Arrays();\n  print \"that's all, folks!\\n\";\n}\n\nmethod Sequences() {\n  var a1 := [42];\n  var a2 := [42];\n  assert a1 == a2;\n  expect a1 == a2;\n}\n\nmethod Arrays() {\n  var a1 := new int[] [42];\n  var a2 := new int[] [42];\n  assert a1 != a2;\n  expect a1 != a2;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1347.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Foo {\n  datatype T = TX()\n  datatype U = U\n  datatype V = TV()\n  datatype W0 = W0()\n  datatype W1 = W1()\n}\n\nmodule Bar {\n  datatype T = TY()\n  datatype U = U\n  ghost function V(): int\n  datatype W0 = W0\n  datatype W1 = W1\n}\n\nmodule Consumer {\n  import opened Foo\n  import opened Bar\n\n  type W0 = Foo.W0\n  type W1 = Bar.W1\n\n  // The following export set once caused a crash in Dafny, because of the\n  // ambiguously import-opened T (and U).\n  export\n    provides Foo, Bar\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-4144.dfy", "dafny": "// RUN: %baredafny verify %args %s > %t\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule P {\n  predicate m() reads {}\n  predicate p() reads []\n  predicate q() reads multiset{}\n  \n  predicate k(o: object) reads (() => {o})\n  predicate l(o: object) reads ((x: int) => [o])\n  predicate n(o: object) reads ((y: real, z: real) => multiset{o})\n\n  predicate k'() reads (() => {})\n  predicate l'() reads ((x: int) => [])\n  predicate n'() reads ((y: real, z: real) => multiset{})\n} \n\nmodule Q refines P {\n  predicate m() { true }\n  predicate p() { true }\n  predicate q() { true }\n  \n  predicate k(o: object) { true }\n  predicate l(o: object) { true }\n  predicate n(o: object) { true }\n\n  predicate k'() { true }\n  predicate l'() { true }\n  predicate n'() { true }\n}\n\nmodule EmptySet {\n    predicate m()\n      reads {}\n    {\n      m'({}, 0)\n    }\n    \n    predicate m'(s: set<object?>, j: nat)\n      reads {}\n      decreases s, j // note, explicit decreases clause\n    {\n      if s == {} then true else m()\n    }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-332.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  var foo := new B.Foo(15);\n  print foo.I(), \"\\n\";\n}\n\nabstract module A {\n  class Foo {\n    var x: int\n    constructor (u: int) { x := u; }\n    twostate function F(): int reads this\n    twostate predicate G() reads this\n    ghost function H(): int reads this\n    function I(): int reads this\n    ghost predicate J() reads this\n  }\n}\n\nmodule B refines A {\n  class Foo ... {\n    twostate function F(): int { old(x) + x }\n    twostate predicate G() { old(x) <= x }\n    ghost function H(): int { x + 4 }\n    function I(): int { x + 5 }\n    ghost predicate J() { x <= x }\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1423.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate P(s: seq)\n\nmethod M(s: seq<int>, i: nat, v: int, n: nat)\n  requires i < n <= |s|\n  requires P(s[n..])\n{\n  var t := s[i := v];\n  // Before issue 1423 was fixed, the following assertion did not prove automatically\n  assert P(t[n..]);\n}\n\nmethod Workaround(s: seq<int>, i: nat, v: int, n: nat)\n  requires i < n <= |s|\n  requires P(s[n..])\n{\n  var t := s[i := v];\n  assert s[n..] == t[n..];\n  assert P(t[n..]);\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-371.dfy", "dafny": "// RUN: %dafny /compile:0 /env:0 /dprint:- \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n  type TT = int\n}\n\nmodule MA {\n  module Inner {\n    type T17 = x | 0 <= x < 17\n  }\n}\n\nmodule MB {\n  module I {\n    type T42 = x | 0 <= x < 42\n  }\n}\n\nmodule A {\n\n  import TTT = M\n\n  import M\n\n  import MA\n  import MAI = MA.Inner\n  import MA.Inner\n  import MB\n  import II = MB.I\n\n  class ZZ {\n    var zc: II.T42\n    var zd: M.TT\n    var ze: TTT.TT\n    var zf: MAI.T17\n    var zg: Inner.T17\n    var zh: MA.Inner.T17\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3956.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\ndatatype AAA<X> = CtorA\ndatatype BBB<Y> = CtorB\ntype AaaBbb<R> = AAA<BBB<R>>\ndatatype MyType<W> = MyType(n: AaaBbb<W>)\n\nmethod Main() {\n  var m: MyType<char> := MyType(CtorA);\n  print m, \"\\n\"; // AAA.CtorA\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-4284.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --compile-suffix\n\nmethod Main() {\n  print (true, false), \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-330.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n\ndatatype Option<A> = Some(value: A) | None\n\ndatatype T<A> = T(value: Option<A>)\n\nghost function f(t: T<int>) : T<int>\n{\n  match t.value {\n    case Some(val) => T(Some(val))\n    case None =>  T(None)\n  }\n}\n\nghost function fok(t: T<int>) : T<int>\n{\n  match t.value {\n    case Some(val) => T(Some(val))\n    case None => (\n      var none : Option<int> := None;\n      T(none)\n    )\n  }\n}\n\nghost function fok1(t: T<int>) : T<int>\n{\n  match t.value {\n    case Some(val) => T(Some(val))\n    case None => T<int>.T(None)\n  }\n}\n\nghost function fok2(t: T<int>) : T<int>\n{\n  match t.value {\n    case Some(val) => T(Some(val))\n    case None => T(Option<int>.None)\n  }\n}\n\nghost function fok3(t: T<int>) : T<int>\n{\n  match t.value {\n    case Some(val) => T(Some(val))\n    case None => T<int>.T(Option<int>.None)\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-904.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule FOO {\n  //  two fields are needed\n  datatype D = D(\n    f1: nat,\n    f2: nat\n  )\n\n  function f(d : D) : nat\n    ensures f(d) != 0\n\n  const D0 := D(0, 0)\n\n  //  Similar outcomes occur using f1 or f2\n  const C1 :=  D0.(f2 := f(D0))\n\n  class E {\n    var a : D\n    constructor ()  {\n      a := C1;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-1267.dfy", "dafny": "// RUN: %dafny /compile:0 /env:0 /dprint:- \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Test()\n{\n  var tuple0 := (1 := 300, 0 := 10);\n  var tuple1 := (10, 300);\n  assert tuple0 == tuple1;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1815b.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\ndatatype Y<+U> = Y(y: U)\n\ntrait Tr {}\nclass Cl extends Tr {\n  constructor () {}\n}\n\nmethod Main() {\n  // Because Y is an erasable type wrapper, it gets compiled as its argument,\n  // so even Java supports this one.\n  var cl := new Cl();\n  var e: Y<Tr> := Y(cl);\n  match e\n  case Y(tr) => return;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1957.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass {:autocontracts} Thing {\n    ghost predicate Valid() {\n        true\n    }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-611.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M1 {\n  export reveals *\n  export Nothing\n\n  type T\n}\n\nmodule M2 {\n  import M1\n  import Nothing = M1`Nothing\n\n  export provides f, Nothing\n\n  ghost function f() : M1.T\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-2071.dfy", "dafny": "// RUN: %dafny /compile:1 /spillTargetCode:2 /compileTarget:java \"%s\" > \"%t\"\n// RUN: javac -cp %binaryDir/DafnyRuntime.jar%{pathsep}%S/git-issue-2071-java %S/git-issue-2071-java/git_issue_2071.java %S/git-issue-2071-java/*/*.java >> \"%t\"\n// RUN: java -ea -cp %binaryDir/DafnyRuntime.jar%{pathsep}%S/git-issue-2071-java git_issue_2071 >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction singletonSeq<T>(x: T): seq<T> {\n  [x]\n}\n\ndatatype MyDatatype = MyDatatype\n\nmethod Main() {\n  // OK\n  print [MyDatatype], \"\\n\";\n\n  // Assertion failure\n  print singletonSeq(MyDatatype), \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1984.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod {:extern \"test\"} testInt(i: int)\nmethod {:extern \"test\"} testBool(b: bool) // Previously the verifier reported a name collision\n"}
{"file": "../dafny/Test/git-issues/git-issue-314.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\ndatatype S = S(G: array<int>)\ndatatype T = T(F: array<S>, ghost Repr: set<object>)\n\nghost predicate Valid(t: T)\n  reads t.F\n  reads (set i | 0 <= i < t.F.Length :: t.F[i].G)\n{\n  var short := t.F;\n  t.Repr == (set i | 0 <= i < short.Length :: short[i].G) + {short}\n}\n\nmethod Main() {\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-327.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  module AA {\n    module AAA {\n      const aaa := 50\n    }\n  }\n  const a := 51\n}\n\nmodule B {\n  import A\n}\n\nmodule C0 {}\n\nmodule C refines C0 {\n  import B\n}\n\nmodule CC refines C {}\n\nmodule D refines CC {\n  import A = B.A\n}\n\nmodule E {\n  import S = A.AA\n}\n\nmodule F {\n  import DD = D.A\n  method m() { assert DD.a == 51; }\n}\n\nmodule G {\n  module H {\n    module Z {\n      const z := 52\n    }\n  }\n\n  module I {\n    module J {\n      import E.S.AAA\n      import HH = H.Z\n      import D.A\n      import D.A.AA\n      import F\n      method m0() { assert AAA.aaa == 50; }\n      method m1() { assert HH.z == 52; }\n      method m2() { assert A.a == 51; }\n      method m3() { assert AA.AAA.aaa == 50; }\n    }\n    module K {\n    }\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1113.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// ---------- 1113 ----------\n\ntype pair = s:seq<int> | |s| == 2 witness [0,0]\n\nghost function id<T>(x: T): T { x }\n\nghost function fst(p: pair): int\n{\n  id(p)[0] // this once gave a type-checking error\n}\n\nghost function pair_id(p: pair): seq<int>\n{\n  id(p)[0..2] // this once gave a type-checking error\n}\n\nghost function pair_to_seq(p: pair): seq<int> { p }\n\nmethod stuff_that_works(p: pair)\n{\n  var _: int := p[0];\n  var _: seq<int> := p[0..1];\n  var _: seq<int> := id(p);\n  var _: int := pair_to_seq(p)[1];\n  var _: seq<int> := pair_to_seq(p)[0..1];\n}\n\n// ---------- 1157 ----------\n\ntype subString = x: seq<char> | 0 <= |x| < 0x8000_0000\n\nfunction foo(s: subString): subString { \"0\" }\n\nmethod goo(s: subString) returns (eq: bool)\n{\n  if s != [] {\n    ghost var s' := foo(s[0..]);\n    assert s'[1..] == []; // this once gave a type-checking error\n  }\n  return true;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-401a.dfy", "dafny": "// Dafny should emit exit value 1\n// RUN: ! %dafny /compile:0 /proverOpt:PROVER_PATH=Output/binz/z3 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod m() {\n  assert 1 + 1 == 2;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-731.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ntrait Trait<Y> {\n  const y: Y\n  const k: Y := y\n  const l: Y\n}\n\nclass ClassB extends Trait<array<bv8>> {\n  var m: array<bv8>\n  constructor () { m := new bv8[42]; }\n}\n\nclass ClassC extends Trait<array3<bv8>> {\n  var m: array3<bv8>\n  constructor () { m := new bv8[8, 9, 10]; }\n}\n\nmethod Main() {\n  var cb := new ClassB();\n  print cb.y.Length, \" \", cb.k.Length, \" \", cb.l.Length, \" \", cb.m.Length, \"\\n\";\n  var cc := new ClassC();\n  print cc.y.Length1, \" \", cc.k.Length1, \" \", cc.l.Length1, \" \", cc.m.Length1, \"\\n\";\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1604.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\ntrait Tr { }\nclass A extends Tr { }\nclass B extends Tr { }\n\nghost predicate SpecialA(a: A)\n{\n  false\n}\ntype Ap  = x : A | SpecialA(x) witness *\n\nfunction testSpecial(x: Tr): bool\n  requires x is A && SpecialA(x)\n{\n  1/0 == 0\n}\n\nfunction test(x: Tr): bool\n  requires x is A\n{\n  if x is B then 1/0 == 0 else true\n}\n\nmethod Main() {\n  var a := new A;\n  var b := new B;\n  var s: set<Tr> := {a, b};\n  var s2: set<Ap> := {};\n  var aa := forall a': A :: a' in s ==> test(a');\n\n  // No way to make any of these work, for now ?\n  //ab := forall a': Ap :: !testSpecial(a') ==> !(a' in s2);\n  //ab := forall a': Ap :: a' in s2 ==> testSpecial(a');\n\n  var si: set<int> := {2, 3, 4};\n  var ai:= forall i: nat :: i in si ==> i > 1;\n\n  assert aa;\n  print \"ok\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1384.dfy", "dafny": "// RUN: %dafny /compile:0 /env:0 /dprint:- \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Test()\n{\n    var f: ((int,int)) -> int := (x: (int,int)) => 1;\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-4261.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n  // 0\n  // 1\n  // 2\n  // 3\n  // 4\n  // 5\n  // 6\n  // 7\n  // 8\n  // 9\n  // 10\n  // 11\n  // 12\n  // 13\n  // 14\n  // 15\n  // 16\n  // 17\n  // 18\n  // 19\n  // 20\n  // 21\n  // 22\n  // 23\n  // 24\n  // 25\n  // 26\n  // 27\n  // 28\n  // 29\n  // 30\n  // 31\n  // 32\n  // 33\n  // 34\n  // 35\n  // 36\n  // 37\n  // 38\n  // 39\n  // 40\n  // 41\n  // 42\n  // 43\n  // 44\n  // 45\n  // 46\n  // 47\n  // 48\n  // 49\n  // 50\n  // 51\n  // 52\n  // 53\n  // 54\n  // 55\n  // 56\n  // 57\n  // 58\n  // 59\n  // 60\n  // 61\n  // 62\n  // 63\n  // 64\n  // 65\n  // 66\n  // 67\n  // 68\n  // 69\n  // 70\n  // 71\n  // 72\n  // 73\n  // 74\n  // 75\n  // 76\n  // 77\n  // 78\n  // 79\n  // 80\n  // 81\n  // 82\n  // 83\n  // 84\n  // 85\n  // 86\n  // 87\n  // 88\n  // 89\n  // 90\n  // 91\n  // 92\n  // 93\n  // 94\n  // 95\n  // 96\n  // 97\n  // 98\n  // 99\n  // 100\n  // 101\n  // 102\n  // 103\n  // 104\n  // 105\n  // 106\n  // 107\n  // 108\n  // 109\n  // 110\n  // 111\n  // 112\n  // 113\n  // 114\n  // 115\n  // 116\n  // 117\n  // 118\n  // 119\n  // 120\n  // 121\n  // 122\n  // 123\n  // 124\n  // 125\n  // 126\n  // 127\n  // 128\n  // 129\n  // 130\n  // 131\n  // 132\n  // 133\n  // 134\n  // 135\n  // 136\n  // 137\n  // 138\n  // 139\n  // 140\n  // 141\n  // 142\n  // 143\n  // 144\n  // 145\n  // 146\n  // 147\n  // 148\n  // 149\n  // 150\n  // 151\n  // 152\n  // 153\n  // 154\n  // 155\n  // 156\n  // 157\n  // 158\n  // 159\n  // 160\n  // 161\n  // 162\n  // 163\n  // 164\n  // 165\n  // 166\n  // 167\n  // 168\n  // 169\n  // 170\n  // 171\n  // 172\n  // 173\n  // 174\n  // 175\n  // 176\n  // 177\n  // 178\n  // 179\n  // 180\n  // 181\n  // 182\n  // 183\n  // 184\n  // 185\n  // 186\n  // 187\n  // 188\n  // 189\n  // 190\n  // 191\n  // 192\n  // 193\n  // 194\n  // 195\n  // 196\n  // 197\n  // 198\n  // 199\n  // 200\n  // 201\n  // 202\n  // 203\n  // 204\n  // 205\n  // 206\n  // 207\n  // 208\n  // 209\n  // 210\n  // 211\n  // 212\n  // 213\n  // 214\n  // 215\n  // 216\n  // 217\n  // 218\n  // 219\n  // 220\n  // 221\n  // 222\n  // 223\n  // 224\n  // 225\n  // 226\n  // 227\n  // 228\n  // 229\n  // 230\n  // 231\n  // 232\n  // 233\n  // 234\n  // 235\n  // 236\n  // 237\n  // 238\n  // 239\n  // 240\n  // 241\n  // 242\n  // 243\n  // 244\n  // 245\n  // 246\n  // 247\n  // 248\n  // 249\n  // 250\n  // 251\n  // 252\n  // 253\n  // 254\n  // 255\n  // 256\n  // 257\n  // 258\n  // 259\n  // 260\n  // 261\n  // 262\n  // 263\n  // 264\n  // 265\n  // 266\n  // 267\n  // 268\n  // 269\n  // 270\n  // 271\n  // 272\n  // 273\n  // 274\n  // 275\n  // 276\n  // 277\n  // 278\n  // 279\n  // 280\n  // 281\n  // 282\n  // 283\n  // 284\n  // 285\n  // 286\n  // 287\n  // 288\n  // 289\n  // 290\n  // 291\n  // 292\n  // 293\n  // 294\n}"}
{"file": "../dafny/Test/git-issues/git-issue-1094.dfy", "dafny": "// RUN: %dafny /compile:0 /functionSyntax:4 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// ----- Type error -----\n\nmethod FP() returns (r: FStatus)\n{\n  {\n    var r: int;  // this variable shadows the out-parameter r\n    :- FTry();  // regression: this once gave an error saying RHS (of type FStatus) not assignable to LHS (of type int)\n  }\n}\n\nmethod MP() returns (r: MStatus)\n{\n  {\n    var r: int;  // this variable shadows the out-parameter r\n    :- MTry();  // regression: this once gave an error saying RHS (of type MStatus) not assignable to LHS (of type int)\n  }\n}\n\nmethod FQ() returns (r: FResult<int>)\n  ensures r == FResult.Failure(5)\n{\n  {\n    var r: int;  // this variable shadows the out-parameter r\n    var x :- FCompute();  // regression: this once gave an error saying RHS (of type FResult<?>) not assignable to LHS (of type int)\n  }\n}\n\nmethod MQ() returns (r: MResult<int>)\n  ensures r == MResult.Failure(5)\n{\n  {\n    var r: int;  // this variable shadows the out-parameter r\n    var x :- MCompute();  // regression: this once gave an error saying RHS (of type MResult<?>) not assignable to LHS (of type int)\n  }\n}\n\n// ----- Verification error -----\n\nmethod FS() returns (r: FStatus)\n  ensures r == FStatus.Error(5)\n{\n  {\n    var r: FStatus;  // this variable shadows the out-parameter r\n    :- FTry();  // regression: this once resulted in a reported postcondition violation\n  }\n}\n\nmethod MS() returns (r: MStatus)\n  ensures r == MStatus.Error(5)\n{\n  {\n    var r: MStatus;  // this variable shadows the out-parameter r\n    :- MTry();  // regression: this once resulted in a reported postcondition violation\n  }\n}\n\nmethod FR() returns (r: FResult<int>)\n  ensures r == FResult.Failure(5)\n{\n  {\n    var r: FResult<int>;  // this variable shadows the out-parameter r\n    var x :- FCompute();  // regression: this once resulted in a reported postcondition violation\n  }\n}\n\nmethod MR() returns (r: MResult<int>)\n  ensures r == MResult.Failure(5)\n{\n  {\n    var r: MResult<int>;  // this variable shadows the out-parameter r\n    var x :- MCompute();  // regression: this once resulted in a reported postcondition violation\n  }\n}\n\n// ----- Aux definitions -----\n\nmethod FTry() returns (status: FStatus)\n  ensures status == FStatus.Error(5)\n\nmethod MTry() returns (status: MStatus)\n  ensures status == MStatus.Error(5)\n\ndatatype FStatus = Okay | Error(code: int) {\n  predicate IsFailure() {\n    Error?\n  }\n  function PropagateFailure(): FStatus\n    requires Error?\n  {\n    this\n  }\n}\n\ndatatype MStatus = Okay | Error(code: int) {\n  predicate IsFailure() {\n    Error?\n  }\n  function PropagateFailure(): MStatus\n    requires Error?\n  {\n    this\n  }\n}\n\nmethod FCompute() returns (result: FResult<int>)\n  ensures result == FResult.Failure(5)\n\nmethod MCompute() returns (result: MResult<int>)\n  ensures result == MResult.Failure(5)\n\ndatatype FResult<X> = Success(x: X) | Failure(code: int) {\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): FResult<U>\n    requires Failure?\n  {\n    FResult.Failure(code)\n  }\n  function Extract(): X\n    requires Success?\n  {\n    x\n  }\n}\n\ndatatype MResult<X> = Success(x: X) | Failure(code: int) {\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): MResult<U>\n    requires Failure?\n  {\n    MResult.Failure(code)\n  }\n  function Extract(): X\n    requires Success?\n  {\n    x\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2173.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\ndatatype T = Leaf(x: int) | T(t: T) {\n  function {:tailrecursion} TR() : int {\n    if Leaf? then 0\n    else t.TR()\n  }\n}\n\nmethod Main() {\n  print Leaf(0).TR(), \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2612.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntrait T {\n  ghost predicate {:opaque} True() { true }\n}\n\nclass C extends T {}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1229.dfy", "dafny": "// RUN: %dafny /compile:1 /compileTarget:cs \"%s\" %S/git-issue-1229-extern.cs > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule {:extern \"MyModule2\"} MyModule2 {\n    type {:extern \"MyType\"} MyType(==,!new)\n}\n\nmodule MyModule1 {\n    import MyModule2\n\n    datatype MyDatatype = MyDatatype (\n        t: MyModule2.MyType\n    )\n}"}
{"file": "../dafny/Test/git-issues/git-issue-621a.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n  export provides D, MyData\n  datatype D = D1 | D2\n  const MyData : D := D1  // OK even though in the export view, MyData does not have an initializer\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-353.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype A = s : seq<int> | |s| < 10\n\nmethod f(a: seq<A>)\n  ensures multiset(a[..]) == multiset(a[..])\n{\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3571.dfy", "dafny": "// NONUNIFORM: Testing CLI options handling, not actual compilation\n// RUN: %resolve --function-syntax:4 --function-syntax:3 \"%s\" > \"%t\"\n// RUN: %resolve --quantifier-syntax:3 --quantifier-syntax:4  \"%s\" >> \"%t\"\n// RUN: %build --target:java --target:cs  \"%s\" >> \"%t\"\n// RUN: %resolve --unicode-char:false --unicode-char:true  \"%s\" >> \"%t\"\n// RUN: %resolve --prelude \"%s\" --prelude \"%s\"  \"%s\" >> \"%t\"\n// RUN: %verify --cores:2 --cores:1  \"%s\" >> \"%t\"\n// RUN: %verify --solver-log x.tct --solver-log y.txt  \"%s\" >> \"%t\"\n// RUN: %verify --resource-limit 100 --resource-limit 200  \"%s\" >> \"%t\"\n// RUN: %verify --solver-path x --solver-path y  \"%s\" >> \"%t\"\n// RUN: %verify --verification-time-limit 300 --verification-time-limit 500  \"%s\" >> \"%t\"\n// RUN: %verify --error-limit:10 --error-limit:5  \"%s\" >> \"%t\"\n// RUN: %translate cs --output x --output y  \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// Crashes size x is nothing real\n// ## %verify --solver-plugin x --solver-plugin x  \"%s\" >> \"%t\"\n// Not testing --boogi, --boogie-filter\n\nmodule A {}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3267.dfy", "dafny": "// RUN: %exits-with 1 %baredafny zzzz \"%s\" > \"%t\"\n// RUN: %exits-with 1 %baredafny -zzzz \"%s\" >> \"%t\"\n// RUN: %exits-with 1 %baredafny test.d \"%s\" >> \"%t\"\n// RUN: %exits-with 1 %baredafny resolve --use-basename-for-filename --zzzz \"%s\" >> \"%t\"\n// RUN: %exits-with 1 %baredafny resolve --use-basename-for-filename test \"%s\" >> \"%t\"\n// RUN: %exits-with 1 %baredafny resolve --use-basename-for-filename test.d \"%s\" >> \"%t\"\n// RUN: %exits-with 1 %baredafny /useBaseNameForFileName test.d \"%s\" >> \"%t\"\n// RUN: %exits-with 1 %baredafny /useBaseNameForFileName /zzzz \"%s\" >> \"%t\"\n// RUN: %exits-with 1 %baredafny /useBaseNameForFileName -zzzz \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// UNSUPPORTED: windows\n\n// The output is slightly different on windows -- not worth automated testing of the alternative\n\nmodule A{}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2827d/A.dfy", "dafny": "// RUN: %baredafny build -t:java --output \"%S/zzz/Q.jar\" \"%s\" > \"%t\"\n// RUN: java -jar \"%S/zzz/Q.jar\" >>  \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"Hello, World!\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2367.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nnewtype IntSubset = i:int | true\n\nmethod Main() {\n  if 2 != (-6 as IntSubset % -4) as int {\n    print 1 / 0;\n  }\n  if -2 != (-6 as IntSubset / 4) as int {\n    print 1 / 0;\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-897a.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function missing_number(nums: seq<nat>): nat\n  requires |set i | i in nums| == |nums|\n  requires forall x :: x in nums ==> 0 <= x <= |nums|\n{\n  var p := x => 0 <= x <= |nums| && x !in nums;\n  assert exists x :: p(x) && forall y :: p(y) ==> y == x by {\n    var range := set i | 0 <= i <= |nums|;\n    assume |range| == |nums| + 1;\n    var missing := range - set i | i in nums;\n    assert |missing| == 1;\n    var x :| x in missing;\n    assert p(x);\n    var y: int;\n    forall y | p(y) ensures y in missing {}\n    assume forall x, y :: x in missing && y in missing ==> x == y;\n    forall y | p(y) ensures y == x {}\n  }\n  var x :| p(x);\n  x\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-864zz.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  export reveals a\n  const a := 10\n  const b := 20\n}\n\nmodule B refines A {\n  export X reveals * extends A // used to complain  A is not in B\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3978.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main()\n{\n  for v := 3 to 18\n  {\n    if false {\n      continue;\n    }\n    var x := 1;\n    print x, \"\\n\";\n  }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-261.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\ndatatype Option<T> = None | Some(T)\n\nmethod Main() {\n  var x : Option<(nat, nat)> := Some((2,3));\n  var Some((a,b)) := x;\n  print a, \" \", b, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-452.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nghost function TwinPrimes(): (int, int) {\n  (41, 43)\n}\n\nfunction TwinPrimesM(): (int, int) {\n  (41, 43)\n}\n\nmethod Main() {\n  var (x, y) := TwinPrimesM();  // x and y are not ghost\n  var p := TwinPrimesM();  // p is not ghost\n  print x, \" \", y, \" \", p, \"\\n\"; // OK\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1373.dfy", "dafny": "// RUN: %exits-with 2 %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  var x := map[1 := () => 1];\n  print x.Values; // error: map range type must support equality\n  print x.Items; // error: map range type must support equality\n}"}
{"file": "../dafny/Test/git-issues/git-issue-4205.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntrait T {\n  opaque function bar(): int\n}\n\nclass F extends T {\n  opaque function bar(): int {\n    1\n  }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-276v.dfy", "dafny": "// RUN: %dafny /compile:0 /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Testing constant folding of bit-vector operations\nmodule Main {\n  const a: bv8 := 20\n  const b: bv8 := 37\n  newtype b0 = x | 0 <= x < (a+b) as int\n  newtype b1 = x | 0 <= x < (a-b) as int\n  newtype b2 = x | 0 <= x < (a*b) as int\n  newtype b3 = x | 0 <= x < (b/a) as int\n  newtype b4 = x | 0 <= x < (-a+b) as int\n  newtype b5 = x | 0 <= x < (b%a) as int\n  newtype b6 = x | 0 <= x < (a&b) as int\n  newtype b7 = x | 0 <= x < (a^b) as int\n  newtype b8 = x | 0 <= x < (a|b) as int\n  newtype b9 = x | 0 <= x < (!a) as int\n  newtype ba = x | 0 <= x < (if a<b then 24 else 56)\n  newtype bb = x | 0 <= x < (if a<=b then 24 else 56)\n  newtype bc = x | 0 <= x < (if a>b then 24 else 56)\n  newtype bd = x | 0 <= x < (if a>=b then 24 else 56)\n  newtype be = x | 0 <= x < (if a==b then 24 else 56)\n  newtype bf = x | 0 <= x < (if a!=b then 24 else 56)\n  newtype bg = x | 0 <= x < (a<<4) as int\n  newtype bh = x | 0 <= x < (b>>1) as int\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1111.dfy", "dafny": "// RUN: %dafny /compileTarget:java \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Foo {\n    class A {\n\n        const a : int\n        const b : int\n\n        constructor(k : int, j : int)\n        {\n            //a := k;\n            //b := j;\n            a, b := k, j;\n        }\n    }\n    method Main()\n    {\n        var o := new A(1, 2);\n    }\n}"}
{"file": "../dafny/Test/git-issues/github-issue-2563.dfy", "dafny": "// RUN: %exits-with 1 %dafny /compile:0 '/verificationLogger:csv;log.csv' \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/git-issues/git-issue-3572.dfy", "dafny": "// RUN: %exits-with 1 %baredafny verify --solver-plugin x test.dfy 2> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/git-issues/git-issue-1165.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\npredicate P()\n\nmethod TestMapMethod(s0: set<int>, s1: set<int>) {\n  var m;\n  m := map key | key in (s0 + s1) && P() :: true;\n  m := map key | key in (s0 + s1) :: true;\n  m := map key | key in s0 + s1 && P() :: true;\n  m := map key | key in s0 + s1 :: true;\n  assert true;\n}\n\nghost function TestMap(s0: set<int>, s1: set<int>): bool {\n  // Once, these caused malformed Boogie, because the parentheses had fooled the\n  // RewriteInExpr mechanism when generating CanCall assumptions.\n  // Ditto for the comprehensions in functions below.\n  var m0 := map key | key in (s0 + s1) && P() :: true;\n  var m1 := map key | key in (s0 + s1) :: true;\n  var m2 := map key | key in s0 + s1 && P() :: true;\n  var m3 := map key | key in s0 + s1 :: true;\n  true\n}\n\nghost function TestSet(s0: set<int>, s1: set<int>): bool {\n  var t0 := set key | key in (s0 + s1) && P() :: key;\n  var t1 := set key | key in (s0 + s1) :: key;\n  var t2 := set key | key in s0 + s1 && P() :: key;\n  var t3 := set key | key in s0 + s1 :: key;\n  true\n}\n\nghost function TestInMultiset(s0: multiset<int>, s1: multiset<int>): bool {\n  var t0 := set key | key in (s0 + s1) && P() :: key;\n  var t1 := set key | key in (s0 + s1) :: key;\n  var t2 := set key | key in s0 + s1 && P() :: key;\n  var t3 := set key | key in s0 + s1 :: key;\n  true\n}\n\nclass Cell { var data: int }\n\nmethod ModifiesClauses(S: set<object>, T: set<object>, p: Cell, q: Cell, n: int)\n  requires p in S + T\n  requires q in S\n  modifies S + T\n{\n  p.data := n;\n  q.data := n;\n}\n\nghost function Id(S: set<object>): set<object> { S }\n\nmethod Fresh0(p: Cell, q: Cell, n: int) returns (S: set<object>, T: set<object>)\n  ensures fresh(S - T)\n{\n  S, T := {p}, {p};\n}\n\nmethod Fresh1(p: Cell, q: Cell, n: int) returns (S: set<object>, T: set<object>)\n  ensures fresh(Id(S) - Id(T))\n{\n  S, T := {p}, {p};\n}\n\nmethod Fresh2(p: Cell, q: Cell, n: int) returns (S: set<object>, T: set<object>)\n  ensures fresh(Id(S - T))\n{\n  S, T := {p}, {p};\n}\n\nghost function ReadsClauses(S: set<object>, T: set<object>, p: Cell, q: Cell, n: int): int\n  requires p in S + T\n  requires q in S\n  reads S + T\n{\n  p.data + q.data + n\n}\n\ntwostate predicate FreshInFunction(S: set<object>, T: set<object>)\n{\n  fresh(S + T)\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-845.dfy", "dafny": "// RUN: %dafny /useBaseNameForFileName /compile:0 %S/git-issue-845.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n/* blah blah /* blah */\nmethod foo() returns (r:bool) { assert true == false; }\n\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-4309.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() {\n  CallFromTextuallyAbove.Test();\n  CallFromTextuallyBelow.Test();\n}\n\nclass CallFromTextuallyAbove {\n  static method Test() {\n    var x := new Class;\n    x.M();\n    print x.m, \"\\n\";\n  }\n}\n\nclass Class {\n  const m: int := 18\n  method M() {\n    print \"hello M, \";\n  }\n}\n\nclass Ssalc {\n  const m: int := 19\n  method M() {\n    print \"hi M, \";\n  }\n}\n\nclass CallFromTextuallyBelow {\n  static method Test() {\n    var x := new Ssalc;\n    x.M();\n    print x.m, \"\\n\";\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-4176.dfy", "dafny": "// RUN: %baredafny verify %args %s > %t\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod test(c: Class) {\n    reveal Class.P();\n    reveal Class.Q();\n    reveal f();\n    \n    assert c.P();\n    assert c.Q();\n    assert f();\n}\n\nclass Class {\n  opaque function P() : bool { true }\n  opaque twostate function Q() : bool { true }\n}\n\nopaque function f() : bool { true }"}
{"file": "../dafny/Test/git-issues/git-issue-3496.dfy", "dafny": "// RUN: %resolve \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod m() {\n  assume true;\n}\n\nmethod p() {\n  assume {:axiom} true;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-633.dfy", "dafny": "// NONUNIFORM: need to add support for --input when running to %testDafnyForEachCompiler\n// RUN: %dafny /compile:0 \"%s\" %S/git-issue-633A.dfy > \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs /spillTargetCode:3 \"%s\" %S/git-issue-633A.dfy >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js /spillTargetCode:3 \"%s\" %S/git-issue-633A.dfy >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go /spillTargetCode:3 \"%s\" %S/git-issue-633A.dfy >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:java /spillTargetCode:3 \"%s\" %S/git-issue-633A.dfy  >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:py /spillTargetCode:3 \"%s\" %S/git-issue-633A.dfy  >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod m() {\n  print \"OK\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1838.dfy", "dafny": "// RUN: %dafny /useBaseNameForFileName /compile:0 %S/git-issue-1838.dfy > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A.B {\n  type u64 = x | 0 <= x <= 0xffff_ffff_ffff_ffff\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1074.dfy", "dafny": "// RUN: %dafny /compileVerbose:1 /compile:1 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  // This test uses an abstract type as the type of \"children\" below. This once caused\n  // a crash in the compiler.\n\n  // To distinguish the crashing test output from the correct test output, we need to\n  // get to a point where the compiler prints some output. If the compilation succeeds,\n  // there will be some output. But to make the abstract type compile, it needs to be\n  // marked with an :extern that redirects it to some existing type. Rather than relying\n  // on some type in the C#-or-other-target runtime library, this test declares a class\n  // MyCollection, which is then named in the :extern attribute. (This relies on that\n  // \"MyCollection\" is not name mangled in the process.)\n  type {:extern \"MyCollection\"} Container<A>\n  class MyCollection<X> {\n  }\n\n  datatype Node = Leaf | Node(children: Container<Node>)\n\n  method Test(node: Node)\n    requires node.Node?\n  {\n    var Node(ch) := node; // this line once crashed the compiler\n  }\n}\n\nmodule B {\n  datatype InnerT<X> = Inner(x: X)\n  datatype Node<X, Y> = Leaf | Node(children: Y)\n\n  method Test(node: Node<int, InnerT<real>>)\n    requires node.Node?\n  {\n    var Node(Inner(z)) := node; // this once compiled into malformed code, because the compiler used \"int\" instead of \"InnerT<real>\" as the type of Inner(z)\n  }\n}\n\nmodule C {\n  datatype InnerT<X> = Inner(x: X)\n  datatype Node<X> = Leaf | Node(children: InnerT<X>)\n\n  method Test(node: Node<int>)\n    requires node.Node?\n  {\n    var Node(Inner(z)) := node; // this once compiled into malformed code, because the compiler used \"X\" instead of \"InnerT<int>\" as the type of Inner(z)\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-276c.dfy", "dafny": "// RUN: %dafny /compile:0 /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Testing constant folding of char, string operations\nmodule Main {\n  const s := \"abcde\"\n  const c := s[4]\n  newtype b0 = x | 0 <= x < |s+s|\n  newtype b1 = x | 0 <= x < c as int\n  newtype b2 = x | 0 <= x < c as bv8 as int\n  newtype b3 = x | 0 <= x < 20 as char as int\n  newtype b4 = x | 0 <= x < 200 as bv8 as char as int\n  newtype b5 = x | 0 <= x < ( if 'a' == c then 30 else 40 )\n  newtype b6 = x | 0 <= x < ( if 'a' != c then 30 else 40 )\n  newtype b7 = x | 0 <= x < ( if 'a' <= c then 30 else 40 )\n  newtype b8 = x | 0 <= x < ( if 'a' <  c then 30 else 40 )\n  newtype b9 = x | 0 <= x < ( if 'a' >=  c then 30 else 40 )\n  newtype ba = x | 0 <= x < ( if 'a' >   c then 30 else 40 )\n  newtype bb = x | 0 <= x < ( if s == s then 30 else 40 )\n  newtype bc = x | 0 <= x < ( if s != s then 30 else 40 )\n  newtype bd = x | 0 <= x < ( if s <= s then 30 else 40 )\n  newtype be = x | 0 <= x < ( if s <  s then 30 else 40 )\n  newtype bf = x | 0 <= x < ( if s <= s+s then 30 else 40 )\n  newtype bg = x | 0 <= x < ( if s <  s+s then 30 else 40 )\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-425.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod M() returns (x: int, ghost y: int) {\n  return 42, 43;\n}\n\ndatatype Color = Red | Blue\n\nmethod Main() {\n  var x0, y0 := M();  // this is fine: x0 is compiled, y0 is ghost\n  print x0, \"\\n\";\n  var c := Red;\n  match c\n  case Red =>\n    var x1, y1 := M();  // this used to generate an error, saying y1 is not ghost :(\n    print x1, \"\\n\";\n  case Blue =>\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2956a.dfy", "dafny": "// RUN: %baredafny run --target=js \"%s\" --input \"%S/git-issue-2956b.js\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod {:extern \"global\", \"OneOne\"} OneOne() returns (s: seq<int>)\n\nmethod Main() {\n  var s := OneOne();\n  expect s == [1];\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1199.dfy", "dafny": "// RUN: %dafny /compile:1 /compileTarget:cs \"%s\" %S/git-issue-1199-extern.cs > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule {:extern \"Microsoft\"} Microsoft {\n    module {:extern \"Microsoft.Dafny\"} Dafny {\n        class {:extern \"Main\"} DafnyMain {}\n    }\n}\n\nmodule M {\n    import Microsoft\n\n    method Foo() {\n        var dafny: Microsoft.Dafny.DafnyMain? := null;\n    }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-4205a.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntrait T {\n  opaque function bar(): (r: int)\n}\n\nclass F extends T {\n  constructor() {}\n  opaque function bar(): (r: int) {\n    1\n  }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-2265.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule DefaultModule {\n  class DefaultClass {\n    static ghost function BrokenFunction(): nat {\n      var y := 0;\n      assert true by {\n        if foobarquux: bool :| true {\n          assert true || foobarquux;\n        }\n      }\n      0\n    }\n  }\n}\n\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-2022.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n  export\n    provides\n      Opened,\n      f\n\n  module Opened {\n    type T = int\n  }\n\n  ghost function f(x: Opened.T): int {\n    5\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2441.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype A = A(B: B)\ndatatype B = X\n"}
{"file": "../dafny/Test/git-issues/git-issue-3744.dfy", "dafny": "// NONUNIFORM: Multiple test scenarios (could be split)\n// RUN: %baredafny test \"%s\" > \"%t\"\n// RUN: %baredafny run \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"Main\\n\";\n}\n\nmethod {:test} Test() {\n  print \"Test\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2947.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ncodatatype Stream<X> = Nil | Cons(head: X, tail: Stream<X>)\n\nleast predicate Finite<Y>(s: Stream<Y>) {\n  // The following once generated malformed Boogie, because of a missing\n  // type substitution in the datatype value Nil\n  s == Nil || Finite(s.tail)\n}\n\nleast predicate F0<Y>(s: Stream<Y>) {\n  var nil := Nil;\n  s == nil || F0(s.tail)\n}\n\nleast predicate F1<Y>(s: Stream<Y>) {\n  s.Nil? || F1(s.tail)\n}\n\nleast predicate G0<Y>(s: Stream<Y>) {\n  s is Stream<Y>\n}\n\nleast predicate G1<Y>(s: Stream<Y>) {\n  s == Identity(s)\n}\n\nleast predicate G2<Y>(s: Stream<Y>) {\n  s == Identity<Stream<Y>>(s)\n}\n\nghost function Identity<W>(w: W): W { w }\n\nleast lemma About<Z>(s: Stream<Z>)\n  requires s == Nil\n  requires s.Nil?\n  requires var nil := Nil; s == nil\n  requires s is Stream<Z>\n  requires s == Identity(s)\n  requires s == Identity<Stream<Z>>(s)\n  requires Finite(s)\n  requires F0(s)\n  requires F1(s)\n  requires G0(s)\n  requires G1(s)\n  requires G2(s)\n{\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-386.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Foo {\n    // this is accepted\n    constructor(ghost b: set<bool>) {}\n    constructor Mk() {}\n    method Initialize(ghost b: set<bool>) {}\n}\n\nmethod TestConstructor() {\n    ghost var b: set<bool> := {};\n    var f := new Foo(b);\n    // error: ghost variables are only allowed in specification contexts\n}\n\nmethod TestInitialize() {\n    ghost var b: set<bool> := {};\n    var f := new Foo.Mk();\n    // works\n    f.Initialize(b);\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-659.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  module Inner {\n    export P reveals a,c\n    export Q reveals b,c\n    const a := 10\n    const b := 20\n    const c := 30\n  }\n}\n\nmodule X {\n  import I = A.Inner`P\n  method m() {\n    assert I.a == 10;\n    assert I.c == 30;\n  }\n}\n\nmodule Y {\n  import I = A.Inner`{P,Q}\n  method m() {\n    assert I.a == 10;\n    assert I.b == 20;\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-505.dfy", "dafny": "// RUN: %dafny /compile:0 /timeLimit:20 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nlemma d()\n{\n  var a: int := 0x0000_0000_0000_BEEF;\n  var testbv: bv16 := a as bv16;\n  var testval: int := testbv as int;\n\n  assert testval == a; // OK\n}\nlemma e()\n{\n  var a: int := 0x0000_0000_0000_00EF;\n  var testbv: bv8 := a as bv8;\n  var testval: int := testbv as int;\n\n  assert testval == a; // OK\n}\n\n// The longer bit vector operations currently timeout (because of Z3's\n// inefficient support for bit-vector/int conversions),\n// but the shorter bit width attempts verify OK\n"}
{"file": "../dafny/Test/git-issues/git-issue-1762.dfy", "dafny": "// RUN: %dafny /compile:3 \"%s\" %S/git-issue-1761-extern.cs > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass {:extern \"ABC\"} XYZ {\n  var y: bool\n  constructor {:extern} Init(x: bool) {\n    y := x;\n  }\n  constructor {:extern} Create(x: bool, z: bool) {\n    y := x && z;\n  }\n}\n\nmethod Main() {\n  var xyz := new XYZ.Init(true);\n  print xyz.y, \"\\n\";\n  xyz := new XYZ.Create(true, false);\n  print xyz.y, \"\\n\";\n}"}
{"file": "../dafny/Test/git-issues/github-issue-4017.dfy", "dafny": "// RUN: %baredafny verify %args %s > %t\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction Crash(e: nat): string\n{\n  assert match e { case _ => true };\n  \"\"\n}"}
{"file": "../dafny/Test/git-issues/git-issue-4152.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\nmethod Main() {\n  var a: bv8 := 0xFF;\n  var b: bv16 := 0xFFFF;\n  var c: bv32 := 0xFFFF_FFFF;\n  var d: bv64 := 0xFFFF_FFFF_FFFF_FFFF;\n  var e: bv128 := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF;\n  print a as real, \" \", b as real, \" \", c as real, \" \", d as real , \" \", e as real, \"\\n\";\n  print a as nat, \" \", b as nat, \" \", c as nat, \" \", d as nat, \" \", e as nat, \"\\n\";\n  print a as ORDINAL, \" \", b as ORDINAL, \" \", c as ORDINAL, \" \", d as ORDINAL, \" \", e as ORDINAL, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1129.dfy", "dafny": "// NONUNIFORM: Program expected to fail in backend-specific ways\n// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" > \"%t\".abyss\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:java \"%s\" > \"%t\".abyss\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js \"%s\" > \"%t\".abyss\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:go \"%s\" > \"%t\".abyss\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:cpp \"%s\" > \"%t\".abyss\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Without providing extern code for the :extern C, Dafny will output\n// target-compiler error messages when asked to compile this program.\n// Some of the compilers had then thrown an exception, which caused\n// Dafny to crash. That doesn't seem very friendly. The fix is to\n// just print the error and exit, without crashing.\n//\n// Errors reported by the underlying compiler may contain absolute\n// path names. These are annoying to have in .expect files. Therefore,\n// the output from the Dafny invocations above are piped into the\n// abyss. This testing still detects any crash.\n\nmodule A {\n  import B\n  datatype D = D(test: B.C)\n}\n\nmodule B {\n  class {:extern} C {\n    constructor {:extern} (name: string)\n  }\n}\n\nmethod Main() {\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2827c/A.dfy", "dafny": "// RUN: %baredafny build -t:java --output \"%S/Q.jar\" \"%s\" > \"%t\"\n// RUN: java -jar \"%S/Q.jar\" >>  \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"Hello, World!\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2726a.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nconst digits := [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n\nfunction IntToString(i: int): string   \n  decreases i < 0, if i<0 then -i else i\n{\n  if i < 0 then (\"-\" + IntToString(-i))\n  else if i < 10 then digits[i]  \n  else if i < 100 then (digits[i/10] + digits[i%10])\n  //else (\"DDD\" + digits[i%10])\n  else (IntToString(i/10) + digits[i%10])  // CRASHES\n}\n\nmethod Main() {\n  print IntToString(4), \"\\n\";\n  print IntToString(42), \"\\n\";\n  print IntToString(422), \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2920.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype D = D(x: int)\n\nghost function Foo(): ()\n  ensures assert true by { var D(x) := D(0); } true\n{ () }\n"}
{"file": "../dafny/Test/git-issues/git-issue-930.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Result<T> = Success(value: T) | Failure(error: string)\n{\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): Result<U>\n    requires Failure?\n  {\n    Failure(this.error)\n  }\n  function Extract(): T\n    requires Success?\n  {\n    value\n  }\n}\n\nclass ClassA<T> {\n  const s: seq<T>\n\n  constructor (s: seq<T>) {\n    this.s := s;\n  }\n\n  method Read() returns (res: Result<seq<T>>)\n    ensures res.Success? ==> 1 <= |res.value|\n  {\n    if 1 <= |s| {\n      if * {\n        return Success(s);\n      }\n    }\n    return Failure(\"failing\");\n  }\n\n  method ReadX<U(==)>(x: U, y: U) returns (res: Result<seq<U>>)\n    ensures res.Success? ==> 1 <= |res.value|\n  {\n    if x != y {\n      return Success([x, y]);\n    }\n    return Failure(\"failing\");\n  }\n}\n\n// Methods M0 and M1 are the same, except that M0 gives the type of\n// \"numbers\", whereas M1 leaves that type to be inferred. In both\n// cases, it should be known that a.Read() returns a Result<seq<int>>,\n// but type inference failed (now fixed) to instantiate the T in ClassA<T>, so\n// a.Read() is typed as returning a Result<seq<T>>.\n\nmethod M0() returns (res: Result<int>) {\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var numbers: seq<int> :- a.Read();  // fixed: once said expected Result<seq<int>>, but got Result<seq<T>>\n  return Success(numbers[0]);\n}\n\nmethod M1() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var numbers :- a.Read();  // fixed: once said expected Result<seq<int>>, but got Result<seq<T>>\n  return Success(numbers[0]);\n}\n\n// Methods P0 and P1 are like M0 and M1, but instead of using :- to\n// handle the Success/Failure of a.Read(), P0 and P1 handle those\n// cases explicitly. In these cases, type checking works properly.\n\nmethod P0() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var result: Result<seq<int>> := a.Read();\n  if result.IsFailure() {\n    res := result.PropagateFailure();\n    return;\n  }\n  var numbers := result.Extract();\n  return Success(numbers[0]);\n}\n\nmethod P1() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var result := a.Read();\n  if result.IsFailure() {\n    res := result.PropagateFailure();\n    return;\n  }\n  var numbers := result.Extract();\n  return Success(numbers[0]);\n}\n\n// Methods N0 and N1 are like M0 and M1, but class a.ReadX\n// instead of a.Read. This makes the type parameter of a.ReadX\n// come into play.\n\nmethod N0() returns (res: Result<int>) {\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var numbers: seq<int> :- a.ReadX(50, 50);  // fixed: once said got int, but expected U\n  return Success(numbers[0]);\n}\n\nmethod N1() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var numbers :- a.ReadX(50, 50);  // fixed: once said got int, but expected U\n  return Success(numbers[0]);\n}\n\n// Methods Q0 and Q1 are like N0 and N1, but without :-. For these methods,\n// type checking works properly.\n\nmethod Q0() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var result: Result<seq<int>> := a.ReadX(50, 50);\n  if result.IsFailure() {\n    res := result.PropagateFailure();\n    return;\n  }\n  var numbers := result.Extract();\n  return Success(numbers[0]);\n}\n\nmethod Q1() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var result := a.ReadX(50, 50);\n  if result.IsFailure() {\n    res := result.PropagateFailure();\n    return;\n  }\n  var numbers := result.Extract();\n  return Success(numbers[0]);\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1093.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  UnusedLabel();\n  var c := new C;\n  c.x := 4;\n  c.LabelUsedInGhostCode();  // 10\n  print c.x, \"\\n\";\n}\n\nmethod UnusedLabel()\n{\n  // The following once resulted in malformed Go code, in particular generating an unused labeled.\n  label foo: {}\n}\n\nclass C {\n  var x: int\n\n  method LabelUsedInGhostCode()\n    modifies this\n  {\n    x := x + 2;\n    label A:\n    x := x + 1;\n    label B:\n    x := x + 3;\n    assert x == old(x) + 6;\n    assert x == old@A(x) + 4;\n    assert old@B(x) + x == 2 * old(x) + 9;\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3719b.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nopaque predicate P(i: int) { true }\n\nmethod testCallOpaqueAssert() {\n  assert f0: P(0) by {\n    reveal P();\n  }\n  assert P(0) by {\n    reveal f0;\n  }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-2608.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod GetNext(i: int) returns (j: int, possible: bool) {\n  if i == 1 {\n    possible := false;\n    j := 0;\n  } else {\n    possible := true;\n    j := if i % 2 == 0 then  i / 2 else i * 3 + 1;\n  }\n}\n\nmethod Main()\n{\n  var i := 10;\n  var k := 27;\n  while i > 0\n    invariant i >= 0\n  {\n    label before:\n    var newK, possible := GetNext(k);\n    if(!possible) {\n      break;\n    }\n    k := newK;\n    print k;\n    i := i - 1;\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1164.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass MyList<T>\n{\n}\n\nmethod AAA<U>(aax: MyList?<U>) returns (aay: MyList?<U>)\n  ensures BBB(aax, aay)\n\nghost predicate BBB<V>(bbx: MyList?<V>, bby: MyList?<V>)\n{\n  // the translation of this \"null\", when inlined into the postcondition of AAA above, once\n  // generated malformed Boogie (because of a missing substitution of the type for \"null\")\n  CCC(bbx, null)\n}\n\nghost predicate CCC<W>(ccx: MyList?<W>, ccy: MyList?<W>)\n"}
{"file": "../dafny/Test/git-issues/git-issue-4188.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nnewtype T1 = nat\nnewtype T2 = int\nnewtype T3 = n: nat | true\nnewtype T4 = i: int | 0 <= i\n\nmethod M(s1: set<T1>, s2: set<T2>, s3: set<T3>, s4: set<T4>)\n  requires s1 != {} && s2 != {} && s3 != {} && s4 != {} \n{\n  var i1: T1 :| i1 in s1;\n  var i2: T2 :| i2 in s2;\n  var i3: T3 :| i3 in s3;\n  var i4: T4 :| i4 in s4;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1815a.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype Dt<+U> = Dt(x: U, i: int)\n\ntrait Tr {}\nclass Cl extends Tr {\n  constructor () {}\n}\n\nmethod Main() {\n  var cl: Cl := new Cl();\n  var e: Dt<Tr> := Dt(cl, 1815);\n  match e {\n    case Dt(tr, _) =>\n  }\n  print \"done\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-452c.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\ndatatype Record = Record(a: int, ghost b: int)\n\nfunction TwinPrimes(): Record {\n  Record(41, 43)\n}\n\nmethod Main() {\n  var u := var Record(x, y) := TwinPrimes(); y; // x is non-ghost\n  var w := var Record(x, y) := TwinPrimes(); x; // x and w are non-ghost\n  //@ assert u == 43;\n  print w, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-305-c.dfy", "dafny": "// RUN: %baredafny /compile:0 /spillTargetCode:2 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// At some point (https://github.com/dafny-lang/dafny/pull/307#issuecomment-510191495)\n// this used to produce an executable even though it shouldn't,\n// therefore we compare the output of \"baredafny\", which contains messages regarding\n// whether an executable has been produced.\n\nmethod Main() {\n    print \"hello\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-697b.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\ndatatype Cell = Cell(x: int)\ntype EvenCell = c: Cell | c.x % 2 == 0 witness Cell(0)\n\nfunction doubleEvenCell(c: EvenCell): int\n{\n  if c.x % 2 == 1 then 1/0 else c.x * 2\n}\n\nmethod Main() {\n  var x: set<Cell> := {Cell(1), Cell(2), Cell(3), Cell(4)};\n  var z: map<EvenCell, nat> := map c: EvenCell | c in x :: c.x;\n  var y := z.Keys;\n  var b := forall c :: c in y ==> doubleEvenCell(c) > 0;\n  assert b;\n  print Cell(1) in y, \" \", z[Cell(2)], \"\\n\";\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1100.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%S/../c++/arrays.dfy\" -- --relax-definite-assignment --unicode-char:false\n\n// Test compilation of a file in another directory\n"}
{"file": "../dafny/Test/git-issues/git-issue-833.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass C {\n  ghost var x:int\n  method f(ghost y:int) {}\n  method test0() { f(x);}  // passes\n  constructor(ghost y:int) {x:=y;}\n  method test1() returns (c:C) { c := new C(x); } // used to fail with \"ghost fields are allowed only in specification contexts\"\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-4202.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nopaque function F(x: int): char\n{ 'D' }\n\nfunction InitArray<D>(f: int -> D): (a: D)\n{\n  f(44)\n}\n\nmethod Main() {\n  reveal F();\n  var c := InitArray(F);\n  assert c == 'D';\n}"}
{"file": "../dafny/Test/git-issues/git-issue-2266.dfy", "dafny": "// RUN: %dafny /compile:0 /noVerify /print:%t.bpl \"%s\"\n// RUN: %boogie \"%t.bpl\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction Test(f: (int ~> bool)): (b:bool) requires forall x: int :: f.requires(x) reads f.reads { true }"}
{"file": "../dafny/Test/git-issues/git-issue-4007.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n    var a := 0;\n    for i := 0 to |(set x: int | 0 <= x < 3 :: x)| {\n        a := a + 1;\n    }\n    print a, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3734.dfy", "dafny": "// RUN: %baredafny verify \"%s\"\n // RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nnewtype uint8 = x : int | 0 <= x < 256\n\nmethod Main() {\n  var y := 0x80 as bv8;\n  var x := (y >> 4) as uint8;\n  print y, \" >> 4 == \", x, \"\\n\";\n  assert x != 248; // What Java obtained before when computing \"y >>> 4\"\n  assert x == 0x8;\n  if x == 248 {\n    var x := 1/0; // Should not be executed\n  }\n\n  var z: bv32 := 12;\n  assert (z >> 31) == 0;\n  print \"12 >> 31 == \", z >> 31, \", \";\n  assert (z >> 32) == 0;\n  print \"12 >> 32 == \", z >> 32, \"\\n\";\n  \n  Right();\n  Left();\n}\n\nmethod Right() {\n  var m: bv0 := 0;\n  print m >> 0, \"\\n\"; // 0\n  var n: bv1 := 1;\n  print n >> 0, \" \", n >> 1, \"\\n\"; // 1 0\n\n  var a: bv7 := 12;\n  print a >> 0, \" \", a >> 1, \" \", a >> 6, \" \", a >> 7, \" \"; // 12 6 0 0\n  a := -1;\n  print a >> 0, \" \", a >> 6, \"\\n\"; // 127 1\n\n  var b: bv8 := 12;\n  print b >> 0, \" \", b >> 1, \" \", b >> 7, \" \", b >> 8, \" \"; // 12 6 0 0\n  b := -1;\n  print b >> 0, \" \", b >> 7, \"\\n\"; // 255 1\n\n  var r: bv15 := 12;\n  print r >> 0, \" \", r >> 1, \" \", r >> 14, \" \", r >> 15, \" \"; // 12 6 0 0\n  r := -1;\n  print r >> 0, \" \", r >> 14, \"\\n\"; // 32767 1\n\n  var s: bv16 := 12;\n  print s >> 0, \" \", s >> 1, \" \", s >> 15, \" \", s >> 16, \" \"; // 12 6 0 0\n  s := -1;\n  print s >> 0, \" \", s >> 15, \"\\n\"; // 65535 1\n\n  var w: bv31 := 12;\n  print w >> 0, \" \", w >> 1, \" \", w >> 30, \" \", w >> 31, \" \"; // 12 6 0 0\n  w := -1;\n  print w >> 0, \" \", w >> 30, \"\\n\"; // 0x7fff_ffff 1\n\n  var x: bv32 := 12;\n  print x >> 0, \" \", x >> 1, \" \", x >> 31, \" \", x >> 32, \" \"; // 12 6 0 0\n  x := -1;\n  print x >> 0, \" \", x >> 31, \"\\n\"; // 0xffff_ffff 1\n\n  var y: bv63 := 12;\n  print y >> 0, \" \", y >> 1, \" \", y >> 62, \" \", y >> 62, \" \"; // 12 6 0 0\n  y := -1;\n  print y >> 0, \" \", y >> 62, \"\\n\"; // 0x7fff_ffff_ffff_ffff 1\n\n  var z: bv64 := 12;\n  print z >> 0, \" \", z >> 1, \" \", z >> 63, \" \", z >> 64, \" \"; // 12 6 0 0\n  z := -1;\n  print z >> 0, \" \", z >> 63, \"\\n\"; // 0xffff_ffff_ffff_ffff 1\n\n  var u: bv100 := 12;\n  print u >> 0, \" \", u >> 1, \" \", u >> 99, \" \", u >> 100, \" \"; // 12 6 0 0\n  u := -1;\n  print u >> 0, \" \", u >> 99, \"\\n\"; // 0xf_ffff_ffff_ffff_ffff_ffff_ffff 1\n}\n\nmethod Left() {\n  var m: bv0 := 0;\n  print m << 0, \"\\n\"; // 0\n  var n: bv1 := 1;\n  print n << 0, \" \", n << 1, \"\\n\"; // 1 0\n\n  var a: bv7 := 12;\n  print a << 0, \" \", a << 1, \" \", a << 6, \" \", a << 7, \" \"; // 12 24 0 0\n  a := -1;\n  print a << 0, \" \", a << 6, \"\\n\"; // 127 64\n\n  var b: bv8 := 12;\n  print b << 0, \" \", b << 1, \" \", b << 7, \" \", b << 8, \" \"; // 12 24 0 0\n  b := -1;\n  print b << 0, \" \", b << 7, \"\\n\"; // 255 128\n\n  var r: bv15 := 12;\n  print r << 0, \" \", r << 1, \" \", r << 14, \" \", r << 15, \" \"; // 12 24 0 0\n  r := -1;\n  print r << 0, \" \", r << 14, \"\\n\"; // 32767 16384\n\n  var s: bv16 := 12;\n  print s << 0, \" \", s << 1, \" \", s << 15, \" \", s << 16, \" \"; // 12 24 0 0\n  s := -1;\n  print s << 0, \" \", s << 15, \"\\n\"; // 65535 32768\n\n  var w: bv31 := 12;\n  print w << 0, \" \", w << 1, \" \", w << 30, \" \", w << 31, \" \"; // 12 24 0 0\n  w := -1;\n  print w << 0, \" \", w << 30, \"\\n\"; // 0x7fff_ffff 0x4000_0000\n\n  var x: bv32 := 12;\n  print x << 0, \" \", x << 1, \" \", x << 31, \" \", x << 32, \" \"; // 12 24 0 0\n  x := -1;\n  print x << 0, \" \", x << 31, \"\\n\"; // 0xffff_ffff 0x8000_0000\n\n  var y: bv63 := 12;\n  print y << 0, \" \", y << 1, \" \", y << 62, \" \", y << 62, \" \"; // 12 24 0 0\n  y := -1;\n  print y << 0, \" \", y << 62, \"\\n\"; // 0x7fff_ffff_ffff_ffff 0x4000_0000_0000_0000\n\n  var z: bv64 := 12;\n  print z << 0, \" \", z << 1, \" \", z << 63, \" \", z << 64, \" \"; // 12 24 0 0\n  z := -1;\n  print z << 0, \" \", z << 63, \"\\n\"; // 0xffff_ffff_ffff_ffff 0x8000_0000_0000_0000\n\n  var u: bv100 := 12;\n  print u << 0, \" \", u << 1, \" \", u << 99, \" \", u << 100, \" \"; // 12 24 0 0\n  u := -1;\n  print u << 0, \" \", u << 99, \"\\n\"; // 0xf_ffff_ffff_ffff_ffff_ffff_ffff 0x8_0000_0000_0000_0000_0000_0000 \n}"}
{"file": "../dafny/Test/git-issues/git-issue-351.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n\nfunction DecodeRecursively(s: seq<int>): (b: seq<int>) {\n  seq(|s|, i requires 0 <= i < |s| =>\n    var d := s[0]; // this line produced the reported error, prior to the fix\n    s[i]\n  )\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-2928.dfy", "dafny": "// RUN: %testDafnyForEachCompiler %s\n\nmethod Main() {\n  var c := '\\0';\n  assert c == 0 as char;\n  expect c == 0 as char;\n\n  var s := \"\\03\";\n  \n  assert |s| == 2;\n  expect |s| == 2;\n\n  assert s[0] == 0 as char;\n  expect s[0] == 0 as char;\n\n  assert s[1] == '3';\n  expect s[1] == '3';\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-645.dfy", "dafny": "// dafny should emit exit value 1\n// RUN: ! %dafny /xyz /useBasenameForFilename  > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// UNSUPPORTED: windows\n"}
{"file": "../dafny/Test/git-issues/git-issue-2672.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nnewtype sreal = r: real | r > -4 as real\nnewtype sint = r: int | r > -4 as int\nnewtype ssreal = r: sreal | r > -3 as sreal\nnewtype ssint = r: sint | r > -3 as sint\n\nmethod Print(b: bool, end: string)\n  // Print boolean `b` as `true` or `false`, then print `end`.  This is needed\n  // by C++ due to BUG(https://github.com/dafny-lang/dafny/issues/2773).\n{\n  if b {\n    print \"true\";\n  } else {\n    print \"false\";\n  }\n  print end;\n}\n\nmethod Main() {\n  Print(24 as real <= 1507 as real, \" \");\n  Print(24 as sreal <= 1507 as sreal, \" \");\n  Print(24 as ssreal <= 1507 as ssreal, \" \");\n  Print(24 as int <= 1507 as int, \" \");\n  Print(24 as sint <= 1507 as sint, \" \");\n  Print(24 as ssint <= 1507 as ssint, \" \");\n  Print(24 as bv16 <= 1507 as bv16, \" \");\n  Print(24 as bv232 <= 1507 as bv232, \" \");\n  Print(24 as char <= 1507 as char, \" \");\n  Print(24 as ORDINAL <= 1507 as ORDINAL, \"\\n\");\n\n  Print(24 as real == 1507 as real, \" \");\n  Print(24 as sreal == 1507 as sreal, \" \");\n  Print(24 as ssreal == 1507 as ssreal, \" \");\n  Print(24 as int == 1507 as int, \" \");\n  Print(24 as sint == 1507 as sint, \" \");\n  Print(24 as ssint == 1507 as ssint, \" \");\n  Print(24 as bv16 == 1507 as bv16, \" \");\n  Print(24 as bv232 == 1507 as bv232, \" \");\n  Print(24 as char == 1507 as char, \" \");\n  Print(24 as ORDINAL == 1507 as ORDINAL, \"\\n\");\n\n  Print(24 as real >= 1507 as real, \" \");\n  Print(24 as sreal >= 1507 as sreal, \" \");\n  Print(24 as ssreal >= 1507 as ssreal, \" \");\n  Print(24 as int >= 1507 as int, \" \");\n  Print(24 as sint >= 1507 as sint, \" \");\n  Print(24 as ssint >= 1507 as ssint, \" \");\n  Print(24 as bv16 >= 1507 as bv16, \" \");\n  Print(24 as bv232 >= 1507 as bv232, \" \");\n  Print(24 as char >= 1507 as char, \" \");\n  Print(24 as ORDINAL >= 1507 as ORDINAL, \"\\n\");\n\n  Print(24 as real < 1507 as real, \" \");\n  Print(24 as sreal < 1507 as sreal, \" \");\n  Print(24 as ssreal < 1507 as ssreal, \" \");\n  Print(24 as int < 1507 as int, \" \");\n  Print(24 as sint < 1507 as sint, \" \");\n  Print(24 as ssint < 1507 as ssint, \" \");\n  Print(24 as bv16 < 1507 as bv16, \" \");\n  Print(24 as bv232 < 1507 as bv232, \" \");\n  Print(24 as char < 1507 as char, \" \");\n  Print(24 as ORDINAL < 1507 as ORDINAL, \"\\n\");\n\n  Print(24 as real != 1507 as real, \" \");\n  Print(24 as sreal != 1507 as sreal, \" \");\n  Print(24 as ssreal != 1507 as ssreal, \" \");\n  Print(24 as int != 1507 as int, \" \");\n  Print(24 as sint != 1507 as sint, \" \");\n  Print(24 as ssint != 1507 as ssint, \" \");\n  Print(24 as bv16 != 1507 as bv16, \" \");\n  Print(24 as bv232 != 1507 as bv232, \" \");\n  Print(24 as char != 1507 as char, \" \");\n  Print(24 as ORDINAL != 1507 as ORDINAL, \"\\n\");\n\n  Print(24 as real > 1507 as real, \" \");\n  Print(24 as sreal > 1507 as sreal, \" \");\n  Print(24 as ssreal > 1507 as ssreal, \" \");\n  Print(24 as int > 1507 as int, \" \");\n  Print(24 as sint > 1507 as sint, \" \");\n  Print(24 as ssint > 1507 as ssint, \" \");\n  Print(24 as bv16 > 1507 as bv16, \" \");\n  Print(24 as bv232 > 1507 as bv232, \" \");\n  Print(24 as char > 1507 as char, \" \");\n  Print(24 as ORDINAL > 1507 as ORDINAL, \"\\n\");\n\n  Print(0 as bv0 <= 0 as bv0, \" \");\n  Print(0 as bv0 == 0 as bv0, \" \");\n  Print(0 as bv0 >= 0 as bv0, \"\\n\");\n\n  Print(0 as bv0 < 0 as bv0, \" \");\n  Print(0 as bv0 != 0 as bv0, \" \");\n  Print(0 as bv0 > 0 as bv0, \"\\n\");\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1181.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype T {\n  ghost predicate P(t: T)\n  ghost predicate Q()\n    requires P(this)  // once got the bogus \"type mismatch for argument (function expects T, got T)\"\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3719a.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost opaque function R(i: int): int {\n  i\n}\n\nlemma Test() {\n  assert 1 == R(1) by { reveal R(); }\n  assert 1 == R(1);\n}"}
{"file": "../dafny/Test/git-issues/git-issue-975.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function f():nat\n  ensures f() == 0\n{                  // no problem for methods\n  var x := 0;      // no problem without this\n  assert true by {}\n  0\n}\n"}
{"file": "../dafny/Test/git-issues/4104-git-issue.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\n// This file tests that it's okay for a filename to start with a digit.\n\nmethod Main() {\n  print \"hello\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-504.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule List {\n  datatype t<A> = Nil | Cons(A, t<A>)\n}\n\nmodule Bug1 {\n  import List\n\n  function foo(x: List.t<char>, y: List.t<char>): List.t<char> {\n    match (x, y)\n      case (Cons(_, _), _) => List.Cons('-', List.Nil)\n      case (Nil, _) => List.Nil\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-4217.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction SpecConverter(input: string): int {\n  1\n}\n\ntype StringWrapper {\n  ghost const base: string\n}\n\nmethod Converter(value: StringWrapper) returns (res: int)\n  // the following postcondition used to not verify\n  ensures res == SpecConverter(value.base)\n{\n  res := 1;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-864z1.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  export reveals a\n  const a := 10\n  const b := 20\n}\n\nmodule B refines A {\n  export reveals *\n  const c := 30\n}\n\nmodule C {\n  import B\n  method m() {\n    assert B.c == 30;\n    assert B.a == 10;\n    assert B.b == 20;\n  }\n}\n\nmodule D {\n  import B`A\n  method m() {\n    assert B.a == 10;\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-3955.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass A {\n  var x: int\n  predicate Valid() reads this {\n    x >= 0\n  }\n}\n\ndatatype B = B(\n  a: A\n) {\n  opaque predicate Valid()\n    reads a\n  {\n    a.Valid()\n  }\n}\n\nclass C {\n  var a: A\n  constructor()\n  opaque twostate predicate Valid()\n    reads this`a, a\n  {\n    a.Valid() && old(a.Valid())\n  }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-2690.dfy", "dafny": "// RUN: %dafny -compile:4 -compileTarget:cs \"%s\" > \"%t\"\n// RUN: %dafny -noVerify -compile:4 -compileTarget:js \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod InSeq<T>(ts: seq<T>) returns (f: T --> bool)\n  ensures forall t <- ts :: f.requires(t)\n{\n  ghost var pre := t => t in ts;\n  f := t requires pre(t) => true;\n}\n\nmethod InSeq2<T>(ghost ts: seq<T>) returns (f: T --> bool)\n  ensures forall t <- ts :: f.requires(t)\n{\n  f := t requires (ghost var b := t in ts; b) => true;\n}\n\nmethod Main() {\n  var f := InSeq([1, 2]);\n  print \"2 in seq? \", f(2),\"\\n\";\n  var g := InSeq2([1, 2]);\n  print \"2 in seq? \", g(2),\"\\n\";\n  print \"All right\";\n}"}
{"file": "../dafny/Test/git-issues/git-issue-2748.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction f(x: int): int { 10 - x * x }\n\nfunction BindingGuardTestStmt(): int {\n  var x: nat := 1;\n  assert true by {\n    if i :| 0 <= i < 10 && (f(i) == f(i+1) || f(i) == f(i+2)) {\n    }\n  }\n  2\n}\n\nfunction BindingGuardTestExpr(): int {\n  var x: nat := 1;\n  assert true by {\n    var x := if i :| 0 <= i < 10 && (f(i) == f(i+1) || f(i) == f(i+2)) then 1 else 0;\n  }\n  2\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2852.dfy", "dafny": "// RUN: %dafny -compile:3 -compileTarget:cs \"%s\" > \"%t\"\n// RUN: %dafny -noVerify -compile:4 -compileTarget:js \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Returns a function that computes the sum of n consecutive integers starting at pos\nfunction Sum(\n  ghost remaining: nat,\n  n: nat\n): (p: nat -> nat)\n  decreases remaining\n  requires remaining == n\n{\n  (pos: nat) =>\n    var x: nat := if n == 0 then 0 else Sum(remaining - 1, n - 1)(pos+1) + pos;\n    x\n}\nmethod Main() {\n  print Sum(5, 5)(10);\n}"}
{"file": "../dafny/Test/git-issues/git-issue-2726.dfy", "dafny": "// RUN: %dafny /compile:1 /compileTarget:cs \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Formula =\n  | And(left: Formula, right: Formula)\n  | Not(underlying: Formula)\n  | True\n{\n  function size(): nat {\n    match this\n    case And(l, r) => l.size() + r.size()\n    case Not(u) => u.size() + 1\n    case True => 1\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1909.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype ABC = ABC(nameonly a: int, nameonly b: int, nameonly c: int)\n\nfunction JustChangeB(abc: ABC): ABC {\n  // The following line once gave an error, complaining 'a' wasn't specified by name. That's been fixed.\n  abc.(b := 42)\n}\n\nfunction ChangeEvathang(abc: ABC): ABC {\n  // The following line once gave an error, complaining 'a' wasn't specified by name. That's been fixed.\n  abc.(b := 42, a := 100, c := 90)\n}\n\ndatatype XYZ = XYZ(x: int, nameonly y: int := 5, z: int := 7)\n\nfunction MakeSureDefaultValuesAreNotUsedInUpdate(xyz: XYZ): XYZ {\n  xyz.(x := 3)\n}\n\nmethod Main() {\n  var abc := ABC(a := 19, c := 23, b := 21);\n  assert abc.b == 21;\n  print abc, \"\\n\"; // 19 21 23\n\n  abc := JustChangeB(abc);\n  assert abc.b == 42 && abc.c == 23;\n  print abc, \"\\n\"; // 19 42 23\n\n  abc := ChangeEvathang(abc);\n  assert abc.b == 42 && abc.c == 90;\n  print abc, \"\\n\"; // 100 42 90\n\n  var xyz := XYZ(0);\n  assert xyz.y == 5;\n  print xyz, \"\\n\"; // 0 5 7\n\n  xyz := XYZ(88, y := 89, z := 90);\n  assert xyz.y == 89;\n  print xyz, \"\\n\"; // 88 89 90\n\n  xyz := MakeSureDefaultValuesAreNotUsedInUpdate(xyz);\n  assert xyz.y == 89;\n  print xyz, \"\\n\"; // 3 89 90\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-262.dfy", "dafny": "// NONUNIFORM: https://github.com/dafny-lang/dafny/issues/4119\n// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nfunction tst(x: nat): nat {\n    x + 1\n}\n\nmethod Main() {\n  var f := tst;\n  print f, \"\\n\";\n  print tst, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2100.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Library {\n  export\n    provides Cl\n\n  trait Tr { }\n  class Cl extends Tr { }\n}\n\nmodule Client {\n  import Library\n\n  // The mention of the export-provided Cl below (in the case where\n  // its parent type, Tr, is not exported) once generated malformed\n  // Boogie. In particular, Cl should be treated as an opaque type in\n  // this Client module, but in some places in the translation to Boogie,\n  // the type was still treated as a non-opaque type.\n  method Test(cl: Library.Cl) {\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-622$f.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation\n\nmethod Main() {\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2429.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate P<A>(s: seq<A>)\n\ntrait T<A> {\n  method M(a: A)\n    requires Q([a][0 := a])\n    modifies if P([a][0 := a]) then {} else {this}\n    ensures P([a][0 := a])\n    decreases if P([a][0 := a]) then 3 else 4\n  ghost function F(a: A): int\n    requires Q([a][0 := a])\n    reads if P([a][0 := a]) then {} else {this}\n    ensures F(a) == 5 ==> P([a][0 := a])\n    decreases if P([a][0 := a]) then 3 else 4\n}\n\nghost predicate Q<A>(s: seq<A>)\n  ensures Q(s) ==> P(s)\n\nclass C extends T<object> {\n  // A missing type substitution in the translator used to cause issues here:\n  method M(a: object)\n    requires P([a][0 := a])\n    modifies if Q([a][0 := a]) then {} else {this}\n    ensures Q([a][0 := a])\n    decreases if Q([a][0 := a]) then 3 else 2\n  ghost function F(a: object): int\n    requires P([a][0 := a])\n    reads if Q([a][0 := a]) then {} else {this}\n    ensures F(a) == 5 ==> Q([a][0 := a])\n    decreases if Q([a][0 := a]) then 3 else 4\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-864rr.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\n// Tests the resolution of the refinement parent -- that it ignores\n// local declarations.\nmodule A {\n  const a := 10\n}\n\nmodule B refines A { // ignore the submodule A, use the top-level A\n  module A {\n    const a := 30\n  }\n  method Main() {\n    assert a == 10; // true\n    expect a == 10; // check it at runtime\n    print \"OK\\n\";\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-895.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  ghost predicate Init(s: int) {\n    s == 0\n  }\n\n  ghost predicate Next(s: int, s': int) {\n    s' == s + 1\n  }\n\n  least predicate Reachable(s: int)\n  {\n    Init(s) || (exists s0 :: Reachable(s0) && Next(s0, s))\n  }\n}\n\nmodule B {\n  import A\n\n  least lemma ReachableImpliesNonneg(s: int)\n  requires A.Reachable(s)\n  ensures s >= 0\n  {\n    if A.Init(s) {\n    } else {\n      var s0: int :| A.Reachable(s0) && A.Next(s0, s);\n      ReachableImpliesNonneg(s0);\n    }\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-966.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Test various ways to get to the members of a datatype\n\ndatatype DT = Make | Create(w: int) {\n  static const b := 30\n  const c := 40\n  function F(): int {\n    if Make? then 92 else 95\n  }\n}\n\nmethod Test0() {\n  var d: DT := Make;\n  var x := d.c;\n  var y := d.b;\n  var f := d.F;\n  assert x == 40 && y == 30 && f() == 92;\n}\n\nmethod Test1() {\n  var d: DT := Create(2);\n  var x := d.c;\n  var y := d.b;\n  var f := d.F;\n  assert x == 40 && y == 30 && f() == 95;\n}\n\nmethod Test2() {\n  // The following three mentions of \"Make.\" once complained about \"Make\" being an unresolved identifier\n  var x := Make.c;\n  var y := Make.b;\n  var f := Make.F;\n  assert x == 40 && y == 30 && f() == 92;\n}\n\nmethod Test3() {\n  var x := Make().c;\n  var y := Make().b;\n  var f := Make().F;\n  assert x == 40 && y == 30 && f() == 92;\n}\n\nmethod Tesst4() {\n  var x := Create(2).c;\n  var y := Create(2).b;\n  var f := Create(2).F;\n  assert x == 40 && y == 30 && f() == 95;\n}\n\nmethod Test4() {\n  var x := DT.Make.c;\n  var y := DT.Make.b;\n  var f := DT.Make.F;\n  assert x == 40 && y == 30 && f() == 92;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-506.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n\n  var a := new int[10];\n  var index := 6;\n  a[8] := 1;\n  a[index], index := 3, index+1;\n  assert a[6] == 3;\n  assert index == 7;\n  print index, \" \", a[6], a[7], a[8], \"\\n\";  // Should be: \"7 301\"\n  index, a[index] := index+1, 9;\n  assert index == 8;\n  assert a[7] == 9;\n  assert a[8] == 1; // Assertion is OK\n  expect a[8] == 1; // This failed before the bug fix\n  print index, \" \", a[6], a[7], a[8], \"\\n\";  // Should be \"8 391\" not \"8 309\"\n\n  a[index+1], index := 7, 6;\n  assert a[9] == 7 && index == 6;\n  expect a[9] == 7 && index == 6;\n\n  var o := new F(2);\n  var oo := o;\n  print o.f, \" \", oo.f, \"\\n\";\n  assert o.f == 2;\n  assert oo.f == 2;\n  var ooo := new F(4);\n  o.f, o := 5, ooo;\n  print o.f, \" \", oo.f, \"\\n\";\n  assert o.f == 4;\n  assert oo.f == 5;\n  var oooo := new F(6);\n  o, o.f := oooo, 7;\n  assert o.f == 6;\n  assert ooo.f == 7;\n  expect ooo.f == 7;  // This failed before the bug fix\n  print o.f, \" \", ooo.f, \"\\n\";\n\n  var aa := new int[9,9];\n  var j := 4;\n  var k := 5;\n  aa[j,k] := 8;\n  j, k, aa[j,k] := 2, 3, 7;\n  print j, \" \", k, \" \", aa[4,5], \" \", aa[2,3], \"\\n\"; // Should be 2 3 7 0\n  assert aa[4,5] == 7;\n  expect aa[4,5] == 7; // This failed before the bug fix\n  j, aa[j,k], k := 5, 6, 1;\n  assert j == 5 && aa[2,3] == 6 && k == 1;\n  expect j == 5 && aa[2,3] == 6 && k == 1; // This failed before the bug fix\n  aa[j,k], k, j := 5, 6, 1;\n  assert j == 1 && aa[5,1] == 5 && k == 6;\n  expect j == 1 && aa[5,1] == 5 && k == 6;\n}\n\nclass F {\n  var f: int\n  constructor (f: int) ensures this.f == f { this.f := f; }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-643.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n   expect false;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2827b/B.dfy", "dafny": "// RUN: %baredafny build -t:java \"%s\" \"%S\"/org/D.java > \"%t\"\n// RUN: java -cp \"%S\"/B.jar org.D >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Fails on integration tests because the file org/D.java is not put in the right place.\nmethod m() {\n  print \"Hello, World!\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-443.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  print F(), \" \", G(802.11), \"\\n\";  // 12 15\n}\n\nfunction F(): int {\n  var rx := false;\n  assert 20 < 30 by {\n    var u := 5.0;  // this once caused a crash in Translator.cs\n    assert u < 6.0;\n  }\n  12\n}\n\nfunction G<T>(t: T): int {\n  var rx := false;\n  assert 20 < 30 by {\n    var u: T := t;  // this once caused a crash in Translator.cs\n    {\n      var v: T := u;\n      assert t == v;\n      v := t;\n      assert t == u;\n    }\n    assert u == t;\n  }\n  15\n}\n"}
{"file": "../dafny/Test/git-issues/class.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\n// This file tests that it's okay for a filename to have a name like \"class, which is\n// reserved in many languages.\n\nmethod Main() {\n  print \"hello\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-757.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n  export\n    provides A, A.New\n  datatype A<T> = A(s:seq<T>) {\n    static method New() returns (self: A<T>) {\n      self := A([]);\n    }\n  }\n}\n\nmodule M2 {\n  import M\n\n  method test() {\n    var a := M.A<int>.New(); // Used to throw when resolving this line\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1963c.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n/// This file checks that refinement works for members of newtypes and\n/// datatypes.\n\nabstract module A {\n  datatype D = D {\n    function f(): int\n    function g(): int { 1 }\n  }\n\n  newtype NT0 = int {\n    function f(): int\n    function g(): int { 1 }\n  }\n\n  newtype NT = x: int | x >= 0 witness 0 {\n    function f(): int\n    function g(): int { 1 }\n  }\n}\n\nmodule B refines A {\n  datatype D ... {\n    function f() : int { 1 }\n    function g ...\n  }\n\n  newtype NT0 ... {\n    function f() : int { 1 }\n    function g ...\n  }\n\n  newtype NT ... {\n    function f() : int { 1 }\n    function g ...\n  }\n}\n\nmodule Parent {\n  type t\n  newtype pos = n: nat | n > 0 witness 1\n  datatype Bool = True | False\n}\n\nmodule Child refines Parent {\n  type t\n  newtype pos ... {\n    method Print() { print this; }\n  }\n  datatype Bool ... {\n    function AsDafnyBool() : bool { this.True? }\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-663.dfy", "dafny": "// RUN: %exits-with 3 %dafny /compile:1 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod StatementsInCompiledMethod() {\n  assume false;  // error\n  calc {\n    100;\n  ==  { assume false; }  // error\n    100;\n  }\n  assert true by {\n    assume false;  // error\n  }\n  ghost var b := true;\n  if b {\n    assume false;  // error\n  }\n}\n\nghost method StatementsInGhostMethod() {\n  // statements\n  assume false;  // error\n  calc {\n    100;\n  ==  { assume false; }  // error\n    100;\n  }\n  assert true by {\n    assume false;  // error\n  }\n  ghost var b := true;\n  if b {\n    assume false;  // error\n  }\n}\n\nmethod ExpressionsInCompiledMethod() {\n  var a :=\n    assume false;  // error\n    5;\n  var b :=\n    calc {\n      100;\n    ==  { assume false; }  // error\n      100;\n    }\n    5;\n  var c :=\n    assert true by {\n      assume false;  // error\n    }\n    5;\n  var d :=\n    ghost var g := 5;\n    assume false;  // error\n    5;\n\n  ghost var x :=\n    assume false;  // error\n    5;\n  ghost var y :=\n    calc {\n      100;\n    ==  { assume false; }  // error\n      100;\n    }\n    5;\n  ghost var z :=\n    assert true by {\n      assume false;  // error\n    }\n    5;\n  ghost var w :=\n    ghost var g := 5;\n    assume false;  // error\n    5;\n}\n\nghost method ExpressionsInGhostMethod() {\n  var a :=\n    assume false;  // error\n    5;\n  var b :=\n    calc {\n      100;\n    ==  { assume false; }  // error\n      100;\n    }\n    5;\n  var c :=\n    assert true by {\n      assume false;  // error\n    }\n    5;\n  var d :=\n    ghost var g := 5;\n    assume false;  // error\n    5;\n\n  ghost var x :=\n    assume false;  // error\n    5;\n  ghost var y :=\n    calc {\n      100;\n    ==  { assume false; }  // error\n      100;\n    }\n    5;\n  ghost var z :=\n    assert true by {\n      assume false;  // error\n    }\n    5;\n  ghost var w :=\n    ghost var g := 5;\n    assume false;  // error\n    5;\n}\n\nfunction CompiledFunction(): int {\n  assume false;  // error\n  calc {\n    100;\n  ==  { assume false; }  // error\n    100;\n  }\n  assert true by {\n    assume false;  // error\n  }\n  ghost var g := 5;\n  assume false;  // error\n  5\n}\n\nghost function GhostFunction(): int {\n  assume false;  // error\n  calc {\n    100;\n  ==  { assume false; }  // error\n    100;\n  }\n  assert true by {\n    assume false;  // error\n  }\n  ghost var g := 5;\n  assume false;  // error\n  5\n}\n\n// --------------------------------------------------\n\nmethod SpecificationOfCompiledMethod()\n  requires assume false; true  // error\n  modifies assume false; {}  // error\n  ensures assume false; true  // error\n  decreases assume false; 5  // error\n{\n}\n\nghost method SpecificationOfGhostMethod()\n  requires assume false; true  // error\n  modifies assume false; {}  // error\n  ensures assume false; true  // error\n  decreases assume false; 5  // error\n{\n}\n\nfunction SpecificationOfCompiledFunction(): int\n  requires assume false; true  // error\n  reads assume false; {}  // error\n  ensures assume false; true  // error\n  decreases assume false; 5  // error\n{\n  5\n}\n\nghost function SpecificationOfGhostFunction(): int\n  requires assume false; true  // error\n  reads assume false; {}  // error\n  ensures assume false; true  // error\n  decreases assume false; 5  // error\n{\n  5\n}\n\nmethod SpecificationOfCompiledMethodWithoutBody()  // error: has no body\n  requires assume false; true  // error\n  modifies assume false; {}  // error\n  ensures assume false; true  // error\n  decreases assume false; 5  // error\n\nghost method SpecificationOfGhostMethodWithoutBody()  // error: has no body\n  requires assume false; true  // error\n  modifies assume false; {}  // error\n  ensures assume false; true  // error\n  decreases assume false; 5  // error\n\nfunction SpecificationOfCompiledFunctionWithoutBody(): int  // error: has no body\n  requires assume false; true  // error\n  reads assume false; {}  // error\n  ensures assume false; true  // error\n  decreases assume false; 5  // error\n\nghost function SpecificationOfGhostFunctionWithoutBody(): int  // error: has no body\n  requires assume false; true  // error\n  reads assume false; {}  // error\n  ensures assume false; true  // error\n  decreases assume false; 5  // error\n\n// --------------------------------------------------\n\nleast predicate ExtremePredicate()\n  requires assume false; true  // error\n{\n  assume false;  // error\n  true\n}\n\nleast lemma ExtremeLemma()\n  requires assume false; true  // error\n  ensures assume false; true  // error\n  decreases assume false; 5  // error\n{\n  assume false;  // error\n}\n\nleast predicate ExtremePredicateWithoutBody()  // error: has no body\n  requires assume false; true  // error\n\nleast lemma ExtremeLemmaWithoutBody()  // error: has no body\n  requires assume false; true  // error\n  ensures assume false; true  // error\n  decreases assume false; 5  // error\n\n// --------------------------------------------------\n\nnewtype NewType = x | x % 2 == 1\n  witness assume false; 5  // error\n\ntype SubsetType = x | x % 2 == 1\n  witness assume false; 5  // error\n\nnewtype NewTypeGhostWitness = x | x % 2 == 1\n  ghost witness assume false; 5  // error\n\ntype SubsetTypeGhostWitness = x | x % 2 == 1\n  ghost witness assume false; 5  // error\n\nconst CompiledConst := assume false; 5  // error\n\nghost const GhostConst := assume false; 5  // error\n\nclass C {\n  const InstanceCompiledConst := assume false; 5  // error\n  ghost const InstanceGhostConst := assume false; 5  // error\n}\n\ndatatype D = D {\n  const InstanceCompiledConst := assume false; 5  // error\n  ghost const InstanceGhostConst := assume false; 5  // error\n}\n\nnewtype T = int {\n  const InstanceCompiledConst := assume false; 5  // error\n  ghost const InstanceGhostConst := assume false; 5  // error\n}\n\n// --------------------------------------------------\n\nfunction F(x: int, ghost y: int): int { 5 }\nghost function G(x: int): int { 5 }\nmethod M(x: int, ghost y: int) { }\nlemma N(x: int) { }\n\ndatatype Dt = Dt(x: int, ghost y: int)\n\nmethod CompiledMethodCaller() {\n  var a := F(assume false; 5, assume false; 6);  // error (x2)\n  ghost var b := G(assume false; 5);  // error\n  M(assume false; 5, assume false; 6);  // error (x2)\n  N(assume false; 5);  // error\n  var d := Dt(assume false; 5, assume false; 6);  // error (x2)\n  ghost var e := Dt(assume false; 5, assume false; 6);  // error (x2)\n}\n\nghost method GhostMethodCaller() {\n  var a := F(assume false; 5, assume false; 6);  // error (x2)\n  ghost var b := G(assume false; 5);  // error\n  N(assume false; 5);  // error\n  var d := Dt(assume false; 5, assume false; 6);  // error (x2)\n  ghost var e := Dt(assume false; 5, assume false; 6);  // error (x2)\n}\n\nfunction CompiledFunctionCaller(): int {\n  var a := F(assume false; 5, assume false; 6);  // error (x2)\n  ghost var b := G(assume false; 5);  // error\n  N(assume false; 5);  // error\n  var d := Dt(assume false; 5, assume false; 6);  // error (x2)\n  ghost var e := Dt(assume false; 5, assume false; 6);  // error (x2)\n  100\n}\n\nghost function GhostFunctionCaller(): int {\n  var a := F(assume false; 5, assume false; 6);  // error (x2)\n  ghost var b := G(assume false; 5);  // error\n  N(assume false; 5);  // error\n  var d := Dt(assume false; 5, assume false; 6);  // error (x2)\n  ghost var e := Dt(assume false; 5, assume false; 6);  // error (x2)\n  100\n}\n\nclass A {\n\n  method StatementsInCompiledMethod() {\n    assume false;  // error\n    calc {\n      100;\n    ==  { assume false; }  // error\n      100;\n    }\n    assert true by {\n      assume false;  // error\n    }\n    ghost var b := true;\n    if b {\n      assume false;  // error\n    }\n  }\n\n  ghost method StatementsInGhostMethod() {\n    // statements\n    assume false;  // error\n    calc {\n      100;\n    ==  { assume false; }  // error\n      100;\n    }\n    assert true by {\n      assume false;  // error\n    }\n    ghost var b := true;\n    if b {\n      assume false;  // error\n    }\n  }\n\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-4139-main.dfy", "dafny": "// RUN: echo 'lit should ignore this file' \n\nclass TestLogic''TopLevel {\n  constructor () \n  {\n  }\n}"}
{"file": "../dafny/Test/git-issues/github-issue-305-b.dfy", "dafny": "// RUN: %exits-with 3 %dafny /compile:0 /spillTargetCode:2 /useBaseNameForFileName \"%s\" > \"%t\"\n// RUN: %diff \"%s\".expect \"%t\"\n\nmethod hasNoBody()\n\nmethod Main() {\n    hasNoBody();\n    print \"hello\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1195.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod M0(B: ORDINAL)\n{\n  var b := B;\n  var w := 0 < b;\n  var y := b.IsLimit;\n}\n\nmethod M1(B: ORDINAL)\n{\n  var b := B;\n  var w := 0 <= b;\n  var y := b.IsLimit; // this once had bogusly reported \"type int does not have member IsLimit\"\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-698b.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ntype Small = x: int | 0 <= x < 100 && x != 3\n\nfunction F(x: int): int\n  requires x != 3\n{\n  if x == 3 then 1/0 else 100\n}\n\nmethod Main() {\n  var b := !exists n: Small :: F(n) != 100;\n  assert b;\n  print b;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1150.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype Foo = Foo(x: nat)\n{\n  // the following once generated malformed Boogie\n  const good?: bool := 0 < x < 5\n}\n\nmethod Main()\n{\n  var x := Foo(2);\n  assert x.good?;\n  print x, \" \", x.good?, \"\\n\";\n\n  var y := Foo(5);\n  assert !y.good?;\n  print y, \" \", y.good?, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1761.dfy", "dafny": "// RUN: %baredafny run %args \"%s\" --input %S/git-issue-1761-extern.cs > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass {:extern \"ABC\"} XYZ {\n  var y: bool\n  constructor {:extern} (x: bool) {\n    y := x;\n  }\n}\n\nmethod Main() {\n  var xyz := new XYZ(true);\n  print xyz.y, \"\\n\";\n}"}
{"file": "../dafny/Test/git-issues/git-issue-276b.dfy", "dafny": "// RUN: %dafny /compile:0 /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Testing constant folding of bool operations\nmodule Main {\n  newtype b0 = x | 0 <= x < (if true then 30 else 40)\n  newtype b1 = x | 0 <= x < (if false then 30 else 40)\n  newtype b2 = x | 0 <= x < (if true && false then 30 else 40)\n  newtype b3 = x | 0 <= x < (if true || false then 30 else 40)\n  newtype b4 = x | 0 <= x < (if true ==> false then 30 else 40)\n  newtype b5 = x | 0 <= x < (if true <== false then 30 else 40)\n  newtype b6 = x | 0 <= x < (if true <==> false then 30 else 40)\n  newtype b7 = x | 0 <= x < (if true == false then 30 else 40)\n  newtype b8 = x | 0 <= x < (if true != false then 30 else 40)\n  newtype b9 = x | 0 <= x < (if !false then 30 else 40)\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1130.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  var a := new Issue.Foo<int>();\n  Issue.CallUseFoo(a);\n\n  var b := new Variation.Foo<int>();\n  Variation.CallUseFoo(b);\n\n  var c := new AnotherVariation.Foo<int>();\n  AnotherVariation.CallUseFoo(c);\n\n  print \"\\n\";\n}\n\nmodule Issue\n{\n  class Foo<T> {\n    ghost function Repr(): set<object> { {this} }\n    constructor() {}\n  }\n\n  method UseFoo<T>(t: Foo<T>)\n    modifies t.Repr()\n  {\n    print 0;\n  }\n\n  method CallUseFoo<T>(t: Foo<T>)\n    modifies t.Repr()\n  {\n    // the following line once produced malformed Boogie\n    UseFoo(t);\n  }\n}\n\n// the following variation was working all along\nmodule Variation {\n  class Foo<T> {\n    ghost function Repr(): set<object> { {this} }\n    constructor() {}\n  }\n\n  class UseFooHelper<T>\n  {\n    const foo: Foo<T>\n    constructor(foo: Foo<T>)\n      ensures this.foo == foo\n    {\n      this.foo := foo;\n    }\n\n    method Do()\n      modifies foo.Repr()\n    {\n      print 1;\n    }\n  }\n\n  method CallUseFoo<T>(t: Foo<T>)\n    modifies t.Repr()\n  {\n    var fh := new UseFooHelper(t);\n    fh.Do();\n  }\n}\n\n// the following variation was also working all along\nmodule AnotherVariation\n{\n  class Foo<T> {\n    ghost function Repr(): set<object> { {this} }\n    constructor() {}\n\n    method UseFoo()\n      modifies Repr()\n    {\n      print 2;\n    }\n  }\n\n  method CallUseFoo<T>(t: Foo<T>)\n    modifies t.Repr()\n  {\n    t.UseFoo();\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-Main4.dfy", "dafny": "// NONUNIFORM: Multiple test scenarios (could be split)\n// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs /Main:A.AA.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js /Main:A.AA.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go /Main:A.AA.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:java /Main:A.AA.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs /Main:B.C.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js /Main:B.C.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go /Main:B.C.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:java /Main:B.C.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs /Main:B.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js /Main:B.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go /Main:B.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:java /Main:B.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs /Main:Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js /Main:Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go /Main:Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:java /Main:Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs /Main:C.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js /Main:C.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go /Main:C.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:java /Main:C.Test \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:cs /Main:X \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:js /Main:X \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:go /Main:X \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:java /Main:X \"%s\" >> \"%t\"\n\nmodule A {\n  module AA {\n    method Test() { print \"Test1\\n\"; }\n  }\n}\n\nmodule B {\n  class C {\n    static method Test() { print \"Test2\\n\"; }\n  }\n  method Test() { print \"Test3\\n\"; }\n}\n\nmethod Test() { print \"Test4\\n\"; }\n\nclass C {\n  static method Test() { print \"Test5\\n\"; }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1224.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nabstract module SlowPoke {\n  lemma {:timeLimitMultiplier 4} SlowLemma()\n}\n\nmodule SlowChild refines SlowPoke { }\n"}
{"file": "../dafny/Test/git-issues/git-issue-327a.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  module X { }\n}\nmodule B {\n  import A.X  // used to require an 'import A' first\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1210.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nabstract module A {\n  const c: nat\n}\nabstract module B refines A {}\nmodule C refines B {\n  const c: nat := 0\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-Main3.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmodule A {\n  module AA {\n    method Main() { print \"Main1\\n\"; }\n  }\n}\n\nmodule B {\n  class C {\n    static method Test() { print \"Main2\\n\"; }\n  }\n}\n\nmethod {:main} Main() { print \"Test3\\n\"; }\n"}
{"file": "../dafny/Test/git-issues/git-issue-612.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype D = D\n{\n  function {:extern Foo} Foo() : bool\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-3873.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() {\n  var a := new ()[1];\n  var m: map<array<()>, ()> := map[a := ()];\n  var v :| v in m;\n  print v[0], \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3288c.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\" \n\nmodule M {\n  export \n  greatest predicate p() { true } // Warning: the greatest goes with the export\n}\n\nmodule N {\n  export\n    least\n  predicate p() { true } // OK\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-403.dfy", "dafny": "// RUN: %dafny -compile:4 -compileTarget:java \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nnewtype {:nativeType \"byte\"} uint8 = x:int | 0 <= x < 0x100\nnewtype {:nativeType \"int\"} int32 = x:int | -0x8000_0000 <= x < 0x8000_0000\n\nmethod Main() {\n  var u8 : uint8 := 140;\n  var i32 : int32 := u8 as int32;\n  print u8, \" == \", i32, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2307.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  newtype int0 = x: int | true\n  type int1 = x: int0 | true\n\n  const x: int0 := 0;\n  const y: int1 := 0 as int1;\n  // It was once the case that Dafny inferred the type of 0 in the next line as 'int', which is bad.\n  const z: int1 := 0;\n}\n\nmodule B {\n  newtype int0 = int\n  type int1 = x: int0 | true\n\n  const x: int0 := 0;\n  const y: int1 := 0 as int1;\n  // It was once the case that Dafny inferred the type of 0 in the next line as 'int', which is bad.\n  const z: int1 := 0;\n}\n\nmodule C {\n  newtype real0 = x: real | true\n  type real1 = x: real0 | true\n\n  const x: real0 := 0.0;\n  const y: real1 := 0.0 as real1;\n  // It was once the case that Dafny inferred the type of 0.0 in the next line as 'real', which is bad.\n  const z: real1 := 0.0;\n}\n\nmodule D {\n  newtype real0 = real\n  type real1 = x: real0 | true\n\n  const x: real0 := 0.0;\n  const y: real1 := 0.0 as real1;\n  // It was once the case that Dafny inferred the type of 0.0 in the next line as 'real', which is bad.\n  const z: real1 := 0.0;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-446b.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\ndatatype Result<T> = Success(value: T) | Failure(error: string)\n{\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): Result<U>\n    requires Failure?\n  {\n    Failure(this.error)\n  }\n}\n\nmethod mn() returns (r: Result<int>, out: int)\n  ensures out == -2 && r.Failure?\n{\n  var o :- m(1);\n  assert o == 3;\n  print \"OK\\n\";\n  out :- m(-1); // Should exit with failure\n  return Success(0), 4;\n}\n\nmethod mn1() returns (r: Result<int>)\n  ensures r.Failure?\n{\n  :- m1(1);\n  print \"OK\\n\";\n  :- m1(-1); // SHould exit with failure\n  return Success(0);\n}\n\n\nmethod m(i: int) returns (r: Result<int>, o: int)\n  ensures 0 <= i ==> r.Success? && r.value == i && o == i+i+i\n  ensures i < 0 ==> r.Failure? && o == i+i\n{\n  if i < 0 { return Failure(\"negative\"), i+i; }\n  return Success(i), i+i+i;\n}\n\nmethod m1(i: int) returns (r: Result<int>)\n  ensures 0 <= i ==> r.Success? && r.value == i\n  ensures i < 0 ==> r.Failure?\n{\n  if i < 0 { return Failure(\"negative\"); }\n  return Success(i);\n}\n\nmethod mexp() returns (r: Result<int>, k: int)\n  ensures r.IsFailure() && k == 100\n{\n  k :- Result<int>.Failure(\"always\"), 100;\n  k := 101; // Not executed\n  return Success(0), k;\n}\n\nmethod mstar() returns (r: Result<int>, k: int)\n  ensures r.IsFailure()\n{\n  k :- Result<int>.Failure(\"always\"), *;\n  k := 101; // Not executed\n  return Success(0), k;\n}\n\n\nmethod Main() {\n  var x := mn1();\n  print x.Failure?, \" \";\n  var out;\n  x, out := mn();\n  print x.Failure?, \" \", out, \"\\n\";\n  x, out := mexp();\n  print x.Failure?, \" \", out, \"\\n\";\n  print \"End\\n\";\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1564-4.dfy", "dafny": "// RUN: %baredafny verify %args --function-syntax:4 --print:- \"%s\" > \"%t\"\n// RUN: %baredafny verify %args --function-syntax:experimentalDefaultGhost --print:- \"%s\" >> \"%t\"\n// RUN: %baredafny verify %args --function-syntax:experimentalDefaultCompiled --print:- \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function F0(): int\nfunction F1(): int\n\ntwostate function G0(): int\n\nfunction H0(): int {\n  2\n} by method {\n  return 2;\n}\n\nghost predicate P0()\npredicate P1()\n\ntwostate predicate Q0()\n\npredicate R0() {\n  true\n} by method {\n  return true;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-697f.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nghost function ghostPredicate(x: int): bool {\n  x % 2 == 0\n}\n\ndatatype Cell = Cell(x: int)\ntype EvenCell = c: Cell | ghostPredicate(c.x) witness Cell(0)\n\nfunction doubleEvenCell(c: EvenCell): int\n{\n  if c.x % 2 == 1 then 1/0 else c.x * 2\n}\n\n// No need for the subset constraint to be compilable.\nmethod Main() {\n  var a: EvenCell := Cell(2);\n  if doubleEvenCell(a) > 0 {\n    print \"ok\";\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-697.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype Cell = Cell(x: int)\ntype EvenCell = c: Cell | c.x % 2 == 0 witness Cell(0)\n\nfunction doubleEvenCell(c: EvenCell): int\n{\n  if c.x % 2 == 1 then 1/0 else c.x * 2\n}\n\nmethod Main() {\n  var x: set<Cell> := { Cell(1), Cell(2), Cell(3), Cell(4) };\n  var y := set c: EvenCell | c in x;\n  var b := forall c :: c in y ==> doubleEvenCell(c) > 0;\n  assert b;\n  print b;\n}\n\n"}
{"file": "../dafny/Test/git-issues/github-issue-4004.dfy", "dafny": "// RUN: %baredafny verify %args %s > %t\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() returns ()\n{\n  match 8 {\n    case _ => {\n      var v_bool: bool, v_real: real := true, match 15.06 {\n        case _ => 6.58\n      };\n      print v_bool, \" \", v_real, \"\\n\";\n    }\n  }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-1553.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() { }\nmethod Test<R>() {\n  var r: R;\n  var s: seq<R>;\n  var t: array?<R>;\n  var u: array<R>;\n  var v: (R, int);\n}\n\nmethod Test0<R(0)>() {\n  var r: R;\n  var s: seq<R>;\n  var t: array?<R>;\n  var u: array<R>;\n  var v: (R, int);\n}\n\nmethod Test00<R(00)>() {\n  var r: R;\n  var s: seq<R>;\n  var t: array?<R>;\n  var u: array<R>;\n  var v: (R, int);\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-283.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\ndatatype Result<T> =\n  | Success(value: T)\n  | Failure(error: string)\n\ndatatype C = C1 | C2(x: int)\n\ntrait Foo\n{\n  method FooMethod1(r: Result<()>)\n    ensures\n      match r {\n        case Success(()) => true // OK\n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(()) => x := 1;\n      case Failure(e) => x := 2;\n    }\n    assert x > 0;\n    expect x == 1;\n  }\n  method FooMethod2(r: Result<C>)\n    ensures\n      match r {\n        case Success(C1()) => true // OK\n        case Success(C2(x)) => true // OK\n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(C1()) => x := 1;\n      case Success(C2(_)) => x := 2;\n      case Failure(e) => x := 3;\n    }\n    assert x > 0;\n    expect x == 1;\n  }\n  method FooMethod2q(r: Result<C>)\n    ensures\n      match r {\n        case Success(C1()) => true // OK\n        case Success(C2(x)) => true // OK\n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(C1()) => x := 1;\n      case Success(C2(x)) => x := 2;  // x is local variable\n      case Failure(e) => x := 3;\n    }\n    assert x == 0 || x == 1 || x == 3;\n    expect x == 0 || x == 1 || x == 3;\n  }\n  method FooMethod2r(r: Result<C>)\n    ensures\n      match r {\n        case Success(C1()) => true // OK\n        case Success(C2(x)) => true // OK\n        case Failure(e) => true\n      }\n  {\n    var x: real := 0.0;\n    match r {\n      case Success(C1()) => x := 1.0;\n      case Success(C2(x)) => x := 2;  // x is local variable\n      case Failure(e) => x := 3.0;\n    }\n    assert x == 0.0 || x == 1.0 || x == 3.0;\n    expect x == 0.0 || x == 1.0 || x == 3.0;\n  }\n  method FooMethod3(r: Result<C>)\n    ensures\n      match r {\n        case Success(C1) => true // OK\n        case Success(C2(x)) => true // OK\n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(C1) => x := 1;\n      case Success(C2(_)) => x := 2;  // BUG - problem if _ is x\n      case Failure(e) => x := 3;\n    }\n    assert x > 0;\n    expect x == 1;\n  }\n  method FooMethod4(r: Result<C>)\n    ensures\n      match r {\n        case Success(C2) => true // OK -- C2 is a variable\n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(C2) => x := 1;\n      case Failure(e) => x := 2;\n    }\n    assert x > 0;\n    expect x == 1;\n  }\n  method FooMethod5(r: Result<string>)\n    ensures\n      match r {\n        case Success(C1) => true // OK -- C1 is a variable\n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(C1) => x := 1;\n      case Failure(e) => x := 2;\n    }\n    assert x > 0;\n    expect x == 1;\n  }\n}\n\nclass CL extends Foo {}\n\nmethod Main() {\n  var t := new CL;\n  m(t);\n}\n\nmethod m(t: Foo) {\n  t.FooMethod1(Result.Success(()));\n  t.FooMethod2(Result<C>.Success(C1));\n  t.FooMethod2q(Result<C>.Success(C1));\n  t.FooMethod2r(Result<C>.Success(C1));\n  t.FooMethod3(Result<C>.Success(C1));\n  t.FooMethod4(Result<C>.Success(C1));\n  t.FooMethod5(Result<string>.Success(\"\"));\n  print \"Done\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-3658.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This case used to cause duplicate Boogie variable declarations\n// because MatchFlattner was not cloning NestedMatchCaseStmts as it\n// created multiple copies for disjunctive patterns.\n\nmethod mmm() returns (i: int) {\n  match \"abc\"\n    case \"def\"|\"ghi\" => { var st := 0; return st; }\n    case _ => { return 1; }\n}\n\n// Whereas this case produced the same symptom but for a different reason:\n// incorrect cloning of CasePatterns that resulted in not cloning LocalVariable\n// declarations.  \n\ndatatype Choice = A | B | C\n\nmethod Foo(x: Choice) returns (r: bool) {\n  match x {\n    case A => return true;\n    case _ => \n      var (x, y) := (42, 43);\n      return false;\n  }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-549.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ntrait T {\n  function bar(): bv8\n}\n\nclass F extends T {\n  // once upon a time, the following used to crash Dafny\n  function bar(): bv8 {\n    1\n  }\n}\n\nmethod Main() {\n  var f: F := new F;\n  print \"bar() = \", f.bar(), \"\\n\";\n  var t: T := new F;\n  print \"bar() = \", t.bar(), \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1903.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod g<T>(x : seq<T> := []) \n{\n   print \"worked!\\n\";  \n}\n\n\nmethod Main() { \n   g<nat>();\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2813.dfy", "dafny": "// RUN: %dafny /version > %t\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n\n// Just make sure the version string is present and not a default like 0.0.0 or 1.0.0.\n// This will have to be changed with each major version but I can live with that :)\n// CHECK: dafny 4\\..*\n"}
{"file": "../dafny/Test/git-issues/git-issue-907.dfy", "dafny": "// RUN: %dafny /compile:1 /compileTarget:java /spillTargetCode:1  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Checks that the Java runtime library is present\n\nfunction identity(n:nat):nat\n{\n    n\n}\n\n"}
{"file": "../dafny/Test/git-issues/github-issue-3615.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction Foo(x: int := 3): int {\n   x\n}\n\ndatatype Zee = Kwa | Zam\n\nfunction Zaz(x: Zee): int {\n  match x {\n    case Kwa => Foo()\n    case _ => Foo()\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3221.dfy", "dafny": "// RUN: %baredafny test \"%s\" > \"%t\"\n// RUN: %baredafny test --methods-to-test='q' \"%s\" >> \"%t\"\n// RUN: %baredafny test --methods-to-test='m' \"%s\" >> \"%t\"\n// RUN: %baredafny test --methods-to-test='M.*' \"%s\" >> \"%t\"\n// RUN: %baredafny test --methods-to-test='^.$' \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod {:test} m() {\n  print \"Testing m\\n\";\n}\nmethod {:test} q() {\n  print \"Testing q\\n\";\n}\nmethod {:test} pp() {\n  print \"Testing pp\\n\";\n}\n\nmodule M {\n\n  method {:test} m() {\n    print \"Testing M.m\\n\";\n  }\n  method {:test} t() {\n    print \"Testing M.t\\n\";\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-267.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n    var c := 1;\n    print(c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c\n          + c + c + c + c + c + c + c), \"\\n\";\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-2883.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype MyArray = array<int>\ntype MyMatrix = m: array2<int> | m.Length0 == m.Length1 witness *\n\nclass State\n{  \n  var arr: MyArray\n  var m: MyMatrix\n  var count: nat\n\n  constructor () {\n    arr, m := new int[100], new int[100, 100];\n  }\n\n  method Process(i: nat)\n    requires i < arr.Length < m.Length0\n    modifies this, arr, m\n  {\n    // two of the LHSs in the following assignment once caused the translator to crash\n    arr[i], m[i, i], count := 0, 0, 0;\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2108.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M0.M1.Base {}\n\nmodule M0.M2 {\n  import M1.Base\n\n  module Derived refines Base {\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-4048.dfy", "dafny": "// RUN: %exits-with 1 %baredafny build -t:lib --use-basename-for-filename \"%s\" x.doo > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Tests case in which an input .doo file does not exist\nconst c := 5\n\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-701.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  var ca := new ClassA;\n  print ca.y, \" \", ca.k, \" \", ca.l, \"\\n\";\n  var cb := new ClassB;\n  print cb.y[..], \" \", cb.k[..], \" \", cb.l[..], \"\\n\";\n  var cc := new ClassC;\n  print cc.y, \" \", cc.k, \" \", cc.l, \"\\n\";\n}\n\ntrait Trait<Y> {\n  const y: Y\n  const k: Y := y\n  const l: Y\n}\n\ndatatype C<T> = Atom(T) | Nothing\n\nclass ClassA extends Trait<bv8> { }\nclass ClassB extends Trait<array<bv8>> { }\nclass ClassC extends Trait<C<bv8>> { }\n"}
{"file": "../dafny/Test/git-issues/git-issue-Main.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  module AA {\n    method Main() {}\n  }\n}\n\nmodule B {\n  class C {\n    static method Main() {}\n  }\n}\n\nmethod Main() {}\n"}
{"file": "../dafny/Test/git-issues/git-issue-4141.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\nmethod Test<X(==)>(a: X, b: X) {\n    print a == b, \"\\n\";\n}\n\nmethod Main()\n{\n  var a := new bool[1];\n  var ars := [a];\n  a := new bool[1];\n  var ars' := [a];\n  Test(ars, ars');\n  ars[0][0] := true;\n  Test(ars, ars');\n  ars'[0][0] := true;\n  Test(ars, ars');\n  Test([ars[0]], [ars[0]]);\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1029.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmodule ValueType {\n  export S\n    provides Value, Gimmie\n\n  type Value = s: seq<bool> | |s| <= 10\n\n  function Gimmie(): Value {\n    [true, true, false]\n  }\n}\n\nmodule UI {\n  import ValueType`S\n\n  datatype Op = GetOp(value: ValueType.Value)\n  datatype Op2 = GetOps(v: ValueType.Value, v': ValueType.Value)\n}\n\nimport V = ValueType`S\n\nmethod Main() {\n  var op := UI.GetOp(V.Gimmie());\n  var op2 := UI.GetOps(V.Gimmie(), V.Gimmie());\n  print op, \" \", op2, \"\\n\"; // [true, true, false] Op2([true, true, false], [true, true, false])\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-Main1.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmodule A {\n  module AA {\n    method Main() { print \"Main1\\n\"; }\n  }\n}\n\nmodule B {\n  class C {\n    static method {:main} Main() { print \"Main2\\n\"; }\n  }\n}\n\nmethod Main() { print \"Main3\\n\"; }\n"}
{"file": "../dafny/Test/git-issues/git-issue-731b.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\n// Testing issue#731 when the class in question has type parameters\n\ntrait Tr2<W, Y> {\n  const w: W\n  const y: Y\n}\n\nclass ClassA<Q> extends Tr2<Q, array<bv8>> {\n  constructor (q: Q) { w := q; }\n}\n\nmethod Main() {\n  var a := new int[42];\n  var ca := new ClassA<array<int>>(a);\n  print ca.y.Length, \" \", ca.w.Length, \"\\n\";\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1211.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction apply<T,U>(op: T --> U): ()\n{\n  ()\n}\n\ndatatype D = O | LD(c: D, thunk: () -> D)\n{\n  \n  function e(d: D): ()\n  {\n      apply((x: D) requires x.LD? => x.(c := d))\n  }\n}\n\n\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-4056.dfy", "dafny": "// RUN: %baredafny verify %args %s > %t\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntrait ADT {\n  ghost function ReprFamily(n: nat): set<object>\n    decreases n\n    ensures n > 0 ==> ReprFamily(n) >= ReprFamily(n-1)\n    reads this, if n == 0 then {} else ReprFamily(n-1)\n}\n\nclass P extends ADT {\n  ghost function ReprFamily(n: nat): set<object>\n    decreases n\n    ensures n > 0 ==> ReprFamily(n) >= ReprFamily(n-1)\n    reads this, if n == 0 then {} else ReprFamily(n-1)\n  { {} }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1231.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Dt = Dt(x:int)\n{\n  method {:timeLimitMultiplier 5} DatatypeTest(y:int) {\n    var z := y;\n    assert z == y;\n  }\n}\n\nnewtype Even = x : int | x % 2 == 0\n{\n  method {:timeLimitMultiplier 4} NewtypeTest(y:int) {\n    assert y == y;\n  }\n}\n\ncodatatype Stream<T> = More(head: T, rest: Stream) \n{\n  method {:timeLimitMultiplier 3} CodatatypeTest(y:int) {\n    assert y == y;\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1143.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Nat = Zero | Succ(pred: Nat)\n{\n  function MemberToInt(): int {\n    match this\n    case Zero => 0\n    case Succ(p) => 1 + p.MemberToInt()\n  }\n}\n\nfunction ExternalToInt(n: Nat): int {\n  match n\n  case Zero => 0\n  case Succ(p) => 1 + ExternalToInt(p)\n}\n\nfunction Prefix(n: Nat, len: nat): Nat\n  requires len <= n.MemberToInt() && len <= ExternalToInt(n)\n  ensures ExternalToInt(Prefix(n, len)) == len  // this line verifies\n  ensures Prefix(n, len).MemberToInt() == len  // this once failed to verify\n{\n  if len == 0 then Zero else Succ(Prefix(n.pred, len - 1))\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3549b.dfy", "dafny": "// RUN: %exits-with 1 %baredafny resolve \"\" 2> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/git-issues/BoundedInts.dfy", "dafny": "// RUN: %diff \"%s\" \"%s\"\nmodule {:options \"-functionSyntax:4\"} BoundedInts {\n  const TWO_TO_THE_0:   int := 1\n\n  const TWO_TO_THE_1:   int := 2\n  const TWO_TO_THE_2:   int := 4\n  const TWO_TO_THE_4:   int := 16\n  const TWO_TO_THE_5:   int := 32\n  const TWO_TO_THE_8:   int := 0x100\n  const TWO_TO_THE_16:  int := 0x10000\n  const TWO_TO_THE_24:  int := 0x1000000\n  const TWO_TO_THE_32:  int := 0x1_00000000\n  const TWO_TO_THE_40:  int := 0x100_00000000\n  const TWO_TO_THE_48:  int := 0x10000_00000000\n  const TWO_TO_THE_56:  int := 0x1000000_00000000\n  const TWO_TO_THE_64:  int := 0x1_00000000_00000000\n  const TWO_TO_THE_128: int := 0x1_00000000_00000000_00000000_00000000\n  const TWO_TO_THE_256: int := 0x1_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000\n  const TWO_TO_THE_512: int :=\n    0x1_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000\n\n  newtype uint8 = x: int  | 0 <= x < TWO_TO_THE_8\n  newtype uint16 = x: int | 0 <= x < TWO_TO_THE_16\n  newtype uint32 = x: int | 0 <= x < TWO_TO_THE_32\n  newtype uint64 = x: int | 0 <= x < TWO_TO_THE_64\n\n  newtype int8 = x: int   | -0x80 <= x < 0x80\n  newtype int16 = x: int  | -0x8000 <= x < 0x8000\n  newtype int32 = x: int  | -0x8000_0000 <= x < 0x8000_0000\n  newtype int64 = x: int  | -0x8000_0000_0000_0000 <= x < 0x8000_0000_0000_0000\n\n  newtype nat8 = x: int   | 0 <= x < 0x80\n  newtype nat16 = x: int  | 0 <= x < 0x8000\n  newtype nat32 = x: int  | 0 <= x < 0x8000_0000\n  newtype nat64 = x: int  | 0 <= x < 0x8000_0000_0000_0000\n\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-4233.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nnewtype MyReal = real\n\nmethod Main() {\n  var x: MyReal := 12.0 / 10.0;\n  print x, \"\\n\"; // expect 1.2\n\n  if x == 1.0 {\n    assert false;\n    print \"unreachable\\n\";\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1158.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype Id(==)\n\nghost function F(s: set<Id>): int\n\nlemma Test(x: Id)\n{\n  var X := {x};\n  var a := map i | i <= X :: F(i);\n  var b := map[{} := F({}), X := F(X)];\n\n  assert a.Keys == b.Keys by {  // spurious error reported here\n    forall i\n      ensures i in a.Keys <==> i in b.Keys\n    {\n      calc {\n        i in a.Keys;\n      ==\n        i <= X;\n      ==  { assert i <= X <==> i == {} || i == X; }\n        i in b.Keys;\n      }\n    }\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-305-a.dfy", "dafny": "// NONUNIFORM: Testing exit codes, not compilation\n// RUN: %baredafny translate cs --cores:2 --use-basename-for-filename --verification-time-limit:300 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n    print \"hello\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3513/src/sub/B.dfy", "dafny": "// RUN: %baredafny resolve \"%s\"\n\nmodule B {\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-4000.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Gas {\n    const STATICCALL : nat := 0xfa\n\n    function f(op: nat, s: int): int\n    {\n        match op\n            case STATICCALL => 0\n            case _ => s\n    }\n\n    lemma MatchIsCorrect() {\n      assert f(0, 2) == 2;\n    }\n}"}
{"file": "../dafny/Test/git-issues/github-issue-3797.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nnewtype uint16 = x | 0 <= x < 0x1_0000\ndatatype D = A | B\n\nmethod M(x: D, u: uint16) returns (r: uint16) {\n  var v := 5;\n  match x {\n    case A => r := 12;\n    case B => r := 13;\n  }\n  r := v;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3839/git-issue-3839c.dfy", "dafny": "// RUN: ! %baredafny test --use-basename-for-filename \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod {:test} M() returns (r: int)\n{\n    expect 0 != 0, \"Expected equality\";\n    return 0;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3839/git-issue-3839d.dfy", "dafny": "// RUN: %baredafny test --use-basename-for-filename \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod {:test} M() returns (r: int)\n{\n    return 0;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3839/git-issue-3839b.dfy", "dafny": "// RUN: ! %baredafny test --use-basename-for-filename \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod {:test} M() returns (r: int)\n{\n    expect 0 != 0;\n    return 0;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3839/git-issue-3839a.dfy", "dafny": "// RUN: ! %baredafny test --use-basename-for-filename --show-snippets:false \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod {:test} M(x: int) returns (r: int)\n{\n    expect x != x;\n    return x;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-032.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n\nmethod Main() {\n  m();\n  mm();\n}\n\nmethod m() {\n  var x := (2,3);\n  match x { case (2,y) => print \"OK\",y; case _ => print \"DEF\"; }\n  print \"\\n\";\n  match x { case zz => print \"OK\"; case _ => print \"DEF\"; } // warning\n  print \"\\n\";\n}\n\nmethod mm() {\n  var x := ();\n  match x { case () => print \"OK\"; }\n  match () { case () => print \"OK\"; }\n  print \"\\n\";\n  var z := match x { case () => 0 case _ => 1 }; // warning\n  var y := match () { case () => 0 case _ => 1 }; // warning\n  print z, y, \"\\n\";\n}\n\n\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-274.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule P {\n  type M\n}\n\nmodule N2 {\n  import opened M = P\n  trait T {\n      var m: M.M\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-684.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype Level1 = Level1(u:int)\ndatatype Level2 = Level2(u:int, l:Level1)\n\nmethod TestNestedLet() {\n  var x := Level2(5, Level1(3));\n\n  var Level2(u, Level1(v)) := x;\n}\n\nmethod Main() {}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-Main0.dfy", "dafny": "// NONUNIFORM: Multiple test scenarios (could be split)\n// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs /Main:A.B.Main \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js /Main:A.B.Main \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go /Main:A.B.Main \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js /Main:A.B.Main \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs /Main:A.C.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js /Main:A.C.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go /Main:A.C.Test \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:java /Main:A.C.Test \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  class B {\n    method Main() { print \"Main\\n\"; }\n  }\n  class C {\n    method Test() { print \"Test\\n\"; }\n  }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-Main2.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  module AA {\n    method {:main} Main() {}\n  }\n}\n\nmodule B {\n  class C {\n    static method {:main} Main() {}\n  }\n}\n\nmethod Main() {}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3549a.dfy", "dafny": "// RUN: %exits-with 1 %baredafny \"\" 2> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/git-issues/git-issue-446.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\ndatatype Result<T> = Success(value: T) | Failure(error: string)\n{\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): Result<U>\n    requires Failure?\n  {\n    Failure(this.error)\n  }\n  function Extract(): T\n    requires Success?\n  {\n    value\n  }\n}\n\nmethod mn() returns (r: Result<int>, out: int)\n  ensures r.Failure? && out == -2\n{\n  var t, k :- m(1);\n  assert t == 1 && k == 2;\n  var rr;\n  rr, out :- m(-1); // Should exit with failure\n  return Success(k), out;\n}\n\nmethod mn1() returns (r: Result<int>, out: int)\n  ensures r.Failure? && out == 42\n{\n  out := 42;\n  var k :- m1(1);\n  assert k == 1;\n  out :- m1(-1); // Should exit with failure\n  return Success(k), out;\n}\n\n\nmethod m(i: int) returns (r: Result<int>, o: int)\n  ensures 0 <= i ==> r.Success? && r.Extract() == i && o == i+i\n  ensures i < 0 ==> r.Failure? && o == i+i\n{\n  if i < 0 { return Failure(\"negative\"), i+i; }\n  return Success(i), i+i;\n}\n\nmethod m1(i: int) returns (r: Result<int>)\n  ensures 0 <= i ==> r.Success? && r.Extract() == i\n  ensures i < 0 ==> r.Failure?\n{\n  if i < 0 { return Failure(\"negative\"); }\n  return Success(i);\n}\n\nmethod Main() {\n  var x, out := mn();\n  print x.Failure?, \" \", out, \"\\n\";\n  x, out := mn1();\n  print x.Failure?, \" \", out, \"\\n\";\n  print \"End\\n\";\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-897b.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function F(): int {\n  var p := x => true;\n  assert true by {\n    forall y: int | p(y) {}\n  }\n  5\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-590.dfy", "dafny": "// dafny should emit exit value 1\n// RUN: ! %dafny /compile:3 x.cs > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/git-issues/git-issue-4449.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\nmodule AnyName {\n  class B {\n    const i := 1\n\n    constructor() {}\n  }\n\n  class AnyName {\n    const j: B\n\n    constructor ()\n    {\n      this.j := new B();\n    }\n  }\n}\n\nmethod Main() {\n  var b := new AnyName.B();\n  var an := new AnyName.AnyName();\n  print b, \"\\n\", an, \"\\ndone\", \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2733.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --unicode-char:false\n\nmethod Main() {\n  print \"XYZ\"; // Checks that no extra newline is added to the output\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1607.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmodule M {\n  datatype D = D_1(a: bool) | D_2(b: bool)\n\n  method DoIt (d: D)\n  {\n    if (d.D_1?) {\n      print \"1 \", d.a;\n    }\n    else {\n      print \"2 \", d.b;\n    }\n  }\n}\n\nmethod Main(){\n  var x : M.D := M.D_2(true);\n  M.DoIt(x);\n  print \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-032a.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod m() {\n  var x := ();\n  match x { case () => print \"OK\"; case _ => print \"DEF\"; }\n  print \"\\n\";\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-3358.dfy", "dafny": "// RUN: %exits-with 2 %baredafny verify %args --warn-as-errors \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype MyResult = Ok | Err(error: set<string>)\nfunction warningTriggerTest(sr: seq<MyResult>): set<string> {\n  set i, err | 0 <= i < |sr| && err in (if sr[i].Err? then sr[i].error else {}) :: err\n}"}
{"file": "../dafny/Test/git-issues/git-issue-755.dfy", "dafny": "// NONUNIFORM: https://github.com/dafny-lang/dafny/issues/4108\n// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  var s := { 1,9,3,7,5};\n  m(s);\n  mp(map[ 1:= 3, 3:= 5]);\n}\n\n\nmethod m(s: set<int>) {\n  var ss := s;\n  while ss != {}\n    decreases |ss|\n  {\n    var i: int :| i in ss;\n    ss := ss - {i};\n    print i, \"\\n\";\n  }\n}\n\nmethod mp(m: map<int,int>)\n{\n  var items := m.Items;\n  while items != {}\n    decreases |items|\n  {\n    var item :| item in items;\n    items := items - { item };\n    print item.0, \" \", item.1, \"\\n\";\n  }\n}\n\nmethod mpi(m: imap<int,int>)\n{\n  var items: iset<(int,int)> := m.Items;\n  var keys: iset<int> := m.Keys;\n  var vals: iset<int> := m.Values;\n}\n\nmethod mseq(s: seq<int>) {\n  var i: int := 0;\n  var sum: int := 0;\n  while i < |s|\n    decreases |s| - i\n  {\n    sum := sum + s[i];\n    i := i + 1;\n  }\n}\n\nmethod marr(s: array<int>) {\n  var i: int := 0;\n  var sum: int := 0;\n  while i < s.Length\n    decreases s.Length - i\n  {\n    sum := sum + s[i];\n    i := i + 1;\n  }\n\n  var rev := new int[s.Length];\n  forall i | 0 <= i < s.Length {\n    rev[i] := s[s.Length-i-1];\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2013.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\n\nmethod Main() {\n  TestTraits();\n  TestSiblings();\n  TestException();\n  MoreTests.Test();\n  Conveyance.Test();\n  Regression.Test();\n}\n\n// ----- reference types -----\n\ndatatype Dt<+U> = Dt(u: U)\n\ntrait Tr {\n  var y: int\n}\n\nclass Cl extends Tr {\n  constructor () {\n    y := 15;\n  }\n}\n\nmethod Print(e: Dt<Cl>) {\n  print e.u.y, \"\\n\";\n}\n\nmethod CreateDtForTrait(e: Dt<Cl>) returns (d: Dt<Tr>)\n  ensures d.u == e.u\n{\n  d := e; // upcast\n}\n\nmethod TestTraits() {\n  var cl := new Cl();\n  var e: Dt<Cl> := Dt(cl);\n  var d: Dt<Tr> := CreateDtForTrait(e);\n  cl.y := cl.y + 1;\n  var f: Dt<Cl> := d; // downcast\n\n  Print(f); // 16\n  Print(e); // 16\n}\n\n// ----- sibling types -----\n\ntype Even = x | x % 2 == 0\n\nmethod TestSiblings() {\n  // downcasts\n  var a: Dt<int> := Dt(10);\n  var b: Dt<nat> := a;\n  var c: Dt<Even> := a;\n\n  // upcasts\n  b := Dt(11);\n  c := Dt(12);\n  a := b;\n  a := c;\n\n  // sideway casts\n  b := Dt(20);\n  c := b;\n  c := Dt(30);\n  b := c;\n\n  print a, \" \", b, \" \", c, \"\\n\"; // Dt.Dt(12) Dt.Dt(30) Dt.Dt(30)\n}\n\n// ----- Result -----\n\ndatatype Result<+T, +R> = | Success(value: T) | Failure(error: R)\n\ntrait Exception {}\n\nclass MyClassException extends Exception { }\n\nclass MyClass {\n  const error: Exception\n\n  constructor () {\n    error := new MyClassException;\n  }\n\n  function Foo(u: int): Result<int, Exception> {\n    if u < 8 then\n      Success(8)\n    else\n      Failure(error)\n  }\n}\n\nmethod TestException() {\n  var c := new MyClass();\n  print c.Foo(2), \" \", c.Foo(22), \"\\n\"; // Result.Success(8) Result.Failure(_module.MyClassException)\n}\n\nmodule MoreTests {\n  type Even = x | x % 2 == 0\n\n  datatype Dt<T> = Make(T)\n  datatype DtCovariant<+T> = MakeCovariant(T)\n\n  trait Z { }\n  trait X extends Z { }\n  trait Y extends Z { }\n  class C extends X, Y { }\n\n  method Test() {\n    var c := new C;\n\n    var s: set<int> := {100};\n    var t: set<nat> := s;\n    var u: set<Even> := s;\n    t := u;\n    u := t;\n    s := u;\n    s := t;\n    print s, \" \", t, \" \", u, \"\\n\"; // {100} {100} {100}\n\n    var S: set<Z> := {c};\n    var T: set<X> := S;\n    var U: set<Y> := S;\n    T := U;\n    U := T;\n    S := U;\n    S := T;\n    print S, \" \", T, \" \", U, \"\\n\"; // {_module.C} {_module.C} {_module.C}\n\n    // The assignments in the following example don't need covariance of Dt, because\n    // Dafny checks that the value with its payload is suitable for the target type.\n    var k: Dt<int> := Make(100);\n    var m: Dt<nat> := k;\n    var n: Dt<Even> := k;\n    m := n;\n    n := m;\n    k := m;\n    k := n;\n    print k, \" \", m, \" \", n, \"\\n\"; // Dt.Make(100) Dt.Make(100) Dt.Make(100)\n\n    var K: DtCovariant<Z> := MakeCovariant(c);\n    var M: DtCovariant<X> := K;\n    var N: DtCovariant<Y> := K;\n    M := var u: DtCovariant<Z> := N; u; // like M := N, but allowed by Dafny's type system\n    N := var u: DtCovariant<Z> := M; u; // like N := M, but allowed by Dafny's type system\n    print K, \" \", M, \" \", N, \"\\n\"; // DtCovariant.MakeCovariant(_module.C) DtCovariant.MakeCovariant(_module.C) DtCovariant.MakeCovariant(_module.C)\n  }\n}\n\n// ----- Vehicle -----\n\nmodule Conveyance {\n  trait Vehicle {\n  }\n  class Car extends Vehicle {\n    constructor() {}\n  }\n\n  trait Error {\n  }\n  class FlatTireError extends Error {\n    constructor() {}\n  }\n\n  datatype NonVariantResult<T, E> = NVSuccess(value: T) | NVFailure(error: E)\n  datatype CovariantResult<+T, +E> = CVSuccess(value: T) | CVFailure(error: E)\n\n  method Test() {\n    var myCar: Car := new Car();\n    var error: Error := new FlatTireError();\n\n    var cvSuccess: CovariantResult<Vehicle, Error> := CVSuccess(myCar);\n    var cvFailure: CovariantResult<Vehicle, Error> := CVFailure(error);\n\n    var nvSuccess: NonVariantResult<Vehicle, Error> := NVSuccess(myCar);\n    var nvFailure: NonVariantResult<Vehicle, Error> := NVFailure(error);\n\n    // This was and remains just fine\n    var nvCarSuccess: NonVariantResult<Car, Error> := NVSuccess(myCar);\n    // The following would not be type correct for the non-variant NonVariantResult:\n    //     var nvVehicleSuccess: NonVariantResult<Vehicle, Error> := nvCarSuccess; // RHS (...) not assignable to LHS (...)\n\n    // Once, the following was not support for the Java target, but now it is\n    var cvCarSuccess: CovariantResult<Car, Error> := CVSuccess(myCar);\n    var cvVehicleSuccess: CovariantResult<Vehicle, Error> := cvCarSuccess;\n\n    print nvCarSuccess, \" \", cvCarSuccess, \"\\n\"; // NonVariantResult.NVSuccess(_module.Car) CovariantResult.CVSuccess(_module.Car)\n  }\n}\n\n// ----- Regression test -----\n\nmodule Regression {\n  module M {\n    // A previous bug was that the following declaration was not exported correctly (in several compilers).\n    codatatype Stream<T> = Next(shead: T, stail: Stream)\n  }\n\n  function CoUp(n: int, b: bool): M.Stream<int>\n  {\n    if b then\n      CoUp(n, false)  // recursive, not co-recursive, call\n    else\n      M.Next(n, CoUp(n+1, true))  // CoUp is co-recursive call\n  }\n\n  method Test(){\n    print CoUp(0, false), \"\\n\";\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3377.dfy", "dafny": "// RUN: %exits-with 2 %baredafny test --show-snippets:false --use-basename-for-filename \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod {:extern} {:test} m(i: int, ghost j: int) \n  requires j == 1\n"}
{"file": "../dafny/Test/git-issues/git-issue-1185.dfy", "dafny": "// NONUNIFORM: https://github.com/dafny-lang/dafny/issues/4108\n// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\npredicate P(s: set)\n  requires s != {}\n{\n  // In the following line, the let-such-that is compiled by TrExprOpt\n  var e :| e in s;\n  e == e\n}\n\nfunction F(s: set): int\n  requires s != {}\n{\n  var p :=\n    // In the following line, the let-such-that is compiled by TrExpr\n    var e :| e in s;\n    e == e;\n  if p then 6 else 8\n}\n\nmethod Main() {\n  var s := {12, 20};\n  var b := P(s);\n  var x := F(s);\n  print s, \" \", b, \" \", x, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3411.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Test(f: int -> int) {\n  assert seq(1, x => f(x))[0] == f(0);  // No problem\n  assert seq(1, f)[0] == f(0);  // No problem anymore\n}"}
{"file": "../dafny/Test/git-issues/git-issue-950.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" \"%s\" > \"%t\"\n// RUN: %dafny /compile:0 \"%s\" %S/git-issue-950.dfy >> \"%t\"\n// RUN: %dafny /compile:0 \"%s\" %S/../git-issues/git-issue-950.dfy >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n\n  const x: int := 5\n  method m() {\n    assert x == 5;\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1564-eag.dfy", "dafny": "// RUN: %baredafny verify %args --function-syntax:experimentalPredicateAlwaysGhost --print:- \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function F0(): int\nfunction F1(): int\n\ntwostate function G0(): int\n\nfunction H0(): int {\n  2\n} by method {\n  return 2;\n}\n\npredicate P1()\n\ntwostate predicate Q0()\n\npredicate R0() {\n  true\n} by method {\n  return true;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2016.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n  datatype D = D() {\n    static function f(): (res: int) {\n      5\n    } by method {\n      return 5;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-396.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype Foo = Bar(value: int)\n\nmethod GetValue(f: Foo) returns (i: int) {\n  match f\n  case Bar(Bar) =>\n    return 72 + Bar;\n}\n\nmethod Main() {\n  var x: int := 0;\n  var f: Foo := Bar(42);\n  x := GetValue(f);\n  print x, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-698.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ntype Small = x: int | 0 <= x < 100 && x != 3\n\nfunction F(x: int): int\n  requires x != 3\n{\n  if x == 3 then 1/0 else 100\n}\n\nmethod Main() {\n  var b := forall n: Small :: F(n) == 100;\n  assert b;\n  print b, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1184.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype IntMap = map<int, int>\n\nghost function RemoveElement(m: IntMap, x: int): IntMap\n{\n  // The following operation once got resolved as set difference instead\n  // of map domain subtraction, because the resolver didn't expand the\n  // IntMap type synonym before checking if the type was a map.\n  m - {x}\n}\n\nghost function RemoveElement'(m: map<int, int>, x: int): map<int, int>\n{\n  // This operation always worked (and continues to work)\n  m - {x}\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-289b.dfy", "dafny": "// RUN: echo \"\"\n// This is just an auxiliary file, with no tests by itself\n\nabstract module Foo {\n  type Value\n\n  datatype Message =\n    | M(value: Value)\n\n  lemma someLemma(a: Message, b: Message, c: Message)\n  {\n    match (a, b, c) {\n      case (M(x), M(y), M(z)) => { }\n    }\n  }\n}\n\nmodule ByteDefinition {\n  newtype byte = i:int | 0 <= i < 0x100\n  type Byte = byte\n}\n\nmodule ConcreteFoo refines Foo {\n  import ByteDefinition\n\n  type Value = ByteDefinition.Byte\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-3343.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\nmethod Bug() {\n    var zero := 0;\n    var a := new int[zero] [];\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-364.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype NatOutcome =\n| Success(value: nat)\n| Failure(error: string)\n{\n  predicate IsFailure() {\n    this.Failure?\n  }\n  // translation of \"this\" in well-formedness check here previously crashed\n  function PropagateFailure(): NatOutcome\n    requires IsFailure()\n  {\n    this\n  }\n  function Extract(): nat\n    requires !IsFailure()\n  {\n    this.value\n  }\n  function P(): nat\n    ensures this.P() < 20  // translation of \"this\" here previously crashed\n  {\n    if Success? then 12 else 14\n  }\n  function R(): nat\n  {\n    var x :| 0 <= x < this.P() + 1 && x < 1;  // translation of \"this\" here previously crashed\n    x\n  }\n}\n\nmethod Main() {\n  var n := Success(55);\n  assert !n.IsFailure();\n  var v := n.Extract();\n  print n, \" \", n.IsFailure(), \" \", v, \"\\n\";  // Success(55) false 55\n  print n.P(), \" \", n.R(), \"\\n\";  // 12 0\n\n  n := Failure(\"it could be worse\");\n  assert n.IsFailure();\n  var p := n.PropagateFailure();\n  print n, \" \", n.IsFailure(), \" \", p, \"\\n\";  // Failure(...) true Failure(...)\n  print n.P(), \" \", n.R(), \"\\n\";  // 14 0\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1105.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\n// Regression: A constructor like PushOp with 1+ ghost parameters and 0 non-ghost parameters\n// once caused the Java compiler to emit two 0-parameter constructors\n\ndatatype Op =\n  | NoOp\n  | PushOp(ghost id: int)\n\nmethod Main() {\n  var o := PushOp(20);\n  print o, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-856.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main()\n{\n  var big := 9223372036854775808;\n  var a := new int[big];\n  assert a.Length == big;\n  print a.Length == big;\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-321a.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype lowercase = ch | 'a' <= ch <= 'z' witness 'd'\n\nmethod InitTests() {\n  var aa := new lowercase[3];\n  var s := \"hello\";\n  aa := new lowercase[|s|](i requires 0 <= i < |s| => s[i]);\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-3370.dfy", "dafny": "// RUN: %baredafny build --use-basename-for-filename --show-snippets:false \"%s\" > \"%t\"\n// RUN: %exits-with 4 %baredafny build --use-basename-for-filename --show-snippets:false --enforce-determinism \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod m() {\n  var a: array<int>;\n  a := new int[10];\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1587.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Foo = Foo(Keys: (), Values: (), Items: (), IsLimit: (), IsSucc: (), Offset: (), IsNat: ())\n"}
{"file": "../dafny/Test/git-issues/git-issue-283f.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\ndatatype D = Nil | MM | D(x: int, tail: D)\n\nmethod M1() {\n\nvar D(a,b) := D(1, D(2, Nil)); //OK\nassert a == 1;\nassert b == D(2,Nil);\nexpect a == 1;\nexpect b == D(2,Nil);\n\n}\n\nmethod M4() {\n\nvar D(c, Nil) := D(1, Nil); // OK\nassert c == 1;\nassert Nil == Nil();\nexpect c == 1;\nexpect Nil == Nil();\n\n}\n\nmethod M6() {\n\nvar D(a,D(b,Nil)) := D(1, D(2, Nil)); //OK\nassert a == 1;\nassert b == 2;\nexpect a == 1;\nexpect b == 2;\n\n}\n\nmethod Main() {\n  M1();\n  M4();\n  M6();\n  print \"Done\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2510.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n/// Check that the compiler accepts `:- assume {:axiom} …`.\n\ndatatype Result<+T> = | Success(value: T) | Failure {\n  predicate IsFailure() { Failure? }\n  function PropagateFailure<U>(): Result<U> requires Failure? { Failure() }\n  function Extract(): T requires Success? { value }\n}\n\nmethod Main() {\n  var x: int :- assume {:axiom} Success(1);\n  print x;\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-532.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\npredicate SuppressNoTriggerWarning<X>(x: X) { true }\n\ntrait Tr {\n  var x: int\n}\n\nclass C extends Tr {\n  var y: int\n}\n\nclass D extends Tr {\n  var z: int\n}\n\nmethod M(t: Tr)\n  modifies t\n{\n  print \"t.x=\", t.x, \"  \";\n  var s: set<C> := set c: C | c == t && SuppressNoTriggerWarning(c);  // this line used to crash for the call M(d)\n  if s == {} {\n    print \"The given Tr is not a C\\n\";\n  } else {\n    var c :| c in s;\n    print \"The given Tr is a C, and c.y=\", c.y, \"\\n\";\n    c.y := c.y + 10;\n  }\n}\n\nmethod Main() {\n  var c := new C;\n  var d := new D;\n  c.x, c.y := 5, 6;\n  d.x, d.z := 100, 102;\n\n  M(c);\n  M(d);\n  M(c);\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1604b.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --error-limit:0 --relax-definite-assignment\n\n// Double constraints. Will this still work?\n\ndatatype Cell = Cell(x: int)\n\n// Compilable constraint\ntype CompilableNaturalCell = cn: Cell | cn.x >= 0 witness Cell(0)\n\n// Compilable constraint\ntype CompilableOrdinalCell = coc: CompilableNaturalCell | coc.x != 0 witness Cell(1)\n\npredicate compiledOrdinalCellIsOneOrMore(c: CompilableOrdinalCell)\n{\n  (if c.x <= 0 then 1/0 else c.x) > 1\n}\n\nfunction returnsOneIfCompilableOrdinalCell(c: CompilableOrdinalCell): int\n{\n  if c.x <= 0 then 1/0 else 1\n}\n\nfunction {:opaque} getOriginalSet(): set<Cell> {\n  { Cell(-1), Cell(0), Cell(1), Cell(2) }\n}\n\npredicate isSetOfCompilableOrdinalCells(s: set<CompilableOrdinalCell>) {\n  forall c :: c in s ==> returnsOneIfCompilableOrdinalCell(c) == 1\n}\n\nmethod Main() {\n  var x: set<Cell> := getOriginalSet();\n  var b := true;\n  b := b && isSetOfCompilableOrdinalCells(set co: CompilableOrdinalCell | co in x && compiledOrdinalCellIsOneOrMore(co) :: co);\n  assert b;\n  print if b then \"ok\" else \"error\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1639.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Foo {\n    ghost function Fun(): () {\n        calc { 0; }\n        ()\n    }\n}\n\nabstract module Bar {\n    import Foo' : Foo\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1250.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file contains the automatic proofs of two nice properties about Fibonacci-like numbers.\n// The theorems were inspired by singingbanana's video https://www.youtube.com/watch?v=CWhcUea5GNc.\n//\n// The attempt to prove them discovered issue 1250, for which this file contains regression tests.\n// In particular, the proof obligations marked with a (*) below did not verify before the issue-1250 fix.\n\nconst A: int\nconst B: int\n\nghost function Fib(n: nat): int {\n  if n == 0 then A\n  else if n == 1 then B\n  else Fib(n - 2) + Fib(n - 1)\n}\n\n// Sum f(i) for i from 0 through n (inclusive)\nghost function Sum(n: nat, f: nat -> int): int {\n  f(n) + if n == 0 then 0 else Sum(n - 1, f)\n}\n\nlemma Eleven()\n  ensures Sum(9, Fib) == 11 * Fib(6)\n{\n}\n\nlemma FibSum(n: nat)\n  ensures Sum(n, Fib) == Fib(n + 2) - Fib(1) // (*)\n{\n}\n\nlemma {:induction false} FibSumManual(n: nat)\n  ensures Sum(n, Fib) == Fib(n + 2) - Fib(1) // (*)\n{\n  if n == 0 {\n  } else {\n    calc {\n      Sum(n, Fib);\n    ==  // def. Sum\n      Fib(n) + Sum(n - 1, Fib);\n    ==  { FibSumManual(n - 1); }\n      Fib(n) + Fib(n - 1 + 2) - Fib(1);\n    ==\n      Fib(n) + Fib(n + 1) - Fib(1);\n    ==  // def. Fib\n      Fib(n + 2) - Fib(1);\n    }\n    assert Sum(n, Fib) == Fib(n + 2) - Fib(1); // (*)\n    assert Sum(n, Fib) == Fib(n + 2) - Fib(1); // (*)\n\n    assert Sum(n, Fib) == Sum(n, Fib);\n  }\n  assert Sum(n, Fib) == Fib(n + 2) - Fib(1); // (*)\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2593.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate P(x: int)\n\nlemma L()\n  ensures forall y :: P(old(y))\n"}
{"file": "../dafny/Test/git-issues/git-issue-2103.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\ndatatype DT_<+A> = DT(ret: A)\ntype DT<A> = r: DT_<A> | true witness *\n\nmethod Main() {\n  var d := DT(3);\n  print d, \"\\n\"; // 3\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-374.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nclass C {\n  constructor(ghost x: int)\n  {\n  }\n}\n\nghost function f() : int { 0 }\n\nmethod Main() {\n  var c := new C(f());\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-478-good.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// By first defining import LibA and then defining a module LibA,\n// the latter used to generate:\n//     duplicate module name: LibA\n// This now works, and the effect is to imported LibA opened and\n// not introduce another local name for it.\nimport opened LibA\nmodule LibA {\n  method Hello() {\n    print \"hello\\n\";\n  }\n}\n\n// By first defining module LibB and then defining import LibB,\n// the latter used to generate:\n//     can't import module LibB when not inside of a module\n// This now works, and the effect is to imported LibB opened and\n// not introduce another local name for it.\nmodule LibB {\n  method Hi() {\n    print \"hi\\n\";\n  }\n}\nimport opened LibB\n\nmodule LibC {\n  method Hey() {\n    print \"hey\\n\";\n  }\n}\nimport opened C = LibC\n\nmodule LibD {\n  method Tjena() {\n    print \"tjena\\n\";\n  }\n}\nimport opened LibD = LibD  // name LibD explicitly\n\nmethod Main() {\n  Hello();  // via opened import\n  LibA.Hello();  // via module name\n\n  Hi();  // via opened import\n  LibB.Hi();  // via module name\n\n  Hey();  // via opened import\n  C.Hey();  // via local name of import\n  LibC.Hey();  // via module name\n\n  Tjena();  // via opened import\n  LibD.Tjena();  // via module name\n\n  var w := Outer.B.P(2, 4);\n  print w, \"\\n\";  // 6\n}\n\nmodule Outer {\n  module A {\n    type T = int\n  }\n  module B {\n    import opened A\n    method P(u: A.T, v: T) returns (w: int) {\n      w := u + v;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3691.dfy", "dafny": "// RUN: %exits-with 0 %dafny /compile:0 /functionSyntax:4 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntrait A {\n  predicate f()\n  method g() ensures f()\n}\n\nclass B<T> extends A {\n  predicate f() { true }\n  method g() ensures f()\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-956.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype T = T1(x:nat) | T2(y:nat) {\n    ghost predicate i() requires T2? {\n        y > 0\n    }\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-354.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nclass C<X(0)> {\n  static const u: X\n}\n\nmethod Main() {\n  print C<int>.u, \"\\n\";\n  print C<nat>.u, \"\\n\";\n  print C<real>.u, \"\\n\";\n  print C<bool>.u, \"\\n\";\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-2216.dfy", "dafny": "// NONUNIFORM: Too slow on other backends\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" >> \"%t\"\n\nconst REPEAT := 100_000\n\nmethod NoPhysicalEqualityOnSequences(s: seq<int>) {\n  for i := 0 to REPEAT {\n    var b := s == s; // No physical equality makes this take linear time\n  }\n}\n\nmethod EqualityAtLeastLinear(s: seq<int>) {\n  var s0 := [0] + s;\n  var s1 := [1] + s;\n  for i := 0 to REPEAT {\n    var b := s0 == s1; // Full sequence copy makes this linear time\n  }\n}\n\nmethod ElementsCopiedToPerformLengthCheck(s: seq<int>) {\n  var empty: seq<int> := [];\n  for i := 0 to REPEAT {\n    var b := [] <= s;\n  }\n}\n\nmethod Main() {\n  var s := seq(10_000_000, _ => 0);\n\n  print \"ElementsCopiedToPerformLengthCheck... \";\n  ElementsCopiedToPerformLengthCheck(s);\n  print \"done.\\n\";\n\n  print \"EqualityAtLeastLinear... \";\n  EqualityAtLeastLinear(s);\n  print \"done.\\n\";\n\n  print \"NoPhysicalEqualityOnSequences... \";\n  NoPhysicalEqualityOnSequences(s);\n  print \"done.\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-697g.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nfunction returnNat(c: nat): int\n{\n  if c < 0 then 1/0 else c\n}\n\nmethod Main() {\n  var x: set<int> := { -1, 2, -3, 4 };\n  var y := set c: nat | c in x;\n  var b := forall c :: c in y ==> returnNat(c) >= 0;\n  assert b;\n  print b;\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-697d.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nfunction nonGhostPredicate(x: int): bool {\n  x % 2 == 0\n}\n\ndatatype Cell = Cell(x: int)\ntype EvenCell = c: Cell | nonGhostPredicate(c.x) witness Cell(0)\n\nfunction doubleEvenCell(c: EvenCell): int\n{\n  if c.x % 2 == 1 then 1/0 else c.x * 2\n}\n\nmethod Main() {\n  var x: set<Cell> := { Cell(1), Cell(2), Cell(3), Cell(4) };\n  var y := set c: EvenCell | c in x;\n  var b := forall c :: c in y ==> doubleEvenCell(c) > 0;\n  var b2 := forall c: EvenCell :: c in x ==> c.x % 2 == 0;\n  var b3 := exists c: EvenCell :: c in x && c.x == 3;\n  assert b;\n  assert b2;\n  assert !b3;\n  print b && b2 && !b3;\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-616.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n\nmodule TestBad2 {\n  export Abs provides D1, D1.constTest\n\n  datatype D1<T> = D1(o : T)\n  {\n    const constTest := true\n  }\n\n}\n\nmodule TestBad3 {\n  import TestBad2`Abs\n\n  method test(qa : TestBad2.D1<int>) {}\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-643a.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n   expect false, \"fails\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-4012.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() {\n  var m: multiset<()> := multiset{};\n  m := m[() := 18446744073709551616];\n  print |m|, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2885.dfy", "dafny": "// RUN: %dafny /compile:1 /compileTarget:cs \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype KeyValues<T> = Store(underlying: map<string, T> := map[])\n\nfunction CreateStore<T>(): (r: KeyValues<T>) {\n  Store()\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-817.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\ndatatype Result<T> = Failure(msg: string) | Success(value: T) {\n  predicate IsFailure() { Failure? }\n  function PropagateFailure(): Result<T> requires IsFailure() { this }\n  function Extract(): (t: T) requires !IsFailure() ensures t == this.value { this.value }\n}\n\nclass D {\n  constructor (vv: int) ensures v == vv { v := vv; }\n  var v: int\n}\nmethod Main() {\n  var _ := m();\n  var _ := mm();\n  var _ := mmm();\n}\n\nmethod m() returns (rr: Result<int>) {\n  var d0 := new D(42);\n  var r := Success(100);\n  var d: D := new D(90);\n  var dd: D := d;\n  print d.v, \" \", dd.v, \"\\n\"; // 90 90\n  assert d.v == 90 && dd.v == 90;\n  expect d.v == 90 && dd.v == 90;\n\n  d.v, d :- r, d0;\n  print d.v, \" \", dd.v, \" \", d != dd, \"\\n\"; // 42 100 true\n  assert d.v == 42;\n  assert dd.v == 100;\n  expect d.v == 42 && dd.v == 100;\n  rr := *;\n}\n\nmethod mm() returns (rr: Result<int>) {\n  var d0 := new int[1]; d0[0] := 42;\n  var r := Success(100);\n  var d := new int[1]; d[0] :=  90;\n  var dd := d;\n  print d[0], \" \", dd[0], \"\\n\"; // 90 90\n  assert d[0] == 90 && dd[0] == 90;\n  expect d[0] == 90 && dd[0] == 90;\n\n  d[0], d :- r, d0;\n  print d[0], \" \", dd[0], \" \", d != dd, \"\\n\"; // 42 100 true\n  assert d[0] == 42 && dd[0] == 100;\n  expect d[0] == 42 && dd[0] == 100;\n  rr := *;\n}\n\nmethod mmm() returns (rr: Result<int>) {\n  var d0 := new int[1,1]; d0[0,0] := 42;\n  var r := Success(100);\n  var d := new int[1,1]; d[0,0] :=  90;\n  var dd := d;\n  print d[0,0], \" \", dd[0,0], \"\\n\"; // 90 90\n  assert d[0,0] == 90 && dd[0,0] == 90;\n  expect d[0,0] == 90 && dd[0,0] == 90;\n\n  d[0,0], d :- r, d0;\n  print d[0,0], \" \", dd[0,0], \" \", d != dd, \"\\n\"; // 42 100 true\n  assert d[0,0] == 42 && dd[0,0] == 100;\n  expect d[0,0] == 42 && dd[0,0] == 100;\n  rr := *;\n}\n\nclass C {\n  var x: int\n\n  method m() returns (rr: Result<int>)\n    modifies this\n  {\n    var y: int;\n    var r := Success(100);\n    x, y :- r, 100;\n    rr := r;\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2719.dfy", "dafny": "// RUN: %exits-with 1 %baredafny foobar.dll \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/git-issues/git-issue-2792.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype Wrapper<T> = Wrapper(s: seq<T>)\n{\n  static function empty(): Wrapper<T> {\n    Wrapper([])\n  }\n}\n\ndatatype Wrapper2<T> = Wrapper2(s: seq<T>, t: T)\n{\n  static function empty(t: T): Wrapper2<T> {\n    Wrapper2([], t)\n  }\n}\n\nmethod Main() {\n  var xs: Wrapper<nat> := Wrapper<nat>.empty();\n  var xs2: Wrapper2 := Wrapper2.empty(2792);\n  print xs, \" \", xs2, \"\\n\"; // [] Wrapper2([], 2792)\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3987.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\ndatatype D = A\n\nmethod Main() {\n  //Clone\n  match A {\n    case A =>\n      var a: array<nat> := new nat[1](i => i);\n      forall i | 0 <= i < a.Length {\n        a[i] := i;\n      }\n  }\n  print \"pass\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-4004_v2.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() returns ()\n{\n  match (-19 / 23) {\n    case 26 => {\n      var v_bool_7: bool, v_bool_8: bool := (match true {\n        case _ => true\n      }), false;\n    }\n    case _ => {\n    }\n  }\n}"}
{"file": "../dafny/Test/git-issues/git-issue-859.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\ndatatype FailureCompatible = Make {\n  predicate IsFailure() { true }\n  function PropagateFailure(): int { 12 }\n  function Extract(): (r: real) { 0.0 }\n}\n\nmethod M() returns (r: FailureCompatible) {\n  r := *;\n}\n\nmethod N() returns (x: int) {\n  var s: real :- M();\n  return 13;\n}\n\nmethod Main() {\n  var x := N();\n  print x, \"\\n\";\n}\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-258.dfy", "dafny": "// NONUNIFORM: https://github.com/dafny-lang/dafny/issues/2582\n// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nmethod pr<T>(s: seq<T>) {\n  print s, \"\\n\";\n}\n\nmethod Main() {\n  var a := new char[2];\n  a[0] := 'h';\n  a[1] := 'i';\n  print a[..], \"\\n\";   // hi\n  print (a[..]), \"\\n\"; // hi\n  var b := new char[0];\n  print b[..], \"\\n\";   //    -- empty line\n  print \"\", \"\\n\";      //    -- empty line\n  print \"HI!\", \"\\n\";   // HI!\n\n  pr(a[..]);           // hi\n  pr(b[..]);           //    -- empty line  // JS and GO unavoidably produce [] -- as a generic object cannot distinguish empty char sequence and empty other sequence\n  pr(\"HI!\");           // HI!\n  pr(\"\");              //    -- empty line\n\n  var d:= new int[2];\n  d[0] := 23;\n  d[1] := 45;\n  print d[..], \"\\n\";   // [23,45]\n  pr(d[..]);           // [23,45]\n  d := new int[0];\n  print d[..], \"\\n\";   // []\n  pr(d[..]);           // []\n\n  var s: string := \"abc\";\n  print (s+s), \"\\n\";   // abcabc\n  pr(s+s);             // abcabc\n  print (\"abc\"+\"def\"), \"\\n\"; // abcdef\n  pr(\"abc\"+\"def\");           // abcdef\n  print \"\"+\"\", \"\\n\";         //    -- empty line\n  pr(\"\"+\"\");                 //    -- empty line\n  print [1,2]+[3,4], \"\\n\";   // [1,2,3,4]\n  pr([1,2]+[3,4]);           // [1,2,3,4]\n\n  // print []+[], \"\\n\"; // not legal Dafny\n  // pr([]+[]);         // not legal Dafny\n}\n\n\n"}
{"file": "../dafny/Test/git-issues/git-issue-1714.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ntrait Base {}\nclass Derived extends Base { var n: int constructor() { n := 0; } }\n\nmethod f(b: Base) {\n  if (b is Derived) {\n    print \"(b as Derived).n == \", (b as Derived).n, \"\\n\";\n  }\n}\n\nmethod Main() {\n  var d := new Derived();\n  f(d);\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2827a/A.dfy", "dafny": "// RUN: %baredafny build -t:java \"%s\" > \"%t\"\n// RUN: java -jar \"%S/A.jar\" >>  \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"Hello, World!\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3883.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\ntype MyType<T> = x: T | true witness * // this used to not compile (C#, Java, Go) -- issue #3883\ntype MyInt<T> = x: int | true witness *\n\nmethod Main() {\n  var a: MyType<int> := 13; // this used to not verify (issue #3891)\n  TestMyTest(a, 14); // 13 14 // this used to crash the resolver\n  var b: MyType<bool> := true;\n  TestMyTest(b, false); // true false\n  print a, \" \", b, \"\\n\"; // 13 true\n\n  var c: MyInt<object> := 18;\n  var d: MyInt<bv19> := 19;\n  print c, \" \", d, \"\\n\"; // 18 19\n\n  TestOthers();\n\n  DoIt<real>();\n\n  Arrows();\n\n  MoreTests.Placebo();\n}\n\nmethod TestMyTest<U>(m: MyType<U>, u: U) {\n  var w: U := u;\n  var n: MyType<U> := m;\n  w := m;\n  n := u;\n  print m, \" \", u, \"\\n\";\n}\n\ndatatype ABC<X> = MakeABC(X)\ndatatype XYZ<A(0)> = MakeXYZ(A)\ntype SSS<Y> = s: seq<Y> | |s| <= 10\n\nmethod TestOthers() {\n  var a := MakeABC(10);\n  var b := MakeXYZ(null);\n  var c: SSS<bool> := [false, true, false];\n  print a, \" \", b, \" \", c, \"\\n\"; // 10 null [false, true, false]\n}\n\ntype ST0<T, U(0)> = x: int | x % 5 == 1 witness 16\ntype ST1<T, U(0)> = x: int | (if var m: map<T,U> := map[]; m == map[] then 0 else 8) <= x\n\nmethod DoIt<X(0)>() {\n  var t0: ST0<int, X> := *;\n  var t1: ST1<int, X> := *;\n  Print(t0, \" \"); // 16-16\n  Print(t1, \"\\n\"); // 0-0\n}\n\nmethod Print<X(0)>(x: X, suffix: string) {\n  var y: X := *;\n  print x, \"-\", y, suffix;\n}\n\ntype pos = x | 1 <= x witness 9\ntype Fn<R(0)> = f: int -> R | true witness * // this used to generate malformed Java code (issue #3892)\n\ndatatype Option<T> = Some(t: T) | None\ntype Fn0<R(0)> = f: int -> Option<R> | true witness PartialFnWitness // this used to generate malformed Java code (issue #3892)\ntype Fn1<R> = f: int -> Option<R> | true witness PartialFnWitness // this used to generate malformed Java code (issue #3892)\n\nfunction PartialFnWitness<R>(x: int): Option<R> {\n  None\n}\n\nmethod Arrows() {\n  var f: Fn<int>;\n  var g: Fn<pos>;\n\n  var h: Fn0<pos>;\n  var k: Fn1<pos>;\n}\n\nmodule MoreTests {\n  datatype BSingle<X> = BPlop(bool)\n  type BMyTypeWrapper<T> = x: BSingle<T> | true witness *\n  datatype BD = BD(BMyTypeWrapper<int>)\n\n  datatype XSingle<X> = XPlop(X)\n  type XMyTypeWrapper<T> = x: XSingle<T> | true witness *\n  datatype XD = XD(XMyTypeWrapper<int>)\n\n  datatype IntCell = IntCell(int)\n  type ConstrainedIntCell = c: IntCell | true witness *\n  type GurgleInt = ConstrainedIntCell\n  datatype WrappedInt = WrappedInt(GurgleInt)\n  type MyTypeAroundInt<T> = x: WrappedInt | true witness *\n\n  datatype UCell<U> = UCell(U)\n  type ConstrainedUCell<U> = u: UCell<U> | true witness *\n  type GurgleU<U> = ConstrainedUCell<U>\n  datatype WrappedU<U> = WrappedU(GurgleU<U>)\n  type MyTypeAroundU<U> = x: WrappedU<U> | true witness *\n\n  method Placebo() {\n    var a: XSingle<int>;\n    var b: XMyTypeWrapper<int>;\n    var c: XD;\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/Wrappers.dfy", "dafny": "// RUN: %diff \"%s\" \"%s\"\n/*******************************************************************************\n *  Copyright by the contributors to the Dafny Project\n *  SPDX-License-Identifier: MIT \n *******************************************************************************/\n\nmodule {:options \"-functionSyntax:4\"} Wrappers {\n\n  datatype Option<+T> = None | Some(value: T) {\n    function ToResult(): Result<T, string> {\n      match this\n      case Some(v) => Success(v)\n      case None() => Failure(\"Option is None\")\n    }\n\n    function UnwrapOr(default: T): T {\n      match this\n      case Some(v) => v\n      case None() => default\n    }\n\n    predicate IsFailure() {\n      None?\n    }\n\n    function PropagateFailure<U>(): Option<U>\n      requires None?\n    {\n      None\n    }\n\n    function Extract(): T\n      requires Some?\n    {\n      value\n    }\n  }\n\n  datatype Result<+T, +R> = | Success(value: T) | Failure(error: R) {\n    function ToOption(): Option<T>\n    {\n      match this\n      case Success(s) => Some(s)\n      case Failure(e) => None()\n    }\n\n    function UnwrapOr(default: T): T\n    {\n      match this\n      case Success(s) => s\n      case Failure(e) => default\n    }\n\n    predicate IsFailure() {\n      Failure?\n    }\n\n    function PropagateFailure<U>(): Result<U, R>\n      requires Failure?\n    {\n      Failure(this.error)\n    }\n\n    function MapFailure<NewR>(reWrap: R -> NewR): Result<T, NewR>\n    {\n      match this\n      case Success(s) => Success(s)\n      case Failure(e) => Failure(reWrap(e))\n    }\n\n    function Extract(): T\n      requires Success?\n    {\n      value\n    }\n  }\n\n  datatype Outcome<E> = Pass | Fail(error: E)\n  {\n    predicate IsFailure() {\n      Fail?\n    }\n    // Note: PropagateFailure returns a Result, not an Outcome.\n    function PropagateFailure<U>(): Result<U, E>\n      requires Fail?\n    {\n      Failure(this.error)\n    }\n    // Note: no Extract method\n  }\n\n  // A helper function to ensure a requirement is true at runtime\n  // :- Need(5 == |mySet|, \"The set MUST have 5 elements.\")\n  function Need<E>(condition: bool, error: E): (result: Outcome<E>)\n  {\n    if condition then Pass else Fail(error)\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3497.dfy", "dafny": "// RUN: %resolve \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod m() {\n  forall \n    ensures true \n  {\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/github-issue-3874.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() {\n    var s: multiset<bool> := multiset{true};\n\n    while (s != multiset{}) {\n        var x :| x in s;\n\ts := s[x := 0];\n    }\n\n    print \"done\", \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-784.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype List<T> = Nil | Cons(T, List<T>) {\n  function App(ys: List<T>): List<T> {\n    match this\n      case Nil => ys\n      case Cons(x, xs) => Cons(x, xs.App(ys))\n  }\n\n  static ghost function Concat<T>(l: List<List<T>>): List<T> {\n    match l\n      case Nil => Nil\n      case Cons(x, xs) => x.App(Concat(xs))\n  }\n\n  lemma AppAssoc(m: List<T>, n: List<T>)\n    ensures App(m).App(n) == App(m.App(n))\n  {}\n\n  static lemma ConcatApp<T>(l1: List<List<T>>, l2: List<List<T>>)\n    ensures Concat(l1.App(l2)) == Concat(l1).App(Concat(l2))\n  {\n      match l1\n        case Nil =>\n        case Cons(x, xs) =>\n          x.AppAssoc(Concat(xs), Concat(l2));\n  }\n}\n\nmethod Main() {}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3382.dfy", "dafny": "// RUN: %resolve \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nnewtype uint16 = x | 0 <= x < 0x1_0000\ndatatype D = A | B\n\nghost function F(x: D): uint16 {\n  match x\n  case A => 12\n  case B => 13\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-4162.dfy", "dafny": "// NONUNIFORM: %testDafnyForEachCompiler doesn't support /out\n// RUN: %dafny /compile:4 /compileTarget:py /out:M \"%s\" > \"%t\"\n// RUN: %dafny /compile:4 /compileTarget:cs /out:M \"%s\" >> \"%t\"\n// RUN: %dafny /compile:4 /compileTarget:java /out:M \"%s\" >> \"%t\"\n// RUN: %dafny /compile:4 /compileTarget:js /out:M \"%s\" >> \"%t\"\n// RUN: %dafny /compile:4 /compileTarget:go /out:M \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n    const i := 0\n}\n\nmethod Main() {\n    print M.i, \"\\n\";\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-2903.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmodule A {\n  datatype Wrapper = Wrap(val: int)\n}\n\nmodule B {\n  datatype Wrapper = Wrap\n}\n\nmodule Main {\n  import opened A\n  import B\n\n  method Main() {\n    var Wrap(x) := Wrap(0);\n    expect x == 0;\n  }\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-3288a.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\" \n\n// Check that contextual keywords can be used as identifiers\n\nconst least := 0\nconst greatest := 42\nconst to := true\nconst downto := false\nconst older := 0.0\n\nmodule M {\n  function least(): int { 42 }\n  method greatest() {}\n  type to\n  predicate downto() { true }\n  module older {}\n}\n"}
{"file": "../dafny/Test/git-issues/git-issue-1852.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmodule A {\n  export\n    reveals F, G\n\n  ghost function G(): int { 5 }\n\n  function F(): int {\n    G()\n  } by method {\n    return 5;\n  }\n}\n\nmodule B {\n  export\n    provides F\n\n  ghost function G(): int { 5 }\n\n  function F(): int {\n    G()\n  } by method {\n    return 5;\n  }\n}\n\nmodule Client {\n  import A\n  import B\n\n  method Main() {\n    // Test that A.F and B.F are both non-ghost here\n    print A.F(), \" \", B.F(), \"\\n\"; // 5 5\n  }\n}\n"}
{"file": "../dafny/Test/vstte2012/RingBufferAuto.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass {:autocontracts} RingBuffer<T(0)>\n{\n  // public view of the class:\n  ghost var Contents: seq<T>  // the contents of the ring buffer\n  ghost var N: nat  // the capacity of the ring buffer\n\n  // private implementation:\n  var data: array<T>\n  var start: nat\n  var len: nat\n\n  // Valid encodes the consistency of RingBuffer objects (think, invariant)\n  ghost predicate Valid()\n  {\n    data.Length == N &&\n    (N == 0 ==> len == start == 0 && Contents == []) &&\n    (N != 0 ==> len <= N && start < N) &&\n    Contents == if start + len <= N then data[start..start+len]\n                                    else data[start..] + data[..start+len-N]\n  }\n\n  constructor Create(n: nat)\n    ensures Contents == [] && N == n\n  {\n    data := new T[n];\n    start, len := 0, 0;\n    Contents, N := [], n;\n  }\n\n  method Clear()\n    ensures Contents == [] && N == old(N)\n  {\n    len := 0;\n    Contents := [];\n  }\n\n  method Head() returns (x: T)\n    requires Contents != []\n    ensures x == Contents[0]\n  {\n    x := data[start];\n  }\n\n  method Enqueue(x: T)\n    requires |Contents| != N\n    ensures Contents == old(Contents) + [x] && N == old(N)\n  {\n    var nextEmpty := if start + len < data.Length\n                     then start + len else start + len - data.Length;\n    data[nextEmpty] := x;\n    len := len + 1;\n    Contents := Contents + [x];\n  }\n\n  method ResizingEnqueue(x: T)\n    ensures Contents == old(Contents) + [x] && N >= old(N)\n  {\n    if data.Length == len {\n      var more := data.Length + 1;\n      var d := new T[data.Length + more];\n      forall i | 0 <= i < data.Length {\n        d[if i < start then i else i + more] := data[i];\n      }\n      N, data, start := N + more, d, if len == 0 then 0 else start + more;\n    }\n    var nextEmpty := if start + len < data.Length\n                     then start + len else start + len - data.Length;\n    data[nextEmpty] := x;\n    len := len + 1;\n    Contents := Contents + [x];\n  }\n\n  method Dequeue() returns (x: T)\n    requires Contents != []\n    ensures x == old(Contents)[0] && Contents == old(Contents)[1..] && N == old(N)\n  {\n    x := data[start];  assert x == Contents[0];\n    start, len := if start + 1 == data.Length then 0 else start + 1, len - 1;\n    Contents := Contents[1..];\n  }\n}\n\nmethod TestHarness(x: int, y: int, z: int)\n{\n  var b := new RingBuffer.Create(2);\n  b.Enqueue(x);\n  b.Enqueue(y);\n  var h := b.Dequeue();  assert h == x;\n  b.Enqueue(z);\n  h := b.Dequeue();  assert h == y;\n  h := b.Dequeue();  assert h == z;\n}\n"}
{"file": "../dafny/Test/vstte2012/RingBuffer.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass RingBuffer<T(0)>\n{\n  // public view of the class:\n  ghost var Contents: seq<T>  // the contents of the ring buffer\n  ghost var N: nat  // the capacity of the ring buffer\n  ghost var Repr: set<object?>  // the set of objects used in the implementation\n\n  // private implementation:\n  var data: array<T>\n  var start: nat\n  var len: nat\n\n  // Valid encodes the consistency of RingBuffer objects (think, invariant)\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr && null !in Repr &&\n    data in Repr &&\n    data.Length == N &&\n    (N == 0 ==> len == start == 0 && Contents == []) &&\n    (N != 0 ==> len <= N && start < N) &&\n    Contents == if start + len <= N then data[start..start+len]\n                                    else data[start..] + data[..start+len-N]\n  }\n\n  constructor Create(n: nat)\n    ensures Valid() && fresh(Repr)\n    ensures Contents == [] && N == n\n  {\n    data := new T[n];\n    Repr := {this, data};\n    start, len := 0, 0;\n    Contents, N := [], n;\n  }\n\n  method Clear()\n    requires Valid()\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures Contents == [] && N == old(N)\n  {\n    len := 0;\n    Contents := [];\n  }\n\n  method Head() returns (x: T)\n    requires Valid()\n    requires Contents != []\n    ensures x == Contents[0]\n  {\n    x := data[start];\n  }\n\n  method Enqueue(x: T)\n    requires Valid()\n    requires |Contents| != N\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures Contents == old(Contents) + [x] && N == old(N)\n  {\n    var nextEmpty := if start + len < data.Length\n                     then start + len else start + len - data.Length;\n    data[nextEmpty] := x;\n    len := len + 1;\n    Contents := Contents + [x];\n  }\n\n  method Dequeue() returns (x: T)\n    requires Valid()\n    requires Contents != []\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures x == old(Contents)[0] && Contents == old(Contents)[1..] && N == old(N)\n  {\n    x := data[start];  assert x == Contents[0];\n    start, len := if start + 1 == data.Length then 0 else start + 1, len - 1;\n    Contents := Contents[1..];\n  }\n}\n\nmethod TestHarness(x: int, y: int, z: int)\n{\n  var b := new RingBuffer.Create(2);\n  b.Enqueue(x);\n  b.Enqueue(y);\n  var h := b.Dequeue();  assert h == x;\n  b.Enqueue(z);\n  h := b.Dequeue();  assert h == y;\n  h := b.Dequeue();  assert h == z;\n}\n"}
{"file": "../dafny/Test/vstte2012/Two-Way-Sort.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This method is a slight generalization of the\n// code provided in the problem statement since it\n// is generic in the type of the array elements.\nmethod swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var t := a[i];\n  a[i] := a[j];\n  a[j] := t;\n}\n\n// This method is a direct translation of the pseudo\n// code given in the problem statement.\n// The first postcondition expresses that the resulting\n// array is sorted, that is, all occurrences of \"false\"\n// come before all occurrences of \"true\".\n// The second postcondition expresses that the post-state\n// array is a permutation of the pre-state array. To express\n// this, we use Dafny's built-in multisets. The built-in\n// function \"multiset\" takes an array and yields the\n// multiset of the array elements.\n// Note that Dafny guesses a suitable ranking function\n// for the termination proof of the while loop.\n// We use the loop guard from the given pseudo-code.  However,\n// the program also verifies with the stronger guard \"i < j\"\n// (without changing any of the other specifications or\n// annotations).\nmethod two_way_sort(a: array<bool>)\n  modifies a\n  ensures forall m,n :: 0 <= m < n < a.Length ==> (!a[m] || a[n])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var i := 0;\n  var j := a.Length - 1;\n  while (i <= j)\n    invariant 0 <= i <= j + 1 <= a.Length\n    invariant forall m :: 0 <= m < i ==> !a[m]\n    invariant forall n :: j < n < a.Length ==> a[n]\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    if (!a[i]) {\n      i := i+1;\n    } else if (a[j]) {\n      j := j-1;\n    } else {\n      swap(a, i, j);\n      i := i+1;\n      j := j-1;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/expectations/ExpectWithNonStringMessage.dfy", "dafny": "// RUN: %dafny /compile:0 /unicodeChar:0 \"%s\" > \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /unicodeChar:0 /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /unicodeChar:0 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /unicodeChar:0 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /unicodeChar:0 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: ! %dafny /noVerify /compile:4 /unicodeChar:0 /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Option<T> = None | Some(get: T)\n\nmethod Main() {\n  var x := Some(\"where over the rainbow\");\n  expect x.None?, x;\n}\n"}
{"file": "../dafny/Test/expectations/ExpectWithMessage.dfy", "dafny": "// RUN: ! %dafny /compile:3 /compileTarget:cs \"%s\" > \"%t\"\n// RUN: ! %dafny /compile:3 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: ! %dafny /compile:3 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: ! %dafny /compile:3 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  expect 2 + 2 == 5, \"Down with Doublethink!\";\n}\n"}
{"file": "../dafny/Test/expectations/Expect.dfy", "dafny": "// RUN: ! %baredafny run %args --target=cs \"%s\" > \"%t\"\n// RUN: ! %baredafny run %args --target=go \"%s\" >> \"%t\"\n// RUN: ! %baredafny run %args --target=java \"%s\" >> \"%t\"\n// RUN: ! %baredafny run %args --target=js \"%s\" >> \"%t\"\n// RUN: ! %baredafny run %args --target=py \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype OOAgent = | OO7 {\n  function Talk(): bool {\n    true\n  }\n  function Die(): bool {\n    false\n  }\n}\n\nmethod TestExpect() {\n  var jamesBond := OO7;\n  // Do you...\n  expect jamesBond.Talk();\n  // No Mr. Bond, I...\n  expect jamesBond.Die(); // Runtime error: expectation violation\n}\n\nmethod Main() {\n  TestExpect();\n}\n"}
{"file": "../dafny/Test/attr-help.dfy", "dafny": "// RUN: %baredafny /attrHelp\n\n// Just checks that the attribute help option works\n"}
{"file": "../dafny/Test/irondafny0/optimize0.dfy", "dafny": "// NONUNIFORM: /optimize option not supported by the new CLI\n// RUN: %dafny /compile:3 /optimize /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// See https://github.com/dafny-lang/dafny/issues/508\n\nmethod Main() {\n    print \"o hai!\";\n}\n"}
{"file": "../dafny/Test/irondafny0/opened_workaround.dfy", "dafny": "// RUN: %exits-with 3 %dafny /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n\n    ghost predicate P()\n\n    class C\n    {\n        static method{:axiom} M()\n            ensures P()\n    }\n}\n\nabstract module B {\n    import opened A\n}\n\nabstract module C {\n    import Bee : B       // Works\n}\n"}
{"file": "../dafny/Test/refinement/aliasInRefinee.dfy", "dafny": "// RUN: %baredafny resolve --use-basename-for-filename %s\n\nmodule Aliased {\n  module Nested {\n    const x := 3\n    const y := 4\n  }\n}\n\nmodule Refinee {\n  import opened Aliased.Nested\n}\n\nmodule Refiner refines Refinee {\n  const z := y + 1 \n  const x := \"blocking\"\n}\n\nmodule SecondNestedOpener {\n  import opened Aliased.Nested\n}\n\nmodule Outer {\n  import opened SecondNestedOpener\n  import opened Refiner\n}"}
{"file": "../dafny/Test/auditor/IgnoredAssumptions.dfy", "dafny": "// RUN: %diff \"%s\" \"%s\"\nlemma {:axiom} BadAssumptionButWeDon'tCare(x: int)\n  ensures x*x == 2\n"}
{"file": "../dafny/Test/vacid0/LazyInitArray.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass LazyInitArray<T(0)> {\n  ghost var Contents: seq<T>\n  var Zero: T\n  /*private*/ var a: array<T>\n  /*private*/ var b: array<int>\n  /*private*/ var c: array<int>\n  /*private*/ var n: int\n  /*private*/ ghost var d: seq<int>\n  /*private*/ ghost var e: seq<int>\n  ghost predicate Valid()\n    reads this, a, b, c\n  {\n    a.Length == |Contents| &&\n    b.Length == |Contents| &&\n    c.Length == |Contents| &&\n    b != c && a != b && a != c &&\n    0 <= n && n <= c.Length &&\n    (forall i :: 0 <= i && i < |Contents| ==>\n       Contents[i] == (if 0 <= b[i] && b[i] < n && c[b[i]] == i then a[i] else Zero)) &&\n    (forall i :: 0 <= i && i < |Contents| ==>\n              ((exists j :: 0 <= j && j < n && c[j] == i)\n               <==>\n               0 <= b[i] && b[i] < n && c[b[i]] == i)) &&\n    // The idea behind d and e is the following:\n    //  *  d is a permutation of the first |Contents| natural numbers\n    //  *  e describes which permutation d is\n    //  *  c[..n] == d[..n]\n    |d| == |Contents| &&\n    |e| == |Contents| &&\n    (forall i :: 0 <= i && i < n ==> c[i] == d[i]) &&\n    (forall i :: 0 <= i && i < |d| ==> 0 <= d[i] && d[i] < |d|) &&\n    (forall i :: 0 <= i && i < |e| ==> 0 <= e[i] && e[i] < |e|) &&\n    (forall i :: 0 <= i && i < |e| ==> d[e[i]] == i)\n  }\n\n  method Init(N: int, zero: T)\n    requires 0 <= N\n    modifies this, a, b, c\n    ensures Valid()\n    ensures |Contents| == N && Zero == zero\n    ensures forall x :: x in Contents ==> x == zero\n  {\n    a := new T[N];\n    b := new int[N];\n    c := new int[N];\n    n := 0;\n\n    // initialize ghost variable Contents to a sequence of length N containing only zero's,\n    // and ghost variables d and e to be the identity sequences of length N\n    ghost var s := [];\n    ghost var id := [];\n    ghost var k := 0;\n    while k < N\n      invariant k <= N\n      invariant |s| == k && forall i :: 0 <= i && i < |s| ==> s[i] == zero\n      invariant |id| == k && forall i :: 0 <= i && i < k ==> id[i] == i\n    {\n      s := s + [zero];\n      id := id + [k];\n      k := k + 1;\n    }\n\n    d := id;\n    e := id;\n    Zero := zero;\n    Contents := s;\n  }\n\n  method Get(i: int) returns (x: T)\n    requires Valid()\n    requires 0 <= i && i < |Contents|\n    ensures x == Contents[i]\n  {\n    if 0 <= b[i] && b[i] < n && c[b[i]] == i {\n      x := a[i];\n    } else {\n      x := Zero;\n    }\n  }\n\n  method Set(i: int, x: T)\n    requires Valid()\n    requires 0 <= i && i < |Contents|\n    modifies this, a, b, c\n    ensures Valid()\n    ensures |Contents| == |old(Contents)| && Contents == Contents[i := x]\n    ensures Zero == old(Zero)\n  {\n    if 0 <= b[i] && b[i] < n && c[b[i]] == i {\n    } else {\n      assert n <= e[i];  // lemma\n      b[i] := n;\n      c[n] := i;\n      ghost var t := d[n];\n      ghost var k := e[i];\n      d := d[n := i][k := t];\n      e := e[i := n][t := k];\n      n := n + 1;\n    }\n\n    a[i] := x;\n    Contents := Contents[i := x];\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue27.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype word = x | 0 <= x < 0x1_0000_0000\n\nghost function extract(src:map<int, word>): map<int, word>\n    requires forall i :: 0 <= i < 0x10 ==> i in src\n{\n    (map i | 0 <= i < 0x10 :: src[i])\n}\n\n"}
{"file": "../dafny/Test/dafny4/git-issue42.dfy", "dafny": "// RUN: %dafny /warnShadowing /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nlemma L(x:int)\n{\n    var x := 2;\n}\n\nlemma {:warnShadowing false} L1(x:int)\n{\n    var x := 2;\n}\n"}
{"file": "../dafny/Test/dafny4/Bug155.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function foo(m: multiset<object>): int\n  reads m\n{\n  0\n}\n"}
{"file": "../dafny/Test/dafny4/Circ.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// A couple of examples from Grigore Rosu and Dorel Lucanu, \"Circular coinduction: A proof theoretical\n// foundation\", CALCO 2009.\n\ncodatatype Stream<T> = Cons(head: T, tail: Stream)\n\n// ----- standard examples -----\n\nghost function zeros(): Stream<int> { Cons(0, zeros()) }\nghost function ones(): Stream<int> { Cons(1, ones()) }\nghost function blink(): Stream<int> { Cons(0, Cons(1, blink())) }\nghost function zip(a: Stream, b: Stream): Stream { Cons(a.head, zip(b, a.tail)) }\n\ngreatest lemma BlinkZipProperty()\n  ensures zip(zeros(), ones()) == blink();\n{\n    BlinkZipProperty();\n}\n\n// ----- Thue-Morse sequence -----\n\ndatatype Bit = O | I\nghost function bitnot(b: Bit): Bit\n{\n  if b == O then I else O\n}\n\nghost function not(s: Stream<Bit>): Stream<Bit>\n{\n  Cons(bitnot(s.head), not(s.tail))\n}\n\n/* Function morse() is essentially this:\n\nghost function morse(): Stream<int>\n{\n  Cons(0, morseTail())\n}\nghost function morseTail(): Stream<int>\n{\n  Cons(1, zip(morseTail(), not(morseTail())))\n}\n\n * However, this definition of morseTail() is not allowed in Dafny, because it violates Dafny's\n * syntactic guardedness checks.  Instead, we give the defining properties of morse() and\n * morseTail() as an axiom (that is, an unproved lemma).\n */\n\nghost function morse(): Stream<Bit>\nghost function morseTail(): Stream<Bit>\nlemma MorseProperties()\n  ensures morse().head == O;\n  ensures morseTail() == morse().tail;\n  ensures morseTail().head == I;\n  ensures morseTail().tail == zip(morseTail(), not(morseTail()));\n\n// We will now define a function f and show that morse() is a fix-point of f.\n\nghost function f(s: Stream<Bit>): Stream<Bit>\n{\n  Cons(s.head, Cons(bitnot(s.head), f(s.tail)))\n}\n\n// The insightful property about f is that it satisfies the following property, which\n// we prove by co-induction.\n\ngreatest lemma FProperty(s: Stream<Bit>)\n  ensures f(s) == zip(s, not(s));\n{\n  calc {\n    zip(s, not(s));\n    // def. zip\n    Cons(s.head, zip(not(s), s.tail));\n    // def. zip\n    Cons(s.head, Cons(not(s).head, zip(s.tail, not(s).tail)));\n  }\n  FProperty(s.tail);\n}\n\n// The fix-point theorem now follows easily.\n\nlemma Fixpoint()\n  ensures f(morse()) == morse();\n{\n  MorseProperties();\n  FProperty(morseTail());\n}\n"}
{"file": "../dafny/Test/dafny4/Bug103.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate IsLessThanSuccesor(i:int)\n{\n  i < i + 1\n}\n\nlemma LemmaWithoutTriggerOnForallStatement()\n{\n  forall i\n    ensures IsLessThanSuccesor(i)\n  {\n  }\n}\n\n\n\n\n\n"}
{"file": "../dafny/Test/dafny4/Bug58.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function M1(f:map<int, bool>, i:int):bool\n\nghost function M2(f:map<int, bool>, i:int):bool\n{\n    M1(map j | j in f :: f[j], i)\n}\n\nlemma L(f:map<int, bool>, i:int)\n    requires i in f\n    requires M2(f, i)\n    requires forall j:int, f:map<int, bool> :: M1(f, j) == (j in f && f[j])\n{\n    assert f[i];\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue92.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype d = D(i:int)\nghost predicate p(s:int, y:int)\nghost predicate q(d:d) { exists s :: (match d case D(z) => p(s, z)) }\n\n"}
{"file": "../dafny/Test/dafny4/Bug111.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype A = A(i:int)\ndatatype B = B1(a1:A) | B2(a2:A)\n\nghost function f(b:B):int\n{\n  match b\n  {\n    case B1(A(i)) => i\n    case B2(A(j)) => j\n  }\n}\n\n\n\n\n"}
{"file": "../dafny/Test/dafny4/Bug75.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate R1(x:int, y:int) { x > 0 ==> R2(x - 1) }\nghost predicate R2(x:int) { exists y :: R1(x, y) }\n\nlemma L1(x:int)\n{\n    assume R2(x);\n    assert exists y :: R1(x, y); // FAILS\n}\n\nlemma L2(x:int)\n    requires R2(x) // Oddly, adding this requires fixes the problem\n{\n    assume R2(x);\n    assert exists y :: R1(x, y); // SUCCEEDS\n}\n\n// this predicate says that the first \"n\" elements of \"s\"\n\n// are in strictly increasing order\n\npredicate Increasing(s: seq<int>, n: nat)\n  requires n <= |s|\n{\n  n < 2 ||\n  (s[n-2] < s[n-1] && Increasing(s, n-1))\n}\n\nmethod Extend(s: seq<int>, n: nat) returns (n': nat)\n  requires n < |s|\n  requires forall i :: 0 <= i < n ==> Increasing(s, i)\n  ensures n <= n' <= |s|\n  ensures forall j :: 0 <= j < n' ==> Increasing(s, j)\n{\n  if 2 <= n && s[n-2] < s[n-1] {\n    n' := n + 1;\n  } else {\n    n' := n;\n  }\n}\n\nghost function pred(i:int):int { i - 1 }\nghost predicate f(a:int, s:int)            { (a <= 0 || (exists s0 :: f(pred(a), s0))) }\n\nlemma Fuel1(a:int, s:int)\n{\n    assert  f(a, s) <==> (a <= 0 || (exists s0 :: f(pred(a), s0))); // FAILS\n}\n"}
{"file": "../dafny/Test/dafny4/Bug116.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// test various compiler-target keywords\n\ndatatype struct = S  // C# keyword\ndatatype byte = arguments  // JavaScript keyword\n\nmethod Main()\n{\n  var s := S;\n  var t: struct;\n  var b := arguments;\n  print s, \" \", b, \"\\n\";\n\n  var ref: enum.goto, transient: enum.goto;\n  ref := enum.switch;\n  transient := enum.do();\n  print ref, \" \", transient, \"\\n\";\n\n  var params := catch(20);\n  var final := enum.catch(params);\n  var procedure := params + final;  // Boogie keyword\n  print params, \" + \", final, \" == \", procedure, \"\\n\";\n}\n\nmethod catch(do: int) returns (finally: int) {\n  finally := do;\n}\n\nmodule enum {\n  datatype goto = switch\n  function do(): goto {\n    switch\n  }\n  method catch(do: int) returns (finally: int) {\n    finally := do;\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/Bug99.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate P(e:int, p:int) { true }\nghost predicate Q(i:int, t:int)\n\nlemma Tester(x:int)\n{\n    assert forall i :: Q(i, x) ==> (forall p {:trigger P(i, p)} :: P(i, p));\n\n}\n"}
{"file": "../dafny/Test/dafny4/Bug82.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function {:opaque} Reverse(id:int) : int\n\nghost function RefineToMap(ReverseKey:int->int) : bool\n\nghost function RefineToMapOfSeqNums() : bool\n{\n    RefineToMap(Reverse)\n}\n"}
{"file": "../dafny/Test/dafny4/Regression16.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Tree = Leaf | Node(x: int, left: Tree, right: Tree)\n\nfunction Insert(t: Tree, y: int): Tree\n{\n  match t\n  case Leaf => Node(y, Leaf, Leaf)\n  case Node(x, left, right) =>\n    if y < x then\n      Node(y, Insert(right, x), left)\n    else\n      Node(x, Insert(right, y), left)\n}\n\nghost function Elements(t: Tree): multiset<int>\n{\n  match t\n  case Leaf =>  multiset {}\n  case Node(x, left, right) => multiset {x} + Elements(left) + Elements(right)\n}\n\nghost predicate IsBalanced(t: Tree)\n{\n  match t\n  case Leaf => true\n  case Node(_, left, right) =>\n    IsBalanced(left) && IsBalanced(right) &&\n    var L, R := |Elements(left)|, |Elements(right)|;\n    L == R || L == R+1\n}\n\nlemma InsertBalanced_A(t: Tree, y: int)\n  requires IsBalanced(t)\n  ensures var t' := Insert(t, y);\n    Elements(\n      Insert(t, y)  // Use Insert(t, y) here instead of t'.  This verifies (and did before).\n    ) == Elements(t) + multiset {y} &&\n    IsBalanced(t')\n{\n}\n\nlemma InsertBalanced_B(t: Tree, y: int)\n  requires IsBalanced(t)\n  ensures var t' := Insert(t, y);\n    Elements(\n      t'  // Use t' here, which stands for Insert(t, y).  This used to not verify (because the\n          // fuel of this call to Insert was previously not increments).\n    ) == Elements(t) + multiset {y} &&\n    IsBalanced(t')  // An effect of the \"fixed\" implementation is that the fuel of Insert gets\n                    // incremented here, too, whereas it did not used to.\n{\n}\n"}
{"file": "../dafny/Test/dafny4/Bug55.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate {:opaque} G(f:int~>bool)\n  reads f.reads(0)\n  requires f.requires(0)\n{\n  true\n}\n\nghost predicate A<T>(s:set<T>)\n\npredicate{:opaque} B(s:set<int>)\n    requires A(s)\n"}
{"file": "../dafny/Test/dafny4/CoqArt-InsertionSort.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Dafny transcription of the Coq development of insertion sort, as found in Coq'Art.\n\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost predicate sorted(l: List<int>)\n{\n  match l\n  case Nil => true\n  case Cons(x, rest) =>\n    match rest\n    case Nil => true\n    case Cons(y, _) => x <= y && sorted(rest)\n}\n\nlemma example_sort_2357()\n  ensures sorted(Cons(2, Cons(3, Cons(5, Cons(7, Nil)))));\n{\n}\n\nlemma sorted_inv(z: int, l: List<int>)\n  requires sorted(Cons(z, l));\n  ensures sorted(l);\n{\n  match l {\n    case Nil =>\n    case Cons(_, _) =>\n  }\n}\n\n// Number of occurrences of z in l\nghost function nb_occ(z: int, l: List<int>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(z', l') =>\n    (if z == z' then 1 else 0) + nb_occ(z, l')\n}\n\nlemma example_nb_occ_0()\n  ensures nb_occ(3, Cons(3, Cons(7, Cons(3, Nil)))) == 2;\n{\n}\n\nlemma example_nb_occ_1()\n  ensures nb_occ(36725, Cons(3, Cons(7, Cons(3, Nil)))) == 0;\n{\n}\n\n// list l' is a permutation of list l\nghost predicate equiv(l: List<int>, l': List<int>)\n{\n  forall z :: nb_occ(z, l) == nb_occ(z, l')\n}\n\n// equiv is an equivalence\nlemma equiv_refl(l: List<int>)\n  ensures equiv(l, l);\n{\n}\n\nlemma equiv_sym(l: List<int>, l': List<int>)\n  requires equiv(l, l');\n  ensures equiv(l', l);\n{\n}\n\nlemma equiv_trans(l: List<int>, l': List<int>, l'': List<int>)\n  requires equiv(l, l') && equiv(l', l'');\n  ensures equiv(l, l'');\n{\n}\n\nlemma equiv_cons(z: int, l: List<int>, l': List<int>)\n  requires equiv(l, l');\n  ensures equiv(Cons(z, l), Cons(z, l'));\n{\n}\n\nlemma equiv_perm(a: int, b: int, l: List<int>, l': List<int>)\n  requires equiv(l, l');\n  ensures equiv(Cons(a, Cons(b, l)), Cons(b, Cons(a, l')));\n{\n  var L, L' := Cons(a, Cons(b, l)), Cons(b, Cons(a, l'));\n  forall z {\n    calc {\n      nb_occ(z, L);\n      (if z == a && z == b then 2 else if z == a || z == b then 1 else 0) + nb_occ(z, l);\n      (if z == a && z == b then 2 else if z == a || z == b then 1 else 0) + nb_occ(z, l');\n      nb_occ(z, L');\n    }\n  }\n}\n\n// insertion of z into l at the right place (assuming l is sorted)\nfunction aux(z: int, l: List<int>): List<int>\n{\n  match l\n  case Nil => Cons(z, Nil)\n  case Cons(a, l') =>\n    if z <= a then Cons(z, l) else Cons(a, aux(z, l'))\n}\n\nlemma example_aux_0()\n  ensures aux(4, Cons(2, Cons(5, Nil))) == Cons(2, Cons(4, Cons(5, Nil)));\n{\n}\n\nlemma example_aux_1()\n  ensures aux(4, Cons(24, Cons(50, Nil))) == Cons(4, Cons(24, Cons(50, Nil)));\n{\n}\n\n// the aux function seems to be a good tool for sorting...\n\nlemma aux_equiv(l: List<int>, x: int)\n  ensures equiv(Cons(x, l), aux(x, l));\n{\n  match l {\n    case Nil =>\n    case Cons(_, _) =>\n  }\n}\n\nlemma aux_sorted(l: List<int>, x: int)\n  requires sorted(l);\n  ensures sorted(aux(x, l));\n{\n  match l {\n    case Nil =>\n    case Cons(_, l') =>\n      match l' {\n        case Nil =>\n        case Cons(_, _) =>\n      }\n  }\n}\n\n// the sorting function\nghost function sort(l: List<int>): List<int>\n  ensures var l' := sort(l); equiv(l, l') && sorted(l');\n{\n  existence_proof(l);\n  var l' :| equiv(l, l') && sorted(l'); l'\n}\n\nlemma existence_proof(l: List<int>)\n  ensures exists l' :: equiv(l, l') && sorted(l');\n{\n  match l {\n    case Nil =>\n      assert sorted(Nil);\n    case Cons(x, m) =>\n      existence_proof(m);\n      var m' :| equiv(m, m') && sorted(m');\n      calc ==> {\n        equiv(m, m') && sorted(m');\n        equiv(l, Cons(x, m')) && sorted(m');\n        { aux_equiv(m', x); }\n        equiv(l, aux(x, m')) && sorted(m');\n        { aux_sorted(m', x); }\n        equiv(l, aux(x, m')) && sorted(aux(x, m'));\n      }\n  }\n}\n\n// to get a compilable function in Dafny\nfunction Sort(l: List<int>): List<int>\n  ensures equiv(l, Sort(l)) && sorted(Sort(l));\n{\n  match l\n  case Nil => l\n  case Cons(x, m) =>\n    var m' := Sort(m);\n    assert equiv(l, Cons(x, m'));\n    aux_equiv(m', x);\n    aux_sorted(m', x);\n    aux(x, m')\n}\n\nghost predicate p_aux_equiv(l: List<int>, x: int)\n  ensures equiv(Cons(x, l), aux(x, l));\n{\n  aux_equiv(l, x);\n  true\n}\n\nghost predicate p_aux_sorted(l: List<int>, x: int)\n  requires sorted(l);\n  ensures sorted(aux(x, l));\n{\n  aux_sorted(l, x);\n  true\n}\n"}
{"file": "../dafny/Test/dafny4/Bug81.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function {:opaque} RefineSeqToSeq<T(!new), U>(s:seq<T>, refine_func: T ~> U) : seq<U>\n{\n  if |s| == 0 then []\n  else RefineSeqToSeq(s[1..], refine_func)\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue98.dfy", "dafny": "// RUN: %baredafny verify %args --disable-nonlinear-arithmetic \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nabstract module One {\n  type State\n  type Action\n\n  ghost predicate StateNext(s:State, s':State, a:Action)\n\n  ghost predicate StateNextSeq(sseq:seq<State>, actions:seq<Action>)\n  {\n    |sseq| == |actions| + 1\n    && (forall i :: 0 <= i < |actions| ==> StateNext(sseq[i], sseq[i+1], actions[i]))\n  }\n\n}\n\nabstract module Two {\n    import opened O : One\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue57.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nlemma lemma_RotateRightAdds(x:bv32)\n   ensures  (x.RotateRight(2)).RotateRight(3) == x.RotateRight(5)\n{\n}\n\n\n"}
{"file": "../dafny/Test/dafny4/git-issue105.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod lol() returns (c: int)\n{\n  c := 5;\n  return c;\n}\n"}
{"file": "../dafny/Test/dafny4/Bug68.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod M1()\n{\n  var m := map [{10, 20} := 33];\n  assert {10, 20} in m; // succeeds\n  print {10, 20} in m, \"\\n\"; // prints False\n}\n\nmethod M1'()\n{\n  var m := map [{10, 20} := 33];\n  assert {10, 20} == {20, 10};\n  assert {20, 10} in m; // succeeds\n  print {20, 10} in m, \"\\n\"; // prints False\n}\n\nmethod M2()\n{\n  var m := map [(map [1 := 10, 2 := 20]) := 33];\n  assert (map [1 := 10, 2 := 20]) in m; // succeeds\n  print (map [1 := 10, 2 := 20]) in m, \"\\n\"; // prints False\n}\n\nmethod M2'()\n{\n  var m := map [(map [1 := 10, 2 := 20]) := 33];\n  assert (map [1 := 10, 2 := 20] == map [2 := 20, 1 := 10]);\n  assert (map [2 := 20, 1 := 10]) in m; // succeeds\n  print (map [2 := 20, 1 := 10]) in m, \"\\n\"; // prints False\n}\n\nmethod M3()\n{\n  var m := map [(multiset{10, 20}) := 33];\n  assert (multiset{10, 20}) in m; // succeeds\n  print (multiset{10, 20}) in m, \"\\n\"; // prints False\n}\n\nmethod M3'()\n{\n  var m := map [(multiset{10, 20}) := 33];\n  assert multiset{10, 20} == multiset{20, 10};\n  assert (multiset{20, 10}) in m; // succeeds\n  print (multiset{20, 10}) in m, \"\\n\"; // prints False\n}\n\nmethod M4()\n{\n  var m := map [[10, 20] := 33];\n  assert [10, 20] in m; // succeeds\n  print [10, 20] in m, \"\\n\"; // prints False\n}\n\nmethod Main()\n{\n  M1();\n  M1'();\n  M2();\n  M2'();\n  M3();\n  M3'();\n  M4();\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue2.dfy", "dafny": "// RUN: %dafny /rprint:\"%t.rprint\" /print:\"%t.print\" /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype sp_state\ntype operand = int\n\nghost function sp_op_const(c:int) : int { c }\n\nghost predicate {:opaque} InBounds(s:sp_state, o:operand, v:int)\n{\n    0 <= o < 0x1_0000_0000\n}\n\nlemma lemma_K_InBounds()\n    ensures forall s:sp_state ::\n                InBounds(s, sp_op_const(0x428a2f98), 0x428a2f98) &&\n                InBounds(s, sp_op_const(0x71374491), 0x71374491) &&\n                InBounds(s, sp_op_const(0xb5c0fbcf), 0xb5c0fbcf) &&\n                InBounds(s, sp_op_const(0xe9b5dba5), 0xe9b5dba5) &&\n                InBounds(s, sp_op_const(0x3956c25b), 0x3956c25b) &&\n                InBounds(s, sp_op_const(0x59f111f1), 0x59f111f1) &&\n                InBounds(s, sp_op_const(0x923f82a4), 0x923f82a4) &&\n                InBounds(s, sp_op_const(0xab1c5ed5), 0xab1c5ed5) &&\n                InBounds(s, sp_op_const(0xd807aa98), 0xd807aa98) &&\n                InBounds(s, sp_op_const(0x12835b01), 0x12835b01) &&\n                InBounds(s, sp_op_const(0x243185be), 0x243185be) &&\n                InBounds(s, sp_op_const(0x550c7dc3), 0x550c7dc3) &&\n                InBounds(s, sp_op_const(0x72be5d74), 0x72be5d74) &&\n                InBounds(s, sp_op_const(0x80deb1fe), 0x80deb1fe) &&\n                InBounds(s, sp_op_const(0x9bdc06a7), 0x9bdc06a7) &&\n                InBounds(s, sp_op_const(0xc19bf174), 0xc19bf174) &&\n                InBounds(s, sp_op_const(0xe49b69c1), 0xe49b69c1) &&\n                InBounds(s, sp_op_const(0xefbe4786), 0xefbe4786) &&\n                InBounds(s, sp_op_const(0x0fc19dc6), 0x0fc19dc6) &&\n                InBounds(s, sp_op_const(0x240ca1cc), 0x240ca1cc) &&\n                InBounds(s, sp_op_const(0x2de92c6f), 0x2de92c6f) &&\n                InBounds(s, sp_op_const(0x4a7484aa), 0x4a7484aa) &&\n                InBounds(s, sp_op_const(0x5cb0a9dc), 0x5cb0a9dc) &&\n                InBounds(s, sp_op_const(0x76f988da), 0x76f988da) &&\n                InBounds(s, sp_op_const(0x983e5152), 0x983e5152) &&\n                InBounds(s, sp_op_const(0xa831c66d), 0xa831c66d) &&\n                InBounds(s, sp_op_const(0xb00327c8), 0xb00327c8) &&\n                InBounds(s, sp_op_const(0xbf597fc7), 0xbf597fc7) &&\n                InBounds(s, sp_op_const(0xc6e00bf3), 0xc6e00bf3) &&\n                InBounds(s, sp_op_const(0xd5a79147), 0xd5a79147) &&\n                InBounds(s, sp_op_const(0x06ca6351), 0x06ca6351) &&\n                InBounds(s, sp_op_const(0x14292967), 0x14292967) &&\n                InBounds(s, sp_op_const(0x27b70a85), 0x27b70a85) &&\n                InBounds(s, sp_op_const(0x2e1b2138), 0x2e1b2138) &&\n                InBounds(s, sp_op_const(0x4d2c6dfc), 0x4d2c6dfc) &&\n                InBounds(s, sp_op_const(0x53380d13), 0x53380d13) &&\n                InBounds(s, sp_op_const(0x650a7354), 0x650a7354) &&\n                InBounds(s, sp_op_const(0x766a0abb), 0x766a0abb) &&\n                InBounds(s, sp_op_const(0x81c2c92e), 0x81c2c92e) &&\n                InBounds(s, sp_op_const(0x92722c85), 0x92722c85) &&\n                InBounds(s, sp_op_const(0xa2bfe8a1), 0xa2bfe8a1) &&\n                InBounds(s, sp_op_const(0xa81a664b), 0xa81a664b) &&\n                InBounds(s, sp_op_const(0xc24b8b70), 0xc24b8b70) &&\n                InBounds(s, sp_op_const(0xc76c51a3), 0xc76c51a3) &&\n                InBounds(s, sp_op_const(0xd192e819), 0xd192e819) &&\n                InBounds(s, sp_op_const(0xd6990624), 0xd6990624) &&\n                InBounds(s, sp_op_const(0xf40e3585), 0xf40e3585) &&\n                InBounds(s, sp_op_const(0x106aa070), 0x106aa070) &&\n                InBounds(s, sp_op_const(0x19a4c116), 0x19a4c116) &&\n                InBounds(s, sp_op_const(0x1e376c08), 0x1e376c08) &&\n                InBounds(s, sp_op_const(0x2748774c), 0x2748774c) &&\n                InBounds(s, sp_op_const(0x34b0bcb5), 0x34b0bcb5) &&\n                InBounds(s, sp_op_const(0x391c0cb3), 0x391c0cb3) &&\n                InBounds(s, sp_op_const(0x4ed8aa4a), 0x4ed8aa4a) &&\n                InBounds(s, sp_op_const(0x5b9cca4f), 0x5b9cca4f) &&\n                InBounds(s, sp_op_const(0x682e6ff3), 0x682e6ff3) &&\n                InBounds(s, sp_op_const(0x748f82ee), 0x748f82ee) &&\n                InBounds(s, sp_op_const(0x78a5636f), 0x78a5636f) &&\n                InBounds(s, sp_op_const(0x84c87814), 0x84c87814) &&\n                InBounds(s, sp_op_const(0x8cc70208), 0x8cc70208) &&\n                InBounds(s, sp_op_const(0x90befffa), 0x90befffa) &&\n                InBounds(s, sp_op_const(0xa4506ceb), 0xa4506ceb) &&\n                InBounds(s, sp_op_const(0xbef9a3f7), 0xbef9a3f7) &&\n                InBounds(s, sp_op_const(0xc67178f2), 0xc67178f2)\n{ reveal_InBounds(); }\n\n\n\n"}
{"file": "../dafny/Test/dafny4/Bug122.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Try (a:int)\n{\n\tforall\n    ensures a == a\n\t{\n\t}\n}\n\n\n\n\n\n\n\n"}
{"file": "../dafny/Test/dafny4/git-issue104.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\npredicate bug(a: array<int>)\n  reads a\n{\n  forall i, j | 0 <= i <= j < a.Length :: a[i] <= a[j]\n}\n\nmethod Main() {\n  var a := new int[25](i => 2*i + 3);\n  var b := new int[25](i => var u := 2*i + 3; if i == 7 then 2 else u);\n  var c0 := bug(a);\n  var c1 := bug(b);\n  print c0, \" \", c1, \"\\n\"; // true false\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue41.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype uint32 = i:int | 0 <= i < 0x1_0000_0000\n\nghost function last<T>(s:seq<T>):T\n    requires |s| > 0;\n{\n    s[|s|-1]\n}\n\nghost function all_but_last<T>(s:seq<T>):seq<T>\n    requires |s| > 0;\n    ensures  |all_but_last(s)| == |s| - 1;\n{\n    s[..|s|-1]\n}\n\nghost function ConcatenateSeqs<T>(ss:seq<seq<T>>) : seq<T>\n{\n    if |ss| == 0 then [] else ss[0] + ConcatenateSeqs(ss[1..])\n}\n\nlemma {:axiom} lemma_ReverseConcatenateSeqs<T>(ss:seq<seq<T>>)\n    requires |ss| > 0;\n    ensures  ConcatenateSeqs(ss) == ConcatenateSeqs(all_but_last(ss)) + last(ss);\n\nlemma Test(word_seqs:seq<seq<uint32>>, words:seq<uint32>)\n{\n    var word_seqs' := word_seqs + [words];\n\n    calc {\n        ConcatenateSeqs(word_seqs');\n            { lemma_ReverseConcatenateSeqs(word_seqs'); }\n        ConcatenateSeqs(all_but_last(word_seqs')) + last(word_seqs');\n    }\n}\n\nlemma AltTest(word_seqs:seq<seq<uint32>>, words:seq<uint32>)\n{\n    var word_seqs' := word_seqs + [words];\n    assert last(word_seqs') == words;\n    assert ConcatenateSeqs(word_seqs) + last(word_seqs') == ConcatenateSeqs(word_seqs) + words;\n}\n\nghost function f<T>(s:seq<T>):seq<T>\n\nghost function g<T>(ss:seq<seq<T>>) : seq<T>\n\nlemma {:axiom} lemma_fg<T>(s:seq<seq<T>>)\n    ensures  g(s) == g(f(s));\n\nlemma Test2(s:seq<seq<uint32>>)\n{\n    calc {\n        g(s);\n            { lemma_fg(s); }\n        g(f(s));\n    }\n}\n\nlemma AltTest2(s:seq<seq<uint32>>)\n{\n    lemma_fg(s);\n    assert g(s) == g(f(s));\n}\n\n"}
{"file": "../dafny/Test/dafny4/Bug150.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function foo(s:seq<int>) : (int, int)\n{\n  (0, 0)\n}\n\nmethod pop_run_impl() {\n  var a := new int[10];\n  var i := 0;\n  ghost var (x,y) := foo(a[..i+1]);\n}"}
{"file": "../dafny/Test/dafny4/Bug151.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod foo(xs: set) {\n   assert (set x | x in xs) == xs;\n}\n\nmethod bar(xs: iset) {\n   assert (iset x | x in xs) == xs;\n}\n\nghost function domain<U, V>(m: map<U,V>): set<U>\n   ensures forall i :: i in domain(m) ==> i in m\n   ensures forall i :: i in domain(m) <== i in m\n{\n   set s | s in m\n}\n\nghost function idomain<U, V>(m: imap<U,V>): iset<U>\n   ensures forall i :: i in idomain(m) ==> i in m\n   ensures forall i :: i in idomain(m) <== i in m\n{\n   iset s | s in m\n}\n\nmethod foo2(xs: map) {\n\t  assert (set x | x in xs) == domain(xs);\n}\n\nmethod bar2(xs: imap) {\n\t  assert (iset x | x in xs) == idomain(xs);\n}\n"}
{"file": "../dafny/Test/dafny4/NumberRepresentations.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// We consider a number representation that consists of a sequence of digits.  The least\n// significant digit is stored at index 0.\n// For a given base, function eval gives the number that is represented.  Note\n// that eval can be defined without regard to the sign or magnitude of the digits.\n\nghost function eval(digits: seq<int>, base: int): int\n  requires 2 <= base\n  decreases digits  // see comment in test_eval()\n{\n  if |digits| == 0 then 0 else digits[0] + base * eval(digits[1..], base)\n}\n\nlemma test_eval()\n{\n  assert forall base :: 2 <= base ==> eval([], base) == 0;\n  assert forall base :: 2 <= base ==> eval([0], base) == 0;\n\n  // To prove this automatically, it is necessary that the Lit axiom is sensitive only to the\n  // 'digits' argument being a literal.  Hence, the explicit 'decreases digits' clause on the\n  // 'eval' function.\n  assert forall base :: 2 <= base ==> eval([0, 0], base) == 0;\n\n  assert eval([3, 2], 10) == 23;\n\n  var oct, dec := 8, 10;\n  assert eval([1, 3], oct) == eval([5, 2], dec);\n\n  assert eval([29], 420) == 29;\n  assert eval([29], 8) == 29;\n\n  assert eval([-2, 1, -3], 5) == -72;\n}\n\n// To achieve a unique (except for leading zeros) representation of each number, we\n// consider digits that are drawn from a consecutive range of \"base\" integers\n// including 0.  That is, each digit lies in the half-open interval [lowDigit..lowDigit+base].\n\nghost predicate IsSkewNumber(digits: seq<int>, lowDigit: int, base: int)\n{\n  2 <= base &&  // there must be at least two distinct digits in the number representation\n  lowDigit <= 0 < lowDigit + base &&  // digits must include 0\n  forall i :: 0 <= i < |digits| ==> lowDigit <= digits[i] < lowDigit + base  // every digit is in this range\n}\n\n// The following theorem says that any natural number is representable as a sequence\n// of digits in the range [0..base].\n\nlemma CompleteNat(n: nat, base: int) returns (digits: seq<int>)\n  requires 2 <= base\n  ensures IsSkewNumber(digits, 0, base) && eval(digits, base) == n\n{\n  if n < base {\n    digits := [n];\n  } else {\n    var d, m := n / base, n % base;\n    assert base * d + m == n;\n    DivIsLess(n, base, d);\n    assert d < n && 0 <= m;\n    digits := CompleteNat(d, base);\n    digits := [m] + digits;\n  }\n}\n\nlemma DivIsLess(n: nat, base: int, d: int)\n  requires 2 <= base <= n && d == n / base\n  ensures d < n\n{\n  var m := n % base;\n  if n <= d {\n    calc {\n      base * d + m == n;\n    ==> { assert 0 <= m; }\n      base * d <= n;\n    ==> { assert n <= d; MulIsMonotonic(base, n, d); }\n      base * n <= n;\n      (base - 1) * n + n <= n;\n      (base - 1) * n <= 0;\n    ==> { assert (base - 1) * n <= 0; MulSign(base - 1, n); }\n      (base - 1) <= 0 || n <= 0;\n    ==  { assert 0 < n; }\n      (base - 1) <= 0;\n    ==  { assert 2 <= base; }\n      false;\n    }\n    assert false;\n  }\n}\n\n// we used the following lemma to prove the theorem above\nlemma MulSign(x: int, y: int)\n  requires x * y <= 0\n  ensures x <= 0 || y <= 0\n{\n}\n\n// The following theorem says that, provided there's some digit with the same sign as \"n\",\n// then \"n\" can be represented.\n\nlemma Complete(n: int, lowDigit: int, base: int) returns (digits: seq<int>)\n  requires 2 <= base && lowDigit <= 0 < lowDigit + base\n  requires 0 <= lowDigit ==> 0 <= n  // without negative digits, only non-negative numbers can be formed\n  requires lowDigit + base <= 1 ==> n <= 0  // without positive digits, only positive numbers can be formed\n  ensures IsSkewNumber(digits, lowDigit, base) && eval(digits, base) == n\n  decreases if 0 <= n then n else -n\n{\n  if lowDigit <= n < lowDigit + base{\n    digits := [n];\n  } else if 0 < n {\n    digits := Complete(n - 1, lowDigit, base);\n    digits := inc(digits, lowDigit, base);\n  } else {\n    digits := Complete(n + 1, lowDigit, base);\n    digits := dec(digits, lowDigit, base);\n  }\n}\n\nlemma inc(a: seq<int>, lowDigit: int, base: int) returns (b: seq<int>)\n  requires IsSkewNumber(a, lowDigit, base)\n  requires eval(a, base) == 0 ==> 1 < lowDigit + base\n  ensures IsSkewNumber(b, lowDigit, base) && eval(b, base) == eval(a, base) + 1\n{\n  if a == [] {\n    b := [1];\n  } else if a[0] + 1 < lowDigit + base {\n    b := a[0 := a[0] + 1];\n  } else {\n    // here's what we know about a:\n    assert A: a[0] + 1 == lowDigit + base;\n    var a' := a[1..];\n    assert eval(a, base) == a[0] + base * eval(a', base);\n\n    var b' := inc(a', lowDigit, base);\n    assert eval(b', base) == eval(a', base) + 1;\n\n    b := [lowDigit] + b';\n    assert IsSkewNumber(b, lowDigit, base);\n\n    calc {\n      eval(b, base);\n    ==  // def. eval\n      b[0] + base * eval(b[1..], base);\n    ==  { assert b[0] == lowDigit; }\n      lowDigit + base * eval(b[1..], base);\n    ==  { assert b[1..] == b'; }\n      lowDigit + base * eval(b', base);\n    ==  { assert eval(b', base) == eval(a', base) + 1; }\n      lowDigit + base * (eval(a', base) + 1);\n      lowDigit + base * eval(a', base) + base;\n    ==  { reveal A; }\n      a[0] + base * eval(a', base) + 1;\n    ==  // def. eval\n      eval(a, base) + 1;\n    }\n  }\n}\n\nlemma dec(a: seq<int>, lowDigit: int, base: int) returns (b: seq<int>)\n  requires IsSkewNumber(a, lowDigit, base)\n  requires eval(a, base) == 0 ==> lowDigit < 0\n  ensures IsSkewNumber(b, lowDigit, base) && eval(b, base) == eval(a, base) - 1\n{\n  if a == [] {\n    b := [-1];\n  } else if lowDigit <= a[0] - 1 {\n    b := a[0 := a[0] - 1];\n  } else {\n    b := dec(a[1..], lowDigit, base);\n    b := [lowDigit + base - 1] + b;\n  }\n}\n\n// Finally, we prove that number representations are unique, except for leading zeros.\n// Recall, a \"leading\" zero is one at the end of the sequence.\n\n// The trim function removes any leading zeros.\n\nghost function trim(digits: seq<int>): seq<int>\n{\n  if |digits| != 0 && digits[|digits| - 1] == 0 then trim(digits[..|digits|-1]) else digits\n}\n\n// Here follow a number of lemmas about trim\n\nlemma TrimResult(digits: seq<int>)\n  ensures var last := |trim(digits)| - 1;\n    0 <= last ==> trim(digits)[last] != 0\n{\n}\n\nlemma TrimProperty(a: seq<int>)\n  requires a == trim(a)\n  ensures a == [] || a[1..] == trim(a[1..])\n{\n  assert forall b {:induction} :: |trim(b)| <= |b|;\n}\n\nlemma TrimPreservesValue(digits: seq<int>, base: int)\n  requires 2 <= base\n  ensures eval(digits, base) == eval(trim(digits), base)\n{\n  var last := |digits| - 1;\n  if |digits| != 0 && digits[last] == 0 {\n    assert digits == digits[..last] + [0];\n    LeadingZeroInsignificant(digits[..last], base);\n  }\n}\n\nlemma LeadingZeroInsignificant(digits: seq<int>, base: int)\n  requires 2 <= base\n  ensures eval(digits, base) == eval(digits + [0], base)\n{\n  if |digits| != 0 {\n    var d := digits[0];\n    assert [d] + digits[1..] == digits;\n    calc {\n      eval(digits, base);\n      eval([d] + digits[1..], base);\n      d + base * eval(digits[1..], base);\n      { LeadingZeroInsignificant(digits[1..], base); }\n      d + base * eval(digits[1..] + [0], base);\n      eval([d] + (digits[1..] + [0]), base);\n      { assert [d] + (digits[1..] + [0]) == ([d] + digits[1..]) + [0]; }\n      eval(([d] + digits[1..]) + [0], base);\n      eval(digits + [0], base);\n    }\n  }\n}\n\n// We now get on with proving the uniqueness of the representation\n\nlemma UniqueRepresentation(a: seq<int>, b: seq<int>, lowDigit: int, base: int)\n  requires IsSkewNumber(a, lowDigit, base) && IsSkewNumber(b, lowDigit, base)\n  requires a == trim(a) && b == trim(b)\n  requires eval(a, base) == eval(b, base)\n  ensures a == b\n{\n  if eval(a, base) == 0 {\n    ZeroIsUnique(a, lowDigit, base);\n    ZeroIsUnique(b, lowDigit, base);\n  } else {\n    var aa, bb := eval(a, base), eval(b, base);\n    var arest, brest := a[1..], b[1..];\n    var ma, mb := aa % base, bb % base;\n\n    assert 0 <= ma < base && 0 <= mb < base;\n    LeastSignificantDigitIsAlmostMod(a, lowDigit, base);\n    LeastSignificantDigitIsAlmostMod(b, lowDigit, base);\n    assert ma == mb && a[0] == b[0];\n    var y := a[0];\n\n    assert aa == base * eval(arest, base) + y;\n    assert bb == base * eval(brest, base) + y;\n    MulInverse(base, eval(arest, base), eval(brest, base), y);\n    assert eval(arest, base) == eval(brest, base);\n\n    TrimProperty(a);\n    TrimProperty(b);\n    UniqueRepresentation(arest, brest, lowDigit, base);\n    assert [y] + arest == a && [y] + brest == b;\n  }\n}\n\nlemma {:induction false} ZeroIsUnique(a: seq<int>, lowDigit: int, base: int)\n  requires IsSkewNumber(a, lowDigit, base)\n  requires T: a == trim(a)\n  requires E0: eval(a, base) == 0\n  ensures a == []\n{\n  if a != [] {\n    var a1 := eval(a[1..], base);\n    var b := base * a1;\n    assert a[0] + b == eval(a, base);\n\n    assert R: -base < lowDigit <= a[0] < lowDigit + base <= base by {\n      assert a[0] in a;\n    }\n\n    // next, consider three cases: a1 is negative, a1 is 0, a1 is positive\n\n    calc {\n      a1 <= -1;\n    ==> { MulIsMonotonic(base, a1, -1); }  // multiply both sides by base\n      base * a1 <= base * -1;\n    ==>  { assert base * a1 == b; }\n      b <= base * -1;\n    ==  // add a[0] to both sides\n      a[0] + b <= a[0] - base;\n    ==  { reveal E0; }\n      0 <= a[0] - base;\n    ==\n      base <= a[0];\n    ==>  { reveal R; }\n      false;\n    }\n\n    calc {\n      1 <= a1;\n    ==> { MulIsMonotonic(base, 1, a1); }  // multiply both sides by base\n      base * 1 <= base * a1;\n    ==  { assert base * 1 == base; }\n      base <= base * a1;\n    ==  // add a[0] to both sides\n      a[0] + base <= a[0] + base * a1;\n    ==  { reveal E0; }\n      a[0] + base <= 0;\n    ==\n      a[0] <= -base;\n    ==>  { reveal R; }\n      false;\n    }\n\n    if a1 == 0 {\n      assert |a| == 1 by {\n        assert IsSkewNumber(a[1..], lowDigit, base) by {\n          assert forall d :: d in a[1..] ==> d in a;\n        }\n        assert a[1..] == trim(a[1..]) by {\n          reveal T;\n          TrimProperty(a);\n        }\n        ZeroIsUnique(a[1..], lowDigit, base);\n      }\n\n      calc {\n        true;\n      ==\n        a1 == 0;\n      ==>  // multiply both sides by base\n        base * a1 == 0;\n      ==  // add a[0] to both sides\n        a[0] + base * a1 == a[0];\n      ==  { reveal E0; }\n        0 == a[0];\n      }\n\n      calc {\n        a;\n      ==  { reveal T; }\n        trim(a);\n      ==  // def. trim\n        if |a| != 0 && a[|a| - 1] == 0 then trim(a[..|a|-1]) else a;\n      ==  { assert |a| == 1; }\n        if a[0] == 0 then trim(a[..0]) else a;\n      ==  { assert a[0] == 0; }\n        trim(a[..0]);\n      ==  { assert a[..0] == []; }\n        trim([]);\n      ==  // def. trim\n        [];\n      !=\n        a;\n      }\n    }\n  }\n}\n\nlemma LeastSignificantDigitIsAlmostMod(a: seq<int>, lowDigit: int, base: int)\n  requires IsSkewNumber(a, lowDigit, base)\n  requires a != []\n  ensures var mod := eval(a, base) % base;\n    a[0] == mod || a[0] == mod - base\n{\n  if 0 <= a[0] {\n    LeastSignificantDigitIsAlmostMod_Pos(a, lowDigit, base);\n  } else {\n    LeastSignificantDigitIsAlmostMod_Neg(a, lowDigit, base);\n  }\n}\n\nlemma LeastSignificantDigitIsAlmostMod_Pos(a: seq<int>, lowDigit: int, base: int)\n  requires IsSkewNumber(a, lowDigit, base)\n  requires a != [] && 0 <= a[0]\n  ensures eval(a, base) % base == a[0]\n{\n  var n := eval(a, base);\n  var a1 := eval(a[1..], base);\n  var b := base * a1;\n  assert a[0] + b == n;\n\n  calc {\n    n % base;\n  ==\n    (a[0] + base * a1) % base;\n  ==  { ModProperty(a[0], a1, base); }\n    a[0] % base;\n  ==  { assert a[0] in a; ModNoop(a[0], base); }\n    a[0];\n  }\n}\n\nlemma LeastSignificantDigitIsAlmostMod_Neg(a: seq<int>, lowDigit: int, base: int)\n  requires IsSkewNumber(a, lowDigit, base)\n  requires a != [] && a[0] < 0\n  ensures eval(a, base) % base == a[0] + base\n{\n  var n := eval(a, base);\n  var a1 := eval(a[1..], base);\n  var b := base * a1;\n  assert a[0] + b == n;\n\n  var aPlus, a1minus := a[0] + base, a1 - 1;\n  calc {\n    n % base;\n  ==\n    (a[0] + base * a1) % base;\n  ==  { assert base * a1 == base + base * a1minus; }\n    (a[0] + (base + base * a1minus)) % base;\n  ==\n    ((a[0] + base) + base * a1minus) % base;\n  ==  { ModProperty(a[0] + base, a1minus, base); }\n    (a[0] + base) % base;\n  ==  { assert a[0] in a; ModNoop(a[0] + base, base); }\n    a[0] + base;\n  }\n}\n\n\nlemma ModProperty(n: int, k: int, base: int)\n  requires 2 <= base\n  ensures (n + base * k) % base == n % base\n{\n  var d, m := n / base, n % base;\n  assert base * d + m == n;\n  assert R: 0 <= m < base;\n\n  var n' := n + base * k;\n  var d', m' := n' / base, n' % base;\n  assert base * d' + m' == n';\n  assert R': 0 <= m' < base;\n\n  assert -base < m' - m < base by {\n    reveal R, R';\n  }\n\n  var y := m' - base * k;\n  var p := MulProperty(base, d, m, d', y);\n  var pk := p + k;\n  calc {\n    true;\n    // postcondition of MulProperty\n    y - m == base * p;\n    // def. m'\n    m' - base * k - m == base * p;\n    // add base*k to both sides\n    m' - m == base * p + base * k;\n    // distribute * and +\n    m' - m == base * pk;\n  }\n  if\n  case pk < 0 =>\n    MulIsMonotonic(base, pk, -1);\n    assert base * pk <= -base;\n    assert false;\n  case 0 < pk =>\n    MulIsMonotonic(base, 1, pk);\n    assert base <= base * pk;\n    assert false;\n  case pk == 0 =>\n    assert base * pk == 0;\n    assert m' == m;\n}\n\nlemma MulIsMonotonic(a: int, x: int, y: int)\n  requires 0 <= a && x <= y\n  ensures a * x <= a * y\n{\n}\n\n// This axiom about % is needed.  Unfortunately, Z3 v.4.8.9 seems incapable of proving it.\nlemma ModNoop(a: int, b: int)\n  requires 0 <= a < b\n  ensures a % b == a\n\nlemma MulProperty(k: int, a: int, x: int, b: int, y: int) returns (p: int)\n  requires 0 < k\n  requires k * a + x == k * b + y\n  ensures y - x == k * p\n{\n  calc {\n    k * a + x == k * b + y;\n    k * a - k * b == y - x;\n    k * (a - b) == y - x;\n  }\n  p := a - b;\n}\n\nlemma MulInverse(x: int, a: int, b: int, y: int)\n  requires x != 0 && x * a + y == x * b + y\n  ensures a == b\n{\n}\n"}
{"file": "../dafny/Test/dafny4/Bug56.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function I(f:int->bool):int->bool\n    ensures I(f) == f;\n\nghost predicate G<S>(s:S)\n\ntype D<X>\ntype E\n\nlemma L1<S>(b:int->S)\n    requires forall i :: b.reads(i) == {};\n    requires forall i :: b.requires(i);\n    requires I(j => G(b(j)))(0); // PRECONDITION NOT SATISFIED BY L2\n\nlemma L2(b:int->D<E>)\n    requires forall i :: b.reads(i) == {};\n    requires forall i :: b.requires(i);\n    requires I(j => G(b(j)))(0);\n{\n    L1(b); // FAILS TO SATISFY L1's PRECONDITION\n}\n"}
{"file": "../dafny/Test/dafny4/Bug118.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Foo {\n  ghost var Repr: set<object>\n}\n\nghost function SeqRepr(s:seq<Foo>) : set<object>\n  reads set b | b in s\n{\n  set o,b | b in s && o in b.Repr :: o     // Works if you say \"set b,o | ...\"\n}\n"}
{"file": "../dafny/Test/dafny4/KozenSilva.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Dafny versions of examples from \"Practical Coinduction\" by Kozen and Silva.\n// The comments in this file explain some things about Dafny and its support for\n// co-induction; for a full description, see \"Co-induction Simply\" by Leino and\n// Moskal.\n\n// In Dafny, a co-inductive datatype is declared like an inductive datatype, but\n// using the keyword \"codatatype\" instead of \"datatype\".  The definition lists the\n// constructors of the co-datatype (here, Cons) and has the option of naming\n// destructors (here, hd and tl).  Here and in some other signatures, the type\n// argument to Stream can be omitted, because Dafny fills it in automatically.\n\ncodatatype Stream<A> = Cons(hd: A, tl: Stream)\n\n// --------------------------------------------------------------------------\n\n// A co-predicate is defined as a largest fix-point.\ngreatest predicate LexLess[nat](s: Stream<int>, t: Stream<int>)\n{\n  s.hd <= t.hd &&\n  (s.hd == t.hd ==> LexLess(s.tl, t.tl))\n}\n\n// A co-lemma is used to establish the truth of a co-predicate.\ngreatest lemma Theorem1_LexLess_Is_Transitive[nat](s: Stream<int>, t: Stream<int>, u: Stream<int>)\n  requires LexLess(s, t) && LexLess(t, u)\n  ensures LexLess(s, u)\n{\n  // Here is the proof, which is actually a body of code.  It lends itself to a\n  // simple, intuitive co-inductive reading.  For a theorem this simple, this simple\n  // reading is all you need.  To understand more complicated examples, or to see\n  // what's actually going on under the hood, it's best to read the \"Co-induction\n  // Simply\" paper.\n  if s.hd == u.hd {\n    Theorem1_LexLess_Is_Transitive(s.tl, t.tl, u.tl);\n  }\n}\n\n// Actually, Dafny can do the proof of the previous lemma completely automatically.  Here it is:\ngreatest lemma Theorem1_LexLess_Is_Transitive_Automatic[nat](s: Stream<int>, t: Stream<int>, u: Stream<int>)\n  requires LexLess(s, t) && LexLess(t, u)\n  ensures LexLess(s, u)\n{\n  // no manual proof needed, so the body of the co-lemma is empty\n}\n\n// The following predicate captures the (inductively defined) negation of (the\n// co-inductively defined) LexLess above.\nghost predicate NotLexLess(s: Stream<int>, t: Stream<int>)\n{\n  exists k: nat :: NotLexLess'(k, s, t)\n}\nghost predicate NotLexLess'(k: nat, s: Stream<int>, t: Stream<int>)\n{\n  if k == 0 then false else\n    !(s.hd <= t.hd) || (s.hd == t.hd && NotLexLess'(k-1, s.tl, t.tl))\n}\n\nlemma EquivalenceTheorem(s: Stream<int>, t: Stream<int>)\n  ensures LexLess(s, t) <==> !NotLexLess(s, t)\n{\n  if !NotLexLess(s, t) {\n    EquivalenceTheorem0(s, t);\n  }\n  if LexLess(s, t) {\n    EquivalenceTheorem1(s, t);\n  }\n}\ngreatest lemma EquivalenceTheorem0[nat](s: Stream<int>, t: Stream<int>)\n  requires !NotLexLess(s, t)\n  ensures LexLess(s, t)\n{\n  // Here, more needs to be said about the way Dafny handles co-lemmas.\n  // The way a co-lemma establishes a co-predicate is to prove, by induction,\n  // that all finite unrollings of the co-predicate holds.  The unrolling\n  // depth is specified using an implicit parameter _k to the co-lemma.\n  EquivalenceTheorem0_Lemma(_k, s, t);\n}\n// The following lemma is an ordinary least lemma.  The syntax ...#[...]\n// indicates a finite unrolling of a co-least predicate.  In particular,\n// LexLess#[k] refers to k unrollings of LexLess.\nlemma EquivalenceTheorem0_Lemma(k: nat, s: Stream<int>, t: Stream<int>)\n  requires !NotLexLess'(k, s, t)\n  ensures LexLess#[k](s, t)\n{\n  // This simple inductive proof is done completely automatically by Dafny.\n}\nlemma EquivalenceTheorem1(s: Stream<int>, t: Stream<int>)\n  requires LexLess(s, t)\n  ensures !NotLexLess(s, t)\n{\n  // The forall statement in Dafny is used, here, as universal introduction:\n  // what EquivalenceTheorem1_Lemma establishes for one k, the forall\n  // statement establishes for all k.\n  forall k: nat {\n    EquivalenceTheorem1_Lemma(k, s, t);\n  }\n}\nlemma EquivalenceTheorem1_Lemma(k: nat, s: Stream<int>, t: Stream<int>)\n  requires LexLess(s, t)\n  ensures !NotLexLess'(k, s, t)\n{\n}\n\nlemma Theorem1_Alt(s: Stream<int>, t: Stream<int>, u: Stream<int>)\n  requires NotLexLess(s, u)\n  ensures NotLexLess(s, t) || NotLexLess(t, u)\n{\n  forall k: nat | NotLexLess'(k, s, u) {\n    Theorem1_Alt_Lemma(k, s, t, u);\n  }\n}\nlemma Theorem1_Alt_Lemma(k: nat, s: Stream<int>, t: Stream<int>, u: Stream<int>)\n  requires NotLexLess'(k, s, u)\n  ensures NotLexLess'(k, s, t) || NotLexLess'(k, t, u)\n{\n}\n\nghost function PointwiseAdd(s: Stream<int>, t: Stream<int>): Stream<int>\n{\n  Cons(s.hd + t.hd, PointwiseAdd(s.tl, t.tl))\n}\n\ngreatest lemma Theorem2_Pointwise_Addition_Is_Monotone[nat](s: Stream<int>, t: Stream<int>, u: Stream<int>, v: Stream<int>)\n  requires LexLess(s, t) && LexLess(u, v)\n  ensures LexLess(PointwiseAdd(s, u), PointwiseAdd(t, v))\n{\n  // The co-lemma will establish the co-least predicate by establishing\n  // all finite unrollings thereof.  Each finite unrolling is proved by\n  // induction, and this induction is performed automatically by Dafny.  Thus,\n  // the proof of this co-lemma is trivial (that is, the body of the co-lemma\n  // is empty).\n}\n\n// --------------------------------------------------------------------------\n\n// The declaration of an (inductive or co-inductive) datatype in Dafny automatically\n// gives rise to the declaration of a discriminator for each constructor.  The name\n// of such a discriminator is the name of the constructor plus a question mark (that\n// is, the question mark is part of the identifier that names the discriminator).\n// For example, the boolean expression r.Arrow? returns whether or not a RecType r\n// has been constructed by the Arrow constructor.  One can of course also use a\n// match expression or match statement for this purpose, but for whatever reason, I\n// didn't do so in this file.  Note that the precondition of the access r.dom is\n// r.Arrow?.  Also, for a parameter-less constructor like Bottom, a use of the\n// discriminator like r.Bottom? is equivalent to r == Bottom.\ncodatatype RecType = Bottom | Top | Arrow(dom: RecType, ran: RecType)\n\ngreatest predicate Subtype(a: RecType, b: RecType)\n{\n  a == Bottom ||\n  b == Top ||\n  (a.Arrow? && b.Arrow? && Subtype(b.dom, a.dom) && Subtype(a.ran, b.ran))\n}\n\ngreatest lemma Theorem3_Subtype_Is_Transitive(a: RecType, b: RecType, c: RecType)\n  requires Subtype(a, b) && Subtype(b, c)\n  ensures Subtype(a, c)\n{\n}\n\n// --------------------------------------------------------------------------\n\n// Closure Conversion\n\ntype Const    // uninterpreted type (the details are not important here)\ntype Var(==)  // uninterpreted type that supports equality\ndatatype Term = TermConst(Const) | TermVar(Var) | TermAbs(abs: LambdaAbs)\ndatatype LambdaAbs = Fun(v: Var, body: Term)\ncodatatype Val = ValConst(Const) | ValCl(cl: Cl)\ncodatatype Cl = Closure(abs: LambdaAbs, env: ClEnv)\ncodatatype ClEnv = ClEnvironment(m: map<Var, Val>)  // The built-in Dafny \"map\" type denotes finite maps\n\ngreatest predicate ClEnvBelow[nat](c: ClEnv, d: ClEnv)\n{\n  // The expression \"y in c.m\" says that y is in the domain of the finite map\n  // c.m.\n  forall y :: y in c.m ==> y in d.m && ValBelow(c.m[y], d.m[y])\n}\ngreatest predicate ValBelow[nat](u: Val, v: Val)\n{\n  (u.ValConst? && v.ValConst? && u == v) ||\n  (u.ValCl? && v.ValCl? && u.cl.abs == v.cl.abs && ClEnvBelow(u.cl.env, v.cl.env))\n}\n\ngreatest lemma Theorem4a_ClEnvBelow_Is_Transitive[nat](c: ClEnv, d: ClEnv, e: ClEnv)\n  requires ClEnvBelow(c, d) && ClEnvBelow(d, e)\n  ensures ClEnvBelow(c, e)\n{\n  forall y | y in c.m {\n    Theorem4b_ValBelow_Is_Transitive#[_k-1](c.m[y], d.m[y], e.m[y]);\n  }\n}\ngreatest lemma Theorem4b_ValBelow_Is_Transitive[nat](u: Val, v: Val, w: Val)\n  requires ValBelow(u, v) && ValBelow(v, w)\n  ensures ValBelow(u, w)\n{\n  if u.ValCl? {\n    Theorem4a_ClEnvBelow_Is_Transitive(u.cl.env, v.cl.env, w.cl.env);\n  }\n}\n\ndatatype Capsule = Cap(e: Term, s: map<Var, ConstOrAbs>)\ndatatype ConstOrAbs = CC(c: Const) | AA(abs: LambdaAbs)\n\nghost predicate IsCapsule(cap: Capsule)\n{\n  cap.e.TermAbs?\n}\n\nghost function ClosureConversion(cap: Capsule): Cl\n  requires IsCapsule(cap)\n{\n  Closure(cap.e.abs, ClosureConvertedMap(cap.s))\n  // In the Kozen and Silva paper, there are more conditions, having to do with free variables,\n  // but, apparently, they don't matter for the theorems being proved here.\n}\nghost function ClosureConvertedMap(s: map<Var, ConstOrAbs>): ClEnv\n{\n  // The following line uses a map comprehension.  In the notation \"map y | D :: E\",\n  // D constrains the domain of the map to be all values of y satisfying D, and\n  // E says what a y in the domain maps to.\n  ClEnvironment(map y: Var | y in s :: if s[y].AA? then ValCl(Closure(s[y].abs, ClosureConvertedMap(s))) else ValConst(s[y].c))\n}\n\nghost predicate CapsuleEnvironmentBelow(s: map<Var, ConstOrAbs>, t: map<Var, ConstOrAbs>)\n{\n  forall y :: y in s ==> y in t && s[y] == t[y]\n}\n\ngreatest lemma Theorem5_ClosureConversion_Is_Monotone[nat](s: map<Var, ConstOrAbs>, t: map<Var, ConstOrAbs>)\n  requires CapsuleEnvironmentBelow(s, t)\n  ensures ClEnvBelow(ClosureConvertedMap(s), ClosureConvertedMap(t))\n{\n}\n\n// --------------------------------------------------------------------------\n\n// The following defines, co-inductively, a relation on streams.  The syntactic\n// shorthand in Dafny lets us omit the type parameter to Bisim and the (same)\n// type arguments in the types of s and t.  If we want to write this explicitly,\n// we would write:\n//    greatest predicate Bisim<A>(s: Stream<A>, t: Stream<A>)\n// which is equivalent.  (Being able to omit the arguments reduces clutter.  Note,\n// in a similar way, if one tells a colleague about Theorem 6, one can either\n// say the explicit \"Bisim on A-streams is a symmetric relation\" or, since the\n// A in that sentence is not used, \"Bisim on streams is a symmetric relation\".)\ngreatest predicate Bisim(s: Stream, t: Stream)\n{\n  s.hd == t.hd && Bisim(s.tl, t.tl)\n}\n\ngreatest lemma Theorem6_Bisim_Is_Symmetric(s: Stream, t: Stream)\n  requires Bisim(s, t)\n  ensures Bisim(t, s)\n{\n  // proof is automatic\n}\n\nghost function merge(s: Stream, t: Stream): Stream\n{\n  Cons(s.hd, merge(t, s.tl))\n}\n// SplitLeft and SplitRight are defined in terms of each other.  Because the\n// call to SplitRight in the body of SplitLeft is an argument to a co-constructor,\n// Dafny treats the call as a co-recurvie call.  A consequence of this is that\n// there is no proof obligation to show termination for that call.  However, the\n// call from SplitRight back to SplitLeft is an ordinary (mutually) recursive\n// call, and hence Dafny checks termination for it.\n// In general, the termination argument needs to be supplied explicitly in terms\n// of a metric, rank, variant function, or whatever you want to call it--a\n// \"decreases\" clause in Dafny.  Dafny provides some help in making up \"decreases\"\n// clauses, and in this case it automatically adds \"decreases 0\" to SplitLeft\n// and \"decreases 1\" to SplitRight.  With these \"decreases\" clauses, the\n// termination check of SplitRight's call to SplitLeft will simply be \"0 < 1\",\n// which is trivial to check.\nghost function SplitLeft(s: Stream): Stream\n{\n  Cons(s.hd, SplitRight(s.tl))\n}\nghost function SplitRight(s: Stream): Stream\n{\n  SplitLeft(s.tl)\n}\n\ngreatest lemma Theorem7_Merge_Is_Left_Inverse_Of_Split_Bisim(s: Stream)\n  ensures Bisim(merge(SplitLeft(s), SplitRight(s)), s)\n{\n  var LHS := merge(SplitLeft(s), SplitRight(s));\n  // The construct that follows is a \"calc\" statement.  It gives a way to write an\n  // equational proof.  Each line in the calculation is an expression that, on\n  // behalf of the given hint, is equal to the next line of the calculation.  In\n  // the first such step below, the hint is omitted (there's just an English\n  // comment, but Dafny ignores it, of course).  In the next two steps, the hint\n  // is itself a calculation.  In the last step, the hint is an invocation of\n  // the co-inductive hypothesis--that is, it is a call of the co-lemma itself.\n  calc {\n    Bisim#[_k](LHS, s);  // when all comes around, this is our proof goal:  Bisim unrolled _k times (where _k > 0)\n  ==  // def. Bisim (more precisely, def. Bisim#[_k] in terms of Bisim#[_k-1])\n    LHS.hd == s.hd && Bisim#[_k-1](LHS.tl, s.tl);\n  == calc {  // the left conjunct is easy to establish, so let's do that now\n       LHS.hd;\n       == merge(SplitLeft(s), SplitRight(s)).hd;\n       == SplitLeft(s).hd;\n       == s.hd;\n     }\n    Bisim#[_k-1](LHS.tl, s.tl);\n  == calc {  // let us massage the formula LHS.tl\n       LHS.tl;\n       == merge(SplitLeft(s), SplitRight(s)).tl;\n       == merge(SplitRight(s), SplitLeft(s).tl);\n       == merge(SplitLeft(s.tl), SplitRight(s.tl));\n     }\n    Bisim#[_k-1](merge(SplitLeft(s.tl), SplitRight(s.tl)), s.tl);  // this is the hypothesis on s.tl\n  == { Theorem7_Merge_Is_Left_Inverse_Of_Split_Bisim(s.tl); }\n    true;\n  }\n}\n\ngreatest lemma Theorem7_Merge_Is_Left_Inverse_Of_Split_Equal(s: Stream)\n  ensures merge(SplitLeft(s), SplitRight(s)) == s\n{\n  // The proof of this co-lemma is actually done completely automatically (so the\n  // body of this co-lemma can be empty).  However, just to show what the calculations\n  // would look like in a hand proof, here they are:\n  calc {\n    merge(SplitLeft(s), SplitRight(s)).hd;\n  ==\n    SplitLeft(s).hd;\n  ==\n    s.hd;\n  }\n  calc {\n    merge(SplitLeft(s), SplitRight(s)).tl;\n  ==\n    merge(SplitRight(s), SplitLeft(s).tl);\n  ==\n    merge(SplitLeft(s.tl), SplitRight(s.tl));\n  ==#[_k-1]  { Theorem7_Merge_Is_Left_Inverse_Of_Split_Equal(s.tl); }\n    s.tl;\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue4.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nfunction IntToChar(i:int):char\n  requires 0 <= i < 10\n{\n  (48 + i) as char\n}\n\nfunction CharToInt(i:char):int\n\n{\n  i as int - 48\n}\n\nmethod Main() {\n  print IntToChar(8), \"\\n\";\n  print CharToInt('8'), \"\\n\";\n  Regression();\n}\n\nmethod Regression() {\n  var i := '8';\n  var u := i as myNative;  // this once crashed the verifier\n  var v := i as mySubtype;  // this once crashed the verifier\n  print i, \" \", u, \" \", v, \"\\n\";\n}\n\ntype mySubtype = x:int | 0 <= x < 100_000\nnewtype myNative = x:int | 0 <= x < 100_000\n"}
{"file": "../dafny/Test/dafny4/LargeConstants.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nlemma largeIsLarge()\n  ensures 0x8000000000000000 > 0 {\n}\n\nlemma SmallIsSmall()\n  ensures -0x8000000000000000 < 0 {\n}\n\nlemma ShouldCancelOut()\n  ensures -0x8000000000000000 + 0x8000000000000000 == 0 {\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue257.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule  M {\n  trait T {\n    ghost function f(): nat\n  }\n  class C extends T {\n    constructor () { }\n    ghost function f(): nat { 0 }\n  }\n}\n\nmethod Test0() {\n  var c := new M.C();\n  assert c.f() == 0;\n  var g: M.T := c;\n  assert g.f() == 0;  // used to fail, but shouldn't\n}\n\nmethod Test1() {\n  var c := new M.C();  // type is inferred to M.T? :(\n  var g: M.T := c;\n  assert c.f() == 0;  // which used to cause this to fail, but shouldn't\n}\n\nmethod Test2() {\n  var c := new M.C();\n  assert c.f() == 0;\n}\n\nmethod Test3() {\n  var c: M.C := new M.C();  // explicitly ask for type M.C\n  var g: M.T := c;\n  assert c.f() == 0;\n}\n\nmethod Test4(c: M.C, g: M.T)\n  requires c == g\n{\n  assert c.f() == 0;\n  assert g.f() == 0;  // used to fail, but shouldn't\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue110.dfy", "dafny": "// RUN: %dafny /compile:0 /rprint:\"%t.rprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule MyModule {\n  export provides MyType, Empty, MyLemma\n  type MyType<A>\n  ghost function Empty<B>(): MyType<B>\n  lemma MyLemma<C>(m: MyType<C>)\n    requires m != Empty()  // once upon a time, type inference didn't figure this out\n}\n\n// -----------------\n\nmodule Library {\n  export provides MyType, MyFunction\n\n  type MyType<A>\n  ghost function MyFunction<B>(q: MyType<B>, b: B): MyType<B>\n}\n\nmodule Client {\n  import Library\n    // the same bug caused some types not to be filled in, which caused malformed\n    // Boogie to be produced\n  method Test() {\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/Regression7.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmodule ListLibrary {\n  datatype List<B> = Nil | Cons(head: B, tail: List<B>)\n}\n\nmodule Q {\n  import LL = ListLibrary\n\n  datatype Queue<T> = FQ(front: LL.List<T>, rear: LL.List<T>)\n\n  function MyCons<W>(w: W, ws: LL.List<W>): LL.List<W>\n  {\n    LL.Cons(w, ws)\n  }\n\n  method Test<A>(q: Queue<A>, x: A) returns (r: LL.List<A>)\n  {\n    var r0 := MyCons(x, q.rear);\n    var r1 := var qr := q.rear; LL.Cons(x, qr);\n    var r2 := LL.Cons(x, q.rear);  // this once said \"type Queue<T> does not have a member rear\"\n    assert r0.tail == r1.tail == r2.tail;\n    r := r2;\n  }\n}\n\nmethod Main()\n{\n  var q := Q.FQ(ListLibrary.Nil, ListLibrary.Nil);\n  var x := 28.0;\n  var ll := Q.Test(q, x);\n  print ll, \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/Bug79.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function foo(s:int) : (int, int)\n\nghost function bar(s:int) : bool\n{\n    var (x, rest) := foo(s);\n    x > 0\n}"}
{"file": "../dafny/Test/dafny4/Fstar-QuickSort.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// A Dafny rendition of an F* version of QuickSort (included at the bottom of this file).\n// Unlike the F* version, Dafny also proves termination and does not use any axioms.  However,\n// Dafny needs help with a couple of lemmas in places where F* does not need them.\n// Comments below show differences between the F* and Dafny versions.\n\ndatatype List<T> = Nil | Cons(T, List)\n\nghost function length(list: List): nat  // for termination proof\n{\n  match list\n  case Nil => 0\n  case Cons(_, tl) => 1 + length(tl)\n}\n\n// In(x, list) returns the number of occurrences of x in list\nghost function In(x: int, list: List<int>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(y, tl) => (if x == y then 1 else 0) + In(x, tl)\n}\n\nghost predicate SortedRange(m: int, n: int, list: List<int>)\n  decreases list  // for termination proof\n{\n  match list\n  case Nil => m <= n\n  case Cons(hd, tl) => m <= hd <= n && SortedRange(hd, n, tl)\n}\n\nghost function append(n0: int, n1: int, n2: int, n3: int, i: List<int>, j: List<int>): List<int>\n  requires n0 <= n1 <= n2 <= n3\n  requires SortedRange(n0, n1, i) && SortedRange(n2, n3, j)\n  ensures SortedRange(n0, n3, append(n0, n1, n2, n3, i, j))\n  ensures forall x :: In(x, append(n0, n1, n2, n3, i, j)) == In(x, i) + In(x, j)\n  decreases i  // for termination proof\n{\n  match i\n  case Nil => j\n  case Cons(hd, tl) => Cons(hd, append(hd, n1, n2, n3, tl, j))\n}\n\nghost function partition(x: int, l: List<int>): (List<int>, List<int>)\n  ensures var (lo, hi) := partition(x, l);\n    (forall y :: In(y, lo) == if y <= x then In(y, l) else 0) &&\n    (forall y :: In(y, hi) == if x < y then In(y, l) else 0) &&\n    length(l) == length(lo) + length(hi)  // for termination proof\n{\n  match l\n  case Nil => (Nil, Nil)\n  case Cons(hd, tl) =>\n    var (lo, hi) := partition(x, tl);\n    if hd <= x then\n      (Cons(hd, lo), hi)\n    else\n      (lo, Cons(hd, hi))\n}\n\nghost function sort(min: int, max: int, i: List<int>): List<int>\n  requires min <= max\n  requires forall x :: In(x, i) != 0 ==> min <= x <= max\n  ensures SortedRange(min, max, sort(min, max, i))\n  ensures forall x :: In(x, i) == In(x, sort(min, max, i))\n  decreases length(i)  // for termination proof\n{\n  match i\n  case Nil => Nil\n  case Cons(hd, tl) =>\n    assert In(hd, i) != 0;  // this proof line not needed in F*\n    var (lo, hi) := partition(hd, tl);\n    assert forall y :: In(y, lo) <= In(y, i);  // this proof line not needed in F*\n    var i' := sort(min, hd, lo);\n    var j' := sort(hd, max, hi);\n    append(min, hd, hd, max, i', Cons(hd, j'))\n}\n\n/*\nmodule Sort\n\ntype SortedRange : int => int => list int => E\nassume Nil_Sorted : forall (n:int) (m:int). n <= m <==> SortedRange n m []\nassume Cons_Sorted: forall (n:int) (m:int) (hd:int) (tl:list int).\n               SortedRange hd m tl && (n <= hd) && (hd <= m)\n          <==> SortedRange n m (hd::tl)\n\nval append: n1:int -> n2:int{n1 <= n2} -> n3:int{n2 <= n3} -> n4:int{n3 <= n4}\n         -> i:list int{SortedRange n1 n2 i}\n         -> j:list int{SortedRange n3 n4 j}\n         -> k:list int{SortedRange n1 n4 k\n                      /\\ (forall x. In x k <==> In x i \\/ In x j)}\nlet rec append n1 n2 n3 n4 i j = match i with\n  | [] ->\n    (match j with\n      | [] -> j\n      | _::_ -> j)\n  | hd::tl -> hd::(append hd n2 n3 n4 tl j)\n\nval partition: x:int\n            -> l:list int\n            -> (lo:list int\n                * hi:list int{(forall y. In y lo ==> y <= x /\\ In y l)\n                               /\\ (forall y. In y hi ==> x < y /\\ In y l)\n                               /\\ (forall y. In y l ==> In y lo \\/ In y hi)})\nlet rec partition x l = match l with\n  | [] -> ([], [])\n  | hd::tl ->\n    let lo, hi = partition x tl in\n    if hd <= x\n    then (hd::lo, hi)\n    else (lo, hd::hi)\n\nval sort: min:int\n       -> max:int{min <= max}\n       -> i:list int {forall x. In x i ==> (min <= x /\\ x <= max)}\n       -> j:list int{SortedRange min max j /\\ (forall x. In x i <==> In x j)}\nlet rec sort min max i = match i with\n  | [] -> []\n  | hd::tl ->\n    let lo,hi = partition hd tl in\n    let i' = sort min hd lo in\n    let j' = sort hd max hi in\n    append min hd hd max i' (hd::j')\n\n*/\n"}
{"file": "../dafny/Test/dafny4/McCarthy91.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n// The usual recursive method for computing McCarthy's 91 function\n\nmethod Main() {\n  var s := [3, 99, 100, 101, 1013];\n\n  var n := 0;\n  while n < |s| {\n    var m := M(s[n]);\n    print \"M(\", s[n], \") = \", m, \"\\n\";\n    n := n + 1;\n  }\n\n  n := 0;\n  while n < |s| {\n    print \"mc91(\", s[n], \") = \", mc91(s[n]), \"\\n\";\n    n := n + 1;\n  }\n\n  n := 0;\n  while n < |s| {\n    var m := Mc91(s[n]);\n    print \"Mc91(\", s[n], \") = \", m, \"\\n\";\n    n := n + 1;\n  }\n\n  n := 0;\n  while n < 5 {\n    var m := iter(n, mc91, 40);\n    print \"iter(\", n, \", mc91, 40) = \", m, \"\\n\";\n    n := n + 1;\n  }\n}\n\nmethod M(n: int) returns (r: int)\n  ensures r == if n <= 100 then 91 else n - 10\n  decreases 100 - n\n{\n  if n <= 100 {\n    r := M(n + 11);\n    r := M(r);\n  } else {\n    r := n - 10;\n  }\n}\n\n// Same as above, but as a function\n\nfunction mc91(n: int): int\n  ensures n <= 100 ==> mc91(n) == 91\n  decreases 100 - n\n{\n  if n <= 100 then\n    mc91(mc91(n + 11))\n  else\n    n - 10\n}\n\n// Iterating a function f e times starting from n\n\nfunction iter(e: nat, f: int -> int, n: int): int\n{\n  if e == 0 then n else iter(e-1, f, f(n))\n}\n\n// Iterative version of McCarthy's 91 function, following in lockstep\n// what the recursive version would do\n\nmethod Mc91(n0: int) returns (r: int)\n  ensures r == mc91(n0)\n{\n  var e, n := 1, n0;\n  while e > 0\n    invariant iter(e, mc91, n) == mc91(n0)\n    decreases 100 - n + 10 * e, e\n  {\n    if n <= 100 {\n      e, n := e+1, n+11;\n    } else {\n      e, n := e-1, n-10;\n    }\n  }\n  return n;\n}\n"}
{"file": "../dafny/Test/dafny4/Bug92.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\nmodule ModOpaque {\n    ghost function {:opaque} Hidden(x:int) : (int, int)\n    {\n        (5, 7)\n    }\n\n    ghost function Visible(x:int) : (int, int)\n    {\n        Hidden(x)\n    }\n\n    lemma foo(x:int, y:int, z:int)\n        requires (y, z) == Visible(x);\n    {\n        assert (y, z) == Hidden(x);\n    }\n\n    lemma bar(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Visible(x);\n    }\n\n    lemma baz(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Hidden(x);\n    }\n}\n\nmodule ModVisible {\n    ghost function Hidden(x:int) : (int, int)\n    {\n        (5, 7)\n    }\n\n    ghost function Visible(x:int) : (int, int)\n    {\n        Hidden(x)\n    }\n\n    lemma foo(x:int, y:int, z:int)\n        requires (y, z) == Visible(x);\n    {\n        assert (y, z) == Hidden(x);\n    }\n\n    lemma bar(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Visible(x);\n    }\n\n    lemma baz(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Hidden(x);\n    }\n}\n\nmodule ModFuel {\n    ghost function {:fuel 0,0} Hidden(x:int) : (int, int)\n    {\n        (5, 7)\n    }\n\n    ghost function Visible(x:int) : (int, int)\n    {\n        Hidden(x)\n    }\n\n    lemma foo(x:int, y:int, z:int)\n        requires (y, z) == Visible(x);\n    {\n        assert (y, z) == Hidden(x);\n    }\n\n    lemma bar(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Visible(x);\n    }\n\n    lemma baz(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Hidden(x);\n    }\n}\n"}
{"file": "../dafny/Test/dafny4/Bug165.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype T\nghost function f(a: T) : bool\n\nmethod Select(s1: seq<T>) returns (r: seq<T>)\n  ensures (forall e: T  :: f(e) ==> multiset(s1)[e] == multiset(r)[e])\n  ensures (forall e: T  :: (!f(e)) ==> 0 == multiset(r)[e])\n\nmethod Main(s1: seq<T>)\n{\n   var r1, r2: seq<T>;\n\n   r1 := Select(s1);\n   r2 := Select(s1);\n\n   assert multiset(r1) == multiset(r2);\n\n}"}
{"file": "../dafny/Test/dafny4/Bug104.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype PartRealPartGhost = PartRealPartGhost(x:int, ghost y:int)\n\nmethod UpdateField()\n{\n var v := PartRealPartGhost(3, 4);\n ghost var g := 5;\n v := v.(y := g);\n}\n"}
{"file": "../dafny/Test/dafny4/Bug94.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nghost function foo() : (int, int)\n{\n    (5, 10)\n}\n\nghost function bar() : int\n{\n    var (x, y) := foo();\n    x + y\n}\n\nlemma test()\n{\n    var (x, y) := foo();\n}\n\nfunction foo2() : (int,int)\n{\n    (5, 10)\n}\n\nmethod test2()\n{\n    var (x, y) := foo2();\n}\n\nmethod Main()\n{\n    var (x, y) := foo2();\n    assert (x+y == 15);\n    print(x+y);\n}\n"}
{"file": "../dafny/Test/dafny4/NatList.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// This file tests some programs where \"nat\" is a type parameter to\n// a datatype.\n\ndatatype List<+T> = Nil | Cons(head: T, tail: List<T>)\n\nmethod Main() {\n  var ns := Nil;\n  ns := Cons(4, Cons(10, Nil));\n  print \"ns = \", ns, \"\\n\";\n  print \"Sum(ns) = \", Sum(ns), \"\\n\";\n\n  var ns' := Cons(20, Nil);\n  var ns'' := Append(ns, ns');\n  print \"ns' = \", ns', \"\\n\";\n  print \"Append(ns, ns') = \", ns'', \"\\n\";\n  print \"Sum(Append(ns, ns')) = \", Sum(ns''), \"\\n\";\n\n  ConvertAndPrint(ns, -12);\n}\n\nfunction Sum(ns: List<nat>): nat\n{\n  match ns\n  case Nil => 0\n  case Cons(n, tail) => n + Sum(tail)\n}\n\nfunction Append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(t, tail) => Cons(t, Append(tail, ys))\n}\n\nfunction Negate(xs: List<int>): List<int>\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, tail) => Cons(-x, Negate(tail))\n}\n\nlemma DoubleNegation(xs: List<int>)\n  ensures Negate(Negate(xs)) == xs\n{\n  // proof by induction\n}\n\nmethod ConvertAndPrint(ns: List<nat>, nn: int)\n  requires nn <= 0\n{\n  var xs := Negate(Negate(ns));\n  DoubleNegation(ns);\n  var ns': List<nat> := xs;\n  print \"Sum(Negate(Negate(ns))) = \", Sum(ns'), \"\\n\";\n\n  // In the following, no lemmas are needed, because \"negs\" is a literal so\n  // functions applied to it will be fully expanded.\n  var negs := Cons(-3, Cons(0, Cons(-2, Nil)));\n  var s := Sum(Negate(negs));\n  print \"negs = \", negs, \"\\n\";\n  print \"Sum(Negate(negs)) = \", s, \"\\n\";\n\n  // Here, the lemmas NatTan and Conversion_Int2Nat are needed.\n  negs := Cons(-3, Cons(nn, Cons(-2, Nil)));\n  assert ElementsAreTan(Cons(nn, Cons(-2, Nil)));  // help lemma\n  NatTan(negs);\n  var _ := Conversion_Int2Nat(Negate(negs));\n  s := Sum(Negate(negs));\n  print \"negs = \", negs, \"\\n\";\n  print \"Sum(Negate(negs)) = \", s, \"\\n\";\n}\n\nlemma {:induction false} Conversion_Nat2Int(ns: List<nat>) returns (xs: List<int>)\n  ensures ns == xs\n{\n  xs := ns;  // easy!\n}\n\nghost predicate ElementsAreNat(xs: List<int>)\n{\n  match xs\n  case Nil => true\n  case Cons(x, tail) => 0 <= x && ElementsAreNat(tail)\n}\n\nghost predicate ElementsAreTan(xs: List<int>)\n{\n  match xs\n  case Nil => true\n  case Cons(x, tail) => x <= 0 && ElementsAreTan(tail)\n}\n\nlemma NatTan(xs: List<int>)\n  requires ElementsAreTan(xs)\n  ensures ElementsAreNat(Negate(xs))\n{\n  // proof by induction\n}\n\nlemma {:induction false} Conversion_Int2Nat(xs: List<int>) returns (ns: List<nat>)\n  requires ElementsAreNat(xs)\n  ensures xs == ns\n{\n  match xs\n  case Nil =>\n    ns := xs;\n  case Cons(x, tail) =>\n    ns := Conversion_Int2Nat(tail);\n    ns := Cons(x, ns);\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue22.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate bad()\n{\n    forall i :: i in {1}\n}\n"}
{"file": "../dafny/Test/dafny4/Bug71.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction{:opaque} MapSetToSet<X(!new), Y>(xs:set<X>, f:X~>Y):set<Y>\n//function MapSetToSet<X, Y>(xs:set<X>, f:X->Y):set<Y>\n  reads f.reads\n  requires forall x :: f.requires(x)\n{\n  set x | x in xs :: f(x)\n}\n"}
{"file": "../dafny/Test/dafny4/Issue09.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function Transform(x:int) : int\n\nlemma TransformProperties()\n    ensures forall x1, x2 {:trigger Transform(x1), Transform(x2)} :: Transform(x1) == Transform(x2) ==> x1 == x2\n\nghost function {:opaque} Looper(input:seq<int>) : seq<int>\n    ensures |Looper(input)| == |input|\n    ensures forall i :: 0 <= i < |input| ==> Looper(input)[i] == Transform(input[i])\n{\n    if |input| == 0 then []\n    else [Transform(input[0])] + Looper(input[1..])\n}\n\nlemma proof(s1:seq<int>, s2:seq<int>)\n    requires Looper(s1) == Looper(s2)\n    ensures forall i :: i in s1 <==> i in s2\n{\n    reveal_Looper();\n    TransformProperties();\n}\n\n"}
{"file": "../dafny/Test/dafny4/Bug60.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// This method can be used to test compilation.\nmethod Main()\n{\n  var s := {2, 3};\n  var m := map[2 := 20, 3 := 30];\n  print (s, m), \"\\n\";\n  print (|s|, |m|), \"\\n\";\n  print set s | s in m, \"\\n\";\n  print forall x :: x in (map[1 := 10, 2 := 20]) ==> x > 0, \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/ExpandedGuardedness.dfy", "dafny": "// UNSUPPORTED: windows\n// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\nmethod Main() // Windows not supported because of Java that does not pass the check as expected on the CI\n{\n  PrintStream(\"Up\", Up(19));\n  PrintStream(\"Up2\", Up2(19));\n  PrintStream(\"UpIf\", UpIf(19));\n  PrintStream(\"CUp1\", CUp1(19, Blue));\n  PrintStream(\"UpLet0\", UpLet0(19));\n  PrintStream(\"UpLet1\", UpLet1(19));\n\n  var l := OnlyDs();\n  var s := \"\";\n  while |s| < 6\n    invariant l == OnlyDs() || l == Nothing()\n  {\n    print s, if l.nullable then \"  yes\\n\" else \"  no\\n\";\n    var ch := if |s| < 3 then 'D' else 'v';\n    l := l.deriv(ch);\n    s := s + [ch];\n  }\n  GhostMain();\n\n  var ml := MOnlyDs();\n  s := \"\";\n  while |s| < 6\n    invariant ml == MOnlyDs() || ml == MNothing()\n  {\n    print s, if ml.nullable then \"  yes\\n\" else \"  no\\n\";\n    var ch := if |s| < 3 then 'D' else 'v';\n    ml := if ch in ml.deriv then ml.deriv[ch] else MNothing();\n    s := s + [ch];\n  }\n}\n\nmethod PrintStream(tag: string, s: Stream<int>)\n{\n  print tag;\n  var n, s := 0, s;\n  while n < 5\n  {\n    print \" \", s.head;\n    s, n := s.tail, n + 1;\n  }\n  print \"\\n\";\n}\n\nghost method GhostMain()\n{\n  var l := IMOnlyDs();\n  var s := \"\";\n  while |s| < 6\n  {\n    var ch := if |s| < 3 then 'D' else 'v';\n    l := if ch in l.deriv.Keys then l.deriv[ch] else IML(false, l.deriv);\n    s := s + [ch];\n  }\n}\n\n// ---------------------------------------------------\n\ncodatatype Stream<T> = ICons(head: T, tail: Stream<T>)\n\nfunction Up(n: int): Stream<int>\n{\n  ICons(n, Up(n+1))\n}\n\nfunction Up2(n: int): Stream<int>\n{\n  ICons(n, ICons(n+1, Up2(n+2)))\n}\n\nfunction UpIf(n: int): Stream<int>\n{\n  if n % 2 == 1 then ICons(n, UpIf(n+1)) else ICons(n, UpIf(n+2))\n}\n\nfunction UpIf'(n: int): Stream<int>\n{\n  ICons(n, if n % 2 == 1 then UpIf'(n+1) else UpIf'(n+2))\n}\n\ndatatype Color = Red | Blue\n\nfunction CUp0(n: int, c: Color): Stream<int>\n{\n  match c\n  case Red => ICons(n, CUp0(n+1, c))\n  case Blue => ICons(n, CUp0(n+2, c))\n}\n\nfunction CUp1(n: int, c: Color): Stream<int>\n{\n  ICons(n, match c case Red => CUp1(n+1, c) case Blue => CUp1(n+2, c))\n}\n\nfunction CUp2(n: int, c: Color): Stream<int>\n{\n  if c == Red then\n    ICons(n, CUp2(n+1, c))\n  else\n    ICons(n, CUp2(n+2, c))\n}\n\nfunction CUp3(n: int, c: Color): Stream<int>\n{\n  ICons(n, if c == Red then CUp3(n+1, c) else CUp3(n+2, c))\n}\n\ngreatest lemma CUps(n: int, c: Color)\n  ensures CUp0(n, c) == CUp1(n, c) == CUp2(n, c) == CUp3(n, c)\n{\n}\n\nfunction UpLet0(n: int): Stream<int>\n{\n  var n' := n+1;\n  ICons(n'-1, UpLet0(n'))\n}\n\nfunction UpLet1(n: int): Stream<int>\n{\n  ICons(n, var n' := n+1; UpLet1(n'))\n}\n\n// ---------------------------------------------------\n\ncodatatype Lang<!S> = L(nullable: bool, deriv: S ~> Lang<S>)\n\nfunction Nothing(): Lang\n{\n  L(false, s => Nothing())\n}\n\nfunction OnlyDs(): Lang<char>\n{\n  L(true, ch => if ch == 'd' || ch == 'D' then OnlyDs() else Nothing())\n}\n\ngreatest predicate TotalLang<S(!new)>(l: Lang<S>)\n  reads *\n{\n  forall s: S :: l.deriv.requires(s) && l.deriv.reads(s) == {} && TotalLang(l.deriv(s))\n}\n\ngreatest lemma NothingTotal<S>()\n  ensures TotalLang(Nothing<S>())\n{\n}\n\ngreatest lemma OnlyDsTotal()\n  ensures TotalLang(OnlyDs())\n{\n  NothingTotal<char>();  // Note, to demonstrate the point made below in OnlyDsTotal_Nat, replace this line with \"assume 0 < _k.Offset;\", which shows that's the only case where \"NothingTotal<char>();\" is needed\n  OnlyDsTotal();\n}\n\ngreatest predicate TotalLang_Nat<S(!new)>[nat](l: Lang<S>)\n  reads *\n{\n  forall s: S :: l.deriv.requires(s) && l.deriv.reads(s) == {} && TotalLang_Nat(l.deriv(s))\n}\n\ngreatest lemma NothingTotal_Nat<S>[nat]()\n  ensures TotalLang_Nat(Nothing<S>())\n{\n}\n\ngreatest lemma OnlyDsTotal_Nat[nat]()\n  ensures TotalLang_Nat(OnlyDs())\n{\n  // Unlike the [ORDINAL] version of this greatest lemma above, this version does not\n  // need the following call:\n  //    NothingTotal_Nat<char>();\n  // The reason is that, here, two levels of unrolling will get to a .deriv function\n  // that looks just like the one after one unrolling.  One can then infer what is\n  // needed about the \"Nothing()\" branch.  In contrast, after one level of unrolling\n  // in the [ORDINAL] version, there may be a limit ordinal.  In that case, one needs\n  // one more unrolling before getting to another .deriv function.\n  OnlyDsTotal_Nat();\n}\n\n// ---------------------------------------------------\n\n// S should be specified as a non-strict covariant\ncodatatype IMLang<!S> = IML(nullable: bool, deriv: imap<S, IMLang<S>>)\n\nghost function IMNothing<S(!new)>(): IMLang\n{\n  IML(false, imap s {:nowarn} :: IMNothing())\n}\n\nghost function IMOnlyDs(): IMLang<char>\n{\n  IML(true, imap ch {:nowarn} :: if ch == 'd' || ch == 'D' then IMOnlyDs() else IMNothing())\n}\n\ncodatatype MLang<S> = ML(nullable: bool, deriv: map<S, MLang<S>>)\n\nfunction MNothing(): MLang\n{\n  ML(false, map s {:nowarn} | s in {} :: MNothing())  // TODO: finiteness check should allow 'false'\n}\n\nfunction MOnlyDs(): MLang<char>\n{\n  ML(true, map ch {:nowarn} | ch == 'd' || ch == 'D' :: MOnlyDs())\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue1.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype T = T(n:int)\nghost function P(x: int) : int { x - 1}\n\nghost function ToInt(t:T) : int\n ensures ToInt(t) == t.n as int\n {\n    t.n as int\n }\n\nmethod Test(x:int)\n {\n    assume exists p:int :: exists t:T :: ToInt(t) > 0;\n    assert exists p:int :: exists t:T :: ToInt(t) > 0;\n }\n\n\n\n\n"}
{"file": "../dafny/Test/dafny4/ClassRefinement.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\nabstract module M0 {\n  class Counter {\n    ghost var N: int\n    ghost var Repr: set<object>\n    ghost predicate Valid()\n      reads this, Repr\n      ensures Valid() ==> this in Repr\n\n    constructor Init()\n      ensures N == 0\n      ensures Valid() && fresh(Repr)\n    {\n      Repr := {};\n      new;\n      ghost var repr :| {this} <= repr && fresh(repr - {this});\n      N, Repr := 0, repr;\n      assume Valid();  // to be verified in refinement module\n    }\n\n    method Inc()\n      requires Valid()\n      modifies Repr\n      ensures N == old(N) + 1\n      ensures Valid() && fresh(Repr - old(Repr))\n    {\n      N := N + 1;\n      modify Repr - {this};\n      assume Valid();  // to be verified in refinement module\n    }\n\n    method Get() returns (n: int)\n      requires Valid()\n      ensures n == N\n    {\n      n :| assume n == N;\n    }\n  }\n}\n\nmodule M1 refines M0 {\n  class Cell {\n    var data: int\n    constructor (d: int)\n      ensures data == d\n    { data := d; }\n  }\n\n  class Counter ... {\n    var c: Cell\n    var d: Cell\n    ghost predicate Valid...\n    {\n      this in Repr &&\n      c in Repr &&\n      d in Repr &&\n      c != d &&\n      N == c.data - d.data\n    }\n\n    constructor Init...\n    {\n      c := new Cell(0);\n      d := new Cell(0);\n      new;\n      ghost var repr := Repr + {this} + {c,d};\n      ...;\n      assert ...;\n    }\n\n    method Inc...\n    {\n      ...;\n      modify ... {\n        c.data := c.data + 1;\n      }\n      assert ...;\n    }\n\n    method Get...\n    {\n      n := c.data - d.data;\n    }\n  }\n}\n\nmethod Main() {\n  var mx := new M1.Counter.Init();\n  var my := new M1.Counter.Init();\n  assert mx.N == 0 && my.N == 0;\n  mx.Inc();\n  my.Inc();\n  mx.Inc();\n  var nx := mx.Get();\n  var ny := my.Get();\n  assert nx == 2 && ny == 1;\n  print nx, \" \", ny, \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/Bug134.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule NativeTypes {\n\tnewtype{:nativeType \"ushort\"} uint16 = i:int | 0 <= i < 0x10000\n}\n\nabstract module AbstractModuleA\n{\n\timport opened NativeTypes\n\tdatatype T = T(i:uint16)\n}\n\nabstract module AbstractModuleB\n{\n\timport opened A : AbstractModuleA\n}\n\nabstract module AbstractModuleC\n{\n\timport opened B : AbstractModuleB\n}\n\n"}
{"file": "../dafny/Test/dafny4/Bug69.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M1\n{\n  ghost predicate X(i:int)\n}\n\nmodule M2\n{\n  import opened M1\n  ghost predicate         P(i:int) requires X(i) { true } // ok\n  predicate{:opaque} O(i:int) requires X(i) { true } // resolution/type error: X does not exist\n}"}
{"file": "../dafny/Test/dafny4/Bug166.dfy", "dafny": "// RUN: %dafny /compile:0  /noNLarith /print:\"%t.print\" /rprint:\"%t.rprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate P(x:int)\n\nmethod test(s:seq<int>)\n    ensures forall x :: x > 5 ==> P(x)\n    ensures forall i :: 0 <= i < |s| ==> P(s[i])\n"}
{"file": "../dafny/Test/dafny4/git-issue254.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Foo {}\n\ntrait InputStream {\n  var x: int\n  ghost predicate Valid() reads this\n  method read(b: Foo)\n    requires Valid()\n}\n\nclass ToyInputStream extends InputStream {\n  ghost predicate Valid() reads this {\n    x == 7\n  }\n  // regression test: the following line once complained that preconditions have\n  // to be equal or more permissive precondition than in its parent trait\n  method read(b: Foo)\n    requires Valid()\n  { }\n}\n"}
{"file": "../dafny/Test/dafny4/Bug62.dfy", "dafny": "// RUN: %exits-with 3 %dafny /compile:3  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass C {\n  constructor C() { }\n  method Main()  // not Main since the enclosing class has a constructor.\n  {\n    print \"hello, I'm running ... in C\\n\";\n  }\n}\n\nclass D {\n  method Main()  // not Main since it has modifies clause.\n   modifies this\n  {\n    print \"hello, I'm running ... in D\\n\";\n  }\n}\n\n\nclass E {\n  static method Main()  // not Main since it has requires clause.\n   requires true\n  {\n    print \"hello, I'm running ... in E\\n\";\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/Regression9.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// Some tests for the type inference that was revamped\n// to better support subset types.\n\nmethod Main()\n{\n  var f := F;\n  var f' := F';\n  var f'' := F'';\n  var c := InitArray(F);\n  var d := InitArray(F');\n  var e := InitArray(F'');\n  print c, d, e, \"\\n\";\n}\n\nfunction F(x: int): char  // F has type int -> char\n{ 'D' }\n\nfunction F'(x: int): char\n  requires true  // the presence of a requires clause makes F' have type int --> char\n{ 'D' }\n\nfunction F''(x: int): char\n  reads {}  // the presence of a reads clause makes F' have type int ~> char\n{ 'D' }\n\nmethod InitArray<D>(f: int -> D) returns (a: D)\n{\n  return f(44);\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue74.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction{:opaque} f(x:int):int { x }\n\nlemma L()\n    ensures forall x:int :: f(x) == x\n{\n    forall x:int\n        ensures f(x) == x\n    {\n        reveal f();\n    }\n    assert forall x:int :: f(x) == x;\n}\n\n"}
{"file": "../dafny/Test/dafny4/Lucas-down.dfy", "dafny": "// RUN: %dafny /compile:0 /arith:1 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Proof of the Lucas theorem\n// Rustan Leino\n// 9 March 2018\n//\n// Instead of the lemmas doing \"up\", like:\n//   P(k) == P(2*k)\n//   P(k) == P(2*k + 1)\n// (see Lucas-up.dfy), the lemmas in this version go \"down\", like:\n//   P(k%2) == P(k)\n\n// This file defines the ingredients of the Lucas theorem, proves some\n// properties of these, and then states and proves the Lucas theorem\n// itself.\n\n// The following predicate gives the boolean value of bit \"k\" in\n// the natural number \"n\".\nghost predicate Bit(k: nat, n: nat)\n{\n  if k == 0 then n % 2 == 1\n  else Bit(k-1, n / 2)\n}\n\n// Function \"BitSet\" returns the set of bits in the binary representation\n// of a number.\nghost function BitSet(n: nat): set<nat>\n{\n  set i | 0 <= i < n && Bit(i, n)\n}\n\n// The following lemma shows that the \"i < n\" conjunct in\n// the set comprehension in \"BitSet\" does not restrict\n// the set any more than the conjunct \"Bit(i, n)\" does.\nlemma BitSize(i: nat, n: nat)\n  requires Bit(i, n)\n  ensures i < n\n{\n}\n\n// An easy-to-read name for the expression that checks if a number\n// is even.\nghost predicate EVEN(n: nat)\n{\n  n % 2 == 0\n}\n\n// The binomial function is defined like in the Pascal triangle.\n// \"binom(a, b)\" is also known as \"a choose b\".\nghost function binom(a: nat, b: nat): nat\n{\n  if b == 0 then 1\n  else if a == 0 then 0\n  else binom(a-1, b) + binom(a-1, b-1)\n}\n\n// This lemma shows that the parity of \"binom\" is preserved if\n// div-2 is applied to both arguments--except in the case where\n// the first argument to \"binom\" is even and the second argument\n// is odd, in which case \"binom\" is always even.\nlemma Lucas_Binary''(a: nat, b: nat)\n  ensures binom(a, b) % 2 == if EVEN(a) && !EVEN(b) then 0 else binom(a / 2, b / 2) % 2\n{\n  if a == 0 || b == 0 {\n  } else {\n    Lucas_Binary''(a - 1, b);\n    Lucas_Binary''(a - 1, b - 1);\n  }\n}\n\n// \"Suc(S)\" returns the set constructed by incrementing\n// each number in \"S\" by 1. Stated differently, it is the\n// increment-by-1 (successor) function applied pointwise to the\n// set.\nghost function Suc(S: set<nat>): set<nat>\n{\n  set x | x in S :: x + 1\n}\n\n// The following lemma clearly shows the correspondence between\n// \"S\" and \"Suc(S)\".\nlemma SucElements(S: set<nat>)\n  ensures forall x :: x in S <==> (x+1) in Suc(S)\n{\n}\n\n// Here is a lemma that relates BitSet and Suc.\nlemma BitSet_Property(n: nat)\n  ensures BitSet(n) - {0} == Suc(BitSet(n / 2))\n{\n  if n == 0 {\n  } else {\n    forall x: nat {\n      calc {\n        x in BitSet(n) - {0};\n      ==\n        x != 0 && x in BitSet(n);\n      ==  // def. BitSet\n        0 < x < n && Bit(x, n);\n      ==  // def. Bit\n        0 < x < n && Bit(x-1, n / 2);\n      ==  { if 0 < x && Bit(x-1, n / 2) { BitSize(x-1, n / 2); } }\n        0 <= x-1 < n / 2 && Bit(x-1, n / 2);\n      ==  // def. BitSet\n        (x-1) in BitSet(n / 2);\n      ==  { SucElements(BitSet(n / 2)); }\n        x in Suc(BitSet(n / 2));\n      }\n    }\n  }\n}\n\nlemma Lucas_Theorem'(m: nat, n: nat)\n  ensures BitSet(m) <= BitSet(n) <==> !EVEN(binom(n, m))\n{\n  if m == 0 && n == 0 {\n  } else if EVEN(n) && !EVEN(m) {\n    calc {\n      !EVEN(binom(n, m));\n    ==  { Lucas_Binary''(n, m); }\n      false;\n    ==  { assert 0 in BitSet(m) && 0 !in BitSet(n); }\n      BitSet(m) <= BitSet(n);\n    }\n  } else {\n    var m', n' := m/2, n/2;\n    calc {\n      !EVEN(binom(n, m));\n    ==  { Lucas_Binary''(n, m); }\n      !EVEN(binom(n', m'));\n    ==  { Lucas_Theorem'(m', n'); }\n      BitSet(m') <= BitSet(n');\n    ==  { SucElements(BitSet(m')); SucElements(BitSet(n')); }\n      Suc(BitSet(m')) <= Suc(BitSet(n'));\n    ==  { BitSet_Property(m); BitSet_Property(n); }\n      BitSet(m) - {0} <= BitSet(n) - {0};\n    ==  { assert 0 !in BitSet(m) ==> BitSet(m) == BitSet(m) - {0};\n          assert 0 in BitSet(n) ==> BitSet(n) - {0} <= BitSet(n); }\n      BitSet(m) <= BitSet(n);\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/Regression6.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nfunction Sum(a: array<int>, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= a.Length\n  reads a\n  decreases hi - lo\n{\n  if lo == hi then 0 else a[lo] + Sum(a, lo+1, hi)\n}\n\nmethod Main()\n{\n  var a := new int[100];\n  var b := new int[1000];\n  assert a != b;\n  var s := Sum(a, 0, a.Length);\n  assert s == Sum(a, 0, a.Length);\n  b[17] := 1028;\n  assert s == Sum(a, 0, a.Length);  // for this to verify, the state after allocating\n                                    // b must be marked a heap anchor\n  print s, \" \", b[17], \" \", b[3], \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/Bug107.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main()\n{\n  var f := Inc;\n\tprint(f(4));\n}\n\nfunction Inc(x: int): int\n{\n  x + 2\n}\n\n\n\n"}
{"file": "../dafny/Test/dafny4/git-issue250.dfy", "dafny": "// RUN: %dafny /arith:1 \"%s\" > \"%t\"\n// RUN: %dafny /arith:2 \"%s\" >> \"%t\"\n// RUN: %dafny /arith:3 \"%s\" >> \"%t\"\n// RUN: %dafny /arith:4 \"%s\" >> \"%t\"\n// RUN: %dafny /arith:5 \"%s\" >> \"%t\"\n// RUN: %dafny /arith:6 \"%s\" >> \"%t\"\n// RUN: %dafny /arith:7 \"%s\" >> \"%t\"\n// RUN: %dafny /arith:8 \"%s\" >> \"%t\"\n// RUN: %dafny /arith:9 \"%s\" >> \"%t\"\n// RUN: %dafny /arith:10 \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n\n}"}
{"file": "../dafny/Test/dafny4/git-issue76.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  M0();\n  M1();\n  EqualityOfStrings0();\n  EqualityOfStrings1();\n}\n\n// The verification of the following methods requires knowledge\n// about the injectivity of sequence displays.\n\nmethod M0()\n{\n  assert {\"x\",\"y\",\"z\"}-{\"y\"} == {\"x\",\"z\"};\n}\n\nmethod M1()\n{\n  var n :| (\"R\",n) in {(\"R\",2),(\"P\",1)};\n  assert n == 2;\n  print n, \"\\n\";\n}\n\nmethod EqualityOfStrings0() {\n  assert \"a\" != \"b\";\n}\n\nmethod EqualityOfStrings1() {\n  assert \"a\" + \"b\" == \"ab\";\n}\n\nmethod M2()\n{\n  assert !( [0,0] in {[0,2],[1,2]} );\n}\n\nmethod M3()\n{\n  assert [0,0] !in {[0,2],[1,2]};\n}\n"}
{"file": "../dafny/Test/dafny4/Bug67.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype d = D(m:seq<int>)\n\nmethod Main()\n{\n  assert D([10, 20]) == D([10, 20]); // succeeds\n  print [10, 20] == [10, 20], \"\\n\"; // prints True\n  print D([10, 20]) == D([10, 20]); // prints False\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue206.dfy", "dafny": "// RUN: %dafny /compile:0 /rprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Foo = Bar(x: int)\n\nmethod letTest() {\n  assert (var (Bar(a), c) := (Bar(1), 2); a) == 1;\n}\n"}
{"file": "../dafny/Test/dafny4/Bug161.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype t = seq<int>\n\nghost predicate P(x:t)\nghost function F(x:t) : int\nghost function C() : int { assume (exists x :: P(x)); var x :| P(x); F(x) }\n\nlemma L(x:t)\n{\n  assume P(x);\n  assume forall y :: P(y) ==> y == x;\n  assert F(x) == C(); // FAILS\n}"}
{"file": "../dafny/Test/dafny4/git-issue43.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nclass System { }\n\n"}
{"file": "../dafny/Test/dafny4/Bug169.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate R(x: int)\n\nleast lemma P(x: int)\n{\n  forall x | R(x)\n  {\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/Bug110.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Io {\n  ghost predicate AdvanceTime(oldTime:int) { oldTime > 2 }\n  class Time\n  {\n    static method GetTime()\n        ensures AdvanceTime(1)\n  }\n\n  ghost function MaxPacketSize() : int { 65507 }\n\n  class UdpClient\n  {\n    method Receive()\n        ensures AdvanceTime(3)\n\n    method Send() returns(ok:bool)\n        requires 0 <= MaxPacketSize()\n  }\n}\n\nabstract module Host {\n    import opened Io // Doesn't work.\n    //import Io          // Works\n}\n\nabstract module Main {\n    import H : Host\n}\n"}
{"file": "../dafny/Test/dafny4/Bug120.dfy", "dafny": "// RUN: %dafny /compile:0 /noNLarith \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function G(n: nat): nat\n{\n  if n == 0 then 5 else G(n-1)\n}\n\nmethod Test() {\n  assert G(10) == 5;\n}"}
{"file": "../dafny/Test/dafny4/git-issue148.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function Foo(f: () -> (), n: nat): nat\n{\n    if n == 0 then n\n    else Foo(f, n - 1)\n}\n\nlemma lemma_Foo()\n    ensures forall g: () -> () :: Foo(g, 0) == 0  // regression: this had crashed Dafny\n{}\n"}
{"file": "../dafny/Test/dafny4/Bug70.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M1\n{\n  datatype d = D()\n}\n\nmodule M2 { import opened M1 }\nmodule M3 { import opened M1 }\n\nmodule M4\n{\n  import opened M1  // this is required to access D() unqualified below\n  import opened M2  // this causes no name conflict\n  import opened M3  // this causes no name conflict\n  method Main()\n  {\n    var x := D();\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/Primes.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate IsPrime(n: int)\n{\n  2 <= n && forall m :: 2 <= m < n ==> n % m != 0 // WISH It would be great to think about the status of modulo as a trigger\n}\n\n// The following theorem shows that there is an infinite number of primes\nlemma AlwaysMorePrimes(k: int)\n  ensures exists p :: k <= p && IsPrime(p)\n{\n  var j, s := 0, {};\n  while true\n    invariant AllPrimes(s, j)\n    decreases k - j\n  {\n    var p := GetLargerPrime(s, j);\n    if k <= p { return; }\n    j, s := p, set x | 2 <= x <= p && IsPrime(x);\n  }\n}\n\n// Here is an alternative formulation of the theorem\nlemma NoFiniteSetContainsAllPrimes(s: set<int>)\n  ensures exists p :: IsPrime(p) && p !in s\n{\n  AlwaysMorePrimes(if s == {} then 0 else PickLargest(s) + 1);\n}\n\n// ------------------------- lemmas and auxiliary definitions\n\nghost predicate AllPrimes(s: set<int>, bound: int)\n{\n  // s contains only primes\n  (forall x :: x in s ==> IsPrime(x)) &&\n  // every prime up to \"bound\" is included in s\n  (forall p :: IsPrime(p) && p <= bound ==> p in s)\n}\n\nlemma GetLargerPrime(s: set<int>, bound: int) returns (p: int)\n  requires AllPrimes(s, bound)\n  ensures bound < p && IsPrime(p)\n{\n  var q := product(s);\n  if exists p :: bound < p <= q && IsPrime(p) {\n    p :| bound < p <= q && IsPrime(p);\n  } else {\n    ProductPlusOneIsPrime(s, q);\n    p := q+1;\n    if p <= bound {  // by contradction, establish bound < p\n      assert p in s;\n      product_property(s);\n      assert false;\n    }\n  }\n}\n\nghost function product(s: set<int>): int\n{\n  if s == {} then 1 else\n  var a := PickLargest(s); a * product(s - {a})\n}\n\nlemma product_property(s: set<int>)\n  requires forall x :: x in s ==> 1 <= x\n  ensures 1 <= product(s) && forall x :: x in s ==> x <= product(s)\n{\n  if s != {} {\n    var a := PickLargest(s);\n    var s' := s - {a};\n    assert s == s' + {a};\n    product_property(s');\n    MulPos(a, product(s'));\n  }\n}\n\nlemma ProductPlusOneIsPrime(s: set<int>, q: int)\n  requires AllPrimes(s, q) && q == product(s)\n  ensures IsPrime(q+1)\n{\n  var p := q+1;\n  calc {\n    true;\n    { product_property(s); }\n    2 <= p;\n  }\n\n  forall m | 2 <= m <= q && IsPrime(m)\n    ensures p % m != 0\n  {\n    assert m in s;  // because AllPrimes(s, q) && m <= q && IsPrime(m)\n    RemoveFactor(m, s);\n    var l := product(s-{m});\n    assert m*l == q;\n    MulDivMod(m, l, q, 1);\n  }\n  assert IsPrime_Alt(q+1);\n  AltPrimeDefinition(q+1);\n}\n\n// The following lemma is essentially just associativity and commutativity of multiplication.\n// To get this proof through, it is necessary to know that if x!=y and y==Pick...(s), then\n// also y==Pick...(s - {x}).  It is for this reason that we use PickLargest, instead of\n// picking an arbitrary element from s.\nlemma RemoveFactor(x: int, s: set<int>)\n  requires x in s\n  ensures product(s) == x * product(s - {x})\n{\n  var y := PickLargest(s);\n  if x != y {\n    calc {\n      product(s);\n      y * product(s - {y});\n      { RemoveFactor(x, s - {y}); }\n      y * x * product(s - {y} - {x});\n      x * y * product(s - {y} - {x});\n      { assert s - {y} - {x} == s - {x} - {y}; }\n      x * y * product(s - {x} - {y});\n      /* FIXME: This annotation wasn't needed before the introduction\n       * of auto-triggers. It's not needed if one adds {:no_trigger}\n       * to the forall y :: y in s ==> y <= x part of PickLargest, but that\n       * boils down to z3 picking $Box(...) as good trigger\n       */\n      // FIXME: the parens shouldn't be needed around (s - {x})\n      { assert y in (s - {x}); }\n      { assert y == PickLargest(s - {x}); }\n      x * product(s - {x});\n    }\n  }\n}\n\n// This definition is like IsPrime above, except that the quantification is only over primes.\nghost predicate IsPrime_Alt(n: int)\n{\n  2 <= n && forall m :: 2 <= m < n && IsPrime(m) ==> n % m != 0\n}\n\n// To show that n is prime, it suffices to prove that it satisfies the alternate definition\nlemma AltPrimeDefinition(n: int)\n  requires IsPrime_Alt(n)\n  ensures IsPrime(n)\n{\n  forall m | 2 <= m < n\n    ensures n % m != 0\n  {\n    if !IsPrime(m) {\n      var a, b := Composite(m);\n      if n % m == 0 {  // proof by contradiction\n        var k := n / m;\n        calc {\n          true;\n          k == n / m;\n          m * k == n;\n          a * b * k == n;\n        ==>  { MulDivMod(a, b*k, n, 0); }\n          n % a == 0;\n        ==>  // IsPrime_Alt\n          !(2 <= a < n && IsPrime(a));\n          { assert 2 <= a < m < n; }\n          !IsPrime(a);\n          false;\n        }\n      }\n    }\n  }\n}\n\nlemma Composite(c: int) returns (a: int, b: int)\n  requires 2 <= c && !IsPrime(c)\n  ensures 2 <= a < c && 2 <= b && a * b == c\n  ensures IsPrime(a)\n{\n  calc {\n    true;\n    !IsPrime(c);\n    !(2 <= c && forall m :: 2 <= m < c ==> c % m != 0);\n    exists m :: 2 <= m < c && c % m == 0;\n  }\n  a :| 2 <= a < c && c % a == 0;\n  b := c / a;\n  assert 2 <= a < c && 2 <= b && a * b == c;\n  if !IsPrime(a) {\n    var x, y := Composite(a);\n    a, b := x, y*b;\n  }\n}\n\nghost function PickLargest(s: set<int>): int\n  requires s != {}\n{\n  LargestElementExists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\n\nlemma LargestElementExists(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  var s' := s;\n  while true\n    invariant s' != {} && s' <= s\n    invariant forall x,y :: x in s' && y in s && y !in s' ==> y <= x\n    decreases s'\n  {\n    var x :| x in s';  // pick something\n    if forall y :: y in s' ==> y <= x {\n      // good pick\n      return;\n    } else {\n      // constrain the pick further\n      var y :| y in s' && x < y;\n      s' := set z | z in s && x < z;\n      assert y in s';\n    }\n  }\n}\n\nlemma MulPos(a: int, b: int)\n  requires 1 <= a && 1 <= b\n  ensures a <= a * b\n{\n  if b == 1 {\n    assert a * b == a;\n  } else {\n    assert a * b == a * (b - 1) + a;\n    MulPos(a, b - 1);\n  }\n}\n\n// This axiom about % is needed.  Unfortunately, Z3 seems incapable of proving it.\nlemma MulDivMod(a: nat, b: nat, c: nat, j: nat)\n  requires a * b == c && j < a\n  ensures (c+j) % a == j\n"}
{"file": "../dafny/Test/dafny4/Bug121.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Try (a:int, b:int, c:int)\n{\n\tforall\n    ensures a * c == a * c\n    ensures b * c == b * c\n\t{\n\t}\n}\n\n\n\n\n\n\n\n"}
{"file": "../dafny/Test/dafny4/gcd.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation\n\n// A text describing this file is found in a Dafny Power User note: http://leino.science/papers/krml279.html\n\ntype pos = x | 1 <= x witness 1\n\nghost predicate IsFactor(p: pos, x: pos) {\n  exists q :: p * q == x\n}\n\nghost function Factors(x: pos): set<pos> {\n  set p: pos | p <= x && IsFactor(p, x)\n}\n\n// The following lemma proves that the conjunct \"p <= x\" in the\n// definition of Factors does not reduce the elements in the set.\nlemma FactorsHasAllFactors(x: pos)\n  ensures forall n :: n in Factors(x) <==> n in iset p: pos | IsFactor(p, x)\n{\n}\n\nlemma FactorsContains1(x: pos)\n  ensures 1 in Factors(x)\n{\n  assert 1 * x == x;\n}\n\nlemma FactorsContainsSelf(x: pos)\n  ensures x in Factors(x)\n{\n  assert x * 1 == x;\n}\n\n// This is a somewhat declarative definition of Max\nghost function Max(s: set<pos>): pos\n  requires s != {}\n{\n  // To use the :| operator below, we need to prove that such a value exists\n  MaxExists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\n\nlemma MaxExists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  // One way to show that such an x exists is to compute it\n  var x := FindMax(s);\n}\n\n// Here is a recursive definition for computing the max\nghost function FindMax(s: set<pos>): (max: pos)\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= max\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := FindMax(s');\n    if x < y then y else x\n}\n\nghost function Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  assert 1 in common by {\n    FactorsContains1(x);\n    FactorsContains1(y);\n  }\n  Max(common)\n}\n\nlemma AboutGcd(x: pos, y: pos)\n  ensures IsFactor(Gcd(x, y), x)\n  ensures IsFactor(Gcd(x, y), y)\n  ensures forall p: pos :: IsFactor(p, x) && IsFactor(p, y) ==> p <= Gcd(x, y)\n{\n  forall p: pos | IsFactor(p, x) && IsFactor(p, y)\n    ensures p <= Gcd(x, y)\n  {\n    assert p in Factors(x) * Factors(y);\n  }\n}\n\nlemma GcdSymmetric(x: pos, y: pos)\n  ensures Gcd(x, y) == Gcd(y, x)\n{\n  assert Factors(x) * Factors(y) == Factors(y) * Factors(x);\n}\n\nlemma GcdIdempotent(x: pos)\n  ensures Gcd(x, x) == x\n{\n  FactorsContainsSelf(x);\n  assert x in Factors(x) * Factors(x);\n}\n\nlemma GcdSubtract(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(x, y) == Gcd(x, y - x)\n{\n  var p := Gcd(x, y);\n\n  // By the definition of `Gcd`, we know that p is a factor of both x and y,\n  // We now show that p is also a factor of y - x.\n  assert IsFactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n\n  // Hence, p is a common factor of x and y - x\n  var common := Factors(x) * Factors(y - x);\n  assert p in common;\n\n  // It remains to show that, among the common factors of x and\n  // y - x, p is the greatest\n  forall q | q in common\n    ensures q <= p\n  {\n    // q is a factor of both x and y - x, so a and b exist:\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n    assert IsFactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n    // We just showed that q is a common factor of x and y.\n    assert q in Factors(x) * Factors(y);\n    // By the definition of Gcd(x, y), we then have that q <= p.\n  }\n}\n\nmethod EuclidGcd(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x: pos, y: pos := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)\n    decreases x + y\n  {\n    case x < y =>\n      GcdSubtract(x, y);\n      y := y - x;\n    case y < x =>\n      calc {\n        Gcd(x, y);\n      ==  { GcdSymmetric(x, y); }\n        Gcd(y, x);\n      ==  { GcdSubtract(y, x); }\n        Gcd(y, x - y);\n      ==  { GcdSymmetric(y, x - y); }\n        Gcd(x - y, y);\n      }\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\n\n// ------------------------------------------------------------------------------------------------------\n// The alternative definitions that follow allow the two cases in the GCD algorithm to look more similar.\n\nlemma GcdSubtractAlt(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(y, x) == Gcd(x, y - x) // this says Gcd(y, x) instead of Gcd(x, y) as in GcdSubtract above\n{\n  GcdSymmetric(x, y); // this is the difference from GcdSubtract above\n  var p := Gcd(x, y);\n\n  assert IsFactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n\n  var common := Factors(x) * Factors(y - x);\n  assert p in common;\n  forall q | q in common\n    ensures q <= p\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n    assert IsFactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n    assert q in Factors(x) * Factors(y);\n  }\n}\n\nmethod EuclidGcdAlt(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x: pos, y: pos := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)\n    decreases x + y\n  {\n    case x < y =>\n      GcdSubtractAlt(x, y);\n      GcdSymmetric(y, x);\n      y := y - x;\n    case y < x =>\n      GcdSymmetric(x - y, y);\n      GcdSubtractAlt(y, x);\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\n// ------------------------------------------------------------------------------------------------------\n\nmethod Main() {\n  Test(15, 9);\n  Test(14, 22);\n  Test(371, 1);\n  Test(1, 2);\n  Test(1, 1);\n  Test(13, 13);\n  Test(60, 60);\n}\n\nmethod Test(x: pos, y: pos) {\n  var gcd := EuclidGcd(x, y);\n  print x, \" gcd \", y, \"  =  \", gcd, \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/Regression2.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmodule NativeTypes {\n  newtype uint64 = int\n}\n\nmodule ConversionModule {\n  import opened NativeTypes\n\n  predicate Uint64ToBytes(u:uint64) { true }\n}\n\nabstract module AppStateMachine_s {\n  import opened NativeTypes\n}\n\nmodule AppStateMachine_i refines AppStateMachine_s {\n  import ConversionModule\n\n  predicate F(response:uint64)\n  {\n    ConversionModule.Uint64ToBytes(response)\n  }\n}\n\nmethod Main() {\n  var a := ConversionModule.Uint64ToBytes(67);\n  var b := AppStateMachine_i.ConversionModule.Uint64ToBytes(67);\n  var c := AppStateMachine_i.F(67);\n  print a, \" \", b, \" \", c, \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/Bug140.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nclass Node<T> {\n  ghost var List: seq<T>\n  ghost var Repr: set<Node<T>>\n\n  var data: T\n  var next: Node?<T>\n\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr &&\n    (next == null ==> List == [data]) &&\n    (next != null ==>\n        next in Repr && next.Repr <= Repr &&\n        this !in next.Repr &&\n        List == [data] + next.List &&\n        next.Valid())\n  }\n\n  constructor (d: T)\n    ensures Valid() && fresh(Repr)\n    ensures List == [d]\n  {\n    data, next := d, null;\n    List, Repr := [d], {this};\n  }\n\n  constructor InitAsPredecessor(d: T, succ: Node<T>)\n    requires succ.Valid()\n    ensures Valid() && fresh(Repr - succ.Repr)\n    ensures List == [d] + succ.List\n  {\n    data, next := d, succ;\n    List := [d] + succ.List;\n    Repr := {this} + succ.Repr;\n  }\n\n  method Prepend(d: T) returns (r: Node<T>)\n    requires Valid()\n    ensures r.Valid() && fresh(r.Repr - old(Repr))\n    ensures r.List == [d] + List\n  {\n    r := new Node.InitAsPredecessor(d, this);\n  }\n\n\tmethod Print()\n\t\trequires Valid()\n\t\tdecreases |List|\n\t{\n\t\tprint data, \" \";\n\t\tif next != null {\n\t\t\tnext.Print();\n\t\t}\n\t}\n}\n\nmethod Main()\n{\n\tvar l2 := new Node(2);\n  var l1 := l2.Prepend(1);\n\tl1.Print();\n  print \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue158.dfy", "dafny": "// NONUNIFORM: Multiple testing scenarios (could be split)\n// RUN: %dafny /compile:3 \"%s\" > \"%t\"\n// RUN: %dafny /compile:3 /optimize \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// See https://github.com/dafny-lang/dafny/issues/508\n\nclass Class { }\n\nnewtype byte = x | 0 <= x < 256\n\ndatatype Record<G> = Make(0:Class?, 1:G, 2:Class, 3:int, 4:byte)\n\nmethod Main()\n{\n  var a1 := new Class;\n  var a2 := new Class;\n  var a3 := new Class;\n  var c: map<Record<Class?>,real> := map[\n                Make(null,null,a1,5,10) := 0.8,\n                Make(null,null,a2,4,11) := 0.1,\n                Make(null,null,a3,8,12) := 0.1\n                ];\n  print map r | r in c && r.4 == 10 :: c[r], \"\\n\";\n  print map r | r in c && r.4 == 11 :: c[r], \"\\n\";\n  print map r | r in c && r.4 == 12 :: c[r], \"\\n\";\n  More(null);\n  EvenMore(null);\n  AndThenSome(null);\n  Compare();\n  In();\n}\n\nmethod More(n: Class?)\n{\n  var x := (5,n);\n  var y := (5,n,2);\n  var S := {x};\n  var S' := {y};\n  print x, \"\\n\";\n  print y, \"\\n\";\n  print S, \"\\n\";\n  print S', \"\\n\";\n}\n\nmethod EvenMore(n: Class?)\n{\n  print {n}, \"\\n\";\n  print [n], \"\\n\";\n  var empty: multiset<Class?> := multiset{};\n  print empty, \" \", multiset{n}, \" \", multiset{n,n}, \"\\n\";\n  print map[5 := n], \"\\n\";\n  print map[n := 5], \"\\n\";\n}\n\nmethod AndThenSome(n: Class?)\n{\n  var A := {n};\n  var B := multiset{n};\n  var C := [n];\n  var D := map[n := n];\n  // the following will cause hashcodes to be computed for A, B, C, and D\n  print {A}, \" \", multiset{A}, \" \", [A], \" \", map[A := A], \"\\n\";\n  print {B}, \" \", multiset{B}, \" \", [B], \" \", map[B := B], \"\\n\";\n  print {C}, \" \", multiset{C}, \" \", [C], \" \", map[C := C], \"\\n\";\n  print {D}, \" \", multiset{D}, \" \", [D], \" \", map[D := D], \"\\n\";\n}\n\ndatatype CmpRecord<G> = Cmp(a: object?, g: G)\n\nmethod Compare() {\n  var o := new object;\n  var c := new Class;\n  var r0: CmpRecord<Class?> := Cmp(null, null);\n  var r1: CmpRecord<Class?> := Cmp(o, c);\n  print r0==r1, \" \", r1==r0, \" \", r0==r0, \" \", r1==r1, \"\\n\";\n\n  var s := [c, null];\n  print c in s, \" \", null in s, \" \", o in s, \"\\n\";\n  var t := [2, 3, 5];\n  print 3 in t, \" \", 4 in t, \"\\n\";\n  var u := [false, false];\n  print false in u, \" \", true in u, \"\\n\";\n}\n\nmethod In() {\n  var o: Class? := new Class;\n  var c := new Class;\n  var s: seq<Class> := [];\n  print o in s, \"\\n\";\n  print o == c, \" \", c == o, \"\\n\";\n  print [o] == [c], \" \", [c] == [o], \"\\n\";\n  print [o] == [o], \" \", [c] == [c], \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/Bug54.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate G<X(!new)>(f:X~>bool)\n  reads f.reads\n  requires forall x :: f.requires(x) && f(x)\n{\n  true\n}\n\nghost predicate H()\n{\n  G((x:int) => true)\n}\n\nghost predicate P1<X>(m:map<X,bool>)\n  requires forall x :: x in m ==> m[x]\n{\n  true\n}\n\nghost predicate P2(m:map<int,bool>)\n  requires forall x :: x in m ==> m[x]\n{\n  P1(map x:int | x in m :: true)\n}\n"}
{"file": "../dafny/Test/dafny4/Bug89.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod F() returns(x:int)\n  ensures x == 6\n{\n  x := 5;\n  x := (var y := 1; y + x);\n}\n\nmethod Main()\n{\n  var x := F();\n  print x;\n}\n"}
{"file": "../dafny/Test/dafny4/Regression1.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost method M() {\n  var x :=\n// In the following line, why are the range and term copied in Substitute?\n//    var loo := 100; map y | 0 <= y < 100 :: y+1;\n    var loo := 100; imap y: int | true :: 3;\n}\n"}
{"file": "../dafny/Test/dafny4/Bug136.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod test()\n{\n    assume false;\n    assert true;\n}\n\n\n\n\n"}
{"file": "../dafny/Test/dafny4/git-issue79.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype EInt = Int(val: int) | Unknown\ntype Pair = (string, EInt)\n\nghost function Inc(p: Pair): Pair\n{\n  match p\n  case (s, Int(x)) => (s, Int(x + 1))\n  case (s, Unknown) => (s, Unknown)\n}\n\nghost function Inc2(s1:string, t1:EInt): Pair\n{\n  match (s1, t1)\n  case (s1, Int(x)) => (s1, Int(x + 1))\n  case (s1, Unknown) => (s1, Unknown)\n}\n\nghost function Inc3(s1: string, t1: EInt, t2: EInt) : Pair\n{\n  match (s1, t1, t2)\n  case (s1, Int(x), Unknown) => (s1, Int(x + 1))\n  case (s1, Int(x), Int(y)) => (s1, Int(x + y + 1))\n  case (s1, Unknown, Unknown) => (s1, Unknown)\n  case (s1, Unknown, Int(y)) => (s1, Int(y+1))\n}\n\ntype Triple = (string, EInt, EInt)\n\nghost function Inc4(t: Triple) : Pair\n{\n  match t\n  case (s1, Int(x), Unknown) => (s1, Int(x + 1))\n  case (s1, Int(x), Int(y)) => (s1, Int(x + y + 1))\n  case (s1, Unknown, Unknown) => (s1, Unknown)\n  case (s1, Unknown, Int(y)) => (s1, Int(y+1))\n}\n\nmethod IncM(p: Pair)\n{\n  match p {\n  \tcase (s, Int(x)) =>\n  \tcase (s, Unknown) =>\n  }\n}\n\nmethod IncM2(s:string, t:EInt)\n{\n  match (s,t) {\n  \tcase (s, Int(x)) =>\n  \tcase (s, Unknown) =>\n  }\n}\n\nmethod IncM3(s1: string, t1: EInt, t2: EInt) {\n  match (s1, t1, t2)\n  case (s1, Int(x), Unknown) =>\n  case (s1, Int(x), Int(y)) =>\n  case (s1, Unknown, Unknown) =>\n  case (s1, Unknown, Int(y)) =>\n}\n\nmethod IncM4(t: Triple) {\n  match t\n  case (s1, Int(x), Unknown) =>\n  case (s1, Int(x), Int(y)) =>\n  case (s1, Unknown, Unknown) =>\n  case (s1, Unknown, Int(y)) =>\n}\n"}
{"file": "../dafny/Test/dafny4/Bug133.dfy", "dafny": "// RUN: %dafny /noNLarith /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Math__div_def_i {\n\tfunction my_div_pos(x:int, d:int) : int\n\t\trequires d >  0\n\t\tdecreases if x < 0 then (d - x) else x\n\t{\n\t\tif x < 0 then\n\t\t\t-1 + my_div_pos(x+d, d)\n\t\telse if x < d then\n\t\t\t0\n\t\telse\n\t\t\t1 + my_div_pos(x-d, d)\n\t}\n}\n\n\n"}
{"file": "../dafny/Test/dafny4/Regression3.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main()\n{\n  var z := OutParametersInLetBodies();\n  DoSomeFloors();\n}\n\n// Here is a regression test\n\nmethod OutParametersInLetBodies() returns (t: int)\n{\n  t := 25;\n  var z := var y := 30; F(t, y);\n  assert z == 55;\n  print z, \"\\n\";\n}\n\nfunction F(x: int, y: int): int { x + y }\n\n\n// Here is another compiler test\n\nmethod DoSomeFloors()\n{\n  P(-3.0, -3);\n  P(-2.8, -3);\n  P(-2.2, -3);\n  P(-0.1, -1);\n  P(0.0, 0);\n  P(0.1, 0);\n  P(2.2, 2);\n  P(2.8, 2);\n  P(3.0, 3);\n}\n\nmethod P(r: real, y: int)\n  requires r.Floor == y\n{\n  var x := r.Floor;\n  print \"Trunc( \", r, \" ) = \", x, \" (expected \", y, \")\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue96.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate P(s:seq<int>)\n    requires 10 < |s|\n{\n    (forall i:int {:trigger s[i]} :: forall j:int {:trigger s[j]} ::\n        0 <= i < j < 5 ==> s[i + j] == s[i] == s[j])\n}\n\nghost predicate P0(s:seq<int>)\n    requires 10 < |s|\n{\n    (forall i:int :: forall j:int  ::\n        0 <= i < j < 5 ==> s[i + j] == s[i] == s[j])\n}\n\n\nghost predicate P1(s:seq<int>)\n    requires 10 < |s|\n{\n    (forall i:int, j: int {:trigger s[i], s[j]} ::\n        0 <= i < j < 5 ==> s[i + j] == s[i]+s[j])\n}\n\nghost predicate P2(s:seq<int>)\n    requires 10 < |s|\n{\n    (forall i:int, j: int ::\n        0 <= i < j < 5 ==> s[i + j] == s[i]+s[j])\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue133.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype State = State(m:map<int, bool>)\n\nlemma Test(s:State)\n  requires 42 in s.m\n  ensures s.(m := s.m[42 := s.m[42]]) == s\n{\n  var s' := s.(m := s.m[42 := s.m[42]]);\n  assert s'.m == s.m;\n}\n\ndatatype MyDt = MakeA(x: int, bool) | MakeB(s: multiset<int>, t: State)\n\nlemma AnotherTest(a: MyDt, b: MyDt, c: bool)\n  requires a.MakeB? && b.MakeB?\n  requires a.s == multiset(a.t.m.Keys) && |b.s| == 0\n  requires a.t.m == map[] && |b.t.m| == 0\n{\n  assert a == b;\n}\n\ndatatype GenDt<X,Y> = Left(X) | Middle(X,int,Y) | Right(y: Y)\n\nmethod ChangeGen(g: GenDt)\n{\n  match g\n  case Left(_) =>\n  case Middle(_,_,_) =>\n  case Right(u) =>\n    var h := g.(y := u);\n    assert g == h;\n}\n\ndatatype Recursive<X> = Red | Green(next: Recursive, m: set)\n\nlemma RecLem(r: Recursive) returns (s: Recursive)\n  ensures r == s\n{\n  match r\n  case Red =>\n    s := Red;\n  case Green(next, m) =>\n    var n := RecLem(next);\n    s := Green(n, m + m);\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue141.dfy", "dafny": "// RUN: %dafny /compile:0 /rprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Node<T> {\n  var next: Node?<T>\n}\n\nclass List<T> {\n    ghost var spine: seq<Node<T>>\n    ghost var repr: set<object>\n\n    ghost predicate Valid()\n        reads this, repr\n    {\n        && forall i | 0 <= i < |spine| ::\n            && spine[i] in repr\n            && (spine[i].next == (if i < |spine| - 1 then spine[i+1] else null))\n    }\n}"}
{"file": "../dafny/Test/dafny4/Regression19.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate ContainsNothingBut5(s: set<int>)\n{\n  forall q :: q in s ==> q == 5\n}\n\nghost predicate YeahContains5(s: set<int>)\n{\n  exists q :: q in s && q == 5\n}\n\nghost predicate ViaSetComprehension(s: set<int>) {\n  |set q | q in s && q == 5| != 0\n}\n\nghost predicate LambdaTest(s: set<int>) {\n  (q => q in s)(5)\n}\n\nghost predicate ViaMapComprehension(s: set<int>) {\n  |(map q | q in s && q == 5 :: true).Keys| != 0\n}\n\nghost predicate Contains5(s: set<int>)\n{\n  var q := 5; q in s\n}\n\ndatatype R = MakeR(int) | Other\n\nghost predicate RIs5(r: R) {\n  match r case MakeR(q) => q == 5 case Other => false\n}\n\nlemma NonemptySet(x: int, s: set<int>)\n  requires x in s\n  ensures |s| != 0\n{\n}\nlemma NonemptyMap(x: int, s: map<int,bool>)\n  requires x in s.Keys\n  ensures |s| != 0\n{\n}\n\nmethod M(s: set<int>, r: R, q: int)\n  requires s == {5} && r == MakeR(5)\n{\n  assert ContainsNothingBut5(s);  // forall\n  assert YeahContains5(s);  // exists\n\n  NonemptySet(5, set q | q in s && q == 5);\n  assert ViaSetComprehension(s);  // set comprehension\n\n  NonemptyMap(5, map q | q in s && q == 5 :: true);\n  assert ViaMapComprehension(s);  // map comprehension\n\n  assert LambdaTest(s);  // lambda expression\n  assert Contains5(s);  // let expression (once had generated malformed Boogie)\n\n  assert RIs5(r);  // match expression\n}\n"}
{"file": "../dafny/Test/dafny4/Bug124.dfy", "dafny": "// RUN: %dafny /compile:0 /noNLarith  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function power(n:nat, e:nat) : int\n\nlemma lemma_power()\n    ensures forall n:nat, e:nat :: 0 <= n * e && power(n, e) == 5\n{\n    forall n:nat, e:nat\n        ensures 0 <= n * e && power(n, e) == 5\n    {\n        assume false;\n    }\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue167.dfy", "dafny": "// NONUNIFORM: https://github.com/dafny-lang/dafny/issues/4108\n// RUN: %dafny /compile:3 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  LetTest();\n\n  var m := map[6 := 8, 7 := 3];\n  var n := Rewrite(m);\n  assert m.Keys == n.Keys;\n  print n.Keys, \"\\n\";\n\n  var u := {\"Alfons\", \"Milla\"};\n  var v := Rewrite2(u);\n  assert u == v.Keys;\n  print v.Keys, \"\\n\";\n}\n\n// Some tests of let-expression translation into Boogie's new let expressions:\n\nfunction F(u: int): int\n  requires u < 2400\n{\n  u\n}\n\nfunction G(w: int): int\n{\n  var g := w + w;\n  g - w\n}\n\nmethod LetTest() {\n  var x :=\n    var y := \"unused\"; var y, z := 10, 20; G(F(y)) + z;\n  assert x == G(30);\n  print x, \"\\n\";\n}\n\n// Issue 167:\n\nfunction Rewrite(env: map<nat, nat>): map<nat, nat> {\n  var p := map g: nat | g in env :: g;  // regression test: used to produce malformed Boogie\n  map n: nat | n in p :: n\n}\n\nfunction Rewrite_Keys(env: map<nat, nat>): map<nat, nat> {\n  var p := env.Keys;  // this is an easier way to assign p like in Rewrite\n  map n: nat | n in p :: n\n}\n\nfunction Rewrite2(strs: set<string>): map<string, string> {\n  var p := map g: string | g in strs :: g;  // regression test: used to produce malformed Boogie\n  map s: string | s in p :: s\n}\n\nghost function sum(a: int, b: int): int {\n  a + b\n}\n\nghost predicate sum_is_sum(b: int, c: int) {\n  var s := a => sum(a, b);\n  forall a: int :: s(a) + c == a + b + c\n}\n\nlemma TestApply(x: int, y: int)\n  ensures sum_is_sum(x, y)\n{\n}\n\n// Issue 215:\n\nmodule Test {\n  datatype A = A1\n  datatype B = B1\n\n  ghost function Convert_AB(f:A) : B { B1 }\n  ghost function Convert_BA(f:B) : A { A1 }\n\n  ghost function ConvertMap_AB(m:map<A, int>) : map<B, int>\n  {\n    var dom_B := set a | a in m :: Convert_AB(a);\n    assert forall u :: u in m.Keys ==> u == A1;  // added this to Issue 215 to make the next line verify\n    map b | b in dom_B :: m[Convert_BA(b)]\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue70.dfy", "dafny": "// NONUNIFORM: https://github.com/dafny-lang/dafny/issues/4108\n// RUN: %dafny  /compile:3 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main()\n{\n  mapTest();\n  imapTest();\n}\n\nmethod mapTest() {\n  print \"map test \\n\";\n  var m := map[4 := 5, 6 := 7];\n  assert (set x | x in m) == m.Keys;\n  assert (set x | x in m :: m[x]) == m.Values;\n  print m.Keys, \"\\n\";\n  print m.Values, \"\\n\";\n  assert (4,5) in m.Items;\n  print m.Items, \"\\n\";\n}\n\nmethod imapTest() {\n  print \"imap test \\n\";\n  var m := imap[4 := 5, 6 := 7];\n  assert (iset x | x in m) == m.Keys;\n  assert (iset x | x in m :: m[x]) == m.Values;\n  print m.Keys, \"\\n\";\n  print m.Values, \"\\n\";\n  assert (4,5) in m.Items;\n  print m.Items, \"\\n\";\n}\n\n"}
{"file": "../dafny/Test/dafny4/MonadicLaws.dfy", "dafny": "// RUN: %dafny /compile:0 /rprint:\"%t.rprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Monadic Laws\n// Niki Vazou and Rustan Leino\n// 28 March 2016\n\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost function append(xs: List, ys: List): List\n{\n  match xs\n  case Nil => ys\n  case Cons(x, xs') => Cons(x, append(xs', ys))\n}\n\nlemma AppendNil(xs: List)\n  ensures append(xs, Nil) == xs\n{\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n}\n\nghost function Return<T>(a: T): List\n{\n  Cons(a, Nil)\n}\n\nghost function Bind<T,U>(xs: List<T>, f: T -> List<U>): List<U>\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, xs') => append(f(x), Bind(xs', f))\n}\n\nlemma LeftIdentity<T>(a: T, f: T -> List)\n  ensures Bind(Return(a), f) == f(a)\n{\n  AppendNil(f(a));\n}\n\nlemma RightIdentity<T>(m: List)\n  ensures Bind(m, Return) == m\n{\n  match m\n  case Nil =>\n    assert Bind<T,T>(Nil, Return) == Nil;\n  case Cons(x, m') =>\n    calc {\n      Bind(Cons(x, m'), Return);\n      append(Return(x), Bind(m', Return));\n      Cons(x, Bind(m', Return));\n    }\n}\n\nlemma Associativity<T>(m: List, f: T -> List, g: T -> List)\n  ensures Bind(Bind(m, f), g) == Bind(m, x => Bind(f(x), g))\n{\n  match m\n  case Nil =>\n    assert Bind(m, x => Bind(f(x), g)) == Nil;\n  case Cons(x, xs) =>\n    match f(x)\n    case Nil =>\n      calc {\n        Bind(xs, y => Bind(f(y), g));\n        Bind(Cons(x, xs), y => Bind(f(y), g));\n      }\n    case Cons(y, ys) =>\n      calc {\n        append(g(y), Bind(append(ys, Bind(xs, f)), g));\n        { BindOverAppend(ys, Bind(xs, f), g); }\n        append(g(y), append(Bind(ys, g), Bind(Bind(xs, f), g)));\n        { AppendAssoc(g(y), Bind(ys, g), Bind(Bind(xs, f), g)); }\n        append(append(g(y), Bind(ys, g)), Bind(Bind(xs, f), g));\n        Bind(Cons(x, xs), z => Bind(f(z), g));\n      }\n}\n\nlemma BindOverAppend<T>(xs: List, ys: List, g: T -> List)\n  ensures Bind(append(xs, ys), g) == append(Bind(xs, g), Bind(ys, g))\n{\n  match xs\n  case Nil =>\n  case Cons(x, xs') =>\n    AppendAssoc(g(x), Bind(xs', g), Bind(ys, g));\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue28.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nlemma mylemma()\n{\n    var shift:int := 1;\n    assume (1 as bv32 << shift) as int == 2;\n    assert (1 as bv32 << 1) as int == 2;\n}\n\n"}
{"file": "../dafny/Test/dafny4/Bug129.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Maybe<T> = Some(v:T) | None\ndatatype B = B(b:Maybe<B>)\n\ndatatype List<T> = Nil | Cons(T, List<T>)\ndatatype Tree<T> = Nodes(children: List<Tree<T>>)\n\n\n\n\n"}
{"file": "../dafny/Test/dafny4/git-issue40.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function SeqRepeat<T>(count:nat, elt:T) : seq<T>\n    ensures |SeqRepeat<T>(count, elt)| == count\n    ensures forall i :: 0 <= i < count ==> SeqRepeat<T>(count, elt)[i] == elt\n\ndatatype Maybe<T> = Nothing | Just(v: T)\ntype Num = x | 0 <= x < 10\ndatatype D = C(seq<Maybe<Num>>)\n\nlemma test()\n{\n    ghost var s := SeqRepeat(1, Nothing);\n    ghost var e := C(s);\n    assert e == C(SeqRepeat(1, Nothing));\n}\n\n\n\n"}
{"file": "../dafny/Test/dafny4/Bug148.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main()\n{\n    var zero    : real  := 0.0;\n\t\tvar three   : real  := 3.0;\n    var fifteen : real  := 15.0;\n\t\tvar negone  : real  := -1.0;\n\t\tvar negthree : real := -3.0;\n\n\t\tprint zero <= fifteen, \"\\n\";  // true\n\t\tprint fifteen <= zero, \"\\n\";  // false\n\t\tprint negone <= zero, \"\\n\";   // true\n\t\tprint zero <= negone, \"\\n\";   // false\n\t\tprint negone <= fifteen, \"\\n\"; // true\n\t\tprint fifteen <= negone, \"\\n\";  // false\n\n\t\tprint zero >= fifteen, \"\\n\";  // false\n\t\tprint fifteen >= zero, \"\\n\";  // true\n\t\tprint negone >= zero, \"\\n\";   // false\n\t\tprint zero >= negone, \"\\n\";   // true\n\t\tprint negone >= fifteen, \"\\n\"; // false\n\t\tprint fifteen >= negone, \"\\n\";  // true\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue45.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Library {\n}\n\nmodule Outer {\n  import Library\n\n  module Inner {\n    import Library\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/Bug159.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod ArrayInit(n: nat) returns (a: array<int>)\n  ensures a.Length == n\n  ensures forall i :: 0 <= i < n ==> a[i] == i\n{\n  a := new int[n];\n  forall i | 0 <= i < n {\n    a[i] := i;\n  }\n}\n\nmethod Init(m: array2<int>)\n  modifies m\n  ensures forall i,j :: 0 <= i < m.Length0 && 0 <= j < m.Length1 ==> m[i,j] == 0\n{\n  forall i,j | 0 <= i < m.Length0 && 0 <= j < m.Length1 {\n    m[i,j] := 0;\n  }\n}\n\nmethod Gradient(n: nat) returns (m: array2<int>)\n  ensures m.Length0 == m.Length1 == n\n  ensures forall i,j :: 0 <= i < n && 0 <= j < n ==> m[i,j] == j+i\n{\n  m := new int[n,n];\n  forall i,j | 0 <= i < n && 0 <= j < n {\n    m[i,j] := i+j;\n  }\n}\n\nmethod M3(C: array3<real>)\n  modifies C\n  ensures forall i,j,k ::\n    0 <= i < C.Length0 && 0 <= j < C.Length1 && 0 <= k < C.Length2\n    ==> C[i,j,k] == 0.0\n{\n  forall i,j,k | 0 <= i < C.Length0 && 0 <= j < C.Length1 && 0 <= k < C.Length2\n  {\n    C[i,j,k] := 0.0;\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue44.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype uint32 = i:int | 0 <= i < 0x1_0000_0000\n\nghost function RepeatValue<T>(n:T, count:nat) : seq<T>\n\nghost function RepeatMapValue<T>(n:T, count:nat) : map<T, T>\n\nghost function RepeatArrayValue<T>(n:T, count:nat) : array<T>\n\nghost function Example1(len:nat) : seq<uint32>\n{\n    // Error: value does not satisfy the subset constraints of 'seq<uint32>'\n    RepeatValue(5 as uint32, len)\n}\n\nghost function Example2(len:nat) : map<uint32, uint32>\n{\n    RepeatMapValue(5 as uint32, len)\n}\n\nghost function Example3(len:nat) : array<uint32>\n{\n    RepeatArrayValue(5 as uint32, len)\n}"}
{"file": "../dafny/Test/dafny4/Bug139.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype List = Nil | Cons(int, List)\n\nmethod R(xs: List)\n{\n  var a: int;\n  var b: int;\n  match xs\n  case Nil =>\n  case Cons(a, Nil()) =>  // this 'a' is allowed\n  case Cons(x, Cons(b, tail)) =>  // this 'b' (which is in a nested position) generates an error\n}\n\nghost function F(xs: List): int\n{\n  var a := 4;\n  var b := 7;\n  match xs\n  case Nil => 0\n  case Cons(a, Nil()) => 1\n  case Cons(x, Cons(b, tail)) => 2\n}\n\n"}
{"file": "../dafny/Test/dafny4/git-issue120.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function {:opaque} opfn(): int { 37 }\n\nghost function foo(): int\n{\n    var x := opfn();\n    assert x == 37 by { reveal opfn(); }\n    x\n}\n\n"}
{"file": "../dafny/Test/dafny4/git-issue195.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype Block<Hash,Transaction,VProof> =\n  Block(prevBlockHash:Hash, txs:seq<Transaction>, proof:VProof)\n\nfunction GenesisBlock() : Block<int,int,int> {\n  Block(0, [], 0)\n}\n\nmethod IsGenesisBlock(b : Block<int,int,int>) returns (eq : bool)\n  ensures eq <==> b == GenesisBlock()\n{\n  var gb := GenesisBlock();\n  eq := b == gb;\n}\n\nmethod Main() {\n  var b := GenesisBlock();\n  var eq := IsGenesisBlock(b);\n  assert eq;\n  print eq, \"\\n\";\n  TestEq();\n}\n\nnewtype nt = int\nnewtype ntNative = x | -100 <= x < 100\nclass MyClass { var u: int }\ndatatype X = X(bool, char, int, real, nt, ntNative, bv8, bv167, ORDINAL, MyClass)\n\npredicate TestAny<G(==)>(a: G, b: G)\n  requires a == b\n{\n  a == b\n}\n\nmethod TestEq()\n{\n  print true == true, \" \", TestAny(true, true), \"\\n\";\n  print 'e' == 'e', \" \", TestAny('e', 'e'), \"\\n\";\n  print 12 == 12, \" \", TestAny(12, 12), \"\\n\";\n  print 37.5 == 37.5, \" \", TestAny(37.5, 37.5), \"\\n\";\n  var m0: nt, m1: nt := 12, 12;\n  print m0 == m1, \" \", TestAny(m0, m1), \"\\n\";\n  var n0: ntNative, n1: ntNative := 12, 12;\n  print n0 == n1, \" \", TestAny(n0, n1), \"\\n\";\n  var b0: bv8, b1: bv8 := 12, 12;\n  print b0 == b1, \" \", TestAny(b0, b1), \"\\n\";\n  var c0: bv167, c1: bv167 := 12, 12;\n  print c0 == c1, \" \", TestAny(c0, c1), \"\\n\";\n  var o0: ORDINAL, o1: ORDINAL := 12, 12;\n  print o0 == o1, \"\\n\";\n  var obj := new MyClass;\n  print obj == obj, \" \", TestAny(obj, obj), \"\\n\";\n\n  var x0 := X(true, 'e', 12, 37.5, 12, 12, 12, 12, 12, obj);\n  var x1 := X(true, 'e', 12, 37.5, 12, 12, 12, 12, 12, obj);\n  print [x0] == [x1], \" \", TestAny([x0], [x1]), \"\\n\";\n  print {x0} == {x1}, \" \", TestAny({x0}, {x1}), \"\\n\";\n  print multiset{x0} == multiset{x1}, \" \", TestAny(multiset{x0}, multiset{x1}), \"\\n\";\n  print map[x0 := n0] == map[x0 := n1], \" \", TestAny(map[x0 := n0], map[x0 := n1]), \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/Ackermann.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// Rustan Leino, 8 Sep 2015.\n// This file proves that the Ackermann function is monotonic in each argument\n\nmethod Main() {\n  // Note, don't try much larger numbers unless you're prepared to wait!\n  print \"Ack(3, 4) = \", Ack(3, 4), \"\\n\";\n}\n\n// Here is the definition of the Ackermann function:\nfunction Ack(m: nat, n: nat): nat\n{\n  if m == 0 then\n    n + 1\n  else if n == 0 then\n    Ack(m - 1, 1)\n  else\n    Ack(m - 1, Ack(m, n - 1))\n}\n\n// And here is the theorem that proves the desired result:\nlemma AckermannIsMonotonic(m: nat, n: nat, m': nat, n': nat)\n  requires m <= m' && n <= n'\n  ensures Ack(m, n) <= Ack(m', n')\n{\n  // This is the proof.  It calls two lemmas, stated and proved below.\n  MonotonicN(m, n, n');\n  MonotonicM(m, n, m');\n}\n\n// --------------------------------------------------------\n// What follows are the supporting lemmas and their proofs.\n// --------------------------------------------------------\n\n// Proving that Ackermann is monotonic in its second argument is easy.\nlemma MonotonicN(m: nat, n: nat, n': nat)\n  requires n <= n'\n  ensures Ack(m, n) <= Ack(m, n')\n{\n  // In fact, Dafny completes this proof automatically.\n}\n\n// To prove the other direction, we consider an alternative formulation\n// of the Ackermann function, namely a curried form:\nghost function CurriedAckermann(m: int, n: int): int\n{\n  A(m)(n)\n}\n\nghost function A(m: int): int -> int\n{\n  if m <= 0 then\n    n => n + 1\n  else\n    n => Iter(A(m-1), n)\n}\n\nghost function Iter(f: int -> int, n: int): int\n  decreases n\n{\n  if n <= 0 then\n    f(1)\n  else\n    f(Iter(f, n-1))\n}\n\n// Now, we can prove certain things about CurriedAckermann.  The first thing we\n// prove is that it gives the same result as the Ack function above.\n\nlemma CurriedIsTheSame(m: nat, n: nat)\n  ensures CurriedAckermann(m, n) == Ack(m, n)\n{\n  // The proof considers 3 cases, following the 3 cases in the definition of Ack\n  if m == 0 {\n    // trivial\n  } else if n == 0 {\n      // Give Dafny some help unrolling these definitions\n      // (note to advanced users: We need a bit more fuel\n      //  to meet up with the induction hypothesis)\n      assert CurriedAckermann(m, n) == Iter(A(m-1), 0);\n  } else {\n    // we help Dafny out with the following lemma:\n    assert A(m)(n) == A(m-1)(Iter(A(m-1), n-1));\n  }\n}\n\n// Monotonicity in the first argument of Ackermann now follows from the fact that,\n// for m <= m', A(m) is a function that is always below A(m')\nlemma MonotonicM(m: nat, n: nat, m': nat)\n  requires m <= m'\n  ensures Ack(m, n) <= Ack(m', n)\n{\n  CurriedIsTheSame(m, n);\n  CurriedIsTheSame(m', n);\n  ABelow(m, m');\n}\n\n// We must now prove ABelow.  To do that, we will prove some properties of A and of\n// Iter.  Let us define the three properties we will reason about.\n\n// The first property is a relation on functions.  It is the property that above was referred\n// to as \"f is a function that is always below g\".  The lemma ABelow(m, m') used above establishes\n// FunctionBelow(A(m), A(m')).\nghost predicate FunctionBelow(f: int -> int, g: int -> int)\n{\n  forall n :: f(n) <= g(n)\n}\n\n// The next property says that a function is monotonic.\nghost predicate FunctionMonotonic(f: int -> int)\n{\n  forall n,n' :: n <= n' ==> f(n) <= f(n')\n}\n\n// The third property says that a function's return value is strictly greater than its argument.\nghost predicate Expanding(f: int -> int)\n{\n  forall n :: n < f(n)\n}\n\n// We will prove that A(_) satisfies the properties FunctionBelow, FunctionMonotonic, and\n// FunctionExpanding.  But first we prove three properties of Iter.\n\n// Provided that \"f\" is monotonic and expanding, Iter(f, _) is monotonic.\nlemma IterIsMonotonicN(f: int -> int, n: int, n': int)\n  requires Expanding(f) && FunctionMonotonic(f) && n <= n'\n  ensures Iter(f, n) <= Iter(f, n')\n{\n  // This proof is a simple induction over n' and Dafny completes the proof automatically.\n}\n\n// Next, we prove that Iter(_, n) is monotonic.  That is, given functions \"f\" and \"g\"\n// such that FunctionBelow(f, g), we have Iter(f, n) <= Iter(g, n).  The lemma requires\n// \"f\" to be monotonic, but we don't have to state the same property for g.\nlemma IterIsMonotonicF(f: int -> int, g: int -> int, n: int)\n  requires FunctionMonotonic(f) && FunctionBelow(f, g)\n  ensures Iter(f, n) <= Iter(g, n)\n{\n  // This proof is a simple induction over n and Dafny completes the proof automatically.\n}\n\n// Finally, we shows that for any expanding function \"f\", Iter(f, _) is also expanding.\nlemma IterExpanding(f: int -> int, n: int)\n  requires Expanding(f)\n  ensures n < Iter(f, n)\n{\n  // Here, too, the proof is a simple induction of n and Dafny completes it automatically.\n}\n\n// We complete the proof by showing that A(_) has the three properties we need.\n\n// Of the three properties we prove about A(_), we start by showing that A(m) returns a\n// function that is expanding.\nlemma AExp(m: int)\n  ensures Expanding(A(m))\n{\n  if m <= 0 {\n    // trivial\n  } else {\n    // This branch of the proof follows from the fact that Iter(A(m-1), _) is expanding.\n    forall n {\n      // The following lemma requires A(m-1) to be expanding, which is something that\n      // following from our induction hypothesis.\n      IterExpanding(A(m-1), n);\n    }\n  }\n}\n\n// Next, we show that A(m) returns a monotonic function.\nlemma Am(m: int)\n  ensures FunctionMonotonic(A(m))\n{\n  if m <= 0 {\n    // trivial\n  } else {\n    // We make use of the fact that A(m-1) is expanding:\n    AExp(m-1);\n    // and the fact that Iter(A(m-1), _) is monotonic:\n    forall n,n' | n <= n' {\n      // The following lemma requires A(m-1) to be expanding and monotonic.\n      // The former comes from the invocation of AExp(m-1) above, and the\n      // latter comes from our induction hypothesis.\n      IterIsMonotonicN(A(m-1), n, n');\n    }\n  }\n}\n\n// Our final property about A, which is the lemma we had used above to prove\n// that Ackermann is monotonic in its first argument, is stated and proved here:\nlemma ABelow(m: int, m': int)\n  requires m <= m'\n  ensures FunctionBelow(A(m), A(m'))\n{\n  if m' <= 0 {\n    // trivial\n  } else if m <= 0 {\n    forall n {\n      calc {\n        A(m)(n);\n      ==\n        n + 1;\n      <=  { AExp(m'-1); IterExpanding(A(m'-1), n); }\n        Iter(A(m'-1), n);\n      ==\n        A(m')(n);\n      }\n    }\n  } else {\n    forall n {\n      calc {\n        A(m)(n);\n      ==\n        Iter(A(m-1), n);\n      <=  { Am(m-1); ABelow(m-1, m'-1);\n            IterIsMonotonicF(A(m-1), A(m'-1), n); }\n        Iter(A(m'-1), n);\n      ==\n        A(m')(n);\n      }\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue39.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function BitsAsInt(b:bv32): int\n    ensures 0 <= BitsAsInt(b) < 0x1_0000_0000\n{\n    b as int\n}\n"}
{"file": "../dafny/Test/dafny4/Bug63.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod M()\n  modifies set o: object | true\n{\n}\n\nmethod Client()\n{\n  assume forall o: object {:nowarn} :: false;\n  M();\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue235.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  ghost predicate F(x: int) { true }\n}\n\nmodule B {\n  import I = A\n\n  lemma Test(x: int)\n    ensures I.F(x)\n  {\n  }\n\n  lemma TestWrapper()\n  {\n    forall x {\n      Test(x);\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/Bug170.dfy", "dafny": "// RUN: %dafny /compile:0 /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule InductiveThings {\n  ghost predicate P(x: int)\n  ghost predicate Q(x: int)\n\n  least predicate A(x: int)\n  {\n    P(x) || B(x+1)\n  }\n\n  least predicate B(x: int)\n  {\n    Q(x) || A(x+1)\n  }\n\n  least lemma AA(x: int)  // should be specialized not just for A, but also for B, which is in the same strongly connected component as A in the call graph\n    requires A(x)\n  {\n    if B(x+1) {  // this one should be replaced by B#[_k-1](x+1)\n      BB(x+1);\n    }\n  }\n\n  least lemma BB(x: int)  // should be specialized not just for B, but also for A, which is in the same strongly connected component as B in the call graph\n    requires B(x)\n  {\n    if A(x+1) {  // this one should be replaced by A#[_k-1](x+1)\n      AA(x+1);\n    }\n  }\n}\n\nmodule CoThings {\n  greatest predicate A(x: int)\n  {\n    B(x+1)\n  }\n\n  greatest predicate B(x: int)\n  {\n    A(x+1)\n  }\n\n  greatest lemma AA(x: int)  // should be specialized not just for A, but also for B, which is in the same strongly connected component as A in the call graph\n    ensures A(x)\n  {\n    BB(x+1);\n    assert B(x+1);  // this one should be replaced by B#[_k-1] (which will happen, provided that AA is listed as also being specialized for B)\n  }\n\n  greatest lemma BB(x: int)  // should be specialized not just for B, but also for A, which is in the same strongly connected component as B in the call graph\n    ensures B(x)\n  {\n    AA(x+1);\n    assert A(x+1);  // this one should be replaced by A#[_k-1] (which will happen, provided that BB is listed as also being specialized for A)\n  }\n}\n\nmodule SingleThings {\n  ghost predicate P(x: int)\n\n  least predicate A(x: int)\n  {\n    P(x) || A(x+1)\n  }\n\n  least lemma AA(x: int)  // should be specialized just for A\n    requires A(x)\n  {\n    if A(x+1) {  // this one should be replaced by B#[_k-1](x+1)\n      AA(x+1);\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/Bug91.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype SendState = map<int, seq<int>>\n\nghost function UnAckedMessages(s:SendState) : set<int>\n{\n    set m,dst | dst in s && m in s[dst] :: m\n}\n\nghost function UnAckedMessagesForDst(s:SendState, dst:int) : set<int>\n    requires dst in s\n{\n    set m | m in s[dst] :: m\n}\n\nghost function UnAckedMessages3(s:SendState) : set<int>\n{\n    set m,dst | dst in s && m in UnAckedMessagesForDst(s, dst) :: m\n}\n\nghost function SeqToSet<T>(s:seq<T>) : set<T>\n{\n    set i | i in s\n}\n\nghost function UnAckedMessages4(s:SendState) : set<int>\n{\n\t\tset m,dst | dst in s && m in SeqToSet(s[dst]) :: m\n}\n\nghost function UnAckedLists(s:SendState) : set<seq<int>>\n{\n    set dst | dst in s :: s[dst]\n}\n\nghost function UnAckedMessages5(s:SendState) : set<int>\n{\n    set m, list | list in UnAckedLists(s) && m in list :: m\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue18.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Maybe = Nothing | Just\nghost predicate bad(e:Maybe)\n{\n    forall i :: 0 <= i < 1 ==>\n        0 == match e\n            case Nothing => 0\n            case Just => 0\n}\n\n"}
{"file": "../dafny/Test/dafny4/Bug138.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype List = Nil | Cons(int, List)\n\nmethod R(xs: List)\n{\n  match xs\n  case Nil() =>    // currently produces a parsing error, but shouldn't\n  case Cons(x, Nil()) =>  // currently allowed\n  case Cons(x, Cons(y, tail)) =>\n}\n\nghost function F(xs: List) : int\n{\n  match xs\n  case Nil() =>  0  // currently produces a parsing error, but shouldn't\n  case Cons(x, Nil()) => 1 // currently allowed\n  case Cons(x, Cons(y, tail)) => 2\n}\n\n\n"}
{"file": "../dafny/Test/dafny4/Bug113.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype D = D(q:int, r:int, s:int, t:int)\n\nmethod Main()\n{\n    print D(10, 20, 30, 40);\n    print \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafny4/Bug142.dfy", "dafny": "// RUN: %dafny /warnShadowing  /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function P(x:int):int\nghost function Q(x:int):int\nghost function R(x:int):int\n\nghost function Example0(y:int) : int\n{\n  var state0 := y;\n  var state0 := P(state0);\n  var state0 := Q(state0);\n  var state0 := R(state0);\n  state0\n}\n\n\nghost function {:warnShadowing false} Example(y:int) : int\n{\n  var state := y;\n  var state := P(state);\n  var state := Q(state);\n  var state := R(state);\n  state\n}\n\nghost function Example2(y:int) : int\n{\n  var state1 := y;\n  var state1 := P(state1);\n  var state1 := Q(state1);\n  var state1 := R(state1);\n  state1\n}\n"}
{"file": "../dafny/Test/dafny4/Regression4.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() { }\n\ndatatype Maybe<T> = Nothing | Just(T)\n\nfunction fromJust<T>(x: Maybe<T>): T\n    requires x.Just?\n{\n    match x case Just(v) => v\n}\n\ntype mem = int\ntype AbsPTable = seq<Maybe<AbsL2PTable>>\ntype AbsL2PTable = seq<Maybe<AbsPTE>>\ndatatype AbsPTE = AbsPTE(phys: mem, write: bool, exec: bool)\n\nghost function WritablePagesInTable(pt:AbsPTable): set<mem>\n{\n    (set i, j | 0 <= i < |pt| && pt[i].Just? && 0 <= j < |fromJust(pt[i])|\n        && fromJust(pt[i])[j].Just? && fromJust(fromJust(pt[i])[j]).write\n        :: fromJust(fromJust(pt[i])[j]).phys)\n}\n\nmethod G(pt:AbsPTable, i: int, j: int)\n  requires 0 <= i < |pt| && pt[i].Just? && 0 <= j < |fromJust(pt[i])|\n{\n  var s := pt[i];\n  var aa := fromJust(s);\n  var z := aa[j];\n}\n"}
{"file": "../dafny/Test/dafny4/LeastGreatest.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nleast predicate Natural(x: int) {\n  x == 0 || Natural(x - 1)\n}\n\ngreatest predicate Positive(x: int) {\n  x != 0 && Positive(x + 1)\n}\n\nleast lemma NaturalIsNat(x: int)\n  requires Natural(x)\n  ensures 0 <= x\n{\n}\n\nlemma NatIsNatural(x: int)\n  requires 0 <= x\n  ensures Natural(x)\n{\n}\n\nlemma PositiveIsPos(x: int)\n  requires x <= 0\n  ensures !Positive(x)\n  decreases -x\n{\n}\n\ngreatest lemma PosIsPositive(x: int)\n  requires 0 < x\n  ensures Positive(x)\n{\n}\n\nlemma AboutNatural(x: int)\n  ensures Natural(x) <==> 0 <= x\n{\n  if Natural(x) {\n    NaturalIsNat(x);\n  }\n  if 0 <= x {\n    NatIsNatural(x);\n  }\n}\n\nlemma AboutPositive(x: int)\n  ensures Positive(x) <==> 0 < x\n{\n  if 0 < x {\n    PosIsPositive(x);\n  } else {\n    PositiveIsPos(x);\n  }\n}\n\nmethod least(x: int, y: int) returns (least: int) {\n  var greatest;\n  least, greatest := mixmax(x, y);\n}\n\nmethod greatest(x: int, y: int) returns (greatest: int) {\n  var least;\n  least, greatest := mixmax(x, y);\n}\n\nmethod mixmax(x: int, y: int) returns (least: int, greatest: int)\n  ensures {x, y} == {least, greatest}\n  ensures least <= greatest\n{\n  if x < y {\n    least, greatest := x, y;\n  } else {\n    least, greatest := y, x;\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue67.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Node { }\n\nghost predicate Q(x: Node)\nghost predicate P(x: Node)\n\nmethod AuxMethod(y: Node)\n  modifies y\n\nmethod MainMethod(y: Node)\n  modifies y\n{\n  AuxMethod(y);  // remove this call and the assertion below goes through (as it should)\n\n  forall x | Q(x)\n    ensures P(x)\n  {\n    assume false;\n  }\n  // The following assertion should be a direct consequence of the forall statement above\n  assert forall x :: Q(x) ==> P(x);\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue109.dfy", "dafny": "// RUN: %dafny /compile:0 /rprint:\"%t.rprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype MyTuple = MyTuple(x:int, y:int)\n\nmethod M()\n  requires forall x :: MyTuple(x,x) != MyTuple(x,x+1)\n  requires forall x :: (x,x) != (x,x+1)\n{\n}\n\n\n"}
{"file": "../dafny/Test/dafny4/git-issue75.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype t = i:int | 0 <= i < 10\n\nghost function f():t\n\nghost function g():int\n\nlemma L1() returns(m:map<int, t>)\n{\n  m := map i | 0 <= i < 5 :: f(); // FAILS\n}\n\nlemma L2() returns(m:map<int, t>)\n{\n  m := map i | 0 <= i < 5 :: [f()][0]; // SUCCEEDS\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue26.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function BitvectorCast(x:bv32): int\n    ensures x != 0 ==> BitvectorCast(x) != 0\n{\n    x as int\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue5.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate isEven(x:int)\n{\n  x % 2 == 0\n}\n\nghost function f(x:int, y:int): (z:int)\n  requires x>0 && y > 0\n  ensures z >= 10\n\tensures f(x,y) == z\n  ensures isEven(z)\n{\n\t  2*(x+y) + 10\n}\n\ntwostate function P2(x: int) : (z: int)\n  ensures z == x - 1\n\tensures P2(x) == z\n\tensures P2(x) == x - 1\n{\n   x - 1\n}\n\nmodule Interface\n{\n  ghost function addSome(n: nat): nat\n    ensures addSome(n) > n\n}\n\nmodule Implementation refines Interface\n{\n  ghost function addSome(n: nat): (z: nat)\n    ensures z == n + 1\n  {\n    n + 1\n  }\n}\n\nghost function foo(x:int, y:int) : (v: (int, int))\n  ensures v == (x, y)\n{\n  (x, y)\n}\n\n// bar will not be marked as recursive\nghost function bar(x:int, y:int) : int\n ensures bar(x, y) == 10\n{\n   10\n}\n\n// bar1 will be marked as recursive\nghost function bar1(x:int, y:int) : int\n ensures bar1(x, y+0) == 10\n{\n   10\n}\n\n// bar2 will be marked as recursive\nghost function bar2(x:int, y:int) : int\n  ensures bar2((x), y) == 10\n{\n  10\n}\n\n"}
{"file": "../dafny/Test/dafny4/git-issue176.dfy", "dafny": "// RUN: %dafny /compile:0  \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate Thing1() {\n    var m := map[0 := 1];\n    forall i :: i in m ==> i == 0\n}\n\ndatatype Context = Context(foo: map<int, int>)\n\nghost predicate Thing2(ctx: Context) {\n   var ctx' := ctx.(foo := map[0 := 1]);\n   forall i :: i in ctx'.foo ==> i == 0\n}\n\nmethod Main() {\n   assert Thing1();\n   assert Thing2(Context(map[2 := 3]));\n}"}
{"file": "../dafny/Test/dafny4/git-issue210.dfy", "dafny": "// RUN: %dafny /compile:0 /rprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function F<A>(l: seq<A>): bool {\n  forall i :: 0 <= i < |l|-1 ==> l[i] == l[i + 1] || l[i] == l[i + 1]\n}\n\n"}
{"file": "../dafny/Test/dafny4/Bug108.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main() {\n  var A := map[0 := 1];\n  var B := map x | x in (set y | y in A) :: A[x];\n  print A, \"\\n\";\n  print B, \"\\n\";\n}\n\n\n"}
{"file": "../dafny/Test/dafny4/git-issue155.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype A = A0\ndatatype B = B0\n\nghost function F(a: A, b: B): int\n{\n  match (a, b)\n  case (A0, B0) => 0\n}\n\nmethod M(a: A, b: B)\n{\n  match (a, b)\n  case (A0, B0) =>\n}"}
{"file": "../dafny/Test/dafny4/predicateReturnVariable.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\npredicate tautology1(x: int): (y: bool)\n  ensures x == 2 ==> y\n{\n  x >= 2\n}"}
{"file": "../dafny/Test/dafny4/git-issue88.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ntype Grid = array2<int>\n\nmethod M2() {\n  var g: Grid := new int[9,9];\n  g[0,0] := 1;\n}\n\ntype Line = array<int>\n\nmethod M1() {\n  var g: Line := new int[9];\n  g[0] := 1;\n}\n\nmethod Main()\n{\n  M2();\n  M1();\n}\n"}
{"file": "../dafny/Test/dafny4/git-issue239.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule List {\n  datatype list<A> = Nil | Cons(A, list<A>)\n\n  function split<A, B>(l: list<(A, B)>): (list<A>, list<B>) {\n    match l\n      case Nil =>  (Nil, Nil)\n      case Cons((x, y), xys) =>\n        var (xs, ys) := split(xys);\n        (Cons(x, xs), Cons(y, ys))\n  }\n}\n"}
{"file": "../dafny/Test/dafny4/Bug128.dfy", "dafny": "// RUN: %dafny /noNLarith /proverOpt:O:pi.warnings=true /proverWarnings:1 /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function GetIndexInSequence<T>(s:seq<T>, x:T) : int\n\trequires x in s\n\tensures  0 <= GetIndexInSequence(s, x) < |s|\n\tensures  s[GetIndexInSequence(s, x)] == x {\n\t\tvar i :| 0 <= i < |s| && s[i] == x;\n\t\ti\n\t}\n\n\n\n"}
{"file": "../dafny/Test/dafny4/git-issue203.dfy", "dafny": "// RUN: %dafny /compile:0 /rprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Value = Res(addr: nat) | Nil()\n\ndatatype Expr = Some(body: Expr)\n              | None()\n\nfunction f(e: Expr, fuel: nat): Value\n    decreases fuel, 3\n{\n    var ret := Eval(e, fuel);\n    Res(0)\n}\n\nfunction Eval(e: Expr, fuel: nat): Value\n    decreases fuel, 0\n{\n    if fuel == 0 then Nil() else\n    var fuel' := fuel - 1;\n    match e\n    case Some(body) => f(e.body, fuel')\n    case None() => Nil()\n}\nconst ctxp := Eval(None(), 1)\n"}
{"file": "../dafny/Test/dafny4/git-issue196.dfy", "dafny": "// RUN: %testDafnyForEachCompiler --refresh-exit-code=0 \"%s\" -- --relax-definite-assignment\n\nclass A {\n  var a: array<array<int>>\n  constructor(b: array<array<int>>) {\n    var c := b;\n    a := b;\n  }\n}\nmethod sub(a: array<array<int>>)\n  requires a.Length > 0\n  requires a[0].Length > 0\n{\n  print a[0][0], \" \";\n  var b := a;\n  print b[0][0], \"\\n\";\n}\nmethod Main() {\n  var a := new array<int>[2];\n  a[0] := new int[2];\n  a[0][0] := 42;\n  print a[0][0], \" \";\n  sub(a);\n  var b := new A(a);\n  MoreTests();\n}\n\nmethod MoreTests() {\n  TestA();\n  TestB();\n  TestC();\n  TestD();\n  TestE();\n}\n\nmethod TestA() {\n  var a := new int[2];\n  var b := new array<int>[2];\n  var c := new array<array2<int>>[2];\n  var d := new array2<array<int>>[2];\n  var e := new array4<array3<int>>[2];\n  a[0] := 5000;\n  b[0] := new int[10];\n  b[0][4] := 5000;\n  c[0] := new array2<int>[10];\n  c[0][4] := new int[70,80];\n  c[0][4][63,73] := 5000;\n  d[0] := new array<int>[70,80];\n  d[0][63,73] := new int[10];\n  d[0][63,73][4] := 5000;\n  e[0] := new array3<int>[12,2,3,15];\n  e[0][11,1,2,14] := new int[20,1,1];\n  e[0][11,1,2,14][18,0,0] := 5000;\n  print a[0], \" \", b[0][4], \" \";\n  print c[0][4][63,73], \" \", d[0][63,73][4], \" \";\n  print e[0][11,1,2,14][18,0,0], \"\\n\";\n}\n\nmethod TestB() {\n  var a := new int[2,3];\n  var b := new array<int>[2,3];\n  var c := new array<array2<int>>[2,3];\n  var d := new array2<array<int>>[2,3];\n  var e := new array4<array3<int>>[2,3];\n}\n\nmethod TestC() {\n  var a := new int[2];\n  var b := new array?<int>[2];\n  var c := new array?<array2?<int>>[2];\n  var d := new array2?<array?<int>>[2];\n  var e := new array4?<array3?<int>>[2];\n}\n\nmethod TestD() {\n  var a: array2<int> := new int[3,2];\n  var b: array<array2<int>> := new array2<int>[5];\n  b := new array2<int>[5][a, a, a, a, a];\n  b := new array2<int>[5](_ => a);\n  var c: array3<array<array2<int>>> := new array<array2<int>>[5,4,3];\n  c := new array<array2<int>>[5,4,3]((_,_,_) => b);\n}\n\nmethod TestE() {\n  var a: array2?<int> := new int[3,2];\n  var b: array?<array2?<int>> := new array2?<int>[5];\n  b := new array2?<int>[5][a, a, a, a, a];\n  b := new array2?<int>[5](_ => a);\n  var c: array3?<array?<array2?<int>>> := new array?<array2?<int>>[5,4,3];\n  c := new array?<array2?<int>>[5,4,3]((_,_,_) => b);\n  var d: array15?<int>;\n  var e: array16<int>;\n}\n"}
{"file": "../dafny/Test/comp/ExternCopyFromTrait.dfy", "dafny": "// RUN: %dafny /compile:4 /compileTarget:cs \"%s\" %S/ExternCopyFromTraitLibrary.cs > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n/// This file tests inheritance of `:extern` annotation in traits.\n\n/// First, we check that `:extern` is correctly inherited by child classes, and\n/// can be overriden:\n\nmodule {:extern \"M\"} M {\n  trait {:extern} T1 {\n    method {:extern \"m1_ext\"} m1()\n  }\n  class {:extern} C1 extends T1 {\n    method {:extern \"m1_ext_different\"} m1() {\n      print \"\";\n    }\n  }\n\n  trait {:extern} T2 {\n    method {:extern \"m2_ext\"} m2()\n  }\n  class {:extern} C2 extends T2 {\n    method m2() {}\n  }\n}\n\n/// Second, we check that Dafny does not complain about missing implementations\n/// for `:extern` trait methods.  If `:extern` were completely separate from\n/// `:compile false`, this would be best handled by `:compile false`.  But for\n/// now `:extern \"foo\"` on a class method `M` means not just \"expose `M` under\n/// the name `foo`\", but also \"and do not compile it\".  Hence, we use `:extern`\n/// in the implementation check below.\n///\n/// The rationale for this is that Dafny does not have inheritance, but we might\n/// still want to model external C#-style inheritance.  To do so we declare a\n/// trait corresponding to a C# interface, list all of its methods, and annotate\n/// non-abstract ones as using `:extern`.  This lets Dafny know that it\n/// shouldn't insist on such methods being re-implemented in derived classes.\n///\n/// Note that the above mentions \"interfaces\" when talking about C#.  That is\n/// because the feature below is not flexible enough to accommodate abstract\n/// classes, as it does not add the `override` keyword on implementations.\n/// Hence, the only use of this feature in C# is interfaces with explicit\n/// implementations. The same problem means that this feature is not very\n/// useful for Java either: Dafny translates the `extends` keywords to Java's\n/// `implements`, not `extends`, and so `Asker` below must be an interface in\n/// Java.\n\nmodule {:extern \"M1\"} M1 {\n  trait {:extern \"Asker\"} {:compile false} Asker {\n    method Exclaim() // An abstract method, to be overridden\n    method {:extern} Speak() // A method implemented by the trait\n  }\n\n  trait DoubleAsker extends Asker {\n    method SpeakTwice() {\n      Speak();\n      Speak();\n    }\n  }\n\n  class AC0 extends Asker {\n    // No complaint about `Speak` being unimplemented thanks to `:extern`.\n\n    method Exclaim() {\n      print \"  An argument!\\n\";\n    }\n  }\n\n  class AC1 extends DoubleAsker {\n    // No complaint about `Speak` being declared without a body thanks to `:extern`.\n    method Speak()\n\n    method Exclaim() {\n      print \"  Another argument!\\n\";\n    }\n  }\n\n  method Main() {\n    var ac0: Asker := new AC0;\n    ac0.Speak();\n    var ac1: DoubleAsker := new AC1;\n    ac1.Speak();\n    ac1.SpeakTwice();\n  }\n}\n"}
{"file": "../dafny/Test/comp/ExternNestedModule.dfy", "dafny": "// RUN: %dafny /compile:4 /spillTargetCode:2 /compileTarget:py %S/ExternNestedModule.py \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main(){\n    print Library.THREE, \"\\n\";\n}\n\nmodule {:extern \"Nested.Library\"} Library {\n    const THREE := TWO + 1\n    const TWO: int\n}\n"}
{"file": "../dafny/Test/comp/Module.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\n// Simple sanity test of nested modules\nmodule Parent {\n  module Child {\n    method Test() {\n      print \"hi from a nested module\\n\";\n    }\n  }\n}\n\nmethod Main() {\n  Parent.Child.Test();\n}\n"}
{"file": "../dafny/Test/comp/Poly.dfy", "dafny": "// NONUNIFORM: https://github.com/dafny-lang/dafny/issues/4174\n// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment --spill-translation\n\ntrait Shape {\n  function Center(): (real, real) reads this\n  method PrintCenter() {\n    print \"Center: \", this.Center(), \"\\n\";\n  }\n}\n\nclass Square extends Shape {\n  var x1: real, y1: real, x2: real, y2: real\n  constructor(x1: real, y1: real, x2: real, y2: real) {\n    this.x1 := x1;\n    this.y1 := y1;\n    this.x2 := x2;\n    this.y2 := y2;\n  }\n  function Center(): (real, real) reads this {\n    var x := (this.x1 + this.x2) / 2.0;\n    var y := (this.y1 + this.y2) / 2.0;\n    (x, y)\n  }\n}\n\nclass Circle extends Shape {\n  var x: real, y: real, r: real\n  constructor(x: real, y: real, r: real) {\n    this.x := x;\n    this.y := y;\n    this.r := r;\n  }\n  function Center(): (real, real) reads this {\n    (this.x, this.y)\n  }\n}\n\nmethod PrintArray(shapes: array<Shape?>) {\n  var i : int := 0;\n  while i < shapes.Length\n    invariant 0 <= i <= shapes.Length\n    decreases shapes.Length - i\n  {\n    if shapes[i] != null {\n      shapes[i].PrintCenter();\n    }\n    i := i + 1;\n  }\n}\n\nmethod PrintSeq(shapes: seq<Shape>) {\n  var i : int := 0;\n  while i < |shapes|\n    invariant 0 <= i <= |shapes|\n    decreases |shapes| - i\n  {\n    shapes[i].PrintCenter();\n    i := i + 1;\n  }\n}\n\nlemma ThereIsASmallest(s: set<Shape>) returns (shape: Shape)\n  requires s != {}\n  ensures shape in s && forall shape' :: shape' in s ==> shape.Center().0 <= shape'.Center().0\n{\n  shape :| shape in s;\n  if shape' :| shape' in s && shape'.Center().0 < shape.Center().0 {\n    var s' := s - {shape};\n    assert shape' in s';\n    shape := ThereIsASmallest(s');\n  }\n}\n\nmethod PrintSet(shapes: set<Shape>) {\n  var s := shapes;\n  var ordered := [];\n  while |s| != 0 {\n    ghost var _ := ThereIsASmallest(s);\n    var shape :| shape in s && forall shape' :: shape' in s ==> shape.Center().0 <= shape'.Center().0;\n    ordered := ordered + [shape];\n    s := s - {shape};\n  }\n  PrintSeq(ordered);\n}\n\nlemma ThereIsASmallestInMultiset(s: multiset<Shape>) returns (shape: Shape)\n  requires s != multiset{}\n  ensures shape in s && forall shape' :: shape' in s ==> shape.Center().0 <= shape'.Center().0\n{\n  shape :| shape in s;\n  if shape' :| shape' in s && shape'.Center().0 < shape.Center().0 {\n    var s' := s - multiset{shape};\n    assert shape' in s';\n    shape := ThereIsASmallestInMultiset(s');\n  }\n}\n\nmethod PrintMultiSet(shapes: multiset<Shape>) {\n  var s := shapes;\n  var ordered := [];\n  while |s| != 0 {\n    ghost var _ := ThereIsASmallestInMultiset(s);\n    var shape :| shape in s && forall shape' :: shape' in s ==> shape.Center().0 <= shape'.Center().0;\n    ordered := ordered + [shape];\n    s := s - multiset{shape};\n  }\n  PrintSeq(ordered);\n}\n\nlemma ThereIsASmallestInt(s: set<int>) returns (k: int)\n  requires s != {}\n  ensures k in s && forall k' :: k' in s ==> k <= k'\n{\n  k :| k in s;\n  if k' :| k' in s && k' < k {\n    var s' := s - {k};\n    assert s == s' + {k};\n    assert k' in s';  // prove s' is nonempty\n    k := ThereIsASmallestInt(s');\n  }\n}\n\nmethod PrintMap(shapes: map<nat, Shape>) {\n  var s := shapes.Keys;\n  var ordered := [];\n  while |s| != 0\n    invariant s <= shapes.Keys\n  {\n    ghost var _ := ThereIsASmallestInt(s);\n    var k :| k in s && forall k' :: k' in s ==> k <= k';\n    ordered := ordered + [shapes[k]];\n    s := s - {k};\n  }\n  PrintSeq(ordered);\n}\n\nmethod Main() {\n  var square := new Square(0.0, 1.0, 1.0, 0.0);\n  print \"Center of square: \", square.Center(), \"\\n\";  // (0.5, 0.5)\n\n  var circle := new Circle(1.0, 1.0, 4.0);  // (1.0, 1.0)\n  print \"Center of circle: \", circle.Center(), \"\\n\";\n\n  var shapes : array<Shape?> := new Shape?[2];\n  shapes[0] := square;\n  shapes[1] := circle;\n  PrintArray(shapes);\n\n  PrintSeq([square, circle]);\n  PrintSet({square, circle});\n  PrintMultiSet(multiset{square, circle});\n  PrintMap(map[0 := square, 1 := circle]);\n}\n"}
{"file": "../dafny/Test/comp/ExternDLL.dfy", "dafny": "// RUN: %baredafny build --target=cs %args \"%s\" %S/ExternDLL2.cs %S/ExternHelloLibrary.dll > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  Mod1.Test();\n  ConstInit.Test();\n  TwoArgumentExtern.Test();\n}\n\nmodule {:extern \"Modx\"} Mod1\n{\n  class {:extern \"classx\"} Class1\n  {\n    static function {:extern \"Fun1x\"} Fun1() : int\n      ensures Fun1() > 0\n    static method {:extern \"Method1x\"} Method1() returns (x: int)\n      ensures x > 0\n    static function Fun2() : int\n      ensures Fun2() > 0\n    {\n      Fun1()\n    }\n    static method Method2() returns (x: int)\n      ensures x > 0\n    {\n      x := Method1();\n    }\n  }\n  method Test()\n  {\n    var m2 := Class1.Method2();\n    print \"Fun2() = \", Class1.Fun2(), \", Method2() = \", m2, \"\\n\";\n  }\n}\n\nmodule {:extern \"ConstInit\"} ConstInit {\n  class C { }\n\n  const {:extern} c: C  // because it's extern, it's okay not to have a defining value\n\n  class W {\n    static const {:extern} f: C  // because it's extern, it's okay not to have a defining value\n  }\n\n  class U {\n    // the initial/defining values of d and e must be provided by the extern constructor\n    var d: C\n    const e: C\n    constructor {:extern} (b: bool)\n  }\n\n  method Test() {\n    Check(c);\n    Check(W.f);\n\n    var u := new U(true);\n    Check(u.d);\n    Check(u.e);\n  }\n\n  method Check(o: object?)\n    requires o != null\n  {\n    print if o == null then \"null\" else \"good\", \"\\n\";\n  }\n}\n\nmodule TwoArgumentExtern {\n  method {:extern \"ABC.DEF\", \"MX\"} M(x: int) returns (r: int)\n\n  // git issue 423\n  function {:extern \"ABC.DEF\", \"FX\"} F(x: int): int\n\n  method Test() {\n    var y := M(2);  // calls ABC.DEF.MX\n    var z := F(2);  // calls ABC.DEF.FX\n    print y, \" \", z, \"\\n\";  // 4 2\n  }\n}\n"}
{"file": "../dafny/Test/comp/CompileWithArgumentsFail.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" --args csharp 1 >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main(args: int) {\n  print \"ok\", args;\n}\n"}
{"file": "../dafny/Test/comp/ExternCtors.dfy", "dafny": "// RUN: %dafny /compile:3 /compileTarget:cs \"%s\" %S/ExternCtors-externs/Library.cs > \"%t\"\n// RUN: %dafny /compile:3 /compileTarget:java \"%s\" %S/ExternCtors-externs/Class.java >> \"%t\"\n// RUN: %dafny /compile:3 /compileTarget:py \"%s\" %S/ExternCtors-externs/Library.py >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// FIXME: Extern constructors are currently broken in Go and JavaScript,\n// so they are omitted\n\nmethod Main() {\n  Library.Class.SayHi();\n  var obj := new Library.Class(42);\n  obj.Print();\n}\n\nmodule {:extern \"Library\"} Library {\n  class {:extern} Class {\n    constructor {:extern} (n: int)\n    static method {:extern} SayHi()\n    function {:extern} Get() : int\n    method Print() {\n      print \"My value is \", Get(), \"\\n\";\n    }\n  }\n}\n"}
{"file": "../dafny/Test/comp/Libraries/Inputs/indirectLibrary.dfy", "dafny": "module AnotherGloballyUniqueProducer {\n  module ExportingModule {\n    const exportedVariable := 1\n  }\n}"}
{"file": "../dafny/Test/comp/AsIs-Compile.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\nmethod Main() {\n  var a: A, b: B, c: C, k: K, l: L := new M, new M, new M, new K<real>, new L<real>;\n  var a', b', c', k', l' := AssignBackAndForth(a, b, c, k, l);\n  print a == a', \" \", b == b', \" \", c == c', \" \", k == k', \" \", l == l', \"\\n\";\n  a', b', c', k', l' := AsBackAndForth(a, b, c, k, l);\n  print a == a', \" \", b == b', \" \", c == c', \" \", k == k', \" \", l == l', \"\\n\";\n  IsTests();\n}\n\ntrait A<X> { }\ntrait B<Y0, Y1> { }\ntrait C<Z> extends B<int, Z> { }\n\nclass K<U> extends object, B<int, U> { }\nclass L<V> extends C<V> { }\nclass M extends A<real>, C<real> { }\n\nmethod AssignBackAndForth<W>(a: A<W>, b: B<int, W>, c: C<W>, k: K<W>, l: L<W>) returns (a': A<W>, b': B<int, W>, c': C<W>, k': K<W>, l': L<W>)\n  ensures a' == a && b' == b && c' == c && k' == k && l' == l\n{\n  var o: object?;\n\n  o := a;\n  a' := o;\n\n  o := b;\n  b' := o;\n\n  o := c;\n  c' := o;\n\n  o := k;\n  k' := o;\n\n  o := l;\n  l' := o;\n}\n\nmethod AsBackAndForth<W>(a: A<W>, b: B<int, W>, c: C<W>, k: K<W>, l: L<W>) returns (a': object, b': object, c': object, k': object, l': object)\n  ensures a' == a && b' == b && c' == c && k' == k && l' == l\n{\n  var o: object?;\n\n  o := a;\n  a' := o as A<W>;\n\n  o := b;\n  b' := o as B<int, W>;\n\n  o := c;\n  c' := o as C<W>;\n\n  o := k;\n  k' := o as K<W>;\n\n  o := l;\n  l' := o as L<W>;\n}\n\nmethod IsTests() {\n  var p := new ClassP;\n  var q := new ClassQ<int>;\n  var r, r' := new ClassR<int>, new ClassR';\n  var s := new ClassS;\n  var t := new ClassT<int>;\n\n  print \"IsComparisons ----\\n\";\n  IsComparisons0(q, q, p);\n  IsComparisons0(r, r, r);\n  IsComparisons0(s, s, s);\n  IsComparisons0(q, r, r');\n  IsComparisons1(r, t);\n  IsComparisons1(r', t);\n\n  print \"TestNullIs ----\\n\";\n  TestNullIs(q, q, q, q, q, q);\n  TestNullIs(q, null, q, null, q, null);\n\n  print \"TestFromTraits ----\\n\";\n  TestFromTraits0(null); // 5\n  TestFromTraits1(null); // 0\n  var xx := new XX;\n  TestFromTraits0(xx); // 4\n  TestFromTraits1(xx); // 4\n  TestFromTraits2(xx); // 4\n  TestFromTraits3(xx); // 4\n\n  // TODO: print \"SubsetConstraints ----\\n\";\n  // TODO: SubsetConstraints();\n}\n\ntrait TraitA<X> { }\ntrait TraitB<X> { }\n\nclass ClassP { }\nclass ClassQ<Y> extends TraitA<Y> { }\nclass ClassR<Z> extends TraitA<Z>, TraitB<Z> { }\nclass ClassS extends TraitA<int> { }\nclass ClassT<Z> extends TraitA<seq<Z>> { }\nclass ClassR' extends TraitB<int> { }\n\nmethod IsComparisons0<U>(au: TraitA<U>, ai: TraitA<int>, o: object) {\n  print au as object is ClassP, \" \", au is ClassQ<U>, \" \", au is ClassR<U>, \" \", au as object is ClassS, \"\\n\";\n  print \"  \", ai is ClassQ<int>, \" \", ai is ClassR<int>, \" \", ai is ClassS, \"\\n\";\n  print \"  \", o is ClassP, \" \", o is ClassS, \"\\n\";\n}\n\nmethod IsComparisons1<U>(b: TraitB<U>, tz: TraitA<seq<U>>) {\n  print b is ClassR<U>, \" \", tz is ClassT<U>, \"\\n\";\n}\n\nmethod TestNullIs<U>(o: object, oo: object?, t: TraitA<U>, tt: TraitA?<U>, q: ClassQ<U>, qq: ClassQ?<U>) {\n  ghost var checkit := o is TraitA<U> && o is TraitA?<U> && o is ClassQ<U> && o is ClassQ?<U>;\n  checkit := oo is TraitA<U> && oo is TraitA?<U> && oo is ClassQ<U> && oo is ClassQ?<U>;\n  print o is object, \" \", o is object?, \"\\n\";\n  print oo is object, \" \", oo is object?, \"\\n\";\n  print t is object, \" \", t is object?, \" \", t is TraitA<U>, \" \", t is TraitA?<U>, \" \", t is ClassQ<U>, \" \", t is ClassQ?<U>, \"\\n\";\n  print tt is object, \" \", tt is object?, \" \", tt is TraitA<U>, \" \", tt is TraitA?<U>, \" \", tt is ClassQ<U>, \" \", tt is ClassQ?<U>, \"\\n\";\n  print q is object, \" \", q is object?, \" \", q is TraitA<U>, \" \", q is TraitA?<U>, \" \", q is ClassQ<U>, \" \", q is ClassQ?<U>, \"\\n\";\n  print qq is object, \" \", qq is object?, \" \", qq is TraitA<U>, \" \", qq is TraitA?<U>, \" \", qq is ClassQ<U>, \" \", qq is ClassQ?<U>, \"\\n\";\n}\n\ntrait XA { }\ntrait XB { }\ntrait XC extends XA, XB { }\ntrait XD extends XC { }\ntrait XE { }\nclass XX extends XD { }\n\nmethod TestFromTraits0(x: XX?) {\n  var o: object? := x;\n  var c := 0;\n  c := c + if o is XA? then 1 else 0;\n  c := c + if o is XB? then 1 else 0;\n  c := c + if o is XC? then 1 else 0;\n  c := c + if o is XD? then 1 else 0;\n  c := c + if o is XE? then 1 else 0;\n  print c, \"\\n\"; // 5 when x==null, 4 when x!=null\n}\n\nmethod TestFromTraits1(x: XX?) {\n  var o: object? := x;\n  var c := 0;\n  c := c + if o is XA then 1 else 0;\n  c := c + if o is XB then 1 else 0;\n  c := c + if o is XC then 1 else 0;\n  c := c + if o is XD then 1 else 0;\n  c := c + if o is XE then 1 else 0;\n  print c, \"\\n\"; // 0 when x==null, 4 when x!=null\n}\n\nmethod TestFromTraits2(x: XX) {\n  var o: object := x;\n  var c := 0;\n  c := c + if o is XA? then 1 else 0;\n  c := c + if o is XB? then 1 else 0;\n  c := c + if o is XC? then 1 else 0;\n  c := c + if o is XD? then 1 else 0;\n  c := c + if o is XE? then 1 else 0;\n  print c, \"\\n\"; // 4\n}\n\nmethod TestFromTraits3(x: XX) {\n  var o: object := x;\n  var c := 0;\n  c := c + if o is XA then 1 else 0;\n  c := c + if o is XB then 1 else 0;\n  c := c + if o is XC then 1 else 0;\n  c := c + if o is XD then 1 else 0;\n  c := c + if o is XE then 1 else 0;\n  print c, \"\\n\"; // 4\n}\n/* TODO\nclass SupersetClass {\n  const n: int\n  constructor (n: int)\n    ensures this.n == n\n  {\n    this.n := n;\n  }\n}\n\ntype SubsetClass = s: SupersetClass | s.n <= 10 witness *\ntype SubsetClass' = s: SupersetClass | s.n == 10 witness *\ntype Array = a: array<int> | a.Length <= 10 witness *\ntype Array' = a: Array | a.Length >= 10 witness *\n\nmethod SubsetConstraints() {\n  var a: SupersetClass := new SupersetClass(8);\n  var b: SupersetClass := new SupersetClass(10);\n  print a is SubsetClass, \" \", a is SubsetClass', \" \"; // true false\n  print b is SubsetClass, \" \", b is SubsetClass', \"\\n\"; // true true\n  var aa: SupersetClass?, bb: SupersetClass? := a, b;\n  print aa is SubsetClass, \" \", aa is SubsetClass', \" \"; // true false\n  print bb is SubsetClass, \" \", bb is SubsetClass', \"\\n\"; // true true\n  aa, bb := null, null;\n  print aa is SubsetClass, \" \", aa is SubsetClass', \" \"; // false false\n  print bb is SubsetClass, \" \", bb is SubsetClass', \"\\n\"; // false false\n  var c: SubsetClass := a;\n  print c as SupersetClass is SubsetClass', \" \"; // false\n  c := b;\n  print c as SupersetClass is SubsetClass', \"\\n\"; // true\n\n  var arr := new int[8];\n  var brr := new int[10];\n  print arr is Array, \" \", arr is Array', \" \"; // true false\n  print brr is Array, \" \", brr is Array', \"\\n\"; // true true\n  var aar: array?<int>, bbr: array?<int> := arr, brr;\n  print aar is Array, \" \", aar is Array', \" \"; // true false\n  print bbr is Array, \" \", bbr is Array', \"\\n\"; // true true\n  aar, bbr := null, null;\n  print aar is Array, \" \", aar is Array', \" \"; // false false\n  print bbr is Array, \" \", bbr is Array', \"\\n\"; // false false\n  var crr: Array := arr;\n  print crr is Array', \" \"; // false\n  crr := brr;\n  print crr is Array', \"\\n\"; // true\n}\n*/\n"}
{"file": "../dafny/Test/comp/JsModule.dfy", "dafny": "// NONUNIFORM: Javascript-specific extern test\n// RUN: %dafny /compile:3 /unicodeChar:0 \"%s\" /compileTarget:js > \"%t\"\n// note: putting /compileTarget:js after \"%s\" overrides user-provided option\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// \"url\" is a built-in package in node, so it should be accessible to the\n// test suite without further requirements on the setup.\nmodule {:extern \"url\", \"url\"} URL {\n  class Url {\n    var host: string\n    var pathname: string\n    var search: string\n  }\n  method {:extern \"parse\"} Parse(address: string, b: bool) returns (u: Url)\n}\n\nmethod Main() {\n  var address := \"http://localhost:8080/default.htm?year=1915&month=august&day=29\";\n  var u := URL.Parse(address, true);\n  print \"The address \", address, \"\\n\";\n  print \"has the following parts:\\n\";\n  print \"host: \", u.host, \"\\n\";\n  print \"pathname: \", u.pathname, \"\\n\";\n  print \"search: \", u.search, \"\\n\";\n}\n"}
{"file": "../dafny/Test/comp/Iterators.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\"\n\nclass C {\n  var x: int\n  // for variety, the following tests the use of an instance Main method\n  method Main(ghost u: int) returns (ghost r: bool, ghost s: bool) {\n    print \"hello, instance\\n\";\n    print \"x is \", x, \"\\n\";\n    Client();\n    RegressionClient();\n    r := *;\n    s := *;\n  }\n}\n\niterator Iter<X(==,0)>(a: array<X>, stop: X) yields (x: X)\n  yield ensures |xs| <= a.Length\n  ensures |xs| <= a.Length\n{\n  var i := 0;\n  while i < a.Length\n    invariant |xs| == i <= a.Length\n  {\n    if i % 2 == 0 {\n      yield a[i];\n    }\n    x := a[i];\n    if x == stop {\n      break;\n    }\n    if i % 2 == 1 {\n      yield;\n    }\n    i := i + 1;\n  }\n}\n\nmethod Client()\n{\n  var a := new real[6](i => i as real);\n\n  var iter := new Iter(a, 2.4);\n  while true\n    invariant iter.Valid() && fresh(iter._new)\n    decreases a.Length - |iter.xs|\n  {\n    var more := iter.MoveNext();\n    if (!more) { break; }\n    print iter.x, \" \";\n  }\n  print \"\\n\";\n\n  iter := new Iter(a, 2.0);\n  while true\n    invariant iter.Valid() && fresh(iter._new)\n    decreases a.Length - |iter.xs|\n  {\n    var more := iter.MoveNext();\n    if (!more) { break; }\n    print iter.x, \" \";\n  }\n  print \"\\n\";\n}\n\nmethod RegressionClient() {\n  var c := new C;\n  var d := new C;\n  var iter := new RegressionDefaultVsPlaceboInitialization(c, d);\n  var more := iter.MoveNext();\n  if more {\n    print iter.eq, \"\\n\"; // false\n  }\n}\n\n// The following iterator needs to initialize its .x and .y fields with placebos, not default values.\n// In the past, default values had been used, which causes malformed code that refers to a non-existing type descriptor.\niterator RegressionDefaultVsPlaceboInitialization<X(==)>(x: X, y: X) yields (eq: bool) {\n  yield x == y;\n}\n"}
{"file": "../dafny/Test/comp/separate-compilation/Inputs/producer/timesTwo.dfy", "dafny": "module {:options \"--function-syntax:4\"} LibraryModule {\n\n  function TimesTwo(x: nat): nat\n  {\n    x * 2\n  }\n\n}\n"}
{"file": "../dafny/Test/comp/CompileWithArgumentsFail2.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" --args csharp 1 >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main(args: array<string>, dummy: int) {\n  print \"ok\", dummy;\n}\n"}
{"file": "../dafny/Test/comp/CSharpStyling.dfy", "dafny": "// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:cs \"%s\" %S/CSharpStyling2.cs > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  var c := new MyClass(50);\n  print c.u, \"\\n\";  // 50\n  c := new MyClass.Init(true);\n  print c.u, \"\\n\";  // 2\n  c := new MyClass.Make(true);\n  print c.u, \"\\n\";  // 3\n\n  var r, s;\n  r := c.OneResultExtern(2);\n  print r, \"\\n\";  // 12\n  r := c.OneResult(2);\n  print r, \"\\n\";  // 12\n  r, s := c.TwoResultsExtern(0);\n  print r, \" \", s, \"\\n\";  // 5 7\n  r, s := c.TwoResults(0);\n  print r, \" \", s, \"\\n\";  // 5 7\n}\n\nclass MyClass {\n  var u: int\n  constructor {:extern} (x: int)\n  constructor Init(y: bool) {\n    u := if y then 2 else -2;\n  }\n  constructor {:extern} Make(y: bool)\n  method {:extern} OneResultExtern(z: int) returns (r: int)\n  method OneResult(z: int) returns (r: int) {\n    r := 12;\n    if z == 0 {\n      r := 8;\n      return r;\n    } else if z == 1 {\n      r := 10;\n      return;\n    }\n  }\n  method {:extern} TwoResultsExtern(z: int) returns (r: int, s: int)\n  method TwoResults(z: int) returns (r: int, s: int) {\n    if z == 0 {\n      return 5, 7;\n    } else {\n      r, s := 9, 11;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/comp/Class.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment --spill-translation\n\nclass MyClass {\n  var a: int\n  const b: int\n  const c := 17\n  static const d: int\n  static const e := 18\n  constructor (x: int) {\n    a := 100 + x;\n    b := 200 + x;\n  }\n\n  function F(): int { 8 }\n  static function G(): int { 9 }\n  method M() returns (r: int) { r := 69; }\n  static method N() returns (r: int) { r := 70; }\n}\n\ntrait MyTrait {\n  var a: int\n  const b: int\n  const c := 17\n  static const d: int\n  static const e := 18\n\n  function F(): int { 8 }\n  static function G(): int { 9 }\n  method M() returns (r: int) { r := 69; }\n  static method N() returns (r: int) { r := 70; }\n}\n\nclass MyTraitInstance extends MyTrait {\n  constructor (x: int) {\n    a := 101 + x;\n    b := 201 + x;\n  }\n\n  static method SetTraitField(m : MyTrait) modifies m { m.a := N(); }\n}\n\nmethod CallEm(c: MyClass, t: MyTrait, i: MyTraitInstance)\n  modifies c, t, i\n{\n  // instance fields\n\n  print c.a, \" \", t.a, \" \", i.a, \" \";\n  c.a := c.a + 3;\n  t.a := t.a + 3;\n  i.a := i.a + 3;\n  print c.a, \" \", t.a, \" \", i.a, \"\\n\";\n\n  // (instance and static) members via instance\n\n  var u;\n\n  print c.b, \" \";\n  print c.c, \" \";\n  print c.d, \" \";\n  print c.e, \" \";\n  print c.F(), \" \";\n  print c.G(), \" \";\n  u := c.M();\n  print u, \" \";\n  u := c.N();\n  print u, \"\\n\";\n\n  print t.b, \" \";\n  print t.c, \" \";\n  print t.d, \" \";\n  print t.e, \" \";\n  print t.F(), \" \";\n  print t.G(), \" \";\n  u := t.M();\n  print u, \" \";\n  u := t.N();\n  print u, \"\\n\";\n\n  print i.b, \" \";\n  print i.c, \" \";\n  print i.d, \" \";\n  print i.e, \" \";\n  print i.F(), \" \";\n  print i.G(), \" \";\n  u := i.M();\n  print u, \" \";\n  u := i.N();\n  print u, \"\\n\";\n\n  // static members via type name\n\n  print MyClass.d, \" \";\n  print MyClass.e, \" \";\n  print MyClass.G(), \" \";\n  u := MyClass.N();\n  print u, \"\\n\";\n\n  print MyTrait.d, \" \";\n  print MyTrait.e, \" \";\n  print MyTrait.G(), \" \";\n  u := MyTrait.N();\n  print u, \"\\n\";\n\n  print MyTraitInstance.d, \" \";\n  print MyTraitInstance.e, \" \";\n  print MyTraitInstance.G(), \" \";\n  u := MyTraitInstance.N();\n  print u, \"\\n\";\n\n  MyTraitInstance.SetTraitField(i);\n  print i.a, \"\\n\";\n}\n\nmethod Main() {\n  var c := new MyClass(3);\n  var t := new MyTraitInstance(2);\n  var i := new MyTraitInstance(2);\n  print t == t, \" \", i == i, \" \", i == t, \"\\n\";\n  // Upcast via local variable with rhs\n  var t2 : MyTrait := t;\n  // Upcast via local variable with assignment\n  var t3 : MyTrait;\n  t3 := t;\n  // Upcast via function call\n  CallEm(c, t, i);\n  DependentStaticConsts.Test();\n  NewtypeWithMethods.Test();\n  TestGhostables(70);\n  TestInitializationMethods();\n}\n\nmodule Module1 {\n  trait {:termination false} TraitInModule { }\n}\n\nmodule Module2 {\n  import Module1\n\n  class ClassExtendingTraitInOtherModule extends Module1.TraitInModule { }\n}\n\nmodule DependentStaticConsts {\n  newtype ID = x: int | 0 <= x < 100\n\n  // regression test: const's A,B,C,D should all be initialized before Suite is\n  const A: ID := 0\n  const B: ID := 1\n  const C: ID := 2\n  const Suite := map[A := \"hello\", B := \"hi\", C := \"bye\", D := \"later\"]\n  const D: ID := 3\n\n  method Test()\n  {\n    print Suite[B], \" \", Suite[D], \"\\n\";  // hi later\n  }\n}\n\nnewtype NewtypeWithMethods = x | 0 <= x < 42 {\n  function double() : int {\n    this as int * 2\n  }\n\n  method divide(d : NewtypeWithMethods) returns (q : int, r : int) requires d != 0 {\n    q := (this / d) as int;\n    r := (this % d) as int;\n  }\n\n  static method Test() {\n    var a : NewtypeWithMethods := 21;\n    var b : NewtypeWithMethods;\n    b := 4;\n    var q : int;\n    var r : int;\n    q, r := a.divide(b);\n\n    print a, \" \", b, \" \", a.double(), \" \", q, \" \", r, \"\\n\";\n  }\n}\n\nclass Ghostable {\n  var data: int\n  constructor A(x: int) {\n    data := x;\n  }\n  ghost constructor (x: int) {\n    data := x;\n  }\n}\n\nclass ConstructorLessGhostable {\n  var data: int\n}\n\nghost function GInit(index: nat): int {\n  index - 7\n}\n\nmethod TestGhostables(ghost n: nat) {\n  print \"TestGhostables\\n\";\n\n  var a0 := new Ghostable.A(10);\n  var a1 := new Ghostable(n); // note, a1 is ghost\n\n  var b0 := new ConstructorLessGhostable;\n  ghost var b1 := new ConstructorLessGhostable; // note, b1 is ghost\n\n  var c0 := new int[10];\n  ghost var c1 := new int[n]; // note, c1 is ghost\n  c0 := new int[10](x => x + 2);\n  c1 := new int[n](x => x + n);\n  c1 := new int[100](GInit);\n}\n\n// ---------------------------------------------------\n\n// Additional tests cases for order of evaluation of initialization-method parameters.\n\nclass HasInitializationMethod {\n  var data: int\n\n  method Init(x: int)\n    requires x == 15\n    modifies this\n    ensures data == x + 1\n  {\n    print \"Init called with x=\", x, \"\\n\";\n    data := x + 1;\n  }\n}\n\nmethod TestInitializationMethods() {\n  var c := new HasInitializationMethod;\n  c.data := 15;\n  print c.data, \"\\n\"; // 15\n\n  c := new HasInitializationMethod.Init(c.data); // should pass in c.data, not (new HasInitializationMethod).data\n  \n  print c.data, \"\\n\"; // 16\n}\n"}
{"file": "../dafny/Test/comp/Variance.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --warn-deprecation:false\n\ndatatype Co<+T> = Co(z: T) {\n    const x: int;\n    const y: seq<T>\n\n    function A(x: T): int { 0 }\n    static function sA(x: T): int { 0 }\n    function gA(ghost x: T): int { 0 }\n    function B(x: seq<T>): int { 0 }\n    function C(x: int): seq<T> { y }\n    function D(x: T): T { x }\n\n    method mA(x: T) returns (r: int) { r := 0; }\n    method mD(x: T) returns (r: T) { r := x; }\n}\n\ndatatype Non<T> = Non(T) {\n    const x: int;\n    const y: seq<T>\n\n    function A(x: T): int { 0 }\n    static function sA(x: T): int { 0 }\n    function gA(ghost x: T): int { 0 }\n    function B(x: seq<T>): int { 0 }\n    function C(x: int): seq<T> { y }\n    function D(x: T): T { x }\n\n    method mA(x: T) returns (r: int) { r := 0; }\n    method mD(x: T) returns (r: T) { r := x; }\n}\n\ndatatype Cont<-T> = Cont(z: T -> int) {\n    const x: int;\n    const y: seq<T>\n\n    function A(x: T): int { 0 }\n    static function sA(x: T): int { 0 }\n    function gA(ghost x: T): int { 0 }\n    function B(x: seq<T>): int { 0 }\n    function C(x: int): seq<T> { y }\n    function D(x: T): T { x }\n\n    method mA(x: T) returns (r: int) { r := 0; }\n    method mD(x: T) returns (r: T) { r := x; }\n}\n\ncodatatype CCo<+T> = CCo(T) {\n    const x: int;\n    const y: seq<T>\n\n    function A(x: T): int { 0 }\n    static function sA(x: T): int { 0 }\n    function gA(ghost x: T): int { 0 }\n    function B(x: seq<T>): int { 0 }\n    function C(x: int): seq<T> { y }\n    function D(x: T): T { x }\n\n    method mA(x: T) returns (r: int) { r := 0; }\n    method mD(x: T) returns (r: T) { r := x; }\n}\n\ncodatatype CNon<T> = CNon(z: T) {\n    const x: int;\n    const y: seq<T>\n\n    function A(x: T): int { 0 }\n    static function sA(x: T): int { 0 }\n    function gA(ghost x: T): int { 0 }\n    function B(x: seq<T>): int { 0 }\n    function C(x: int): seq<T> { y }\n    function D(x: T): T { x }\n\n    method mA(x: T) returns (r: int) { r := 0; }\n    method mD(x: T) returns (r: T) { r := x; }\n}\n\ncodatatype CCon<-T> = CCon(T -> int) {\n    const x: int;\n    const y: seq<T>\n\n    function A(x: T): int { 0 }\n    static function sA(x: T): int { 0 }\n    function gA(ghost x: T): int { 0 }\n    function B(x: seq<T>): int { 0 }\n    function C(x: int): seq<T> { y }\n    function D(x: T): T { x }\n\n    method mA(x: T) returns (r: int) { r := 0; }\n    method mD(x: T) returns (r: T) { r := x; }\n}\n\ntrait X {}\n\nclass Int extends X {\n  constructor Int() { }\n}\n\nmethod Covariant() {\n  var i := new Int.Int();\n  var a: Co<Int> := Co(i);\n  var b: Co<X>; // compilation error (java only): compilation does not support trait types as a type parameter; consider introducing a ghost\n  b := a;\n  print a, \" and \", b, \"\\n\";\n\n  var s := Co(false);\n  var t := s.mD(true);\n  var y := s.mA(t);\n  print t, y, s.C(s.x), s.B(s.y), s.A(t), Co.sA(t), s.gA(t), \"\\n\"; \n}\n\nmethod Nonvariant() {\n  var i := new Int.Int();\n  var j := new Int.Int();\n  var a: Non<Int> := Non(i);\n  var b: Non<Int>;\n  b := a;\n  print a, \" and \", b, \"\\n\";\n  \n  var s := Non(false);\n  var t := s.mD(true);\n  var y := s.mA(t);\n  print t, y, s.C(s.x), s.B(s.y), s.A(t), Non.sA(t), s.gA(t), \"\\n\"; \n}\n\nmethod Contravariant() {\n  var i := new Int.Int();\n  var a: Cont<X> := Cont(_ => 0);  // compilation error (java only): compilation does not support trait types as a type parameter; consider introducing a ghost\n  var b: Cont<Int>;\n  b := a;\n  print a.z(i), \" and \", b.z(i), \"\\n\";\n\n  var s: Cont<X> := Cont(_ => 1);\n  var t := s.mD(i);\n  var y := s.mA(t);\n  print t, y, s.C(s.x), s.B(s.y), s.A(t), Cont.sA(t), s.gA(t), \"\\n\"; \n}\n\nmethod CCovariant() {\n  var i := new Int.Int();\n  var a: CCo<Int> := CCo(i);\n  var b: CCo<X>; // compilation error (java only): compilation does not support trait types as a type parameter; consider introducing a ghost\n  b := a;\n  print a, \" and \", b, \"\\n\";\n\n  var s := CCo(false);\n  var t := s.mD(true);\n  var y := s.mA(t);\n  print t, y, s.C(s.x), s.B(s.y), s.A(t), CCo.sA(t), s.gA(t), \"\\n\"; \n}\n\nmethod CNonvariant() {\n  var i := new Int.Int();\n  var j := new Int.Int();\n  var a: CNon<Int> := CNon(i);\n  var b: CNon<Int>;\n  b := a;\n  print a, \" and \", b, \"\\n\";\n  \n  var s := CNon(false);\n  var t := s.mD(true);\n  var y := s.mA(t);\n  print t, y, s.C(s.x), s.B(s.y), s.A(t), CNon.sA(t), s.gA(t), \"\\n\"; \n}\n\nmethod CContravariant() {\n  var a: CCon<X> := CCon(_ => 0); // compilation error (java only): compilation does not support trait types as a type parameter; consider introducing a ghost\n  var b: CCon<Int>;\n  b := a;\n  print a, \" and \", b, \"\\n\";\n\n  var s: CCon<X> := CCon(_ => 1);\n  var i := new Int.Int();\n  var t := s.mD(i);\n  var y := s.mA(t);\n  print t, y, s.C(s.x), s.B(s.y), s.A(t), CCon.sA(t), s.gA(t), \"\\n\"; \n}\n\nmethod Main(){\n  Covariant();\n  Nonvariant();\n  Contravariant();\n  CCovariant();\n  CNonvariant();\n  CContravariant();\n  print \"Done\\n\";\n}\n"}
{"file": "../dafny/Test/comp/ByMethodCompilation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation\n\nmethod Main() {\n  var four := Four();\n  print \"four is \", four, \"\\n\"; // 4\n  print \"Recursive(7) = \", Recursive(7), \"\\n\"; // 14\n  print \"NonCompilableFunction: \", NonCompilableFunction(2), \" \", NonCompilableFunction(4), \"\\n\"; // 4 7\n  var s, s' := {2, 7, 5}, {2, 0, 2, 1};\n  print \"Sums: \", Sum(s), \" \", Sum(s'), \"\\n\";\n}\n\nfunction Four(): int {\n  4\n} by method {\n  // The print statement in Dafny is effectful, but it has no specification that\n  // says whether or not to expect such an effect. In that sense, print is best treated\n  // as a debugging feature. Here, it's used in a by-method, which means it will be\n  // printed as when the caller calls a function--something that does not happen elsewhere\n  // in the language.\n  print \"hello\\n\";\n  return 2 + 2;\n}\n\nfunction Recursive(n: nat, acc: nat := 0): nat {\n  2 * n + acc\n} by method { // compiled as tail recursive\n  if n == 0 {\n    return acc;\n  } else {\n    return Recursive(n - 1, acc + 2);\n  }\n}\n\nfunction NonCompilableFunction(n: nat): (r: nat) {\n  // This function body cannot be compiled, since it mentions a least predicate.\n  // That's fine, as long as the compiler doesn't incorrectly try to compile the\n  // function body.\n  if P(n) then n + 2 else n + 3\n} by method {\n  AboutP(n);\n  r := if n <= 3 then n + 2 else n + 3;\n}\n\nleast predicate P(x: int) {\n  x == 3 || P(x + 1)\n}\n\nlemma AboutP(x: int)\n  ensures P(x) <==> x <= 3\n{\n  if P(x) {\n    Ping(x);\n  }\n  if x <= 3 {\n    Pong(x);\n  }\n}\n\nleast lemma Ping(x: int)\n  requires P(x)\n  ensures x <= 3\n{\n}\n\nlemma Pong(x: int)\n  requires x <= 3\n  ensures P(x)\n  decreases 3 - x\n{\n  if x < 3 {\n    Pong(x + 1);\n  }\n}\n\n// ------------------ longer example ------------------\n// This example sums the elements of a set. Because summing\n// is associate and commutative, the order in which the elements\n// are drawn from the set does not matter. The implementation\n// below is efficient, except for the part that tracks what\n// elements have already been picked from the set (an inefficiency\n// that will be solved once Dafny supports built-in iterations\n// over sets).\n\nfunction Sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x := Pick(s);\n    x + Sum(s - {x})\n} by method {\n  var sum := 0;\n  var s' := s;\n  while s' != {}\n    invariant s' <= s\n    invariant sum + Sum(s') == Sum(s)\n  {\n    var x :| x in s';\n    var s'' := s' - {x};\n    assert s'' + {x} == s';\n    SumLemma(s'', x);\n    sum, s' := sum + x, s'';\n  }\n  return sum;\n}\n\nghost function Pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\nlemma SumLemma(s: set<int>, y: int)\n  requires y !in s\n  ensures Sum(s + {y}) == Sum(s) + y\n{\n  if s == {} {\n  } else {\n    var sy := s + {y};\n    assert s == sy - {y};\n    var x := Pick(sy);\n    if x == y {\n    } else {\n      var s'x := s - {x};\n      assert s'x + {x} == s;\n      calc {\n        Sum(s + {y});\n      ==\n        Sum(sy);\n      ==  // def. Sum\n        x + Sum(sy - {x});\n      ==  { assert sy - {x} == s'x + {y}; }\n        x + Sum(s'x + {y});\n      ==  { SumLemma(s'x, y); }\n        x + Sum(s'x) + y;\n      ==  { SumLemma(s'x, x); }\n        Sum(s'x + {x}) + y;\n      ==\n        Sum(s) + y;\n      }\n    }\n  }\n}\n"}
{"file": "../dafny/Test/comp/Various.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Match(tp: (nat, nat)) {\n  match tp\n  case (0, _) => print \"match\", \"\\n\";\n  case _ =>\n} \n\nmethod {:tailrecursion true} Countdown(x: nat) {\n  label here: {\n    if x == 0 {\n      print \"Kablammo!!\\n\";\n    } else {\n      print x, \"\\n\";\n      Countdown(x - 1);\n    }\n  }\n}\n\ndatatype A = A(val: int)\n\nmethod LetExpr() {\n  print (var a := A(0); var A(zero) := a; zero), \"\\n\";\n}\n\nfunction f(i: int): int {\n  i + 1\n}\n\nfunction F(i: int): int -> int {\n  j => j + i + 1\n}\n\nmethod SequenceConstructionWithNamedFunction(){\n  var g := (i => i+1);\n  print seq(10, f), \"\\n\";\n  print seq(10, g), \"\\n\";\n  print seq(10, F(0)), \"\\n\";\n}\n\nmethod Main() {\n  Match((0,1));\n  Countdown(1);\n  LetExpr();\n  SequenceConstructionWithNamedFunction();\n}\n"}
{"file": "../dafny/Test/comp/Forall.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() {\n  var arrayTests := new ArrayTests();\n  arrayTests.Run();\n\n  var multiArrayTests := new MultiArrayTests();\n  multiArrayTests.Run();\n\n  var objectTests := new ObjectTests();\n  objectTests.Run();\n}\n\nclass ArrayTests {\n  var a: array<int>\n  var b: array<int>\n\n  ghost predicate Valid() reads this, a, b {\n    a.Length == 5 && b.Length == 5\n  }\n\n  constructor() ensures fresh(a) && fresh(b) && Valid() {\n    a := new int[5];\n    b := new int[5];\n  }\n\n  method Initialize() modifies a, b {\n    forall i | 0 <= i < a.Length {\n      a[i] := i;\n    }\n    forall i | 0 <= i < b.Length {\n      b[i] := i;\n    }\n  }\n\n  method Run() modifies a, b requires Valid() ensures Valid() {\n    BasicCases();\n    WrongIndex();\n    SequenceConversion();\n    IndexCollection();\n    Functions();\n  }\n\n  method BasicCases() modifies a, b requires Valid() ensures Valid() {\n    print \"Arrays: Basic cases\\n\";\n\n    // Can sequentialize (compile as single loop):\n    forall i | 0 <= i < a.Length {\n      a[i] := i;\n    }\n    print a[..], \"\\n\"; // [ 0, 1, 2, 3, 4 ];\n\n    // Can sequentialize\n    forall i | 0 <= i < a.Length {\n      b[i] := a[i];\n    }\n    print b[..], \"\\n\"; // [ 0, 1, 2, 3, 4 ];\n\n    // Can sequentialize\n    forall i | 0 <= i < a.Length && a[i] % 2 == 0 {\n      a[i] := a[i] * 2;\n    }\n    print a[..], \"\\n\"; // [ 0, 1, 4, 3, 8 ];\n  }\n\n  method WrongIndex() modifies a, b requires Valid() ensures Valid() {\n    print \"\\nArrays: Wrong index\\n\";\n\n    // Can't sequentialize: different index in RHS\n    Initialize();\n    forall i | 1 <= i < a.Length {\n      a[i] := a[i - 1];\n    }\n    print a[..], \"\\n\"; // [ 0, 0, 1, 2, 3 ];\n\n    // Can't sequentialize: different index in LHS\n    Initialize();\n    forall i | 0 <= i < a.Length - 1 {\n      a[i + 1] := a[i];\n    }\n    print a[..], \"\\n\"; // [ 0, 0, 1, 2, 3 ];\n\n    // Can't sequentialize: wrong array access in range\n    Initialize();\n    forall i | 0 <= i < a.Length && (i == 0 || i != a[0]) {\n      a[i] := a[i] + 1;\n    }\n    print a[..], \"\\n\"; // [ 1, 2, 3, 4, 5 ]\n  }\n\n  method SequenceConversion() modifies a, b requires Valid() ensures Valid() {\n    print \"\\nArrays: Sequence conversion\\n\";\n\n    // Can't sequentialize: sequence conversion in range\n    Initialize();\n    forall i | 0 <= i < a.Length && (i == 0 || i !in a[..2]) {\n      a[i] := a[i] + 2;\n    }\n    print a[..], \"\\n\"; // [ 2, 1, 4, 5, 6 ]\n\n    // Can't sequentialize: sequence conversion in RHS\n    Initialize();\n    forall i | 1 <= i < a.Length - 1 {\n      a[i] := |a[i-1..i+2]|;\n    }\n    print a[..], \"\\n\"; // [ 0, 3, 3, 3, 4 ]\n  }\n\n  method IndexCollection() modifies a, b requires Valid() ensures Valid() {\n    print \"\\nArrays: Index collection\\n\";\n\n    // Can sequentialize: range collection passes through UniqueValues()\n    Initialize();\n    forall i | i in [ 0, 0, 0 ] {\n      a[i] := a[i] + 1;\n    }\n    print a[..], \"\\n\"; // [ 1, 1, 2, 3, 4 ]\n\n    // Can sequentialize\n    Initialize();\n    forall i | i in { 0, 0, 0 } {\n      a[i] := a[i] + 1;\n    }\n    print a[..], \"\\n\"; // [ 1, 1, 2, 3, 4 ]\n\n    // TODO add case that can't be sequentialized\n  }\n\n  method Functions() modifies a, b requires Valid() ensures Valid() {\n    print \"\\nArrays: Functions\\n\";\n\n    var f: int -> int := x => x + 1;\n\n    // Can sequentialize: function is pure\n    Initialize();\n    forall i | 0 <= i < a.Length && a[i] != f(0) {\n      a[i] := f(a[i]);\n    }\n    print a[..], \"\\n\"; // [ 1, 1, 3, 4, 5 ];\n\n    // Can sequentialize: function is pure\n    Initialize();\n    forall i | 0 <= i < a.Length && a[i] != f(0) {\n      a[i] := f(a[i]);\n    }\n    print a[..], \"\\n\"; // [ 1, 1, 3, 4, 5 ];\n\n    var g: int ~> int := x reads this, a, b requires Valid() => x + a[1];\n\n    // Can't sequentialize: impure function call in range\n    Initialize();\n    forall i | 0 <= i < a.Length && a[i] != g(2) {\n      a[i] := i + 1;\n    }\n    print a[..], \"\\n\"; // [ 1, 2, 3, 3, 5 ]\n\n    // Can't sequentialize: impure function call in RHS\n    Initialize();\n    forall i | 0 <= i < a.Length {\n      a[i] := g(i);\n    }\n    print a[..], \"\\n\"; // [ 1, 2, 3, 4, 5 ]\n  }\n}\n\nclass MultiArrayTests {\n  var a: array2<int>\n\n  ghost predicate Valid() reads this, a {\n    a.Length0 == 3 && a.Length1 == 3\n  }\n\n  constructor() ensures fresh(a) && Valid() {\n    a := new int[3,3];\n  }\n\n  function StateAsSeq(): seq<seq<int>> reads this, a requires Valid() {\n    [ [ a[0,0], a[0,1], a[0,2] ],\n      [ a[1,0], a[1,1], a[1,2] ],\n      [ a[2,0], a[2,1], a[2,2] ] ]\n  }\n\n  method Report() requires Valid() ensures Valid() {\n    print StateAsSeq(), \"\\n\";\n  }\n\n  method Run() modifies a requires Valid() ensures Valid() {\n    print \"\\nMulti-dimensional arrays\\n\";\n\n    // Can sequentialize\n    forall i,j | 0 <= i < a.Length0 && 0 <= j < a.Length1 {\n      a[i,j] := i + 2 * j;\n    }\n    Report(); // [[0, 2, 4], [1, 3, 5], [2, 4, 6]]\n\n    // Can't sequentialize\n    forall i,j | 0 <= i < a.Length0 && 0 <= j < a.Length1 {\n      a[i,j] := a[j,i];\n    }\n    Report(); // [[0, 1, 2], [2, 3, 4], [4, 5, 6]];\n  }\n}\n\nclass Thing {\n  var i: int\n  var r: real\n  var t: Thing?\n\n  constructor(i: int, r: real, t: Thing?) ensures this.i == i && this.r == r && this.t == t {\n    this.i := i;\n    this.r := r;\n    this.t := t;\n  }\n\n  method Print() {\n    print \"(\", i, \", \", r, \")\";\n  }\n\n  static method PrintMany(things: seq<Thing>) {\n    print \"[\";\n    var i := 0;\n    var sep := \"\";\n    while i < |things| decreases |things| - i {\n      print sep;\n      things[i].Print();\n      i := i + 1;\n      sep := \", \";\n    }\n    print \"]\";\n  }\n}\n\nclass ObjectTests {\n  var thing1: Thing, thing2: Thing, thing3: Thing\n\n  ghost predicate Valid() reads this {\n    thing1 != thing2 && thing1 != thing3 && thing2 != thing3\n  }\n\n  constructor() ensures fresh(thing1) && fresh(thing2) && fresh(thing3) && Valid() {\n    thing1 := new Thing(1, 1.0, null);\n    thing2 := new Thing(2, 2.0, null);\n    thing3 := new Thing(3, 3.0, null);\n  }\n\n  method Initialize() modifies thing1, thing2, thing3 requires Valid() ensures Valid() {\n    thing1.i := 1; thing1.r := 1.0; thing1.t := null;\n    thing2.i := 2; thing2.r := 2.0; thing2.t := null;\n    thing3.i := 3; thing3.r := 3.0; thing3.t := null;\n  }\n\n  method Report() {\n    Thing.PrintMany([ thing1, thing2, thing3 ]);\n    print \"\\n\";\n  }\n\n  method Run() modifies thing1, thing2, thing3 requires Valid() ensures Valid() {\n    BasicCases();\n    BadFieldAccesses();\n    Functions();\n  }\n\n  method BasicCases() modifies thing1, thing2, thing3 requires Valid() ensures Valid() {\n    print \"\\nObjects: Basic cases\\n\";\n    var things: seq<Thing> := [ thing1, thing2, thing3 ];\n\n    // Can sequentialize\n    Initialize();\n    forall t | t in things {\n      t.i := 0;\n    }\n    Report(); // [(0, 1.0), (0, 2.0), (0, 3.0)]\n\n    // Can sequentialize\n    Initialize();\n    forall t | t in things && t.r != 2.0 {\n      t.i := t.i + 1;\n    }\n    Report(); // [(2, 1.0), (2, 2.0), (4, 3.0)]\n\n    // Can sequentialize\n    Initialize();\n    forall t | t in things && t.i != 3 {\n      t.i := t.i + 1;\n    }\n    Report(); // [(2, 1.0), (3, 2.0), (3, 3.0)]\n  }\n\n  method BadFieldAccesses() modifies thing1, thing2, thing3 requires Valid() ensures Valid() {\n    print \"\\nObjects: Bad field accesses\\n\";\n    var things: seq<Thing> := [ thing1, thing2, thing3 ];\n\n    // Can't sequentialize: bad field access in range\n    Initialize();\n    thing2.t := thing1;\n    forall t | t in things && (t.t == null || t.t.i == 1) {\n      t.i := t.i + 1;\n    }\n    Report(); // [(2, 1.0), (3, 2.0), (4, 3.0)]\n\n    // Can't sequentialize: bad field access in RHS\n    Initialize();\n    forall t | t in things {\n      t.i := thing1.i + 1;\n    }\n    Report(); // [(2, 1.0), (2, 2.0), (2, 3.0)]\n\n    // Can't sequentialize: wrong object in update\n    Initialize();\n    thing1.t := thing3;\n    thing2.t := thing1;\n    thing3.t := thing2;\n    forall t | t in things {\n      t.t.i := t.i;\n    }\n    Report(); // [(2, 1.0), (3, 2.0), (1, 3.0)]\n  }\n\n  method Functions() modifies thing1, thing2, thing3 requires Valid() ensures Valid() {\n    print \"\\nObjects: Functions\\n\";\n    var things: seq<Thing> := [ thing1, thing2, thing3 ];\n\n    var f: int -> int := x => x * 2;\n\n    // Can sequentialize: function is pure\n    Initialize();\n    forall t | t in things {\n      t.i := f(t.i);\n    }\n    Report(); // [(2, 1.0), (4, 2.0), (6, 3.0)]\n\n    var g: () ~> int := () reads this, thing2 => thing2.i;\n\n    // Can't sequentialize: impure function call in range\n    Initialize();\n    forall t | t in things && t.i + g() != 5 {\n      t.i := t.i + 1;\n    }\n    Report(); // [(2, 1.0), (3, 2.0), (3, 3.0)]\n\n    // Can't sequentialize: impure function call in RHS\n    Initialize();\n    forall t | t in things {\n      t.i := t.i + g();\n    }\n    Report(); // [(3, 1.0), (4, 2.0), (5, 3.0)];\n  }\n}\n"}
{"file": "../dafny/Test/comp/Hello.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() {\n    print \"Hello, World! Best, Dafny\\n\";\n    var x := 14;\n    print \"x is \", x, \"\\n\";\n    var y := false;\n    print \"y is \", y, \"\\n\";\n}\n"}
{"file": "../dafny/Test/comp/ExternDafnyString.dfy", "dafny": "// RUN: %dafny /compile:3 /unicodeChar:0 /compileTarget:java \"%s\" %S/Conversions.java %S/ExternDafnyString.java > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// In this example, the extern method obtains a Java string and returns it as a Dafny string.\n\nclass {:extern \"java.lang.String\"} JavaString {\n  ghost const value: string\n}\n\nmethod {:extern \"dafny.ExternDafnyString\", \"getStringFromFile\"} GetStringFromFile() returns (s: string)\n\nmethod Main() {\n  var s := GetStringFromFile();\n\n  var previousStart := 0;\n  for i := 0 to |s|\n    invariant previousStart <= i\n  {\n    if s[i] == '/' {\n      print s[previousStart..i], \"\\n\";\n      previousStart := i + 1;\n    }\n  }\n  if previousStart != |s| {\n    print s[previousStart..], \"\\n\";\n  }\n}\n"}
{"file": "../dafny/Test/comp/ExternJavaString.dfy", "dafny": "// RUN: %dafny /compile:3 /unicodeChar:0 /compileTarget:java \"%s\" %S/Conversions.java %S/ExternJavaString.java > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// In this example, the extern method obtains a Java string and returns it as such.\n// The Dafny code converts that Java string to a Dafny string.\n\nclass {:extern \"java.lang.String\"} JavaString {\n  ghost const value: string\n}\n\n// Note, the following has to be a method, not a function, because the reference it\n// returns is not determined functionally from the input argument.\nmethod {:extern \"Util.Conversions\", \"ToJavaString\"} ToJavaString(s: string) returns (js: JavaString)\n  ensures js.value == s\n\n// The conversion this way can be a function.\nfunction {:extern \"dafny.DafnySequence\", \"asString\"} ToDafnyString(js: JavaString): string\n  ensures ToDafnyString(js) == js.value\n\nmethod {:extern \"dafny.ExternJavaString\", \"getStringFromFile\"} GetStringFromFile() returns (js: JavaString)\n\nmethod Main() {\n  var js := GetStringFromFile();\n  var s := ToDafnyString(js);\n\n  var previousStart := 0;\n  for i := 0 to |s|\n    invariant previousStart <= i\n  {\n    if s[i] == '/' {\n      print s[previousStart..i], \"\\n\";\n      previousStart := i + 1;\n    }\n  }\n  if previousStart != |s| {\n    print s[previousStart..], \"\\n\";\n  }\n}\n"}
{"file": "../dafny/Test/comp/compile1verbose/CompileAndThenRun.dfy", "dafny": "// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:cs \"%s\" > \"%t\"\n// RUN: dotnet %S/CompileAndThenRun.dll >> \"%t\"\n\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: node %S/CompileAndThenRun.js >> \"%t\"\n\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %S/CompileAndThenRun >> \"%t\"\n\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: java -cp %binaryDir/DafnyRuntime.jar%{pathsep}%S/CompileAndThenRun-java CompileAndThenRun >> \"%t\"\n\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:cpp \"%s\" >> \"%t\"\n// RUN: %S/CompileAndThenRun.exe >> \"%t\"\n\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:py \"%s\" >> \"%t\"\n// RUN: python3 %S/CompileAndThenRun-py >> \"%t\"\n\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"hello, Dafny\\n\";\n}\n"}
{"file": "../dafny/Test/comp/CompileWithArguments.dfy", "dafny": "// NONUNIFORM: Multiple testing scenarios, highly backend sensitive, testing CLI\n// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %run --no-verify --target:cs \"%s\" Csharp 1 >> \"%t\"\n// RUN: %run --no-verify --target:cpp --unicode-char:false \"%s\" Cpp Yipee >> \"%t\"\n// RUN: %run --no-verify --target:java \"%s\" -- Java --heya >> \"%t\"\n// RUN: %run --no-verify --target:js \"%s\" -- Javascript 2 >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:py \"%s\" --args Python 1 >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go \"%s\" --args \"Go go\" 1 >> \"%t\"\n// RUN: %build --no-verify --target:cs \"%s\" --output:%s.dll\n// RUN: dotnet %s.dll \"dotnet\" \"howdy\" >> \"%t\"\n// RUN: dotnet %s.dll \"dotnet\" \"hello\" >> \"%t\"\n// RUN: dotnet %s.dll \"dotnet\" \"aloha\" >> \"%t\"\n// RUN: %build --no-verify --target:js \"%s\" --output=%s.js\n// RUN: node %s.js \"javascript\" 2 >> \"%t\"\n// RUN: node %s.js \"javascript\" 1 >> \"%t\"\n// RUN: node %s.js \"javascript\" \"aloha\" >> \"%t\"\n// RUN: %build --no-verify --target:cpp --unicode-char:false \"%s\" --output=%s.exe\n// RUN: %s.exe \"cpp\" 2 >> \"%t\"\n// RUN: %s.exe \"cpp\" 1 >> \"%t\"\n// RUN: %s.exe \"cpp\" \"aloha\" >> \"%t\"\n// RUN: %build --no-verify --target:java \"%s\" --output:\"%s.jar\" >> \"%t\"\n// RUN: java -jar \"%s.jar\" Java 2 >> \"%t\"\n// RUN: java -jar \"%s.jar\" Java 1 >> \"%t\"\n// RUN: java -jar \"%s.jar\" Java aloha >> \"%t\"\n// RUN: %build --no-verify --target:py \"%s\" >> \"%t\"\n// RUN: python3 %S/CompileWithArguments-py Python 2 >> \"%t\"\n// RUN: python3 %S/CompileWithArguments-py Python 1 >> \"%t\"\n// RUN: python3 %S/CompileWithArguments-py Python aloha >> \"%t\"\n// RUN: %build --no-verify --target:go \"%s\" >> \"%t\"\n// RUN: env GO111MODULE=auto GOPATH=%S/CompileWithArguments-go go run %S/CompileWithArguments-go/src/CompileWithArguments.go Go 2 >> \"%t\"\n// RUN: env GO111MODULE=auto GOPATH=%S/CompileWithArguments-go go run %S/CompileWithArguments-go/src/CompileWithArguments.go Go 1 >> \"%t\"\n// RUN: env GO111MODULE=auto GOPATH=%S/CompileWithArguments-go go run %S/CompileWithArguments-go/src/CompileWithArguments.go Go aloha >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main(args: seq<string>) {\n  if |args| != 3 {\n    print \"Expected 3 arguments, got \", |args|;\n  } else {\n    print args[1], \" says \";\n    if args[2] == \"1\" {\n      print \"hello\\n\";\n    } else if args[2] == \"2\" {\n      print \"howdy\\n\";\n    } else {\n      print args[2],\"\\n\";\n    }\n  }\n}\n"}
{"file": "../dafny/Test/comp/EuclideanDivision.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// Some runtimes (like the one for C#) have three implementations\n// of Euclidean div/mod: one for `int`, one for `long`, and one\n// for `BigInteger`.\n\nconst TWO_15: int := 0x0_8000\nconst TWO_63: int := 0x0_8000_0000_0000_0000\nconst TWO_127: int := 0x0_8000_0000_0000_0000_0000_0000_0000_0000\n\n// I0, I1, I2, and I3 use the BigInteger versions\ntype I0 = int\nnewtype I1 = int\nnewtype I2 = x: int | true\nnewtype I3 = x | -TWO_127 <= x < TWO_127\n// I4 uses the int version\nnewtype I4 = x | -TWO_15 <= x < TWO_15\n// I5 uses the long version\nnewtype I5 = x | -TWO_63 <= x < TWO_63\n\nmethod M0() {\n  var neg: I0, pos: I0;\n  neg, pos := -6, 6;\n\n  // div\n\n  var a := neg / (-4); assert a == 2;\n  var b := pos / (-4); assert b == -1;\n  var c := neg / ( 4); assert c == -2;\n  var d := pos / ( 4); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-4) / (-2); assert a == 2;\n  b := ( 4) / (-2); assert b == -2;\n  c := (-4) / ( 2); assert c == -2;\n  d := ( 4) / ( 2); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := 101 / (-3); assert a == -33;\n  b := 100 / (-3); assert b == -33;\n  c :=  99 / (-3); assert c == -33;\n  d :=  98 / (-3); assert d == -32;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) / 3; assert a == -34;\n  b := (-100) / 3; assert b == -34;\n  c := ( -99) / 3; assert c == -33;\n  d := ( -98) / 3; assert d == -33;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  // mod\n\n  a := (-101) % (-3); assert a == 1;\n  b := (-100) % (-3); assert b == 2;\n  c := ( -99) % (-3); assert c == 0;\n  d := ( -98) % (-3); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := ( 101) % (-3); assert a == 2;\n  b := ( 100) % (-3); assert b == 1;\n  c := (  99) % (-3); assert c == 0;\n  d := (  98) % (-3); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) % 3; assert a == 1;\n  b := (-100) % 3; assert b == 2;\n  c := ( -99) % 3; assert c == 0;\n  d := ( -98) % 3; assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (101) % 3; assert a == 2;\n  b := (100) % 3; assert b == 1;\n  c := ( 99) % 3; assert c == 0;\n  d := ( 98) % 3; assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"\\n\";\n}\n\nmethod M1() {\n  var neg: I1, pos: I1;\n  neg, pos := -6, 6;\n\n  // div\n\n  var a := neg / (-4); assert a == 2;\n  var b := pos / (-4); assert b == -1;\n  var c := neg / ( 4); assert c == -2;\n  var d := pos / ( 4); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-4) / (-2); assert a == 2;\n  b := ( 4) / (-2); assert b == -2;\n  c := (-4) / ( 2); assert c == -2;\n  d := ( 4) / ( 2); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := 101 / (-3); assert a == -33;\n  b := 100 / (-3); assert b == -33;\n  c :=  99 / (-3); assert c == -33;\n  d :=  98 / (-3); assert d == -32;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) / 3; assert a == -34;\n  b := (-100) / 3; assert b == -34;\n  c := ( -99) / 3; assert c == -33;\n  d := ( -98) / 3; assert d == -33;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  // mod\n\n  a := (-101) % (-3); assert a == 1;\n  b := (-100) % (-3); assert b == 2;\n  c := ( -99) % (-3); assert c == 0;\n  d := ( -98) % (-3); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := ( 101) % (-3); assert a == 2;\n  b := ( 100) % (-3); assert b == 1;\n  c := (  99) % (-3); assert c == 0;\n  d := (  98) % (-3); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) % 3; assert a == 1;\n  b := (-100) % 3; assert b == 2;\n  c := ( -99) % 3; assert c == 0;\n  d := ( -98) % 3; assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (101) % 3; assert a == 2;\n  b := (100) % 3; assert b == 1;\n  c := ( 99) % 3; assert c == 0;\n  d := ( 98) % 3; assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"\\n\";\n}\n\nmethod M2() {\n  var neg: I2, pos: I2;\n  neg, pos := -6, 6;\n\n  // div\n\n  var a := neg / (-4); assert a == 2;\n  var b := pos / (-4); assert b == -1;\n  var c := neg / ( 4); assert c == -2;\n  var d := pos / ( 4); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-4) / (-2); assert a == 2;\n  b := ( 4) / (-2); assert b == -2;\n  c := (-4) / ( 2); assert c == -2;\n  d := ( 4) / ( 2); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := 101 / (-3); assert a == -33;\n  b := 100 / (-3); assert b == -33;\n  c :=  99 / (-3); assert c == -33;\n  d :=  98 / (-3); assert d == -32;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) / 3; assert a == -34;\n  b := (-100) / 3; assert b == -34;\n  c := ( -99) / 3; assert c == -33;\n  d := ( -98) / 3; assert d == -33;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  // mod\n\n  a := (-101) % (-3); assert a == 1;\n  b := (-100) % (-3); assert b == 2;\n  c := ( -99) % (-3); assert c == 0;\n  d := ( -98) % (-3); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := ( 101) % (-3); assert a == 2;\n  b := ( 100) % (-3); assert b == 1;\n  c := (  99) % (-3); assert c == 0;\n  d := (  98) % (-3); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) % 3; assert a == 1;\n  b := (-100) % 3; assert b == 2;\n  c := ( -99) % 3; assert c == 0;\n  d := ( -98) % 3; assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (101) % 3; assert a == 2;\n  b := (100) % 3; assert b == 1;\n  c := ( 99) % 3; assert c == 0;\n  d := ( 98) % 3; assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"\\n\";\n}\n\nmethod M3() {\n  var neg: I3, pos: I3;\n  neg, pos := -6, 6;\n\n  // div\n\n  var a := neg / (-4); assert a == 2;\n  var b := pos / (-4); assert b == -1;\n  var c := neg / ( 4); assert c == -2;\n  var d := pos / ( 4); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-4) / (-2); assert a == 2;\n  b := ( 4) / (-2); assert b == -2;\n  c := (-4) / ( 2); assert c == -2;\n  d := ( 4) / ( 2); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := 101 / (-3); assert a == -33;\n  b := 100 / (-3); assert b == -33;\n  c :=  99 / (-3); assert c == -33;\n  d :=  98 / (-3); assert d == -32;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) / 3; assert a == -34;\n  b := (-100) / 3; assert b == -34;\n  c := ( -99) / 3; assert c == -33;\n  d := ( -98) / 3; assert d == -33;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  // mod\n\n  a := (-101) % (-3); assert a == 1;\n  b := (-100) % (-3); assert b == 2;\n  c := ( -99) % (-3); assert c == 0;\n  d := ( -98) % (-3); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := ( 101) % (-3); assert a == 2;\n  b := ( 100) % (-3); assert b == 1;\n  c := (  99) % (-3); assert c == 0;\n  d := (  98) % (-3); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) % 3; assert a == 1;\n  b := (-100) % 3; assert b == 2;\n  c := ( -99) % 3; assert c == 0;\n  d := ( -98) % 3; assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (101) % 3; assert a == 2;\n  b := (100) % 3; assert b == 1;\n  c := ( 99) % 3; assert c == 0;\n  d := ( 98) % 3; assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"\\n\";\n}\n\nmethod M4() {\n  var neg: I4, pos: I4;\n  neg, pos := -6, 6;\n\n  // div\n\n  var a := neg / (-4); assert a == 2;\n  var b := pos / (-4); assert b == -1;\n  var c := neg / ( 4); assert c == -2;\n  var d := pos / ( 4); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-4) / (-2); assert a == 2;\n  b := ( 4) / (-2); assert b == -2;\n  c := (-4) / ( 2); assert c == -2;\n  d := ( 4) / ( 2); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := 101 / (-3); assert a == -33;\n  b := 100 / (-3); assert b == -33;\n  c :=  99 / (-3); assert c == -33;\n  d :=  98 / (-3); assert d == -32;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) / 3; assert a == -34;\n  b := (-100) / 3; assert b == -34;\n  c := ( -99) / 3; assert c == -33;\n  d := ( -98) / 3; assert d == -33;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  // mod\n\n  a := (-101) % (-3); assert a == 1;\n  b := (-100) % (-3); assert b == 2;\n  c := ( -99) % (-3); assert c == 0;\n  d := ( -98) % (-3); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := ( 101) % (-3); assert a == 2;\n  b := ( 100) % (-3); assert b == 1;\n  c := (  99) % (-3); assert c == 0;\n  d := (  98) % (-3); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) % 3; assert a == 1;\n  b := (-100) % 3; assert b == 2;\n  c := ( -99) % 3; assert c == 0;\n  d := ( -98) % 3; assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (101) % 3; assert a == 2;\n  b := (100) % 3; assert b == 1;\n  c := ( 99) % 3; assert c == 0;\n  d := ( 98) % 3; assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"\\n\";\n}\n\nmethod M5() {\n  var neg: I5, pos: I5;\n  neg, pos := -6, 6;\n\n  // div\n\n  var a := neg / (-4); assert a == 2;\n  var b := pos / (-4); assert b == -1;\n  var c := neg / ( 4); assert c == -2;\n  var d := pos / ( 4); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-4) / (-2); assert a == 2;\n  b := ( 4) / (-2); assert b == -2;\n  c := (-4) / ( 2); assert c == -2;\n  d := ( 4) / ( 2); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := 101 / (-3); assert a == -33;\n  b := 100 / (-3); assert b == -33;\n  c :=  99 / (-3); assert c == -33;\n  d :=  98 / (-3); assert d == -32;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) / 3; assert a == -34;\n  b := (-100) / 3; assert b == -34;\n  c := ( -99) / 3; assert c == -33;\n  d := ( -98) / 3; assert d == -33;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  // mod\n\n  a := (-101) % (-3); assert a == 1;\n  b := (-100) % (-3); assert b == 2;\n  c := ( -99) % (-3); assert c == 0;\n  d := ( -98) % (-3); assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := ( 101) % (-3); assert a == 2;\n  b := ( 100) % (-3); assert b == 1;\n  c := (  99) % (-3); assert c == 0;\n  d := (  98) % (-3); assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (-101) % 3; assert a == 1;\n  b := (-100) % 3; assert b == 2;\n  c := ( -99) % 3; assert c == 0;\n  d := ( -98) % 3; assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"   \";\n\n  a := (101) % 3; assert a == 2;\n  b := (100) % 3; assert b == 1;\n  c := ( 99) % 3; assert c == 0;\n  d := ( 98) % 3; assert d == 2;\n  print a, \" \", b, \" \", c, \" \", d, \"\\n\";\n}\n\nmethod Main() {\n  // This is expected to print six lines of:\n  // 2 -1 -2 1   2 -2 -2 2   -33 -33 -33 -32   -34 -34 -33 -33   1 2 0 1   2 1 0 2   1 2 0 1   2 1 0 2\n  M0();\n  M1();\n  M2();\n  M3();\n  M4();\n  M5();\n}\n"}
{"file": "../dafny/Test/comp/UnicodeStrings.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --unicode-char\n\nmethod AssertAndExpect(p: bool) \n  requires p\n{\n  expect p;\n}\n\n// Included to test casting between char and all supported native types\nnewtype uint8 = x: int | 0 <= x < 0x100 \nnewtype uint16 = x: int | 0 <= x < 0x1_0000 \nnewtype uint32 = x: int | 0 <= x < 0x1_0000_0000 \nnewtype uint64 = x: int | 0 <= x < 0x1_0000_0000_0000_0000 \nnewtype int8 = x: int | -0x80 <= x < 0x80\nnewtype int16 = x: int | -0x8000 <= x < 0x8000\nnewtype int32 = x: int | -0x8000_0000 <= x < 0x8000_0000\nnewtype int64 = x: int | -0x8000_0000_0000_0000 <= x < 8000_0000_0000_0000\n\nconst AllCasesAsCodePoints := [\n  0,        // \\0, minimum value\n  0x9,      // \\t\n  0xA,      // \\n\n  0xD,      // \\r\n  0x22,     // \\\"\n  0x27,     // \\'\n  0x44,     // \\\\\n  0x5c,     // D (because Dafny)\n  0x80,     // First non-ASCII codepoint (and hence first with two bytes in UTF-8)\n  0xFF,     // Last codepoint that could fit into a single byte\n  0x100,    // First codepoint that can't fit into a single byte\n  0xD7FF,   // Last codepoint before the surrogate range\n  0xE000,   // First codepoint after the surrogate range\n  0xFFEE,   // '￮', which is after the surrogate range but a single code unit in UTF-16\n  0x1_0000, // First codepoint beyong the BMP, requiring two UTF-16 code units\n  0x1_D11E, // '𝄞', [0xD834, 0xDD1E] in UTF-16\n            // Included along with ￮ as an evil test case to catch comparing\n            // encoded bytes lexicographically by accident 😈.\n            // UTF-8 seems to have the property that this comparison\n            // is the same, but UTF-16 doesn't.\n  0x1_F680, // Typical non-BMP codepoint (🚀)\n  0x10_FFFF // Maximum value\n]\n\n\n// The primary definition of the character values is casting to characters from integers.\n// This is the simplest and most likely to be correct at runtime, and used as the baseline for comparisons.\nconst AllCases := \n  seq(|AllCasesAsCodePoints|, i requires 0 <= i < |AllCasesAsCodePoints| => AllCasesAsCodePoints[i] as char)\n\nconst AlternateForms: seq<seq<char>> := [\n  // As character literals with escapes\n  ['\\0', '\\t', '\\n', '\\r', '\\\"', '\\'', '\\U{44}', '\\\\', '\\U{80}', '\\U{FF}',\n      '\\U{100}', '\\U{D7FF}', '\\U{E000}', '\\U{FFEE}', '\\U{10000}', '\\U{1D11E}', '\\U{1F680}', '\\U{10FFFF}'],\n  // As verbatim character literals where reasonable, or using a \\U escape where not\n  ['\\U{0}', '\\U{9}', '\\U{A}', '\\U{D}', '\\U{22}', '\\U{27}', 'D', '\\U{5c}', \n      '', 'ÿ', 'Ā', '\\U{D7FF}', '\\U{E000}', '￮', '𐀀', '𝄞', '🚀', '\\U{10FFFF}'],\n  // In a string literal with escapes\n  \"\\0\\t\\n\\r\\\"\\'\\U{44}\\\\\\U{80}\\U{FF}\\U{100}\\U{D7FF}\\U{E000}\\U{FFEE}\\U{10000}\\U{1D11E}\\U{1F680}\\U{10FFFF}\",\n  // In a string literal without escapes where reasonable\n  \"\\U{0}\\U{9}\\U{A}\\U{D}\\U{22}\\U{27}D\\U{5c}ÿĀ\\U{D7FF}\\U{E000}￮𐀀𝄞🚀\\U{10FFFF}\"\n]\n\nmethod AllCharCasesTest() {\n  // Boy a foreach loop would be really nice right about now... \\U{1F604}\n  for caseIndex := 0 to |AllCases| {\n    var thisCase := AllCases[caseIndex];\n    for formIndex := 0 to |AlternateForms| {\n      expect thisCase == AlternateForms[formIndex][caseIndex];\n      expect !(thisCase != AlternateForms[formIndex][caseIndex]);\n      \n      expect AlternateForms[formIndex][caseIndex] == thisCase;\n      expect !(AlternateForms[formIndex][caseIndex] != thisCase);\n\n      CastChar(thisCase);\n    }\n  }\n\n  // Comparisons - taking advantage of the list of cases being in ascending order\n  for i := 0 to |AllCases| {\n    var left := AllCases[i];\n    for j := 0 to |AllCases| {\n      var right := AllCases[j];\n      if i < j {\n        expect left < right;\n        expect left <= right;\n        expect !(left == right);\n        expect left != right;\n        expect !(left > right);\n        expect !(left >= right);\n      } else if i == j {\n        expect !(left < right);\n        expect left <= right;\n        expect left == right;\n        expect !(left != right);\n        expect !(left > right);\n        expect left >= right;\n      } else {\n        expect !(left < right);\n        expect !(left <= right);\n        expect !(left == right);\n        expect left != right;\n        expect left > right;\n        expect left >= right;\n      }\n    }\n  }\n}\n\n// WARNING: Do not do this in real code!\n// It's a great example of what NOT to do when working with Unicode,\n// since the concept of upper/lower case is culture-specific.\nfunction ToLower(ch: char): char {\n  if 'A' <= ch <= 'Z' then\n    ch - 'A' + 'a'\n  else\n    ch\n}\n\nfunction MapToLower(s: string): string {\n  if 0 == |s| then\n    []\n  else\n    [ToLower(s[0])] + MapToLower(s[1..])\n}\n\nfunction MapToInt32(s: string): seq<int32> {\n  if 0 == |s| then\n    []\n  else\n    [s[0] as int32] + MapToInt32(s[1..])\n}\n\nmethod Main(args: seq<string>) {\n  AllCharCasesTest();\n  CharQuantification();\n  StringPrinting();\n  CharPrinting();\n}\n\n// Not including any non-printable characters in this one\nconst stringThatNeedsEscaping := \"D\\0\\r\\n\\\\\\\"\\'\\U{1F60E}\"\n\nmethod CharPrinting() {\n  var chars := stringThatNeedsEscaping;\n  for i := 0 to |chars| {\n    print chars[i], \"\\n\";\n  }\n  for i := 0 to |chars| {\n    var r := Print(chars[i]);\n    expect chars[i] == r;\n  }\n}\n\n// Used to ensure characters can be passing in and out of generic code\n// (which is a real challenge in Java for example)\nmethod Print<T>(t: T) returns (r: T) {\n  print t, \"\\n\";\n  return t;\n}\n\ndatatype Option<T> = Some(value: T) | None\n\ndatatype StringOption = SomeString(value: string) | NoString\n\nmethod StringPrinting() {\n  var trickyString := \"Dafny is just so \\U{1F60E}\";\n  print trickyString, \"\\n\";\n\n  var trickyString2 := \"Dafny is just so \" + [0x1F60E as char];\n  print trickyString2, \"\\n\";\n\n  // Testing that runtimes don't confuse a seq<uint32> for a string\n  // (which would be a problem if we used Int32 in C# instead of Rune, for example)\n  var s := \"Ceci n'est pas une string\";\n  var notAString := MapToInt32(s);\n  print notAString, \"\\n\";\n\n  // Ensuring character arithmetic can be compiled\n  var sarcastic := \"Oh UNicOdE, tHaT's a REaL usEFuL FEaTuRe!\";\n  var sincere := MapToLower(sarcastic);\n  print sincere, \"\\n\";\n\n  // Exercising the new rules for how strings are printed,\n  // namely that a string is only printed verbatim if the value\n  // is statically known to be a seq<char>\n\n  var mightBeString := Some(trickyString);\n  print mightBeString, \"\\n\";\n  print mightBeString.value, \"\\n\";\n\n  // Note that the string is printed as a string, but with double quotes and escaping\n  var definitelyString := SomeString(stringThatNeedsEscaping);\n  print definitelyString, \"\\n\";\n\n  var tupleOfString := (stringThatNeedsEscaping, 42);\n  print tupleOfString, \"\\n\";\n}\n\nmethod CastChar(c: char) {\n  if (c as int < 0x80) {\n    var asInt8 := c as int8;\n    AssertAndExpect(asInt8 as char == c);\n  }\n  if (c as int < 0x100) {\n    var asUint8 := c as uint8;\n    AssertAndExpect(asUint8 as char == c);\n  }\n  if (c as int < 0x8000) {\n    var asInt16 := c as int16;\n    AssertAndExpect(asInt16 as char == c);\n  }\n  if (c as int < 0x1_0000) {\n    var asUint16 := c as uint16;\n    AssertAndExpect(asUint16 as char == c);\n  }\n  var asInt32 := c as int32;\n  AssertAndExpect(asInt32 as char == c);\n  var asInt64 := c as int64;\n  AssertAndExpect(asInt64 as char == c);\n  var asInt := c as int;\n  AssertAndExpect(asInt as char == c);\n  var asReal := c as real;\n  AssertAndExpect(asReal as char == c);\n}\n\n// Testing that the runtime implementation of AllChars() is correct\nmethod CharQuantification() {\n  ghost var allChars := set c: char {:trigger Identity(c)} | true :: Identity(c);\n  ghost var allCodePoints := (set cp: int {:trigger Identity(cp)} | 0 <= cp < 0xD800 :: Identity(cp as char))\n                     + (set cp: int {:trigger Identity(cp)} | 0xE000 <= cp < 0x11_0000 :: Identity(cp as char));\n  assert forall c: char {:trigger Identity(c)} :: 0 <= Identity(c as int) < 0xD800 || 0xE000 <= Identity(c as int) < 0x11_0000;\n  assert forall c: char :: Identity(c) in allChars;\n  assert allChars == allCodePoints;\n\n  // I'd love to expect allChars == allCodePoints, but that's currently\n  // an O(n^2) operation in some runtimes that don't have hashcode-based\n  // set operations, and n here is over a million. :P\n  // Even just computing allChars at runtime seems to be too slow in Javascript. :(\n  // It seems to be fast enough just to iterate over all characters though.\n  expect forall c: char {:trigger Identity(c)} :: 0 <= c as int < 0xD800 || 0xE000 <= c as int < 0x11_0000;\n}\n\n// Dummy identity function just to enable triggers that Dafny and Boogie are happy with\nfunction Identity<T>(x: T): T { x }\n\nmethod CharsAndArrows() {\n  var lambda := (c: char) requires c <= 'Z' => c + 1 as char;\n  var fromLambda := lambda('C');\n  print fromLambda, \"\\n\";\n\n  var funcRef := IncrementChar;\n  var fromFuncRef := funcRef('C');\n  print fromFuncRef, \"\\n\";\n}\n\nfunction IncrementChar(c: char): char \n  requires c <= 'Z'\n{\n  c + 1 as char\n}\n"}
{"file": "../dafny/Test/comp/MainMethod.dfy", "dafny": "// NONUNIFORM: multiple testing scenarios (could be split into several uniform tests)\n// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n\n// RUN: %dafny /noVerify /compile:4 /Main:Cl.Static   /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Cl.Instance /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Tr.Static   /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Dt.Static   /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Dt.Instance /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Co.Static   /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Co.Instance /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Nt.Static   /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Nt.Instance /compileTarget:cs \"%s\" >> \"%t\"\n\n// RUN: %dafny /noVerify /compile:4 /Main:Cl.Static   /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Cl.Instance /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Tr.Static   /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Dt.Static   /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Dt.Instance /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Co.Static   /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Co.Instance /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Nt.Static   /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Nt.Instance /compileTarget:js \"%s\" >> \"%t\"\n\n// RUN: %dafny /noVerify /compile:4 /Main:Cl.Static   /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Cl.Instance /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Tr.Static   /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Dt.Static   /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Dt.Instance /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Co.Static   /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Co.Instance /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Nt.Static   /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Nt.Instance /compileTarget:go \"%s\" >> \"%t\"\n\n// RUN: %dafny /noVerify /compile:4 /Main:Cl.Static   /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Cl.Instance /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Tr.Static   /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Dt.Static   /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Dt.Instance /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Co.Static   /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Co.Instance /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Nt.Static   /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Nt.Instance /compileTarget:java \"%s\" >> \"%t\"\n\n// RUN: %dafny /noVerify /compile:4 /Main:Cl.Static   /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Cl.Instance /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Tr.Static   /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Dt.Static   /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Dt.Instance /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Co.Static   /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Co.Instance /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Nt.Static   /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /Main:Nt.Instance /compileTarget:py \"%s\" >> \"%t\"\n\n// RUN: %diff \"%s.expect\" \"%t\"\n\ntype plural = x | 2 <= x witness 2\n\nclass Cl<X(0)> {\n  var p: plural\n  var c: real\n  var x: X\n  static method Static() { print \"Cl: static\\n\"; }\n  method Instance() { print \"Cl: \", p, \" \", c, \" \", x, \"\\n\"; }\n}\n\ntrait Tr<X> {\n  static method Static() { print \"Tr: static\\n\"; }\n}\n\ndatatype Dt<X> = Dt0(plural, X) | Dt1(real, X) {\n  static method Static() { print \"Dt: static\\n\"; }\n  method Instance() { print \"Dt: \", this, \"\\n\"; }\n}\n\ncodatatype Co<X> = CoMore(plural, X, Co) {\n  static method Static() { print \"Co: static\\n\"; }\n  method Instance() { print \"Co: \", this, \"\\n\"; }\n}\n\nnewtype Nt = x | -0x8000_0000 <= x <= 0x8000_0000 {\n  const c: plural\n  static method Static() { print \"Nt: static\\n\"; }\n  method Instance() { print \"Nt: \", this, \" \", c, \"\\n\"; }\n}\n"}
{"file": "../dafny/Test/comp/UnoptimizedErasableTypeWrappers.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --optimize-erasable-datatype-wrapper:false --relax-definite-assignment --spill-translation\n\ndatatype SingletonRecord = SingletonRecord(u: int)\ndatatype WithGhost = WithGhost(u: int, ghost v: int)\n\nmethod Main() {\n  var s := SingletonRecord(15);\n  var w := WithGhost(20, 22);\n  var t3a := (ghost 30, ghost 31, ghost 32);\n  var t3b := (30, ghost 31, ghost 32);\n  var t3c := (ghost 30, 31, ghost 32);\n  var t3d := (30, ghost 31, 32);\n\n  print s, \" \", w, \"\\n\"; // SingletonRecord(15) WithGhost(20)\n  print t3a, \" \", t3b, \" \", t3c, \" \", t3d, \"\\n\"; // () (30) (31) (30, 32)\n\n  print s.u, \" \", w.u, \"\\n\"; // 15 20\n  print t3b.0, \" \", t3c.1, \" \", t3d.0, \" \", t3d.2, \"\\n\"; // 30 31 30 32\n}\n"}
{"file": "../dafny/Test/comp/SequenceConcatOptimization.dfy", "dafny": "// RUN: %baredafny verify %args \"%s\" > \"%t\"\n// RUN: %baredafny test --no-verify --target=cs %args   \"%s\" >> \"%t\"\n// RUN: %baredafny test --no-verify --target=java %args \"%s\" >> \"%t\"\n// RUN: %baredafny test --no-verify --target=go %args   \"%s\" >> \"%t\"\n// RUN: %baredafny test --no-verify --target=py %args   \"%s\" >> \"%t\"\n\nmodule SequenceConcatOptimization {\n\n  // A basic performance sanity check for the sequence concatenation\n  // that is now implemented for C#, Java, and Go (with the latter\n  // using a common implementation in Dafny).\n  // In these languages this test completes in a second or so,\n  // but the others take much longer than I was willing to wait.\n  method {:test} SirConcatsALot() {\n    var s: seq<int> := [];\n    for i := 0 to 1_000_000 {\n      s := s + [i];\n    }\n    expect |s| == 1_000_000;\n  }\n}\n"}
{"file": "../dafny/Test/comp/compile1quiet/CompileRunQuietly.dfy", "dafny": "// RUN: %dafny /unicodeChar:0 /compileTarget:cs \"%s\" > \"%t\"\n// RUN: dotnet %S/CompileRunQuietly.dll >> \"%t\"\n\n// RUN: %dafny /unicodeChar:0 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: node %S/CompileRunQuietly.js >> \"%t\"\n\n// RUN: %dafny /unicodeChar:0 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %S/CompileRunQuietly >> \"%t\"\n\n// RUN: %dafny /unicodeChar:0 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: java -cp %binaryDir/DafnyRuntime.jar%{pathsep}%S/CompileRunQuietly-java CompileRunQuietly >> \"%t\"\n\n// RUN: %dafny /unicodeChar:0 /compileTarget:cpp \"%s\" >> \"%t\"\n// RUN: %S/CompileRunQuietly.exe >> \"%t\"\n\n// RUN: %dafny /unicodeChar:0 /compileTarget:py \"%s\" >> \"%t\"\n// RUN: python3 %S/CompileRunQuietly-py >> \"%t\"\n\n // RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"hello, Dafny\\n\";\n}\n"}
{"file": "../dafny/Test/comp/ForLoops-Compilation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation\n\nmethod Main() {\n  TestM(0, 0);\n  TestM(-2, 2);\n  TestM(-2, 3);\n  TestM(10, 20);\n\n  TestP(0, 0);\n  TestP(28, 28);\n  TestP(28, 30);\n  TestP(255, 255); // this one requires an unsigned comparison in Java\n  TestP(0, 255);\n\n  TestQ(-128, -128);\n  TestQ(-128, -127);\n  TestQ(126, 127);\n  TestQ(127, 127);\n\n  Mul(0, 2);\n  Mul(2, 0);\n  Mul(1, 1);\n  Mul(6, 5);\n\n  Add(0, 3);\n  Add(3, 0);\n  Add(4, 0);\n  Add(0, 0);\n  Add(19, 14);\n\n  BreaksAndContinues();\n}\n\nmethod TestM(lo: int, hi: int)\n  requires lo <= hi\n{\n  var s, t := M0(lo, hi);\n  var u, v := M1(lo, hi);\n  print s, \" \", t, \" \", u, \" \", v, \"\\n\";\n}\n\nmethod TestP(lo: byte, hi: byte)\n  requires lo <= hi\n{\n  var s, t := P(lo, hi);\n  print s, \" \", t, \"\\n\";\n}\n\nmethod TestQ(lo: i8, hi: i8)\n  requires lo <= hi\n{\n  var s, t := Q(lo, hi);\n  print s, \" \", t, \"\\n\";\n}\n\nmethod M0(lo: int, hi: int) returns (s: int, t: int)\n  requires lo <= hi\n{\n  s, t := 0, 0;\n  for i := lo to hi {\n    s := s + i;\n  }\n  for i := hi downto lo {\n    t := t + i;\n  }\n}\n\nmethod M1(lo: int, hi: int) returns (s: int, t: int)\n  requires lo <= hi\n{\n  s, t := 0, 0;\n  for i := lo to *\n    invariant i <= hi\n    decreases hi - i\n  {\n    if i == hi {\n      break;\n    }\n    s := s + i;\n  }\n  if lo < hi {\n    for i := hi downto *\n      invariant lo <= i\n      decreases i - lo\n    {\n      if i == lo - 1 {\n        break;\n      }\n      t := t + i;\n    }\n  }\n}\n\nnewtype byte = x | 0 <= x < 256\n\nmethod P(lo: byte, hi: byte) returns (s: int, t: int)\n  requires lo <= hi\n{\n  s, t := 0, 0;\n  for i := lo to hi {\n    s := s + i as int;\n  }\n  for i := hi downto lo {\n    t := t + i as int;\n  }\n}\n\nnewtype i8 = x | -128 <= x < 128\n\nmethod Q(lo: i8, hi: i8) returns (s: int, t: int)\n  requires lo <= hi\n{\n  s, t := 0, 0;\n  for i := lo to hi {\n    s := s + i as int;\n  }\n  for i := hi downto lo {\n    t := t + i as int;\n  }\n}\n\nmethod Mul(a: nat, b: nat) {\n  var c := 0;\n  var aa := a;\n  for _ := 0 to aa {\n    var bb := b;\n    for _ := bb downto 0 {\n      c, bb, aa := c + 1, bb + 3, aa + 2;\n    }\n    aa := aa + 5;\n  }\n  print a, \" * \", b, \" == \", c, \"\\n\";\n}\n\nmethod Add(a: nat, b: nat) {\n  var s := 0;\n  label Outer0:\n  label Outer1:\n  for _ := 0 to 7 {\n    for i := 0 to *\n      invariant i <= a\n      decreases a - i\n    {\n      if i == a {\n        if i % 2 == 0 {\n          break Outer0;\n        } else {\n          break Outer1;\n        }\n      }\n      if a < i {\n        break; // never reached\n      }\n      s := s + 1;\n    }\n    s := 77; // never reached\n  }\n  for _ := 2 to 3 {\n    label Inner:\n    for i: int := b downto *\n      invariant 0 <= i\n      decreases i\n    {\n      if i < 0 {\n        break Inner;\n      }\n      s := s + 1;\n    }\n  }\n  print a, \" + \", b, \" == \", s, \"\\n\";\n}\n\n// --------------- breaks and continues ---------------\n\nmethod BreaksAndContinues() {\n  var n0 := BC0();\n  var n1 := BC1();\n  var n2 := BC2();\n  print n0, \" \", n1, \" \", n2, \"\\n\"; // 4 4 4\n\n  BC10();\n  BC11();\n\n  var b0 := BC20();\n  var b1 := BC21();\n  var b2 := BC22();\n  var c := BC30();\n  print b0, \" \", b1, \" \", b2, \" \", c, \"\\n\"; // true true true 15\n\n  LabelRegressions();\n}\n\nmethod BC0() returns (c: nat) { // 4\n  c := 0;\n  var i := 0;\n  while i < 10 { // 0 3 4 7\n    c := c + 1;\n    if i % 2 == 0 {\n      i := i + 3;\n      continue;\n    } else if i == 7 {\n      break;\n    }\n    i := i + 1;\n  }\n}\n\nmethod BC1() returns (c: nat) { // 4\n  c := 0;\n  var i := 0;\n  while // 0 3 4 7\n    decreases 10 - i\n  case i < 10 && i % 2 == 0 =>\n    c := c + 1;\n    i := i + 3;\n    continue;\n  case i < 10 && i == 7 =>\n    c := c + 1;\n    break;\n  case i < 10 && i != 7 && i % 2 == 1 =>\n    c := c + 1;\n    i := i + 1;\n}\n\nmethod BC2() returns (c: nat) { // 4\n  c := 0;\n  var i := 0;\n  for k := 0 to 10 { // 0 3 4 7\n    c := c + 1;\n    if i % 2 == 0 {\n      i := i + 3;\n      continue;\n    } else if i == 7 {\n      expect k == 3;\n      break;\n    }\n    i := i + 1;\n  }\n}\n\n// Test \"break\", \"continue\", and \"break continue\" for \"for\" loops\nmethod BC10() {\n  print \"== BC10 ==\";\n  for i := 0 to 10 {\n    print \"\\n\", i, \" \";\n    for j := 0 to 10 {\n      print \"--\";\n      if i == 0 && j == 3 {\n        break;\n      } else if i == 1 && j == 4 {\n        break continue;\n      } else if j == 2 {\n        continue;\n      }\n      print \"++\";\n    }\n    print \" ***\";\n  }\n  print \"\\n\";\n}\n\n// Test \"break\", \"continue\", and \"break continue\" for \"while\" and \"while-case\" loops\nmethod BC11() {\n  print \"== BC11 ==\";\n  var i := 0;\n  while i < 10\n  {\n    print \"\\n\", i, \" \";\n    i := i + 1;\n    var j := 0;\n    var b := true;\n    while\n      decreases 10 - j, b\n    {\n      case j < 10 && !b =>\n        print \"--\";\n        if i - 1 == 0 && j == 3 {\n          break;\n        } else if i - 1 == 1 && j == 4 {\n          break continue;\n        } else if j == 1 {\n          j := j + 1;\n          continue;\n        }\n        print \"++\";\n        j := j + 1;\n      case j < 10 && b =>\n        print \"||\";\n        b := false;\n    }\n    print \" ***\";\n  }\n  print \"\\n\";\n}\n\n// Test \"continue Label\" and \"break Label\" for \"while\" loops\nmethod BC20() returns (b: bool) {\n  b := false;\n  var i := 0;\n  label Loop:\n  while i < 10 {\n    if i == 929 {\n    } else if i < 7 {\n      i := i + 1;\n      continue Loop;\n    } else {\n      b := true;\n      break Loop;\n    }\n    assert false; // unreachable\n    expect false; // unreachable\n  }\n}\n\n// Test \"continue Label\" and \"break Label\" for \"while-case\" loops\nmethod BC21() returns (b: bool) {\n  b := false;\n  var i := 0;\n  label Loop:\n  while\n    decreases 10 - i\n  {\n    case i < 10 =>\n      if i == 929 {\n      } else if i < 7 {\n        i := i + 1;\n        continue Loop;\n      } else {\n        b := true;\n        break Loop;\n      }\n      assert false; // unreachable\n      expect false; // unreachable\n  }\n}\n\n// Test \"continue Label\" and \"break Label\" for \"for\" loops\nmethod BC22() returns (b: bool) {\n  b := false;\n  label Loop:\n  for i := 0 to 10 {\n    if i == 929 {\n    } else if i < 7 {\n      continue Loop;\n    } else {\n      b := true;\n      break Loop;\n    }\n    assert false; // unreachable\n    expect false; // unreachable\n  }\n}\n\n// Test \"break break\"\nmethod BC30() returns (c: nat) { // 15\n  c := 0;\n  while true {\n    for k := 0 to 10\n      invariant k <= 5\n    {\n      if k == 5 {\n        break break;\n      }\n      c := c + 1;\n    }\n  }\n\n  while {\n    case true =>\n      for k := 0 to 10\n        invariant k <= 5\n      {\n        if k == 5 {\n          break break;\n        }\n        c := c + 1;\n      }\n  }\n\n  for i := 0 to 100 {\n    for k := 0 to 10 {\n      if k == 5 {\n        break break;\n      }\n      c := c + 1;\n    }\n  }\n}\n\nmethod LabelRegressions() {\n  // The cases of if-case, while-case, and match statements are List<Statement>'s, which are essentially\n  // a BlockStmt but without the curly braces. Each Statement in such a List can have labels, so\n  // it's important to call TrStmtList on these in the Verifier, not just call TrStmt on every Statement\n  // in the List. (See also LabelRegressions() in Test/dafny0/ResolutionErrors.dfy.)\n  if {\n    case true =>\n      label Loop:\n      for k := 0 to 10 {\n        if k % 2 == 0 {\n          continue Loop;\n        } else {\n          break Loop;\n        }\n      }\n  }\n\n  while {\n    case true =>\n      label Loop:\n      for k := 0 to 10 {\n        if k % 2 == 0 {\n          continue Loop;\n        } else {\n          break Loop;\n        }\n      }\n      break;\n  }\n\n  match (0, 0) {\n    case (_, _) =>\n      label Loop:\n      for k := 0 to 10 {\n        if k % 2 == 0 {\n          continue Loop;\n        } else {\n          break Loop;\n        }\n      }\n  }\n\n  print \"all good\\n\";\n}\n"}
{"file": "../dafny/Test/comp/Uninitialized.dfy", "dafny": "// RUN: %testDafnyForEachCompiler --refresh-exit-code=0 \"%s\"\n\nmodule {:options \"--function-syntax=4\"} Stacks {\n  export\n    reveals Stack\n    provides Stack.Valid, Stack.Repr, Stack.Elements\n    reveals Stack.Count\n    provides Stack.Push, Stack.Pop\n\n  datatype MaybeInitialized<T> = ghost Uninitialized | Initialized(value: T)\n\n  // Note, nothing is assumed about the type parameter T in the following line. In particular,\n  // it's not assumed to be an auto-init type (and, in fact, may even be empty).\n  class Stack<T> {\n    ghost var Repr: set<object>\n    ghost var Elements: seq<T>\n    ghost predicate Valid()\n      reads this, Repr\n      ensures Valid() ==> this in Repr\n    {\n      this in Repr &&\n      arr in Repr &&\n      n == |Elements| <= arr.Length != 0 &&\n      forall i :: 0 <= i < n ==>\n        arr[i].Initialized? && arr[i].value == Elements[i]\n    }\n\n    var arr: array<MaybeInitialized<T>>\n    var n: nat\n\n    constructor ()\n      ensures Valid() && fresh(Repr) && Elements == []\n    {\n      Elements, n := [], 0;\n      arr := new [20];\n      Repr := {this, arr};\n    }\n\n    function Count(): nat\n      requires Valid()\n      reads Repr\n    {\n      |Elements|\n    } by method {\n      return n;\n    }\n\n    method Push(t: T)\n      requires Valid()\n      modifies Repr\n      ensures Valid() && fresh(Repr - old(Repr))\n      ensures Elements == old(Elements) + [t]\n    {\n      if n == arr.Length {\n        var a := new [2 * n];\n        forall i | 0 <= i < n {\n          a[i] := arr[i];\n        }\n        arr := a;\n        Repr := Repr + {a};\n      }\n      arr[n] := Initialized(t);\n      Elements, n := Elements + [t], n + 1;\n    }\n\n    method Pop() returns (t: T)\n      requires Valid() && Elements != []\n      modifies Repr\n      ensures Valid() && fresh(Repr - old(Repr))\n      ensures var last := |old(Elements)| - 1;\n        t == old(Elements)[last] &&\n          Elements == old(Elements)[..last]\n    {\n      n := n - 1;\n      Elements := Elements[..n];\n      t := arr[n].value;\n    }\n  }\n}\n\ntype Empty = x: int | false witness *\n\nmethod Main() {\n  var s := new Stacks.Stack();\n  s.Push(10);\n  s.Push(12);\n  s.Push(11);\n  var x := s.Pop();\n  assert s.Elements == [10, 12] && x == 11;\n  var count := s.Count();\n  assert count == 2;\n  print x, \" \", count, \"\\n\"; // 11 2\n\n  var s' := new Stacks.Stack<Empty>();\n  count := s'.Count();\n  assert count == 0;\n  print count, \"\\n\"; // 0\n\n  EnumerationTests.Test();\n  DestructorTests.Test();\n\n  Arrays.Test();\n}\n\nmodule {:options \"/functionSyntax:4\"} EnumerationTests {\n  datatype Enum = ghost EnumA | EnumB\n  {\n    const N := 13\n\n    predicate Is(n: nat) {\n      N == n\n    }\n  }\n\n  datatype AllGhost = ghost Ctor0 | ghost Ctor1\n  {\n    const N := 13\n\n    predicate Is(n: nat) {\n      N == n\n    }\n\n    method CheckIs(n: nat) returns (r: bool) {\n      r := N == n;\n    }\n  }\n\n  method Test() {\n    var e := PickEnumValue();\n    var s: seq<Enum>;\n    s := [e];\n    print |s|, \"\\n\"; // 1\n\n    var g, sg;\n    g := PickAllGhostValue();\n    sg := [g];\n    print |sg|, \"\\n\"; // 1\n  }\n\n  method PickEnumValue() returns (r: Enum) {\n    if e: Enum :| e.Is(13) {\n      r := e;\n    } else {\n      r := *;\n    }\n  }\n\n  method PickAllGhostValue() returns (r: AllGhost) {\n    if ag: AllGhost :| ag.Is(13) {\n      r := ag;\n    } else {\n      r := *;\n    }\n  }\n}\n\nmodule {:options \"/functionSyntax:4\"} DestructorTests {\n  datatype WithCommonDestructors<A, B> =\n    | CtorA(a: A, x: int)\n    | ghost CtorAB(a: A, b: B)\n    | CtorB(b: B, y: int, ghost z: int)\n\n  method Test() {\n    var wcd := CtorA(true, 7);\n    print wcd.a, \" \"; // true\n    wcd := wcd.(a := false);\n    print wcd.a, \" \", wcd.x, \"\\n\"; // false 7\n\n    wcd := CtorB(2.11, 9, 100);\n    print wcd.b, \" \"; // 2.11\n    wcd := wcd.(b := 2.13);\n    print wcd.b, \" \", wcd.y, \"\\n\"; // 2.13 9\n\n    wcd := wcd.(y := 11, z := 101);\n    print wcd.y, \" \"; // 11\n    wcd := wcd.(z := 102, y := 12);\n    print wcd.y, \" \"; // 12\n    wcd := wcd.(z := 103);\n    print wcd.y, \"\\n\"; // 12\n  }\n}\n\nmodule {:options \"/functionSyntax:4\"} WhiteBoxTests {\n  // The following code tests two conditions in the implementation.\n\n  // The following List does not support equality (because of the ghost parameter)\n  datatype List = Nil | Nilly(x: int) | Konstig(ghost head: int, tail: List)\n  type RestrictedList = xs: List | xs == Nilly(2) witness *\n\n  method M(xs: RestrictedList) returns (b: bool) {\n    // \"Resolver.CanCompareWith\" returns \"true\" for the LHS in the following comparison\n    // and returns \"false\" for the RHS. This shows that one needs to call \"Resolver.CanCompareWith\"\n    // on both operands. If either of them returns true, the comparison can be compiled.\n    // Additionally, since the type of \"xs\" is a subset type, this test makes sure that\n    // \"PartiallySupportsEquality\" understands subset types.\n    b := xs == Nilly(2);\n  }\n}\n\nmodule ConstraintsAreGhost {\n  // The constraint of a subset type is ghost. However, the Resolver calls CheckIsCompilable\n  // to determine if, perhaps, the constraint is compilable after all (because that enables\n  // the compiler to do some additional things). The .InCompiledContext fields should not be\n  // set when CheckIsCompilable is called in this mode, as is tested by the following declarations.\n\n  datatype A = ghost MakeA(x: int)\n  type B = a: A | a.x == 0 ghost witness MakeA(0)\n\n  datatype R = R(ghost x: int)\n  type S = r: R | r.x == 0 witness R(0)\n\n  datatype List = Nil | ghost Konstig(ghost head: int, tail: List)\n  type RestrictedList = xs: List | xs.Konstig? ghost witness Konstig(0, Nil)\n}\n\nmodule Arrays {\n  datatype MaybeInitialized<T> = ghost Uninitialized | Initialized(value: T)\n  datatype Singleton<X> = Single(X)\n\n  type Synonym = MaybeInitialized<Class>\n  class Class { }\n\n  method Test() {\n    M<bv5>();\n\n    var st := new Stack(5 as bv5);\n    st.U(6);\n    Print(st.arr, \" | \");\n    Print(st.trr, \" | \");\n    Print(st.brr, \"\\n\");\n  }\n\n  method M<T>() {\n    var arr := new MaybeInitialized<T>[20]; // no need to initialize the array at run time\n    var srr := new Singleton<MaybeInitialized<T>>[20]; // no need to initialize the array at run time\n    var yrr := new Synonym[20]; // no need to initialize the array at run time\n    var trr := new (ghost bool, ghost real, Singleton<MaybeInitialized<T>>, ghost int)[20]; // no need to initialize the array at run time\n    print arr.Length + srr.Length + yrr.Length + trr.Length, \"\\n\"; // 80\n  }\n\n  method Print<X>(x: array<X>, suffix: string) {\n    if x.Length != 0 {\n      print x[x.Length / 2], suffix;\n    }\n  }\n\n  class Stack<T> {\n    var arr: array<MaybeInitialized<T>>\n    var trr: array<T>\n    var brr: array<bool>\n    var arr2: array2<MaybeInitialized<T>>\n    var trr2: array2<T>\n    var brr2: array2<bool>\n\n    constructor (t: T)\n      ensures fresh(arr) && fresh(trr) && fresh(brr)\n    {\n      arr := new [20];\n      trr := new [20](_ => t);\n      brr := new [20];\n    }\n    method U(t: T)\n      modifies this, arr, trr, brr\n    {\n      arr := Update(arr, Initialized(t));\n      trr := Update(trr, t);\n      brr := Update(brr, true);\n    }\n  }\n\n  method Update<T>(a: array<T>, t: T) returns (r: array<T>)\n    modifies a\n  {\n    if a.Length != 0 {\n      a[a.Length / 2] := t;\n    }\n    r := a;\n  }\n}\n"}
{"file": "../dafny/Test/comp/Extern.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" %S/Extern2.cs >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:js \"%s\" %S/Extern3.js >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:go \"%s\" %S/Extern4.go >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:java \"%s\" %S/SingletonOptimization.java %S/LibClass.java %S/OtherClass.java %S/AllDafny.java %S/Mixed.java %S/AllExtern.java >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:py \"%s\" %S/Extern5.py >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"Hello\\n\";\n  var x, y := Library.LibClass.CallMeInt(30);\n  var z := Library.LibClass.CallMeNative(44, true);\n  var w := Library.LibClass.CallMeInAnotherClass();\n  print x, \" \", y, \" \", z, \" \", w, \"\\n\";\n\n  Library.AllDafny.M();\n  Library.Mixed.M();\n  print Library.Mixed.F(), \"\\n\";\n  var m := new Library.Mixed();\n  m.IM();\n  print m.IF(), \"\\n\";\n  Library.AllExtern.P();\n  assert Library.AllDafny.Seven() == Library.Mixed.Seven() == Library.AllExtern.Seven();\n  var maybeInt := Library.AllExtern.MaybeInt();\n  print maybeInt, \"\\n\";\n  var intPair := Library.AllExtern.IntPair();\n  print intPair, \"\\n\";\n\n  var singleton := Library.SingletonOptimization.SingletonTuple((ghost 10, 2));\n  assert singleton.0 == 3;\n  var noWrapper := Library.SingletonOptimization.NoWrapper(Library.ErasableWrapper(2));\n  assert noWrapper.x == 3;\n  var ghostWrapper := Library.SingletonOptimization.GhostWrapper(Library.Something(2));\n  assert ghostWrapper.x == 3;\n  print singleton.0, \" \", noWrapper.x, \" \", ghostWrapper.x, \"\\n\"; // 3 3 3\n}\n\nmodule Wrappers {\n  datatype Option<T> = Some(value: T) | None\n  datatype Pair<A, B> = Pair(first: A, second: B)\n}\n\nmodule {:extern \"Library\"} Library {\n  import opened Wrappers\n\n  newtype MyInt = x | -100 <= x < 0x8000_0000\n  \n  class {:extern \"LibClass\"} LibClass {\n    static method {:extern} CallMeInt(x: int) returns (y: int, z: int)\n    static method {:extern} CallMeNative(x: MyInt, b: bool) returns (y: MyInt)\n    static method {:extern \"Library.OtherClass\", \"CallMe\"} CallMeInAnotherClass() returns (w : object)\n  }\n\n  class {:extern} AllDafny {\n    static function Seven(): int { 7 }\n    static method M() { print \"AllDafny.M\\n\"; }\n  }\n  class {:extern} Mixed {\n    constructor() { }\n    static function Seven(): int { 7 }\n    static method M() { print \"Extern static method says: \"; P(); }\n    static method {:extern} P()\n    method IM() { print \"Extern instance method says: \"; IP(); }\n    method {:extern} IP()\n    static function F() : int { 1000 + G() }\n    static function {:extern} G() : int\n    function IF() : int { 2000 + IG() }\n    function {:extern} IG() : int\n  }\n  class {:extern} AllExtern {\n    static ghost function Seven(): int { 7 }\n    static method {:extern} P()\n    static function {:extern} MaybeInt(): Option<int>\n    static function {:extern} IntPair(): Pair<int, int>\n  }\n\n  datatype ErasableWrapper = ErasableWrapper(x: MyInt)\n\n  datatype Ghost<X> = ghost Uninitialized | Something(x: X)\n\n  class {:extern} SingletonOptimization {\n    // The in-parameter and out-parameter of these methods are optimized to just an \"MyInt\"\n    static method {:extern} SingletonTuple(a: (ghost MyInt, MyInt)) returns (b: (MyInt, ghost MyInt, ghost MyInt))\n      requires a.1 < 0x7fff_ffff\n      ensures b.0 == a.1 + 1\n    static method {:extern} NoWrapper(a: ErasableWrapper) returns (b: ErasableWrapper)\n      requires a.x < 0x7fff_ffff\n      ensures b.x == a.x + 1\n    static method {:extern} GhostWrapper(a: Ghost<MyInt>) returns (b: Ghost<MyInt>)\n      requires a.Something? && a.x < 0x7fff_ffff\n      ensures b.Something? && b.x == a.x + 1\n  }\n}\n"}
{"file": "../dafny/Test/comp/elseWithHavocStatement.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() {\n    var b: bool :| true; \n    var r: int;\n    if b {\n      r := 13;\n    } else {\n      r := *;\n    }\n    print r;\n}"}
{"file": "../dafny/Test/comp/manualcompile/ManualCompile.dfy", "dafny": "// NONUNIFORM: Highly target language specific\n\n// RUN: %baredafny translate cs %args --verbose --include-runtime \"%s\" > \"%t\"\n// RUN: dotnet build %S/ManualCompile.csproj\n// RUN: dotnet %S/bin/Debug/net6.0/ManualCompile.dll >> \"%t\"\n\n// RUN: %dafny /compileVerbose:1 /compile:0 /spillTargetCode:2 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: node %S/ManualCompile.js >> \"%t\"\n\n// RUN: %dafny /compileVerbose:1 /compile:0 /spillTargetCode:2 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: env GO111MODULE=auto GOPATH=%S/ManualCompile-go go run %S/ManualCompile-go/src/ManualCompile.go >> \"%t\"\n\n// RUN: %baredafny translate java %args --verbose --include-runtime \"%s\" >> \"%t\"\n// RUN: javac %S/ManualCompile-java/ManualCompile.java %S/ManualCompile-java/**/*.java\n// RUN: java -cp %S/ManualCompile-java ManualCompile >> \"%t\"\n\n// RUN: %dafny /compileVerbose:1 /compile:0 /unicodeChar:0 /spillTargetCode:2 /compileTarget:cpp \"%s\" >> \"%t\"\n// RUN: g++ -g -Wall -Wextra -Wpedantic -Wno-unused-variable -std=c++17 -I %binaryDir -o %S/ManualCompile.exe %S/ManualCompile.cpp\n// RUN: %S/ManualCompile.exe >> \"%t\"\n\n// RUN: %dafny /compileVerbose:1 /compile:0 /spillTargetCode:2 /compileTarget:py \"%s\" >> \"%t\"\n// RUN: python3 %S/ManualCompile-py >> \"%t\"\n\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"hello, Dafny\\n\";\n}\n"}
{"file": "../dafny/Test/comp/DowncastClone.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\ndatatype Co<+T> = Co(T) | C\ndatatype ReCo<+T> = ReCo(T)\ndatatype Contra<-T> = Contra(f: T -> bool) | C\ndatatype ReContra<-T> = ReContra(f: T -> bool)\n\ntrait X {}\n\nclass Y extends X {\n  constructor () {}\n}\n\nclass ClassWithFields {\n  var y: ReCo<Y>\n  constructor (y: ReCo<Y>) {\n    this.y := y;\n  }\n}\n\nmethod DowncastCo() {\n  var i := new Y();\n  var a: Co<X> := Co(i);\n  var b: Co<Y>;\n  b := a;\n  print a, \" and \", b, \"\\n\";\n}\n\nmethod DowncastReCo() {\n  var i := new Y();\n  var a: ReCo<X> := ReCo(i);\n  var b: ReCo<Y>;\n  b := a;\n  print a, \" and \", b, \"\\n\";\n\n  var s := new ClassWithFields(a);\n  print s.y, \" \"; \n  s.y := a;\n  print s.y, \"\\n\";\n}\n\nmethod DowncastContra() {\n  var y := new Y();\n  var i: Contra<X> := Contra(_ => false);\n  var a: Contra<Y> := i;\n  var b: Contra<X>;\n  b := a;\n  print a.f(y), \" and \", b.f(y), \"\\n\";\n}\n\nmethod DowncastReContra() {\n  var y := new Y();\n  var i: ReContra<X> := ReContra(_ => false);\n  var a: ReContra<Y> := i;\n  var b: ReContra<X>;\n  b := a;\n  print a.f(y), \" and \", b.f(y), \"\\n\";\n}\n\nmethod DowncastFunc() {\n  var i := new Y();\n  var a: bool -> X := (_ => i);\n  var b: bool -> Y;\n  b := a;\n  print a(false), \" and \", b(false), \"\\n\";\n}\n\nmethod Main(){\n  DowncastCo();\n  DowncastReCo();\n  DowncastContra();\n  DowncastReContra();\n  DowncastFunc();\n  print \"Done\\n\";\n}\n"}
{"file": "../dafny/Test/comp/TupleMaximumSize.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() {\n  var a := (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21);\n  print a, \"\\n\";\n}"}
{"file": "../dafny/Test/comp/DefaultParameters-Compile.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation\n\nmethod M(x: int := 16) {\n  print x, \"\\n\";\n}\n\nclass C {\n  var data: int\n  method M(x: int := data, y: int := x + 2) {\n    print x, \" \", y, \"\\n\";\n  }\n}\n\ndatatype Color = Blue(x: int, y: int := x - 1) | Red(x: int, y: int := x + 1)\n\nmethod Main() {\n  M(12);\n  M();\n  var c := new C;\n  c.data := 10;\n  c.M(1, 2); // 1 2\n  c.M(1); // 1 3\n  c.M(y := 20); // 10 20\n  c.data := 11;\n  c.M(); // 11 13\n  var c0, c1 := Blue(2), Red(3);\n  print c0, \" \", c1, \"\\n\"; // Blue(2, 1) Red(3, 4)\n  FF(); // 5 5 6\n  GG(); // 6 6 7\n}\n\nfunction F(x: int := 5): int { x }\n\nmethod FF(w: int := x, x: int := F(), y: int := w + 1) {\n  print w, \" \", x, \" \", y, \"\\n\";\n}\n\nmethod GG(w: int := x, x: int := G(), y: int := w + 1) {\n  print w, \" \", x, \" \", y, \"\\n\";\n}\n\nfunction G(x: int := 6): int { x }\n\n"}
{"file": "../dafny/Test/comp/firstSteps/5_Calls-FunctionsValues-Dt.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n//\n// This fragment of comp/Calls.dfy serves to facilitate incremental compiler development.\n\nmodule FunctionValues {\n  method Test() {\n    var color := Red;\n    ApplyAndPrint(color.F);\n    ApplyAndPrint(color.G);\n    print \"\\n\";\n    // test variable capture\n    var x2, x3 := color.F, color.G;\n    color := Blue;\n    print x2(), \" \", x3(), \"\\n\";\n  }\n\n  method ApplyAndPrint(f: () -> int) {\n    print f(), \" \";\n  }\n\n  datatype Color = Red | Green | Blue {\n    function F(): int { if this == Red then 5 else 2 }\n    static function G(): int { 3 }\n  }\n}\n\nmethod Main()\n{\n  FunctionValues.Test();\n}\n"}
{"file": "../dafny/Test/comp/firstSteps/4_Calls-FunctionsValues-Class+NT.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n//\n// This fragment of comp/Calls.dfy serves to facilitate incremental compiler development.\n\nmodule FunctionValues {\n  method Test() {\n    var c := new Class(5);\n    var nt: NT := 5;\n    ApplyAndPrint(c.F);\n    ApplyAndPrint(c.G);\n    ApplyAndPrint(nt.F);\n    ApplyAndPrint(nt.G);\n    print \"\\n\";\n    // test variable capture\n    var x0, x1, x4, x5 := c.F, c.G, nt.F, nt.G;\n    c := new Class(2);\n    nt := 2;\n    print x0(), \" \", x1(), \" \", x4(), \" \", x5(), \"\\n\";\n  }\n\n  method ApplyAndPrint(f: () -> int) {\n    print f(), \" \";\n  }\n\n  class Class {\n    const x: int\n    constructor (x: int) { this.x := x; }\n    function F(): int { x }\n    static function G(): int { 3 }\n  }\n\n  newtype NT = x | 0 <= x < 15 {\n    function F(): int { this as int }\n    static function G(): int { 3 }\n  }\n}\n\nmethod Main()\n{\n  FunctionValues.Test();\n}\n"}
{"file": "../dafny/Test/comp/firstSteps/7_Arrays.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n//\n// This fragment of comp/Arrays.dfy serves to facilitate incremental compiler development.\n\nmethod LinearSearch(a: array<int>, key: int) returns (n: nat)\n  ensures 0 <= n <= a.Length\n  ensures n == a.Length || a[n] == key\n{\n  n := 0;\n  while n < a.Length\n    invariant n <= a.Length \n  {\n    if a[n] == key {\n      return;\n    }\n    n := n + 1;\n  }\n}\n\nmethod PrintArray<A>(a: array?<A>) {\n  if (a == null) {\n    print \"It's null\\n\";\n  } else {\n    var i := 0;\n    while i < a.Length {\n      print a[i], \" \";\n      i := i + 1;\n    }\n    print \"\\n\";\n  }\n}\n\nmethod Main() {\n  var a := new int[23];\n  var i := 0;\n  while i < 23 {\n    a[i] := i;\n    i := i + 1;\n  }\n  PrintArray(a);\n  var n := LinearSearch(a, 17);\n  print n, \"\\n\";\n  var s : seq<int> := a[..];\n  print s, \"\\n\";\n  s := a[2..16];\n  print s, \"\\n\";\n  s := a[20..];\n  print s, \"\\n\";\n  s := a[..8];\n  print s, \"\\n\";\n    \n  // Conversion to sequence should copy elements (sequences are immutable!)\n  a[0] := 42;\n  print s, \"\\n\";\n  MultipleDimensions();\n}\n     \nmethod PrintMatrix<A>(m: array2<A>) {\n  var i := 0;\n  while i < m.Length0 {\n    var j := 0;\n    while j < m.Length1 {\n      print m[i,j], \" \";\n      j := j + 1;\n    }\n   print \"\\n\";\n   i := i + 1;\n  }\n}\n   \nmethod MultipleDimensions() {\n  var matrix := new int[2,8];\n  PrintMatrix(matrix);\n  var jagged := new array<int>[5];\n  var i := 0;\n  while i < 5 {\n    jagged[i] := new int[i];\n    i := i + 1;\n  }\n  PrintArrayArray(jagged);\n}\n   \nmethod PrintArrayArray<A>(a: array<array<A>>) {\n  var i := 0;\n  while i < a.Length {\n    print a[i][..], \" \";\n    i := i + 1;\n  }\n  print \"\\n\";\n}\n"}
{"file": "../dafny/Test/comp/firstSteps/1_Calls-F.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n//\n// This fragment of comp/Calls.dfy serves to facilitate incremental compiler development.\n\nfunction F(x: int, y: bool): int {\n  x + if y then 2 else 3\n}\n\nmethod Main() {\n  var w;\n  w := F(2, false);\n  print w, \"\\n\";\n}\n"}
{"file": "../dafny/Test/comp/firstSteps/2_Modules.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmodule A {\n  const i: nat := 1\n\n  class X {}\n}\n\nmodule B {\n  const i: nat := 2\n\n  module X {\n    const i: nat := 3\n  }\n}\n\nmethod Main(){\n  print A.i, \" \", B.i, \" \", B.X.i, \"\\n\";\n}\n"}
{"file": "../dafny/Test/comp/firstSteps/0_IKnowThisMuchIs.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n//\n// An extremely small program intended to be the first target input for\n// brand new Dafny compilers. Avoids any use of strings (and therefore sequences)\n// but requires representing booleans at runtime and the bare minimum support for\n// the print statement.\n//\n// This program also serves the purpose of ensuring that new compiler authors\n// immediately have Spandau Ballet stuck in their head. :)\n\nmethod Main() {\n  print true;\n}\n"}
{"file": "../dafny/Test/comp/firstSteps/7_Dt_Algebraic.dfy", "dafny": "// NONUNIFORM: https://github.com/dafny-lang/dafny/issues/4108\n// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n//\n// This fragment of comp/Dt.dfy serves to facilitate incremental compiler development.\n\ndatatype List = Nil | Cons(head: int, tail: List)\n\nmethod Main() {\n  var a := Nil;\n  var b := Cons(5, a);\n  var c := (a, b);\n  var d := (c.1, c.0);\n  var e := ();\n  print a, \"\\n\";\n  print b, \"\\n\";\n  print c, \"\\n\";\n  print d, \"\\n\";\n  print e, \"\\n\";\n\n  print b.head, \" \", b.tail, \"\\n\";\n\n  var u := Up(0, 7);\n  print u, \"\\n\";\n  var s := Sum(u);\n  PrintSum(u, \"\");\n  print \" == \", s;\n  s := SumAgain(u);\n  print \" (once more, that's \", s, \")\\n\";\n\n  AllBerry();\n  TestConflictingNames();\n  TestModule();\n}\n\nfunction Up(m: nat, n: nat): List\n  requires m <= n\n  decreases n - m\n{\n  if m == n then Nil else Cons(m, Up(m+1, n))\n}\n\nfunction Sum(xs: List): int {\n  match xs  // top-level match expression\n  case Nil => 0\n  case Cons(x, tail) => x + Sum(tail)\n}\n\nfunction SumAgain(xs: List): int {\n  var r := match xs  // let expression; non-top-level match expression\n    case Nil => 0\n    case Cons(x, tail) => x + SumAgain(tail);\n  r\n}\n\nmethod PrintSum(xs: List, prefix: string) {\n  match xs  // match statement\n  case Nil =>\n  case Cons(x, tail) =>\n    print prefix, x;\n    PrintSum(tail, \" + \");  // tail recursion\n}\n\ndatatype Berry = Smultron | Jordgubb | Hjortron | Hallon\npredicate IsRed(b: Berry) {\n  b != Berry.Hjortron\n}\n\nmethod AllBerry() {\n  var s := set b: Berry | IsRed(b);\n  print s, \"\\n\";\n}\n\ndatatype ConflictingNames = ConflictingNames1(len: int, public: char, goto: string) | ConflictingNames2(goto: string)\n\nmethod TestConflictingNames() {\n  var x := ConflictingNames1(42, 'q', \"hello\");\n  print x.len, \" \", x.public, \" \", x.goto, \"\\n\";\n}\n\nmodule ModuleM {\n  datatype OptionInt = Some(int) | None\n}\n\nmethod TestModule() {\n  PrintMaybe(ModuleM.Some(1701));\n}\n\nmethod PrintMaybe(x: ModuleM.OptionInt) {\n  match x\n  case Some(n) => print n, \"\\n\";\n  case None => print \"None\\n\";\n}\n"}
{"file": "../dafny/Test/comp/compile3/JustRun.dfy", "dafny": "// NONUNIFORM: /compileVerbose:1 output is backend sensitive\n// (although the second set of comamnds could be separated out)\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:cs /compile:3 \"%s\" > \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:js /compile:3 \"%s\" >> \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:go /compile:3 \"%s\" >> \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:java /compile:3 \"%s\" >> \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:cpp /compile:3 \"%s\" >> \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileVerbose:1 /compileTarget:py /compile:3 \"%s\" >> \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileTarget:cs /compile:3 \"%s\" >> \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileTarget:js /compile:3 \"%s\" >> \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileTarget:go /compile:3 \"%s\" >> \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileTarget:java /compile:3 \"%s\" >> \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileTarget:cpp /compile:3 \"%s\" >> \"%t\"\n// RUN: %dafny /unicodeChar:0 /compileTarget:py /compile:3 \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"hello, Dafny\\n\";\n}\n"}
{"file": "../dafny/Test/HigherOrderIntrinsicSpecification/ReadPreconditionBypass1.dfy", "dafny": "// RUN: %exits-with 4 %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Ref {\n  var inner: Ref\n  constructor()\n}\n\nfunction myf(o: Ref): ()\n  requires false\n  reads o.inner\n{\n  ()\n}\n\nmethod Main()\n  ensures false\n{\n  var outer := new Ref();\n\n  var inner1 := new Ref();\n  outer.inner := inner1;\n  var reads1 := myf.reads(outer);  // Error: function precondition could not be proved\n  assert reads1 == {inner1};\n\n  var inner2 := new Ref();\n  outer.inner := inner2;\n  var reads2 := myf.reads(outer);\n  assert reads2 == {inner2};\n}"}
{"file": "../dafny/Test/HigherOrderIntrinsicSpecification/ReadPreconditionBypass2.dfy", "dafny": "// RUN: %exits-with 4 %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Ref {\n  var inner: Ref\n  constructor()\n}\n\nfunction myf(o: Ref): ()\n  requires false\n  reads o.inner\n{\n  ()\n}\n\nmethod Main()\n  ensures false\n{\n  var outer := new Ref();\n\n  var hof := myf.reads;\n\n  var inner1 := new Ref();\n  outer.inner := inner1;\n  var reads1 := hof(outer); // Error: function precondition could not be proved\n  assert reads1 == {inner1};\n\n  var inner2 := new Ref();\n  outer.inner := inner2;\n  var reads2 := hof(outer);\n  assert reads2 == {inner2};\n}"}
{"file": "../dafny/Test/HigherOrderIntrinsicSpecification/ReadPreconditionBypass3.dfy", "dafny": "// RUN: %exits-with 4 %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Ref {\n  var inner: Ref\n  constructor()\n}\n\nfunction myf(o: Ref): ()\n  requires false\n  reads o.inner\n{\n  ()\n}\n\nmethod Main()\n  ensures false\n{\n  var outer := new Ref();\n\n  var myg := myf.requires;\n\n  var inner1 := new Ref();\n  outer.inner := inner1;\n  var reads1 := myg.reads(outer);\n  assert reads1 == {inner1}; // Error: assertion might not hold\n\n  var inner2 := new Ref();\n  outer.inner := inner2;\n  var reads2 := myg.reads(outer);\n  assert reads2 == {inner2}; // Error: assertion might not hold\n}"}
{"file": "../dafny/Test/HigherOrderIntrinsicSpecification/ReadPreconditionBypass4.dfy", "dafny": "// RUN: %exits-with 4 %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Ref {\n  var inner: Ref\n  constructor()\n}\n\nfunction myf(o: Ref): ()\n  requires false\n  reads o.inner\n{\n  ()\n}\n\nmethod Main()\n  ensures false\n{\n  var outer := new Ref();\n\n  var myg := myf.requires;\n  var myh := myg.requires;\n\n  var inner1 := new Ref();\n  outer.inner := inner1;\n  var reads1 := myh.reads(outer);\n  assert reads1 == {inner1}; // Error: assertion might not hold\n\n  var inner2 := new Ref();\n  outer.inner := inner2;\n  var reads2 := myh.reads(outer);\n  assert reads2 == {inner2}; // Error: assertion might not hold\n}"}
{"file": "../dafny/Test/cli/help.dfy", "dafny": "// RUN: %baredafny verify --help-internal > \"%t\"\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK: --rprint <file>\n"}
{"file": "../dafny/Test/cli/projectFile/projectFile.dfy", "dafny": "// A project file can specify input files and configure options\n// RUN: %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/dfyconfig.toml\" > \"%t\"\n\n// Test using a URL instead of a local file as a project file\n// RUN: ! %baredafny resolve --show-snippets:false --use-basename-for-filename \"https://github.com/dafny-lang/dafny/blob/master/dfyconfig.toml\"\n\n// Test option override behavior\n// RUN: %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/dfyconfig.toml\" --warn-shadowing=false >> \"%t\"\n\n// Test option with default override behavior\n// RUN: ! %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/dfyconfig.toml\" --function-syntax=3 >> \"%t\"\n\n// Multiple project files are not allowed\n// RUN: ! %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/dfyconfig.toml\" \"%S/broken/dfyconfig.toml\"\n\n// Project files may not contain unknown properties\n// RUN: ! %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/broken/dfyconfig.toml\"\n\n// Warn if file contains options that don't exist\n// RUN: %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/broken/invalidOption.toml\" >> \"%t\"\n\n// Project files must be files on disk.\n// RUN: ! %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/doesNotExist/dfyconfig.toml\"\n\n// Project file options must have the right type\n// RUN: ! %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/badTypes/dfyconfig.toml\" 2>> \"%t\"\n\n// A project file without includes will take all .dfy files as input\n// RUN: %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/noIncludes/dfyconfig.toml\" >> \"%t\"\n\n// Files included by the project file and on the CLI, duplicate is ignored.\n// RUN: %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/dfyconfig.toml\" \"%S/src/input.dfy\" >> \"%t\"\n\n// Files excluded by the project file and included on the CLI, are included\n// RUN: ! %baredafny resolve --show-snippets:false --use-basename-for-filename \"%S/dfyconfig.toml\" \"%S/src/excluded.dfy\" >> \"%t\"\n\n// RUN: %diff \"%s.expect\" \"%t\"\n"}
{"file": "../dafny/Test/cli/projectFile/src/excluded.dfy", "dafny": "// RUN: echo \"\"\n\nmethod Foo() {\n  var z := 3;\n  if (true) {\n    var z := 4;\n  }\n}"}
{"file": "../dafny/Test/cli/projectFile/src/input.dfy", "dafny": "// RUN: echo \"\"\n\nmethod Foo() {\n  var x := 3;\n  if (true) {\n    var x := 4;\n  }\n}\n\nghost function Bar(): int {\n  3\n} "}
{"file": "../dafny/Test/cli/projectFile/notInput.dfy", "dafny": "// RUN: echo \"\"\n\nmethod Foo() {\n  var y := 3;\n  if (true) {\n    var y := 4;\n  }\n}"}
{"file": "../dafny/Test/cli/projectFile/noIncludes/src/input.dfy", "dafny": "// RUN: echo \"\"\n\nmethod Foo() {\n  var x := 3;\n  if (true) {\n    var x := 4;\n  }\n}"}
{"file": "../dafny/Test/cli/projectFile/noIncludes/src/moreNested/moreInput.dfy", "dafny": "// RUN: echo \"\"\n\nmethod Bar() {\n  var x := 3;\n  if (true) {\n    var x := 4;\n  }\n}"}
{"file": "../dafny/Test/cli/projectFile/noOptions/input.dfy", "dafny": "// RUN: %baredafny resolve --use-basename-for-filename \"%S/dfyconfig.toml\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule NoOptions {\n  method Main() {\n    print \"Hello, world!\\n\";\n  }\n}"}
{"file": "../dafny/Test/cli/projectFile/libraries/wrappersLib.dfy", "dafny": "// RUN: echo \"\"\n\nmodule Wrappers {\n  datatype Option<+T> = Some(value: T) | None\n}"}
{"file": "../dafny/Test/cli/projectFile/badTypes/badTypes.dfy", "dafny": "// RUN: echo \"\"\n\nmethod Foo() {\n  var x := 3;\n  if (true) {\n    var x := 4;\n  }\n}"}
{"file": "../dafny/Test/cli/multipleBoogieArguments.dfy", "dafny": "// RUN: %baredafny verify --boogie \"/randomSeedIterations:0\" --boogie \"/vcsLoad:2\" %s 2> %t\n// RUN: %baredafny verify --boogie \"/vcsLoad:2 /randomSeedIterations:0\" %s 2>> %t\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction id(x:int) : (r:int) { x }"}
{"file": "../dafny/Test/cli/badArguments.dfy", "dafny": "// RUN: %baredafny resolve \"\" \"%s\" > \"%t\"\n// RUN: %baredafny resolve '' \"%s\" >> \"%t\"\n// RUN: %baredafny verify --boogie '' \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Foo() {}\n"}
{"file": "../dafny/Test/cli/proverPath.dfy", "dafny": "// RUN: %baredafny verify %args --solver-path=\"%z3\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// UNSUPPORTED: windows\nmethod m() {\n  assert 1 + 1 == 2;\n}\n"}
{"file": "../dafny/Test/cli/solverLog.dfy", "dafny": "// RUN: %baredafny verify %args --solver-log=\"log.smt2\" --resource-limit 10 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// RUN: %OutputCheck --file-to-check \"log.smt2\" \"%s\"\n// CHECK: rlimit 10000\nmethod m() {\n  assert 1 + 1 == 2;\n}\n"}
{"file": "../dafny/Test/cli/badProverPath.dfy", "dafny": "// RUN: %exits-with 4 %baredafny verify %args --solver-path=doesNotExist \"%s\" > \"%t\"\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK: Fatal Error: ProverException: Cannot find specified prover:.*\nmethod m() {\n  assert 1 + 1 == 2;\n}\n"}
{"file": "../dafny/Test/DafnyTests/zeroExitCodeTests.dfy", "dafny": "// RUN: %baredafny test %args \"%s\" >> \"%t\"\nmethod {:test} Passing1() {\n  expect 2 == 2;\n}\n"}
{"file": "../dafny/Test/VSI-Benchmarks/b1.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Spec# and Boogie and Chalice:  The program will be\n// the same, except that these languages do not check\n// for any kind of termination.  Also, in Spec#, there\n// is an issue of potential overflows.\n\n// Benchmark1\n\nmethod Add(x: int, y: int) returns (r: int)\n  ensures r == x+y\n{\n  r := x;\n  if (y < 0) {\n    var n := y;\n    while (n != 0)\n      invariant r == x+y-n && 0 <= -n\n    {\n      r := r - 1;\n      n := n + 1;\n    }\n  } else {\n    var n := y;\n    while (n != 0)\n      invariant r == x+y-n && 0 <= n\n    {\n      r := r + 1;\n      n := n - 1;\n    }\n  }\n}\n\nmethod Mul(x: int, y: int) returns (r: int)\n  ensures r == x*y\n  decreases x < 0, x\n{\n  if (x == 0) {\n    r := 0;\n  } else if (x < 0) {\n    r := Mul(-x, y);\n    r := -r;\n  } else {\n    r := Mul(x-1, y);\n    r := Add(r, y);\n  }\n}\n\n// ---------------------------\n\nmethod Main() {\n  TestAdd(3, 180);\n  TestAdd(3, -180);\n  TestAdd(0, 1);\n\n  TestMul(3, 180);\n  TestMul(3, -180);\n  TestMul(180, 3);\n  TestMul(-180, 3);\n  TestMul(0, 1);\n  TestMul(1, 0);\n}\n\nmethod TestAdd(x: int, y: int) {\n  print x, \" + \", y, \" = \";\n  var z := Add(x, y);\n  print z, \"\\n\";\n}\n\nmethod TestMul(x: int, y: int) {\n  print x, \" * \", y, \" = \";\n  var z := Mul(x, y);\n  print z, \"\\n\";\n}\n"}
{"file": "../dafny/Test/VSI-Benchmarks/b6.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Collection<T> {\n  ghost var footprint:set<object>\n  var elements:seq<T>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint\n  }\n\n  method GetCount() returns (c:nat)\n    requires Valid()\n  {\n    c:=|elements|;\n  }\n\n  method Init()\n    modifies this\n    ensures Valid() && fresh(footprint - {this})\n  {\n    elements := [];\n    footprint := {this};\n  }\n\n  method GetItem(i:int) returns (x:T)\n    requires Valid()\n    requires 0 <= i < |elements|\n    ensures elements[i] == x\n  {\n    x:=elements[i];\n  }\n\n  method Add(x:T)\n    requires Valid()\n    modifies footprint\n    ensures Valid() && fresh(footprint - old(footprint))\n    ensures elements == old(elements) + [x]\n  {\n    elements:= elements + [x];\n  }\n\n  method GetIterator() returns (iter:Iterator<T>)\n    requires Valid()\n    ensures iter.Valid()\n    ensures fresh(iter.footprint) && iter.pos == -1\n    ensures iter.c == this\n  {\n    iter:= new Iterator<T>.Init(this);\n  }\n\n}\n\nclass Iterator<T> {\n\n  var c:Collection<T>\n  var pos:int\n\n  ghost var footprint:set<object>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint && -1 <= pos\n  }\n\n  constructor Init(coll:Collection<T>)\n    ensures Valid() && fresh(footprint - {this}) && pos == -1\n    ensures c == coll\n  {\n    c := coll;\n    pos := -1;\n    footprint := {this};\n  }\n\n  method MoveNext() returns (b:bool)\n    requires Valid()\n    modifies footprint\n    ensures fresh(footprint - old(footprint)) && Valid() && pos == old(pos) + 1\n    ensures b == HasCurrent() && c == old(c)\n  {\n    pos := pos+1;\n    b := pos < |c.elements|;\n  }\n\n  ghost predicate HasCurrent()\n    requires Valid()\n    reads this, c, footprint\n  {\n    0 <= pos && pos < |c.elements|\n  }\n\n  method GetCurrent() returns (x:T)\n    requires Valid() && HasCurrent()\n    ensures c.elements[pos] == x\n  {\n    x := c.elements[pos];\n  }\n}\n\nclass Client\n{\n  method Main()\n  {\n    var c := new Collection<int>.Init();\n    c.Add(33);\n    c.Add(45);\n    c.Add(78);\n\n    var s := [];\n\n    var iter := c.GetIterator();\n    var b := iter.MoveNext();\n\n    while (b)\n      invariant iter.Valid() && b == iter.HasCurrent() && fresh(iter.footprint)\n      invariant c.Valid() && fresh(c.footprint) && iter.footprint !! c.footprint //disjoint footprints\n      invariant 0 <= iter.pos && iter.pos <= |c.elements| && s == c.elements[..iter.pos]\n      invariant iter.c == c\n      decreases |c.elements| - iter.pos\n    {\n      var x := iter.GetCurrent();\n      s := s + [x];\n      b := iter.MoveNext();\n    }\n\n    assert s == c.elements; //verifies that the iterator returns the correct things\n    c.Add(100);\n  }\n\n}\n"}
{"file": "../dafny/Test/VSI-Benchmarks/b3.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Note:  We used integers instead of a generic Comparable type, because\n// Dafny has no way of saying that the Comparable type's AtMost function\n// is total and transitive.\n\n// Note:  We couldn't get things to work out if we used the Get method.\n// Instead, we used .contents.\n\n// Note:  Due to infelicities of the Dafny sequence treatment, we\n// needed to supply two lemmas, do a complicated assignment of\n// pperm, had to write invariants over p and perm rather than pperm and we couldn't use\n// \"x in p\".\n\nclass Queue<T> {\n  var contents: seq<T>;\n  method Init()\n    modifies this;\n    ensures |contents| == 0;\n  method Enqueue(x: T)\n    modifies this;\n    ensures contents == old(contents) + [x];\n  method Dequeue() returns (x: T)\n    requires 0 < |contents|;\n    modifies this;\n    ensures contents == old(contents)[1..] && x == old(contents)[0];\n  function Head(): T\n    requires 0 < |contents|;\n    reads this;\n  { contents[0] }\n  function Get(i: int): T\n    requires 0 <= i < |contents|;\n    reads this;\n  { contents[i] }\n}\n\nclass Comparable {\n  ghost function AtMost(c: Comparable): bool\n    reads this, c;\n}\n\n\nclass Benchmark3 {\n  method Sort(q: Queue<int>) returns (r: Queue<int>)\n    modifies q;\n    ensures fresh(r);\n    ensures |r.contents| == |old(q.contents)|;\n    ensures forall i, j :: 0 <= i < j < |r.contents| ==> r.Get(i) <= r.Get(j);\n    // the final Queue is a permutation of the input Queue\n    ensures multiset(r.contents) == multiset(old(q.contents));\n  {\n    r := new Queue<int>.Init();\n    while |q.contents| != 0\n      invariant |r.contents| + |q.contents| == |old(q.contents)|;\n      invariant forall i, j :: 0 <= i < j < |r.contents| ==> r.contents[i] <= r.contents[j];\n      invariant forall i, j ::\n                    0 <= i < |r.contents| &&\n                    0 <= j < |q.contents|\n                    ==> r.contents[i] <= q.contents[j];\n      // the current array is that permutation of the input array\n      invariant multiset(r.contents + q.contents) == multiset(old(q.contents));\n    {\n      ghost var qc := q.contents;\n      var m,k := RemoveMin(q);\n      assert qc == qc[..k] + [m] + qc[k+1..];\n      r.Enqueue(m);\n    }\n  }\n\n  method RemoveMin(q: Queue<int>) returns (m: int, k: int) //m is the min, k is m's index in q\n    requires |q.contents| != 0;\n    modifies q;\n    ensures |old(q.contents)| == |q.contents| + 1;\n    ensures 0 <= k < |old(q.contents)| && old(q.contents[k]) == m;\n    ensures forall i :: 0 <= i < |q.contents| ==> m <= q.contents[i];\n    ensures q.contents == old(q.contents)[k+1..] + old(q.contents)[..k];\n  {\n    var n := |q.contents|;\n    k := 0;\n    m := q.Head();\n    var j := 0;\n    while j < n\n      invariant j <= n;\n      invariant 0 <= k < n && old(q.contents)[k] == m;\n      invariant q.contents == old(q.contents)[j..] + old(q.contents)[..j]; //i.e. rotated\n      invariant forall i :: 0 <= i < j ==> m <= old(q.contents)[i]; //m is min so far\n    {\n      ghost var qc0 := q.contents;\n      var x := q.Dequeue();\n      q.Enqueue(x);\n      RotationLemma(old(q.contents), j, qc0, q.contents);\n      if x < m { k := j; m := x; }\n      j := j+1;\n    }\n\n    Rotate(q, k);\n\n    assert q.contents == old(q.contents)[k..] + old(q.contents)[..k];\n    ghost var qq := q.contents;\n    m := q.Dequeue();\n    assert m == qq[0];\n    assert [m] + q.contents == qq && q.contents == qq[1..];\n  }\n\n  method Rotate(q: Queue<int>, k: nat)\n    requires k <= |q.contents|\n    modifies q\n    ensures q.contents == old(q.contents)[k..] + old(q.contents)[..k]\n  {\n    var j := 0;\n    while j < k\n      invariant j <= k;\n      invariant q.contents == old(q.contents)[j..] + old(q.contents)[..j];\n    {\n      ghost var qc0 := q.contents;\n      var x := q.Dequeue();\n      q.Enqueue(x);\n      RotationLemma(old(q.contents), j, qc0, q.contents);\n      j := j+1;\n    }\n    assert j == k;\n  }\n\n  lemma RotationLemma(O: seq, j: nat, A: seq, C: seq)\n    requires j < |O|;\n    requires A == O[j..] + O[..j];\n    requires C == A[1..] + [O[j]];\n    ensures C == O[j+1..] + O[..j+1];\n  {\n    calc {\n      A;\n      O[j..] + O[..j];\n      O[j..j+1] + O[j+1..] + O[..j];\n      O[j..j+1] + (O[j+1..] + O[..j]);\n    }\n    calc {\n      C;\n      A[1..] + [A[0]];\n      { assert A[0] == O[j] && A[1..] == O[j+1..] + O[..j]; }\n      O[j+1..] + O[..j] + [O[j]];\n      { assert [O[j]] == O[j..j+1]; }\n      O[j+1..] + O[..j] + O[j..j+1];\n      O[j+1..] + (O[..j] + O[j..j+1]);\n      { assert O[..j] + O[j..j+1] == O[..j+1]; }\n      O[j+1..] + O[..j+1];\n    }\n  }\n}\n"}
{"file": "../dafny/Test/VSI-Benchmarks/b7.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Edited B6 to include GetChar and PutChar\n\n//This is the Queue from Benchmark 3.\n\n//restriction:we assume streams are finite\n//what else can we specify?\n\n\nclass Queue<T> {\n  var contents: seq<T>;\n  method Init()\n    modifies this;\n    ensures |contents| == 0;\n  method Enqueue(x: T)\n    modifies this;\n    ensures contents == old(contents) + [x];\n  method Dequeue() returns (x: T)\n    requires 0 < |contents|;\n    modifies this;\n    ensures contents == old(contents)[1..] && x == old(contents)[0];\n  ghost function Head(): T\n    requires 0 < |contents|;\n    reads this;\n  { contents[0] }\n  ghost function Get(i: int): T\n    requires 0 <= i < |contents|;\n    reads this;\n  { contents[i] }\n}\n\nclass Stream {\n  ghost var footprint:set<object>;\n  var stream:seq<int>;\n  var isOpen:bool;\n\n  ghost function Valid():bool\n    reads this, footprint;\n  {\n    this in footprint && isOpen\n  }\n\n  method GetCount() returns (c:int)\n    requires Valid();\n    ensures 0 <= c;\n  {\n    c := |stream|;\n  }\n\n  method Create() //writing\n    modifies this;\n    ensures Valid() && fresh(footprint - {this});\n    ensures stream == [];\n  {\n    stream := [];\n    footprint := {this};\n    isOpen := true;\n  }\n\n  method Open() //reading\n    modifies this;\n    ensures Valid() && fresh(footprint - {this});\n  {\n    footprint := {this};\n    isOpen := true;\n  }\n\n  method PutChar(x:int )\n    requires Valid();\n    modifies footprint;\n    ensures Valid() && fresh(footprint - old(footprint));\n    ensures stream == old(stream) + [x];\n  {\n    stream:= stream + [x];\n  }\n\n  method GetChar()returns(x:int)\n    requires Valid() && 0 < |stream|;\n    modifies footprint;\n    ensures Valid() && fresh(footprint - old(footprint));\n    ensures x ==old(stream)[0];\n    ensures stream == old(stream)[1..];\n  {\n    x := stream[0];\n    stream := stream[1..];\n  }\n\n  method AtEndOfStream() returns(eos:bool)\n    requires Valid();\n    ensures eos  <==> |stream| == 0;\n  {\n    eos := |stream| == 0;\n  }\n\n  method Close()\n    requires Valid();\n    modifies footprint;\n  {\n    isOpen := false;\n  }\n}\n\n\nclass Client {\n  method Sort(q: Queue<int>) returns (r: Queue<int>)\n    modifies q;\n    ensures fresh(r);\n    ensures |r.contents| == |old(q.contents)|;\n    ensures forall i, j :: 0 <= i < j < |r.contents| ==> r.Get(i) <= r.Get(j);\n    // the final Queue is a permutation of the input Queue\n    ensures multiset(r.contents) == multiset(old(q.contents));\n\n  method Main()\n  {\n    var rd := new Stream;\n    rd.Open();\n\n    var q := new Queue<int>;\n    while (true)\n      invariant rd.Valid() && fresh(rd.footprint) && fresh(q);\n      decreases |rd.stream|;\n    {\n      var eos := rd.AtEndOfStream();\n      if (eos) {\n        break;\n      }\n\n      var ch := rd.GetChar();\n      q.Enqueue(ch);\n    }\n\n    rd.Close();\n    q := Sort(q);\n\n    var wr := new Stream;\n    wr.Create();\n    while (0 < |q.contents|)\n      invariant wr.Valid() && fresh(wr.footprint) && fresh(q) && q !in wr.footprint;\n    {\n      var ch := q.Dequeue();\n      wr.PutChar(ch);\n    }\n    wr.Close();\n  }\n}\n"}
{"file": "../dafny/Test/VSI-Benchmarks/b2.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Benchmark2 {\n  method BinarySearch(a: array<int>, key: int) returns (result: int)\n    requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures -1 <= result < a.Length\n    ensures 0 <= result ==> a[result] == key\n    ensures result == -1 ==> forall i :: 0 <= i < a.Length ==> a[i] != key\n  {\n    var low := 0;\n    var high := a.Length;\n\n    while (low < high)\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i :: 0 <= i < low ==> a[i] < key\n      invariant forall i :: high <= i < a.Length ==> key < a[i]\n    {\n      var mid := low + (high - low) / 2;\n      var midVal := a[mid];\n\n      if (midVal < key) {\n        low := mid + 1;\n      } else if (key < midVal) {\n        high := mid;\n      } else {\n        result := mid; // key found\n        return;\n      }\n    }\n    result := -1;  // key not present\n  }\n}\n\nmethod Main() {\n  var a := new int[5];\n  a[0] := -4;\n  a[1] := -2;\n  a[2] := -2;\n  a[3] := 0;\n  a[4] := 25;\n  TestSearch(a, 4);\n  TestSearch(a, -8);\n  TestSearch(a, -2);\n  TestSearch(a, 0);\n  TestSearch(a, 23);\n  TestSearch(a, 25);\n  TestSearch(a, 27);\n}\n\nmethod TestSearch(a: array<int>, key: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n{\n  var b := new Benchmark2;\n  var r := b.BinarySearch(a, key);\n  print \"Looking for key=\", key, \", result=\", r, \"\\n\";\n}\n"}
{"file": "../dafny/Test/doofiles/Test5.dfy", "dafny": "// RUN: %exits-with 1 %baredafny build -t:lib  --use-basename-for-filename \"%s\" --output: 2> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Missing output\n\nconst c := 42\n"}
{"file": "../dafny/Test/doofiles/Test1.dfy", "dafny": "// RUN: %exits-with 1 %baredafny resolve --use-basename-for-filename \"%s\" \"%S/NoSuch.doo\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Input .doo file does not exist\n\nconst c := 42\n"}
{"file": "../dafny/Test/doofiles/Test2.dfy", "dafny": "// RUN: %exits-with 1 %baredafny resolve --use-basename-for-filename \"%s\" \"%S/BadDoo.doo\" 2> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Input .doo file has invalid content\n\nconst c := 42\n"}
{"file": "../dafny/Test/doofiles/Test3a.dfy", "dafny": "// RUN: %baredafny --help\n\n\n// Just an auxiliary file to Test3.dfy\n\nconst d := 42\n"}
{"file": "../dafny/Test/doofiles/Test4.dfy", "dafny": "// RUN: %baredafny build -t:lib --use-basename-for-filename \"%s\" --output \"%S/test2\" > \"%t\"\n// RUN: %baredafny resolve --use-basename-for-filename \"%s\"  \"%S/test2.doo\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// XFAIL: *\n\n// Combining a file with a .doo of itself -- was a crash\n\nconst c := 42\n"}
{"file": "../dafny/Test/doofiles/Test3.dfy", "dafny": "// RUN: %baredafny build -t:lib  --use-basename-for-filename \"%s\" --output \"%S/test\" > \"%t\"\n// RUN: %baredafny resolve --use-basename-for-filename \"%S/Test3a.dfy\"  \"%S/test.doo\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Output file does not have a .doo suffix; test.doo created\n\nconst c := 42\n"}
{"file": "../dafny/Test/newtype/aliases.dfy", "dafny": "// RUN: %baredafny resolve --use-basename-for-filename %s > %t\n// RUN: %diff \"%s.expect\" %t\n\nnewtype VerySpecificInt = x : SpecificIntAlias | x == 1 witness 1\ntype SpecificIntAlias = SpecificInt\nnewtype SpecificInt = x : int | 0 <= x <= 10"}
{"file": "../dafny/Test/triggers/wf-checks-use-the-original-quantifier.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This test checks that typical expressions requiring WF checks do not suddenly\n// loose expressivity due to quantifier splitting. Without special care, the\n// expression (forall x :: x != null && x.a == 0) could fail to verify.\n\n// The logic about split quantifiers is that Boogie (and z3) should never realize\n// that there was an unsplit quantifier. The WF check code does not produce a\n// quantifier, at least in it's checking part; thus, it should use original\n// quantifier. This fixes a problem in VerifyThis2015/Problem2.dfy with a null\n// check, and a problem spotted by Chris, made into a test case saved in\n// triggers/wf-checks-use-the-original-quantifier.dfy.\n\n// Of course, the assumption that WF checks produce for a quantifier is a\n// quantifier, so the assumption part that comes after the WF check does use the\n// split expression.\n\n// This test case is inspired by the example that Chris gave.\n\nghost predicate P(b: nat)\nghost function f(a: int): int\nclass C { var x: int }\n\nmethod M(s: set<C>)\n  requires forall n: nat :: 0 <= f(n) && P(f(n))\n  requires forall c, c' | c in s && c' in s :: c.x == c'.x {\n}\n"}
{"file": "../dafny/Test/triggers/loop-detection-is-not-too-strict.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This test shows that the loop detection engine makes compromises when looking\n// for subexpressions matching a trigger; in particular, it allows a\n// subexpression to match a trigger without reporting a loop and without being\n// equal to that trigger, as long as the only differences are variable\n\nghost predicate P(x: int, y: int)\nghost predicate Q(x: int)\n\nmethod Test(z: int) {\n  // P(x, y) and P(y, x) might look like they would cause a loop. Since they\n  // only differ by their variables, though, they won't raise flags.\n  assume forall x: int, y: int :: P(x, y) == P(y, x);\n\n  // This works independent of extra parentheses:\n  assume forall x: int, y: int :: P(x, y) == (P(y, x));\n\n  // Contrast with the following:\n  assume forall x: int, y: int :: P(x, y) == P(x, y+1);\n\n  // The following examples were made legal after an exchange where Chris\n  // pointed examples in the IronClad sources where things like this were\n  // incorrectly flagged.\n  assert forall x :: true || Q(x) || Q(0);\n  assert forall x :: true || Q(x) || Q(z);\n  assert forall x :: true || P(x, 1) || P(x, z);\n\n  // Support for the following was added following a discussion with Rustan; in\n  // the second one the expression `if z > 1 then z else 3 * z + 1` is not\n  // directly a constant expression, but it does not involve x, so it's ok:\n  assert forall x :: true || Q(x) || Q(0+1);\n  assert forall x :: true || Q(x) || Q(if z > 1 then z else 3 * z + 1);\n  // Sanity check:\n  assert forall x :: true || Q(x) || Q(if z > 1 then x else 3 * z + 1);\n\n  // Let expressions are inlined before loop detection, causing this to get\n  // correctly rewritten.\n  assert forall x :: true || Q(x) || (var xx := x+1; Q(xx));\n}\n"}
{"file": "../dafny/Test/triggers/loop-detection-looks-at-ranges-too.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file checks that loops between the range and the term of a quantifier\n// are properly detected.\n\nghost predicate P(x: int)\n\nmethod M(x: int) {\n  // This will be flagged as a loop even without looking at the range\n  assert true || forall x: int | P(x) :: P(x+1);\n  // This requires checking the range for looping terms\n  assert true || forall x: int | P(x+1) :: P(x);\n}\n"}
{"file": "../dafny/Test/triggers/large-quantifiers-dont-break-dafny.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This test ensures that the trigger  collector (the routine that picks trigger\n// candidates) does not  actually consider all subsets of terms;  if it did, the\n// following would take horribly long\n\nghost predicate P0(x: bool)\nghost predicate P1(x: bool)\nghost predicate P2(x: bool)\nghost predicate P3(x: bool)\nghost predicate P4(x: bool)\nghost predicate P5(x: bool)\nghost predicate P6(x: bool)\nghost predicate P7(x: bool)\nghost predicate P8(x: bool)\nghost predicate P9(x: bool)\nghost predicate P10(x: bool)\nghost predicate P11(x: bool)\nghost predicate P12(x: bool)\nghost predicate P13(x: bool)\nghost predicate P14(x: bool)\nghost predicate P15(x: bool)\nghost predicate P16(x: bool)\nghost predicate P17(x: bool)\nghost predicate P18(x: bool)\nghost predicate P19(x: bool)\nghost predicate P20(x: bool)\nghost predicate P21(x: bool)\nghost predicate P22(x: bool)\nghost predicate P23(x: bool)\nghost predicate P24(x: bool)\nghost predicate P25(x: bool)\nghost predicate P26(x: bool)\nghost predicate P27(x: bool)\nghost predicate P28(x: bool)\nghost predicate P29(x: bool)\nghost predicate P30(x: bool)\nghost predicate P31(x: bool)\nghost predicate P32(x: bool)\nghost predicate P33(x: bool)\nghost predicate P34(x: bool)\nghost predicate P35(x: bool)\nghost predicate P36(x: bool)\nghost predicate P37(x: bool)\nghost predicate P38(x: bool)\nghost predicate P39(x: bool)\nghost predicate P40(x: bool)\nghost predicate P41(x: bool)\nghost predicate P42(x: bool)\nghost predicate P43(x: bool)\nghost predicate P44(x: bool)\nghost predicate P45(x: bool)\nghost predicate P46(x: bool)\nghost predicate P47(x: bool)\nghost predicate P48(x: bool)\nghost predicate P49(x: bool)\n\nmethod M() {\n  assert forall x :: true || P0(x) || P1(x) || P2(x) || P3(x) || P4(x) || P5(x) || P6(x) || P7(x) || P8(x) || P9(x) || P10(x) || P11(x) || P12(x) || P13(x) || P14(x) || P15(x) || P16(x) || P17(x) || P18(x) || P19(x) || P20(x) || P21(x) || P22(x) || P23(x) || P24(x) || P25(x) || P26(x) || P27(x) || P28(x) || P29(x) || P30(x) || P31(x) || P32(x) || P33(x) || P34(x) || P35(x) || P36(x) || P37(x) || P38(x) || P39(x) || P40(x) || P41(x) || P42(x) || P43(x) || P44(x) || P45(x) || P46(x) || P47(x) || P48(x) || P49(x);\n}\n"}
{"file": "../dafny/Test/triggers/useless-triggers-are-removed.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file ensures that Dafny does get rid of redundant triggers before\n// annotating a quantifier, and that ths process does not interfere with cycle\n// detection.\n\nghost function f(x: int): int\nghost function g(x: int): int\nghost function h(x: int): int\n\nmethod M()\n  // In the following, only f(x) is kept. Note that the subset enumeration was\n  // already smart enough to not build any trigger with multiple terms (it only\n  // built 5 candidates)\n  requires forall x: int :: f(x) + g(f(x)) + h(f(x)) + g(h(f(x))) + h(g(f(x))) == 0\n\n  // Loop detection still works fine: in the following example, the trigger is\n  // f(f(x))\n  requires forall x: int :: f(x) == f(f(x))\n\n  // This works for multi-triggers, too:\n  requires forall x, y :: f(x) + g(f(y)) + g(y) + g(f(x)) == 0\n{\n}\n"}
{"file": "../dafny/Test/triggers/regression-tests.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This tests checks that quantifier splitting is resilient to the fact that\n// certain statements (like calc) can return duplicate subexpressions. This was\n// once a problem, because a quantifier that got returned twice would get split\n// on the first pass over it, and would have its nely created children re-split\n// on the second pass. This created a split quantifier whose children were split\n// quantifiers, which violated an invariant of spliit quantifiers.\n\nabstract module Base { }\n\nmodule Blah refines Base {\n  lemma A() {\n    calc {\n\t    forall b :: b;\n   \t}\n  }\n}\n\n"}
{"file": "../dafny/Test/triggers/nested-quantifiers-all-get-triggers.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This checks that nested quantifiers do get triggers, and that the parent\n// quantifier does not get annotated twice\n\nmethod M() {\n  ghost var x := forall s: set<int>, x: int :: (x in s ==> forall y :: y == x ==> y in s);\n}\n"}
{"file": "../dafny/Test/triggers/looping-is-hard-to-decide-modulo-equality.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file shows cases where loops could hide behind equalities. In all three\n// cases we behave the same; that is, we don't warn for loops that would only\n// exist in the presence of an equality. The easiest way to understand the\n// issue, I (CPC) feel, is to look at the old case: f(x) could very well loop\n// with old(f(f(x))) if f(f(x)) did not change the heap at all.\n\n// This equality issue is generally undecidable. It could make sense to special\n// case `old`, but KRML and CPC decided against it on 2015-08-21. Future\n// experiences could cause a change of mind.\n\nclass C { }\nghost function f(c: C): C reads c\nghost function g(c: C): C\nghost function h(c: C, i: int): C\n\n// With explicit arguments\nmethod M0(i: int, j: int, sc: set<C>) {\n  assert forall c | c in sc :: true || h(c, i) == h(h(c, j), j);\n}\n\n// With implicit arguments (f and g respectively, to Apply)\nmethod M1(f: int -> int, g: int -> int) {\n  assert forall x :: true || f(x) == g(f(x));\n}\n\n// With implicit arguments (the heap, to old)\nmethod M2(sc: set<C>) {\n  assert forall c | c in sc :: true || f(c) == old(f(f(c)));\n}\n"}
{"file": "../dafny/Test/triggers/function-applications-are-triggers.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file checks that function applications yield trigger candidates\n\nmethod M(P: (int -> int) -> bool, g: int -> int)\n  requires P.requires(g)\n  requires P(g) {\n  assume forall f: int -> int :: P.requires(f);\n  assume forall f: int -> int :: P(f) ==> f.requires(10) && f(10) == 0;\n  assert forall f: int -> int ::\n    (forall x :: f.requires(x) && g.requires(x) ==> f(x) == g(x)) ==>\n    f.requires(10) ==>\n    f(10) == 0;\n}\n"}
{"file": "../dafny/Test/triggers/redundancy-detection-is-bidirectional.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This test checks for tricky cases of redundancy suppression when building\n// triggers.\n\nghost predicate P(x: int, y: int)\nghost predicate Q(x: int)\nghost predicate R(x: int)\n\nmethod M() {\n  // For this term, it is enough to order the terms by number of variables\n  assert forall x, y :: true || P(x, y) || Q(y) || R(x);\n  assert forall x, y :: true || Q(y) || P(x, y) || R(x);\n  assert forall x, y :: true || Q(y) || R(x) || P(x, y);\n}\n\nghost predicate PP(x: int, y: int, z: int)\nghost predicate QQ(x: int, y: int)\nghost predicate RR(x: int, y: int)\nghost predicate SS(x: int, y: int)\n\nmethod MM() {\n  // Not for this one, though\n  assert forall x, y, z, u, v, w :: true || PP(x, y, z) || QQ(x, u) || RR(y, v) || SS(z, w);\n  assert forall x, y, z, u, v, w :: true || QQ(x, u) || PP(x, y, z) || RR(y, v) || SS(z, w);\n  assert forall x, y, z, u, v, w :: true || QQ(x, u) || RR(y, v) || PP(x, y, z) || SS(z, w);\n  assert forall x, y, z, u, v, w :: true || QQ(x, u) || RR(y, v) || SS(z, w) || PP(x, y, z);\n}\n"}
{"file": "../dafny/Test/triggers/suppressing-warnings-behaves-properly.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file checks that suppressing warnings works properly\n\nghost predicate f(x: int)\nghost predicate g(x: int)\n\nmethod M() {\n  assert forall n :: n >= 0 || n < 0;\n  assert forall n {:nowarn} :: n >= 0 || n < 0;\n  assert forall n {:autotriggers false} :: n >= 0 || n < 0;\n\n  assert forall n: nat :: (n != 0) == f(n) || true;\n  assert forall n: nat {:nowarn} :: (n != 0) == f(n) || true;\n  assert forall n: nat {:autotriggers false} :: (n != 0) == f(n) || true;\n\n  assert forall n: nat :: f(n) == f(n+1) || g(n) || true;\n  assert forall n: nat {:nowarn} :: (n != 0) == f(n) || true;\n  assert forall n: nat {:autotriggers false} :: (n != 0) == f(n) || true;\n}\n"}
{"file": "../dafny/Test/triggers/loop-detection-messages--unit-tests.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file is a series of basic tests for loop detection, focusing on the\n// warnings and information messages\n\nghost function f(i: int): int\nghost function g(i: int): int\n\nmethod M() {\n  assert forall i :: false ==> f(i) == f(f(i));\n  assert forall i :: false ==> f(i) == f(i+1);\n  assert forall i {:matchingloop} :: false ==> f(i) == f(i+1);\n\n  assert forall i :: false ==> f(i) == f(i+1) && f(i) == g(i);\n  assert forall i :: false ==> f(i) == f(i+1) && f(i) == f(i);\n  assert forall i {:matchingloop} :: false ==> f(i) == f(i+1) && f(i) == f(i);\n\n  assert forall i :: false ==> f(i) == 0;\n  assert forall i :: false ==> f(i+1) == 0;\n  assert forall i {:autotriggers false} :: false ==> f(i+1) == 0;\n\n  assert forall i, j: int :: false ==> f(i) == f(j);\n  assert forall i, j: int :: false ==> f(i) == f(i);\n  assert forall i, j: int :: false ==> f(i) == f(i) && g(j) == 0;\n  assert forall i, j: int :: false ==> f(i) == f(i) && g(j+1) == 0;\n  assert forall i, j: int {:autotriggers false} :: false ==> f(i) == f(i);\n  assert forall i, j: int {:trigger f(i), g(j)} :: false ==> f(i) == f(i);\n}\n"}
{"file": "../dafny/Test/triggers/let-expressions.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost predicate Foo(s: seq<int>)\n{\n    && (forall i :: 0 <= i < |s| ==> var j := i; s[j] > 0)\n    && (forall i :: 0 <= i < |s| ==> var j, k := i, i; s[k] > 0)\n    && (forall i :: 0 <= i < |s|-1 ==> s[i] == s[i+1])\n    && (forall i :: 0 <= i < |s|-1 ==> s[i] == var j := i+1; s[j])\n}\n"}
{"file": "../dafny/Test/triggers/auto-triggers-fix-an-issue-listed-in-the-ironclad-notebook.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This example was listed in IronClad's notebook as one place were z3 picked\n// much too liberal triggers. THe Boogie code for this is shown below:\n//\n// forall k#2: Seq Box :: $Is(k#2, TSeq(TInt)) && $IsAlloc(k#2, TSeq(TInt), $Heap)\n//                   ==> Seq#Equal(_module.__default.HashtableLookup($Heap, h1#0, k#2),\n//                                 _module.__default.HashtableLookup($Heap, h2#0, k#2))\n//\n// and z3 would pick $Is(k#2, TSeq(TInt)) or $IsAlloc(k#2, TSeq(TInt), $Heap) as\n// triggers.\n\ntype Key = seq<int>\ntype Value = seq<int>\n\ntype Hashtable = map<Key, Value>\nghost function HashtableLookup(h: Hashtable, k: Key): Value\n\nlemma HashtableAgreement(h1:Hashtable, h2:Hashtable, k:Key)\n  requires forall k :: HashtableLookup(h1,k) == HashtableLookup(h2,k) {\n    assert true || (k in h1) == (k in h2);\n}\n"}
{"file": "../dafny/Test/triggers/old-is-a-special-case-for-triggers.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file ensures that `old()` receives the special treatment that it\n// requires; that is, `old(f(x))` is not less liberal than `f(x)`, and\n// old(f(f(x))) does not loop with f(x) (doesn't it?)\n\nclass C { }\nghost function f(c: C): C\nghost function g(c: C): C\nghost function h(c: C, i: int): C\n\nmethod M(sc: set<C>)\n  // Ensure that old(c) does not get picked as a trigger\n  ensures forall c | c in sc :: true || c == old(f(c)) // warning: old has no effect\n\n  // This checks whether loop detection handles `old` expressions properly.\n  // In the first one f(c)/old(f(f(c))) is not reported as a loop. See\n  // looping-is-hard-to-decide-modulo-equalities.dfy for an explanation.\n  ensures forall c | c in sc :: true || f(c) == old(f(f(c))) // warning: old has no effect\n  ensures forall c | c in sc :: true || old(f(f(c))) == old(g(f(c))) || old(f(g(c))) == g(f(c)) || f(g(c)) == g(f(c)) // warning (x3): old has no effect\n\n  // These check that the final trigger filtering step doesn't get confused\n  // between old expressions and regular expressions.\n  ensures forall c | c in sc :: true || f(c) == old(g(f(c))) // warning: old has no effect\n  ensures forall c | c in sc :: true || f(c) == old(f(c)) || old(g(f(c))) == g(f(c)) // warning (x2): old has no effect\n\n  // WISH: A Dafny rewriter could cleanup expressions so that adding the\n  //       expression forall c :: c == old(c) in a quantifier would cause a warning,\n  //       instead of a trigger generation error as it does now.\n{\n}\n\nghost function ff(c: C): C reads c\n\nmethod MM(sc: set<C>)\n  // Ensure that old(c) does not get picked as a trigger\n  ensures forall c | c in sc :: true || c == old(ff(c))\n\n  // This checks whether loop detection handles `old` expressions properly.\n  // In the first one ff(c)/old(ff(ff(c))) is not reported as a loop. See\n  // looping-is-hard-to-decide-modulo-equalities.dfy for an explanation.\n  ensures forall c | c in sc :: true || ff(c) == old(ff(ff(c)))\n  ensures forall c | c in sc :: true || old(ff(ff(c))) == old(g(ff(c))) || old(ff(g(c))) == g(ff(c)) || ff(g(c)) == g(ff(c))\n\n  // These check that the final trigger filtering step doesn't get confused\n  // between old expressions and regular expressions.\n  ensures forall c | c in sc :: true || ff(c) == old(g(ff(c)))\n  ensures forall c | c in sc :: true || ff(c) == old(ff(c)) || old(g(ff(c))) == g(ff(c))\n{\n}\n"}
{"file": "../dafny/Test/triggers/constructors-cause-matching-loops.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file is just a small test to check that constructors do cause loops\n\ndatatype Nat = Zero | Succ(x: Nat)\nghost function f(n: Nat): Nat\n\nmethod M() {\n  assert forall s :: true || f(Succ(s)) == f(s);\n}\n"}
{"file": "../dafny/Test/triggers/triggers-prevent-some-inlining.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This  file looks  at the  interactions  between inlining  and triggers.   The\n// sum_is_sum predicate gets a {sum(a,  b)} trigger, which explicitly depends on\n// one of the  variables being passed in. Since triggers  are generated prior to\n// inlining  (inlining  happens  during  translation),  inlining  the  last  two\n// instances of that call below would cause  b+1 (a trigger killer) to pop up in\n// a trigger.   This would create  an invalid trigger,  so Dafny doesn't  let it\n// happen.\n\nghost function sum(a: int, b: int): int {\n  a + b\n}\n\nghost predicate sum_is_sum(b: int, c: int) {\n  forall a: int :: sum(a, b) + c == a + b + c\n}\n\nmethod can_we_inline(b: int, c: int)\n  ensures sum_is_sum(0, 0)     // OK  to inline\n  ensures sum_is_sum(b, c)     // OK  to inline\n  ensures sum_is_sum(b, c+1)   // OK  to inline\n  ensures sum_is_sum(b+1, c)   // NOK to inline\n  ensures sum_is_sum(b+1, c+1) // NOK to inline\n{ }\n"}
{"file": "../dafny/Test/triggers/set-construction-is-a-good-trigger.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file ensures that display expressions can be picked as triggers. This is\n// useful for code that checks if a set, sequence, or multiset is a singleton.\n\nmethod M(s: seq<int>, st: set<int>, mst: multiset<int>)\n  requires exists y :: s == [y]           // Seq#Build(Seq#Empty(): Seq Box, $Box(y#3))\n  requires exists y :: st == {y}          // Set#UnionOne(Set#Empty(): Set Box, $Box(y#4))\n  requires exists y :: mst == multiset{y} // MultiSet#UnionOne(MultiSet#Empty(): MultiSet Box, $Box(y#5))\n{\n}\n"}
{"file": "../dafny/Test/hofs/Compilation.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nclass Ref<A> {\n  var val : A\n  constructor (a : A)\n    ensures val == a\n  {\n    val := a;\n  }\n}\n\nmethod Main() {\n  // simple\n  print \"1 = \", (x => x)(1), \"\\n\";\n  print \"3 = \", (x => y => x + y)(1)(2), \"\\n\";\n  print \"3 = \", ((x,y) => y + x)(1,2), \"\\n\";\n  print \"0 = \", (() => 0)(), \"\\n\";\n\n  // local variable\n  var y := 1;\n  var f := x => x + y;\n  print \"3 = \", f(2), \"\\n\";\n  print \"4 = \", f(3), \"\\n\";\n  y := 2;\n  print \"3 = \", f(2), \"\\n\";\n  print \"4 = \", f(3), \"\\n\";\n\n  // reference\n  var z := new Ref(1);\n  f := x reads z => x + z.val;\n  print \"3 = \", f(2), \"\\n\";\n  print \"4 = \", f(3), \"\\n\";\n  z.val := 2;\n  print \"4 = \", f(2), \"\\n\";\n  print \"5 = \", f(3), \"\\n\";\n\n  // loop\n  f := x => x;\n  y := 10;\n  while y > 0\n    invariant forall x :: f.requires(x)\n    invariant forall x :: f.reads(x) == {}\n  {\n    f := x => f(x+y);\n    y := y - 1;\n  }\n  print \"55 = \", f(0), \"\\n\";\n\n  // substitution test\n  print \"0 = \", (x => var y:=x;y)(0), \"\\n\";\n  print \"1 = \", (y => (x => var y:=x;y))(0)(1), \"\\n\";\n}\n\n"}
{"file": "../dafny/Test/hofs/WhileLoop.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nclass Ref<A(0)> {\n  var val: A\n}\n\nmethod Nice(n: int) returns (k: int) {\n  var f : int -> int := x => x;\n  var i := new Ref<int>;\n  i.val := 0;\n  while i.val < n\n    invariant forall u :: f.requires(u)\n    invariant forall u :: f.reads(u) == {}\n    invariant forall u :: f(u) == u + i.val\n  {\n    i.val := i.val + 1;\n    f := x => f(x) + 1;\n  }\n  return f(0);\n}\n\nmethod OneShot(n: int) returns (k: int) {\n  var f : int -> int := x => x;\n  var i := 0;\n  while i < n\n    invariant forall u :: f.requires(u)\n    invariant forall u :: f(u) == u + i\n  {\n    i := i + 1;\n    f := x requires f.requires(x) reads f.reads(x) => f(x) + 1;\n  }\n  k := f(0);\n}\n\nmethod HeapQuant(n: int) returns (k: int) {\n  var f : int -> int := x => x;\n  var i := new Ref;\n  ghost var r := 0;\n  i.val := 0;\n  while i.val < n\n    invariant forall u :: f.requires(u)\n    invariant forall u :: f.reads(u) == {}\n    invariant r == i.val\n    invariant forall u :: f(u) == u + r\n  {\n    i.val, r := i.val + 1, r + 1;\n    f := x => f(x) + 1;\n  }\n  k := f(0);\n}\n\nmethod Main() {\n  var k0 := Nice(22);\n  var k1 := OneShot(22);\n  var k2 := HeapQuant(22);\n  print k0, \" \", k1, \" \", k2, \"\\n\";\n}\n"}
{"file": "../dafny/Test/hofs/SumSum.dfy", "dafny": "// RUN: %dafny /compile:0 /rprint:\"%t.rprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Tests that come down to comparing the bodies of (possibly nested) functions.\n// Many of these currently require far more effort than one would like.\n// KRML, 2 May 2016\n\nghost function Sum(n: nat, f: int -> int): int\n{\n  if n == 0 then 0 else f(n-1) + Sum(n-1, f)\n}\n\nlemma Exchange(n: nat, f: int -> int, g: int -> int)\n  requires forall i :: 0 <= i < n ==> f(i) == g(i)\n  ensures Sum(n, f) == Sum(n, g)\n{\n}\n\nlemma ExchangeEta(n: nat, f: int -> int, g: int -> int)\n  requires forall i :: 0 <= i < n ==> f(i) == g(i)\n  ensures Sum(n, x => f(x)) == Sum(n, x => g(x))\n{\n}\n\nlemma NestedAlphaRenaming(n: nat, g: (int,int) -> int)\n  ensures Sum(n, x => Sum(n, y => g(x,y))) == Sum(n, a => Sum(n, b => g(a,b)))\n{\n}\n\nlemma DistributePlus1(n: nat, f: int -> int)\n  ensures Sum(n, x => 1 + f(x)) == n + Sum(n, f)\n{\n}\n\nlemma Distribute(n: nat, f: int -> int, g: int -> int)\n  ensures Sum(n, x => f(x) + g(x)) == Sum(n, f) + Sum(n, g)\n{\n}\n\nlemma {:induction false} PrettyBasicBetaReduction(n: nat, g: (int,int) -> int, i: int)\n  ensures (x => Sum(n, y => g(x,y)))(i) == Sum(n, y => g(i,y))\n{\n  // NOTE: This proof is by induction on n (it can be done automatically)\n  if n == 0 {\n    calc {\n      (x => Sum(n, y => g(x,y)))(i);\n      0;\n      Sum(n, y => g(i,y));\n    }\n  } else {\n    calc {\n      (x => Sum(n, y => g(x,y)))(i);\n      g(i,n-1) + (x => Sum(n-1, y => g(x,y)))(i);\n      { PrettyBasicBetaReduction(n-1, g, i); }\n      g(i,n-1) + Sum(n-1, y => g(i,y));\n      (y => g(i,y))(n-1) + Sum(n-1, y => g(i,y));\n      Sum(n, y => g(i,y));\n    }\n  }\n}\n\nlemma BetaReduction0(n: nat, g: (int,int) -> int, i: int)\n  ensures (x => Sum(n, y => g(x,y)))(i) == Sum(n, y => g(i,y))\n{\n  // automatic proof by induction on n\n}\n\nlemma BetaReduction1(n': nat, g: (int,int) -> int, i: int)\n  ensures g(i,n') + Sum(n', y => g(i,y)) == (x => g(x,n') + Sum(n', y => g(x,y)))(i)\n{\n}\n\nlemma BetaReductionInside(n': nat, g: (int,int) -> int)\n  ensures Sum(n', x => g(x,n') + Sum(n', y => g(x,y)))\n       == Sum(n', x => (w => g(w,n'))(x) + (w => Sum(n', y => g(w,y)))(x))\n{\n  forall i | 0 <= i < n'\n  {\n    calc {\n      (x => g(x,n') + Sum(n', y => g(x,y)))(i);\n      (x => (w => g(w,n'))(x) + (w => Sum(n', y => g(w,y)))(x))(i);\n    }\n  }\n  Exchange(n', x => g(x,n') + Sum(n', y => g(x,y)), x => (w => g(w,n'))(x) + (w => Sum(n', y => g(w,y)))(x));\n}\n\nlemma L(n: nat, n': nat, g: (int, int) -> int)\n  requires && n == n' + 1\n  ensures Sum(n, x => Sum(n, y => g(x,y)))\n       == Sum(n', x => Sum(n', y => g(x,y))) + Sum(n', x => g(x,n')) + Sum(n', y => g(n',y)) + g(n',n')\n{\n  var A := w => g(w,n');\n  var B := w => Sum(n', y => g(w,y));\n\n  calc {\n    Sum(n, x => Sum(n, y => g(x,y)));\n    { assume false;/*TODO*/ }\n    (x => Sum(n, y => g(x,y)))(n') + Sum(n', x => Sum(n, y => g(x,y)));\n    { BetaReduction0(n, g, n'); }\n    Sum(n, y => g(n',y)) + Sum(n', x => Sum(n, y => g(x,y)));\n    { assume false;/*TODO*/ }\n    (y => g(n',y))(n') + Sum(n', y => g(n',y)) + Sum(n', x => Sum(n, y => g(x,y)));\n    { assert (y => g(n',y))(n') == g(n',n'); }\n    g(n',n') + Sum(n', y => g(n',y)) + Sum(n', x => Sum(n, y => g(x,y)));\n    {\n      forall i | 0 <= i < n' {\n        calc {\n          (x => Sum(n, y => g(x,y)))(i);\n          { PrettyBasicBetaReduction(n, g, i); }\n          Sum(n, y => g(i,y));\n          { assume false;/*TODO*/ }\n          (y => g(i,y))(n') + Sum(n', y => g(i,y));\n          // beta reduction\n          g(i,n') + Sum(n', y => g(i,y));\n          { BetaReduction1(n', g, i); }\n          (x => g(x,n') + Sum(n', y => g(x,y)))(i);\n        }\n      }\n      Exchange(n', x => Sum(n, y => g(x,y)), x => g(x,n') + Sum(n', y => g(x,y)));\n    }\n    g(n',n') + Sum(n', y => g(n',y)) + Sum(n', x => g(x,n') + Sum(n', y => g(x,y)));\n    { BetaReductionInside(n', g); }\n    g(n',n') + Sum(n', y => g(n',y)) + Sum(n', x => (w => g(w,n'))(x) + (w => Sum(n', y => g(w,y)))(x));\n    { Exchange(n', x => (w => g(w,n'))(x) + (w => Sum(n', y => g(w,y)))(x), x => A(x) + B(x)); }\n    g(n',n') + Sum(n', y => g(n',y)) + Sum(n', x => A(x) + B(x));\n    { Distribute(n', A, B); }\n    g(n',n') + Sum(n', y => g(n',y)) + Sum(n', A) + Sum(n', B);\n    // defs. A and B\n    g(n',n') + Sum(n', y => g(n',y)) + Sum(n', w => g(w,n')) + Sum(n', w => Sum(n', y => g(w,y)));\n    // alpha renamings, and commutativity of the 4 plus terms\n    Sum(n', x => Sum(n', y => g(x,y))) + Sum(n', y => g(n',y)) + Sum(n', x => g(x,n')) + g(n',n');\n  }\n}\n\nlemma Commute(n: nat, g: (int,int) -> int)\n  ensures Sum(n, x => Sum(n, y => g(x,y))) == Sum(n, x => Sum(n, y => g(y,x)))\n// TODO\n\nlemma CommuteSum(n: nat, g: (int,int) -> int)\n  ensures Sum(n, x => Sum(n, y => g(x,y))) == Sum(n, y => Sum(n, x => g(x,y)))\n// TODO\n"}
{"file": "../dafny/Test/hofs/Fold.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ndatatype List<A> = Nil | Cons(A,List<A>)\n\ndatatype Expr = Add(List<Expr>) | Mul(List<Expr>) | Lit(int)\n\nfunction Eval(e : Expr): int\n{\n  match e\n    case Add(es) => Fold(es, 0, (e,v) requires e < es => Eval(e) + v)\n    case Mul(es) => Fold(es, 1, (e,v) requires e < es => Eval(e) * v)\n    case Lit(i)  => i\n}\n\nfunction Fold<A,B(!new)>(xs : List<A>, unit : B, f : (A,B) --> B): B  // (is this (!new) really necessary?)\n  requires forall x, y :: x < xs ==> f.requires(x,y)\n{\n  match xs\n    case Nil => unit\n    case Cons(x,xs) => f(x, Fold(xs, unit, f))\n}\n\nmethod Main() {\n  var two := Lit(2);\n  var add := (x,y) => Add(Cons(x,Cons(y,Nil)));\n  assert Eval(add(two,two)) == 4;\n  print \"3 = \", Eval(add(Lit(1),two)), \"\\n\";\n}\n"}
{"file": "../dafny/Test/hofs/Requires.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nmethod Main()\n{\n  test0(10);\n\ttest5(11);\n\ttest6(12);\n\ttest1();\n\ttest2();\n}\n\nghost predicate valid(x:int)\n{\n  x > 0\n}\n\nghost function ref1(y:int) : int\n  requires valid(y)\n{\n  y - 1\n}\n\nlemma assumption1()\n  ensures forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b\n{\n}\n\nmethod test0(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition should suffice to let us call the method\n    ghost var b := ref1(a);\n  }\n}\nmethod test5(a: int)\n{\n  if valid(a) {\n    // valid(a) is the precondition of ref1\n    assert ref1.requires(a);\n  }\n}\nmethod test6(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition of ref1 is valid(a)\n    assert valid(a);\n  }\n}\n\nmethod test1()\n{\n  if * {\n    assert forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n  } else {\n    assert forall a, b :: ref1.requires(a) && ref1.requires(b) && ref1(a) == ref1(b)\n                          ==> a == b;\n  }\n}\n\nghost function {:opaque} ref2(y:int) : int        // Now with an opaque attribute\n  requires valid(y)\n{\n  y - 1\n}\n\nlemma assumption2()\n  ensures forall a, b :: valid(a) && valid(b) && ref2(a) == ref2(b) ==> a == b\n{\n  reveal ref2();\n}\n\nmethod test2()\n{\n  assumption2();\n  if * {\n    assert forall a, b :: valid(a) && valid(b) && ref2(a) == ref2(b) ==> a == b;\n  } else {\n    assert forall a, b :: ref2.requires(a) && ref2.requires(b) && ref2(a) == ref2(b)\n                          ==> a == b;\n  }\n}\n"}
{"file": "../dafny/Test/hofs/Renaming.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\nfunction OnId(f : (bool -> bool) -> int) : int\n  reads f.reads(x => x)\n  requires f.requires(y => y)\n{\n  f(z => z)\n}\n\nmethod Equal() {\n  var id1 : bool -> bool := x => x;\n  var id2                := y => y;\n  assert forall x :: id1(x) == id2(x);\n  assert id1 == id2;\n}\n\nmethod K<A,B>(P : (A -> A) -> bool)\n  requires P.requires(x => x)\n  requires P(y => y)\n{\n  assert P(z => z);\n  assert (x => y => x) == ((a : A) => (b : B) => a);\n}\n\nmethod Main() {\n  Equal();\n  var p := (x: real -> real) => x(25.0) <= 25.0;\n  K<real,bool>(p);\n  var f := (b: bool -> bool) => if b(true) then 10 else 11;\n  var x := OnId(f);\n  print x, \" \", f(_ => false), \"\\n\";\n}\n"}
{"file": "../dafny/Test/hofs/Monads.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nabstract module Monad {\n  type M<A>\n\n  function Return<A>(x: A): M<A>\n  function Bind<A,B>(m: M<A>, f:A -> M<B>): M<B>\n\n  // return x >>= f = f x\n  lemma LeftIdentity<A,B>(x: A, f: A -> M<B>)\n    ensures Bind(Return(x),f) == f(x)\n\n  // m >>= return = m\n  lemma RightIdentity<A>(m: M<A>)\n    ensures Bind(m,Return) == m\n\n  // (m >>= f) >>= g = m >>= (x => f(x) >>= g)\n  lemma Associativity<A,B,C>(m: M<A>, f: A -> M<B>, g: B -> M<C>)\n    ensures Bind(Bind(m,f),g) ==\n            Bind(m,x => Bind(f(x),g))\n}\n\nmodule Identity refines Monad {\n  datatype M<A> = I(A)\n\n  function Return<A>(x: A): M<A>\n  { I(x) }\n\n  function Bind<A,B>(m: M<A>, f:A -> M<B>): M<B>\n  {\n    var I(x) := m; f(x)\n  }\n\n  lemma LeftIdentity<A,B>(x: A, f: A -> M<B>)\n  {\n  }\n\n  lemma RightIdentity<A>(m: M<A>)\n  {\n    assert Bind(m,Return) == m;\n  }\n\n  lemma Associativity<A,B,C>(m: M<A>, f: A -> M<B>, g: B -> M<C>)\n  {\n    assert\n      Bind(Bind(m,f),g) ==\n      Bind(m,x => Bind(f(x),g));\n  }\n\n}\n\nmodule Maybe refines Monad {\n  datatype M<A> = Just(A) | Nothing\n\n  function Return<A>(x: A): M<A>\n  { Just(x) }\n\n  function Bind<A,B>(m: M<A>, f:A -> M<B>): M<B>\n  {\n    match m\n    case Nothing => Nothing\n    case Just(x) => f(x)\n  }\n\n  lemma LeftIdentity<A,B>(x: A, f: A -> M<B>)\n  {\n  }\n\n  lemma RightIdentity<A>(m: M<A>)\n  {\n    assert Bind(m,Return) == m;\n  }\n\n  lemma Associativity<A,B,C>(m: M<A>, f: A -> M<B>, g: B -> M<C>)\n  {\n    assert\n      Bind(Bind(m,f),g) ==\n      Bind(m,x => Bind(f(x),g));\n  }\n\n}\n\nmodule List refines Monad {\n  datatype M<A> = Cons(hd: A,tl: M<A>) | Nil\n\n  function Return<A>(x: A): M<A>\n  { Cons(x,Nil) }\n\n  function Concat<A>(xs: M<A>, ys: M<A>): M<A>\n  {\n    match xs\n    case Nil => ys\n    case Cons(x,xs) => Cons(x,Concat(xs,ys))\n  }\n\n  function Join<A>(xss: M<M<A>>): M<A>\n  {\n    match xss\n    case Nil => Nil\n    case Cons(xs,xss) => Concat(xs,Join(xss))\n  }\n\n  function Map<A,B>(xs: M<A>, f: A -> B): M<B>\n  {\n    match xs\n    case Nil => Nil\n    case Cons(x,xs) => Cons(f(x),Map(xs,f))\n  }\n\n  function Bind<A,B>(m: M<A>, f: A -> M<B>): M<B>\n  {\n    Join(Map(m,f))\n  }\n\n  lemma LeftIdentity<A,B>(x: A, f: A -> M<B>)\n  {\n    calc {\n       Bind(Return(x),f);\n    == Join(Map(Cons(x,Nil),f));\n    == Join(Cons(f(x),Nil));\n    == Concat(f(x),Nil);\n    == { assert forall xs: M<B> {:induction} :: Concat(xs,Nil) == xs; }\n       f(x);\n    }\n  }\n\n  lemma RightIdentity<A>(m: M<A>)\n  {\n    match m\n    case Nil =>\n      calc {\n         Bind(Nil,Return);\n      == Join(Map(Nil,Return));\n      == Join(Nil);\n      == Nil;\n      == m;\n      }\n    case Cons(x,xs) =>\n      calc {\n         Bind(m,Return);\n      == Bind(Cons(x,xs),Return);\n      == Join(Map(Cons(x,xs),Return));\n      == Join(Cons(Return(x),Map(xs,Return)));\n      == Concat(Return(x),Join(Map(xs,Return)));\n      == { RightIdentity(xs); }\n         Concat(Return(x),xs);\n      == Concat(Cons(x,Nil),xs);\n      == Cons(x,xs);\n      == m;\n      }\n  }\n\n  lemma ConcatAssociativity<A>(xs: M<A>, ys: M<A>, zs: M<A>)\n    ensures Concat(Concat(xs,ys),zs) == Concat(xs,Concat(ys,zs))\n  {}\n\n  lemma BindMorphism<A,B>(xs: M<A>, ys: M<A>, f: A -> M<B>)\n    ensures Bind(Concat(xs,ys),f) == Concat(Bind(xs,f),Bind(ys,f))\n  {\n    match xs\n    case Nil =>\n      calc {\n         Bind(Concat(Nil,ys),f);\n      == Bind(ys,f);\n      == Concat(Nil,Bind(ys,f));\n      == Concat(Bind(Nil,f),Bind(ys,f));\n      }\n    case Cons(z,zs) =>\n      calc {\n         Bind(Concat(xs,ys),f);\n      == Bind(Concat(Cons(z,zs),ys),f);\n      == Concat(f(z),Bind(Concat(zs,ys),f));\n      == { BindMorphism(zs,ys,f); }\n         Concat(f(z),Concat(Bind(zs,f),Bind(ys,f)));\n      == { ConcatAssociativity(f(z),Bind(zs,f),Bind(ys,f)); }\n         Concat(Concat(f(z),Join(Map(zs,f))),Bind(ys,f));\n      == Concat(Bind(Cons(z,zs),f),Bind(ys,f));\n      == Concat(Bind(xs,f),Bind(ys,f));\n      }\n  }\n\n  lemma Associativity<A,B,C>(m: M<A>, f: A -> M<B>, g: B -> M<C>)\n  {\n    match m\n    case Nil =>\n      calc {\n         Bind(Bind(m,f),g);\n      == Bind(Bind(Nil,f),g);\n      == Bind(Nil,g);\n      == Nil;\n      == Bind(Nil,x => Bind(f(x),g));\n      == Bind(m,x => Bind(f(x),g));\n      }\n    case Cons(x,xs) =>\n      calc {\n         Bind(Bind(m,f),g);\n      == Bind(Bind(Cons(x,xs),f),g);\n      == Bind(Concat(f(x),Bind(xs,f)),g);\n      == { BindMorphism(f(x),Bind(xs,f),g); }\n         Concat(Bind(f(x),g),Bind(Bind(xs,f),g));\n      == { Associativity(xs,f,g); }\n         Concat(Bind(f(x),g),Join(Map(xs,y => Bind(f(y),g))));\n      == Join(Cons(Bind(f(x),g),Map(xs,y => Bind(f(y),g))));\n      == Join(Map(Cons(x,xs),y => Bind(f(y),g)));\n      == Bind(Cons(x,xs),y => Bind(f(y),g));\n      == Bind(m,x => Bind(f(x),g));\n      }\n  }\n}\n"}
{"file": "../dafny/Test/hofs/TreeMapSimple.dfy", "dafny": "// RUN: %testDafnyForEachCompiler --refresh-exit-code=0 \"%s\" -- --relax-definite-assignment\n\nmethod Main() {\n  TestY();\n}\n\ndatatype List<A> = Nil | Cons(head: A, tail: List<A>)\n\ndatatype Tree<A> = Branch(val: A, trees: List<Tree<A>>)\n\nghost function ListData(xs: List): set\n  ensures forall x :: x in ListData(xs) ==> x < xs\n{\n  match xs\n  case Nil => {}\n  case Cons(x,xs) => {x} + ListData(xs)\n}\n\nghost function TreeData(t0: Tree): set\n  ensures forall t :: t in TreeData(t0) ==> t < t0\n{\n  var Branch(x, ts) := t0;\n  {x} + set t, y | t in ListData(ts) && y in TreeData(t) :: y\n}\n\n// ---------- Partial functions ----------\n\nghost predicate PreY<A,B>(f: A --> B, s: set<A>) {\n  forall x :: x in s ==> f.requires(x)\n}\n\nfunction MapY<A,B>(xs: List<A>, f: A --> B): List<B>\n  requires PreY(f, ListData(xs))\n  decreases xs\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, xs) => Cons(f(x), MapY(xs, f))\n}\n\nfunction TreeMapY<A,B>(t0: Tree<A>, f: A --> B): Tree<B>\n  requires PreY(f, TreeData(t0))\n  decreases t0\n{\n  var Branch(x, ts) := t0;\n  Branch(f(x), MapY(ts, t requires t in ListData(ts) && PreY(f, TreeData(t)) => TreeMapY(t, f)))\n}\n\nmethod TestY() {\n  var f := x requires x != 0 => 100 / x;\n  var t := TreeMapY(Branch(1, Cons(Branch(2, Nil), Nil)), f);\n  assert t == Branch(100, Cons(Branch(50, Nil), Nil));  // proved via Lit axioms\n  print t, \"\\n\";\n}\n"}
{"file": "../dafny/Test/dafnydoc/doc2/Test.dfy", "dafny": "// RUN: rm -rf \"%S/docs2\"\n// RUN: %baredafny doc --use-basename-for-filename --program-name=TestProgram --output:\"%S/docs2\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// RUN: %diff \"%S/docs2/index.html\" \"%S/docs-expected/index.html\"\n// RUN: %diff \"%S/docs2/__95.html\" \"%S/docs-expected/__95.html\"\n// RUN: %diff \"%S/docs2/Test_13716.html\" \"%S/docs-expected/Test_13716.html\"\n\nmodule Test {}\n"}
{"file": "../dafny/Test/dafnydoc/doc4/Test.dfy", "dafny": "// RUN: %baredafny doc --use-basename-for-filename --verbose \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Test {}\n"}
{"file": "../dafny/Test/dafnydoc/doc0/Doc.dfy", "dafny": "// RUN: %baredafny doc \"%S\"/doc.toml\n// RUN: %diff \"%S\"/documentation/index.html \"%S\"/docs-expected/index.html\n// RUN: %diff \"%S\"/documentation/__95.html \"%S\"/docs-expected/__95.html\n// RUN: %diff \"%S\"/documentation/styles.css \"%S\"/docs-expected/styles.css\n"}
{"file": "../dafny/Test/unicodechars/comp/ExternDafnyString.dfy", "dafny": "// RUN: %dafny /compile:3 /unicodeChar:1 /compileTarget:java \"%s\" %S/ExternDafnyString.java > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// In this example, the extern method obtains a Java string and returns it as a Dafny string.\n\nclass {:extern \"java.lang.String\"} JavaString {\n  ghost const value: string\n}\n\nmethod {:extern \"dafny.ExternDafnyString\", \"getStringFromFile\"} GetStringFromFile() returns (s: string)\n\nmethod Main() {\n  var s := GetStringFromFile();\n\n  var previousStart := 0;\n  for i := 0 to |s|\n    invariant previousStart <= i\n  {\n    if s[i] == '/' {\n      print s[previousStart..i], \"\\n\";\n      previousStart := i + 1;\n    }\n  }\n  if previousStart != |s| {\n    print s[previousStart..], \"\\n\";\n  }\n}\n"}
{"file": "../dafny/Test/unicodechars/comp/ExternJavaString.dfy", "dafny": "// RUN: %dafny /compile:3 /unicodeChar:1 /compileTarget:java \"%s\" %S/Conversions.java %S/ExternJavaString.java > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// In this example, the extern method obtains a Java string and returns it as such.\n// The Dafny code converts that Java string to a Dafny string.\n\nclass {:extern \"java.lang.String\"} JavaString {\n  ghost const value: string\n}\n\n// Note, the following has to be a method, not a function, because the reference it\n// returns is not determined functionally from the input argument.\nmethod {:extern \"Util.Conversions\", \"ToJavaString\"} ToJavaString(s: string) returns (js: JavaString)\n  ensures js.value == s\n\n// The conversion this way can be a function.\nfunction {:extern \"dafny.DafnySequence\", \"asUnicodeString\"} ToDafnyString(js: JavaString): string\n  ensures ToDafnyString(js) == js.value\n\nmethod {:extern \"dafny.ExternJavaString\", \"getStringFromFile\"} GetStringFromFile() returns (js: JavaString)\n\nmethod Main() {\n  var js := GetStringFromFile();\n  var s := ToDafnyString(js);\n\n  var previousStart := 0;\n  for i := 0 to |s|\n    invariant previousStart <= i\n  {\n    if s[i] == '/' {\n      print s[previousStart..i], \"\\n\";\n      previousStart := i + 1;\n    }\n  }\n  if previousStart != |s| {\n    print s[previousStart..], \"\\n\";\n  }\n}\n"}
{"file": "../dafny/Test/unicodechars/comp/CompileWithArguments.dfy", "dafny": "// NONUNIFORM: Multiple testing scenarios, highly backend sensitive, testing CLI\n// Note that C++ is not supported yet\n\n// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %baredafny run %args --unicode-char --no-verify --target:cs \"%s\" Csharp 1 >> \"%t\"\n// RUN: %baredafny run %args --unicode-char --no-verify --target:java \"%s\" -- Java --heya >> \"%t\"\n// RUN: %baredafny run %args --unicode-char --no-verify --target:js \"%s\" -- Javascript 2 >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /unicodeChar:1 /compileTarget:py \"%s\" --args Python 1 >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /unicodeChar:1 /compileTarget:go \"%s\" --args \"Go go\" 1 >> \"%t\"\n// RUN: %baredafny build %args --unicode-char --no-verify --target:cs \"%s\" --output:%s.dll\n// RUN: dotnet %s.dll \"dotnet\" \"howdy\" >> \"%t\"\n// RUN: dotnet %s.dll \"dotnet\" \"hello\" >> \"%t\"\n// RUN: dotnet %s.dll \"dotnet\" \"aloha\" >> \"%t\"\n// RUN: %baredafny build %args --unicode-char --no-verify --target:js \"%s\" --output=%s.js\n// RUN: node %s.js \"javascript\" 2 >> \"%t\"\n// RUN: node %s.js \"javascript\" 1 >> \"%t\"\n// RUN: node %s.js \"javascript\" \"aloha\" >> \"%t\"\n// RUN: %baredafny build %args --unicode-char --no-verify --target:java \"%s\" --output:\"%s.jar\" >> \"%t\"\n// RUN: java -jar \"%s.jar\" Java 2 >> \"%t\"\n// RUN: java -jar \"%s.jar\" Java 1 >> \"%t\"\n// RUN: java -jar \"%s.jar\" Java aloha >> \"%t\"\n// RUN: %baredafny build %args --unicode-char --no-verify --target:py \"%s\" >> \"%t\"\n// RUN: python3 %S/CompileWithArguments-py Python 2 >> \"%t\"\n// RUN: python3 %S/CompileWithArguments-py Python 1 >> \"%t\"\n// RUN: python3 %S/CompileWithArguments-py Python aloha >> \"%t\"\n// RUN: %baredafny build %args --unicode-char --no-verify --target:go \"%s\" >> \"%t\"\n// RUN: env GO111MODULE=auto GOPATH=%S/CompileWithArguments-go go run %S/CompileWithArguments-go/src/CompileWithArguments.go Go 2 >> \"%t\"\n// RUN: env GO111MODULE=auto GOPATH=%S/CompileWithArguments-go go run %S/CompileWithArguments-go/src/CompileWithArguments.go Go 1 >> \"%t\"\n// RUN: env GO111MODULE=auto GOPATH=%S/CompileWithArguments-go go run %S/CompileWithArguments-go/src/CompileWithArguments.go Go aloha >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main(args: seq<string>) {\n  if |args| != 3 {\n    print \"Expected 3 arguments, got \", |args|;\n  } else {\n    print args[1], \" says \";\n    if args[2] == \"1\" {\n      print \"hello\\n\";\n    } else if args[2] == \"2\" {\n      print \"howdy\\n\";\n    } else {\n      print args[2],\"\\n\";\n    }\n  }\n}\n"}
{"file": "../dafny/Test/exceptions/NatOutcomeDt.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// Does not test anything Exceptions-related, but is included by other tests\n\ndatatype NatOutcome =\n| NatSuccess(value: nat)\n| NatFailure(error: string)\n{\n    predicate IsFailure() {\n        this.NatFailure?\n    }\n    function PropagateFailure(): NatOutcome requires IsFailure() {\n        this\n    }\n    function Extract(): nat requires !IsFailure() {\n        this.value\n    }\n}\n"}
{"file": "../dafny/Test/exceptions/NatOutcome.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// Does not test anything Exceptions-related, but is included by other tests\n\ndatatype Option<T> = None | Some(get: T)\n\nfunction Unreachable<R>(): R\n    requires false\n{\n    var o: Option<R> := None;\n    assert o.Some?;\n    o.get\n}\n\ntrait NatOutcome {\n    predicate IsFailure()\n    function PropagateFailure(): NatOutcome requires IsFailure()\n    function Extract(): nat requires !IsFailure()\n}\n\nclass NatSuccess extends NatOutcome {\n    const value: nat\n    constructor(value: nat) {\n        this.value := value;\n    }\n    predicate IsFailure() {\n        false\n    }\n    function PropagateFailure(): NatOutcome requires IsFailure() {\n        Unreachable<NatOutcome>()\n    }\n    function Extract(): nat requires !IsFailure() {\n        value\n    }\n}\n\nclass NatFailure extends NatOutcome {\n    const error: string\n    constructor(error: string) {\n        this.error := error;\n    }\n    predicate IsFailure() {\n        true\n    }\n    function PropagateFailure(): NatOutcome requires IsFailure() {\n        this\n    }\n    function Extract(): nat requires !IsFailure() {\n        Unreachable<nat>()\n    }\n}\n\nmethod MakeNatSuccess(n: nat) returns (res: NatOutcome) {\n    res := new NatSuccess(n);\n}\n\nmethod MakeNatFailure(msg: string) returns (res: NatOutcome) {\n    res := new NatFailure(msg);\n}\n"}
{"file": "../dafny/Test/exceptions/VoidOutcomeDt.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// Does not test anything Exceptions-related, but is included by other tests\n\ndatatype VoidOutcome =\n| VoidSuccess\n| VoidFailure(error: string)\n{\n    predicate IsFailure() {\n        this.VoidFailure?\n    }\n    function PropagateFailure(): VoidOutcome requires IsFailure() {\n        this\n    }\n}\n"}
{"file": "../dafny/Test/exceptions/VoidOutcome.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// Does not test anything Exceptions-related, but is included by other tests\n\ntrait VoidOutcome {\n    predicate IsFailure()\n    function PropagateFailure(): VoidOutcome requires IsFailure()\n}\n\nclass VoidSuccess extends VoidOutcome {\n    constructor() {}\n    predicate IsFailure() {\n        false\n    }\n    function PropagateFailure(): VoidOutcome requires IsFailure() {\n        this\n    }\n}\n\nclass VoidFailure extends VoidOutcome {\n    const error: string\n    constructor(error: string) {\n        this.error := error;\n    }\n    predicate IsFailure() {\n        true\n    }\n    function PropagateFailure(): VoidOutcome requires IsFailure() {\n        this\n    }\n}\n\nmethod MakeVoidSuccess() returns (res: VoidOutcome) {\n    res := new VoidSuccess();\n}\n\nmethod MakeVoidFailure(msg: string) returns (res: VoidOutcome) {\n    res := new VoidFailure(msg);\n}\n"}
{"file": "../dafny/Test/exceptions/GenericOutcomeDt.dfy", "dafny": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// Does not test anything Exceptions-related, but is included by other tests\n\ndatatype Outcome<T> =\n| Success(value: T)\n| Failure(error: string)\n{\n    predicate IsFailure() {\n        this.Failure?\n    }\n    function PropagateFailure<U>(): Outcome<U> requires IsFailure() {\n        Failure(this.error)\n    }\n    function Extract(): T requires !IsFailure() {\n        this.value\n    }\n}\n"}
{"file": "../dafny/Test/dafny1/MatrixFun.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod MirrorImage<T>(m: array2<T>)\n  modifies m\n  ensures forall i,j :: 0 <= i < m.Length0 && 0 <= j < m.Length1 ==>\n            m[i,j] == old(m[i, m.Length1-1-j])\n{\n  var a := 0;\n  while a < m.Length0\n    invariant a <= m.Length0\n    invariant forall i,j :: 0 <= i && i < a && 0 <= j && j < m.Length1 ==>\n                m[i,j] == old(m[i, m.Length1-1-j])\n    invariant forall i,j :: a <= i && i < m.Length0 && 0 <= j && j < m.Length1 ==>\n                m[i,j] == old(m[i,j])\n  {\n    var b := 0;\n    while b < m.Length1 / 2\n      invariant  b <= m.Length1 / 2\n      invariant forall i,j :: 0 <= i && i < a && 0 <= j && j < m.Length1 ==>\n                  m[i,j] == old(m[i, m.Length1-1-j])\n      invariant forall j :: 0 <= j && j < b ==>\n                  m[a,j] == old(m[a, m.Length1-1-j]) &&\n                  old(m[a,j]) == m[a, m.Length1-1-j]\n      invariant forall j :: b <= j && j < m.Length1-b ==> m[a,j] == old(m[a,j])\n      invariant forall i,j :: a+1 <= i && i < m.Length0 && 0 <= j && j < m.Length1 ==>\n                  m[i,j] == old(m[i,j])\n    {\n      m[a, m.Length1-1-b], m[a, b] := m[a, b], m[a, m.Length1-1-b];\n      b := b + 1;\n    }\n    a := a + 1;\n  }\n}\n\nmethod Flip<T>(m: array2<T>)\n  requires m.Length0 == m.Length1\n  modifies m\n  ensures forall i,j :: 0 <= i < m.Length0 && 0 <= j < m.Length1 ==> m[i,j] == old(m[j,i])\n{\n  var N := m.Length0;\n  var a := 0;\n  var b := 1;\n  while a != N\n    invariant a < b <= N || (a == N && b == N+1)\n    invariant forall i,j :: 0 <= i <= j < N ==>\n                if i < a || (i == a && j < b)\n                  then m[i,j] == old(m[j,i]) && m[j,i] == old(m[i,j])\n                  else m[i,j] == old(m[i,j]) && m[j,i] == old(m[j,i])\n    decreases N-a, N-b\n  {\n    if b < N {\n      m[a,b], m[b,a] := m[b,a], m[a,b];\n      b := b + 1;\n    } else {\n      a := a + 1;  b := a + 1;\n    }\n  }\n}\n\nmethod Main()\n{\n  var B := new bool[2,5];\n  B[0,0] := true;  B[0,1] := false;  B[0,2] := false;  B[0,3] := true;  B[0,4] := false;\n  B[1,0] := true;  B[1,1] := true;   B[1,2] := true;   B[1,3] := true;  B[1,4] := false;\n  print \"Before:\\n\";\n  PrintMatrix(B);\n  MirrorImage(B);\n  print \"Mirror image:\\n\";\n  PrintMatrix(B);\n\n  var A := new int[3,3];\n  A[0,0] := 5;  A[0,1] := 7;  A[0,2] := 9;\n  A[1,0] := 6;  A[1,1] := 2;  A[1,2] := 3;\n  A[2,0] := 7;  A[2,1] := 1;  A[2,2] := 0;\n  print \"Before:\\n\";\n  PrintMatrix(A);\n  Flip(A);\n  print \"Flip:\\n\";\n  PrintMatrix(A);\n}\n\nmethod PrintMatrix<T>(m: array2<T>)\n{\n  var i := 0;\n  while i < m.Length0 {\n    var j := 0;\n    while j < m.Length1 {\n      print m[i,j];\n      j := j + 1;\n      if j == m.Length1 {\n        print \"\\n\";\n      } else {\n        print \", \";\n      }\n    }\n    i := i + 1;\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/TerminationDemos.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Example {\n  method M(n: int)\n  {\n    var i := 0;\n    while i < n\n    {\n      i := i + 1;\n    }\n  }\n}\n\n// -----------------------------------\n\nclass Fibonacci {\n  ghost function Fib(n: int): int\n  {\n    if n < 2 then n else Fib(n-2) + Fib(n-1)\n  }\n}\n\n// -----------------------------------\n\nclass Ackermann {\n  ghost function F(m: int, n: int): int\n  {\n    if m <= 0 then\n      n + 1\n    else if n <= 0 then\n      F(m - 1, 1)\n    else\n      F(m - 1, F(m, n - 1))\n  }\n\n  ghost function G(m: int, n: int): int\n    requires 0 <= m && 0 <= n\n    ensures 0 <= G(m, n)\n  {\n    if m == 0 then\n      n + 1\n    else if n == 0 then\n      G(m - 1, 1)\n    else\n      G(m - 1, G(m, n - 1))\n  }\n\n  ghost function H(m: nat, n: nat): nat\n  {\n    if m == 0 then\n      n + 1\n    else if n == 0 then\n      H(m - 1, 1)\n    else\n      H(m - 1, H(m, n - 1))\n  }\n\n  method ComputeAck(m: nat, n: nat) returns (r: nat)\n  {\n    if m == 0 {\n      r := n + 1;\n    } else if n == 0 {\n      r := ComputeAck(m - 1, 1);\n    } else {\n      var s := ComputeAck(m, n - 1);\n      r := ComputeAck(m - 1, s);\n    }\n  }\n}\n\n// -----------------------------------\n\nclass List {\n  var data: int\n  var next: List?\n  ghost var ListNodes: set<List>\n  ghost predicate IsAcyclic()\n    reads *\n    decreases ListNodes\n  {\n    this in ListNodes &&\n    (next != null ==>\n      next.ListNodes <= ListNodes && this !in next.ListNodes &&\n      next.IsAcyclic())\n  }\n\n  method Singleton(x: int) returns (list: List)\n    ensures list.IsAcyclic()\n  {\n    list := new List;\n    list.data := x;\n    list.next := null;\n    list.ListNodes := {list};\n  }\n\n  method Prepend(x: int, tail: List?) returns (list: List)\n    requires tail == null || tail.IsAcyclic()\n    ensures list.IsAcyclic()\n  {\n    list := new List;\n    list.data := x;\n    list.next := tail;\n    list.ListNodes := if tail == null then {list} else {list} + tail.ListNodes;\n  }\n\n  ghost function Sum(): int\n    requires IsAcyclic()\n    reads *\n    decreases ListNodes\n  {\n    if next == null then data else data + next.Sum()\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/SeparationLogicList.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file contains three variations of the separation-logic lseg linked-list example.\n\n// In this first variation, the auxiliary information about the contents represented by a linked list\n// and the subpart of the heap that the list occupies is passed around as additional parameters.  In\n// separation logic, the contents (here called 'q') would indeed be passed around in that way, whereas\n// separating conjunction and the abstract predicate ListSegment would take care of staking out which\n// subpart of the heap is being occupied by the linked-list representation.\nclass Node<T(0)> {\n  var data: T\n  var next: Node?<T>\n\n  static ghost predicate ListSegment(q: seq<T>, from: Node?<T>, to: Node?<T>, S: set<Node<T>>)\n    reads S\n  {\n    if q == []\n    then from == to\n    else from != null && from in S && from.data == q[0] && ListSegment(q[1..], from.next, to, S - {from})\n  }\n\n  static method Create(x: T) returns (l: Node<T>, ghost S: set<Node<T>>)\n    ensures ListSegment([x], l, null, S) && fresh(S);\n  {\n    // By using the following non-deterministic 'if' statement, the example shows that 'Create' can be\n    // implemented either directly or by call 'Cons'.\n    if (*) {\n      l := new Node<T>;\n      l.data := x;\n      l.next := null;\n      S := {l};\n    } else {\n      l, S := Cons(x, null, [], {});\n    }\n  }\n\n  static method Cons(x: T, tail: Node?<T>, ghost q: seq<T>, ghost S: set<Node<T>>) returns (l: Node<T>, ghost U: set<Node<T>>)\n    requires ListSegment(q, tail, null, S);\n    ensures ListSegment([x] + q, l, null, U) && fresh(U - S);\n  {\n    l := new Node<T>;\n    l.data := x;\n    l.next := tail;\n    U := S + {l};\n  }\n}\n\n// The following class is a variation of the one above.  The difference is that, in this one, each node\n// keeps track of its own contents (called 'q' above) and representation (called 'S' and 'U' above).\nclass ListNode<T(0)> {\n  ghost var Contents: seq<T>\n  ghost var Repr: set<ListNode<T>>\n\n  var data: T\n  var next: ListNode?<T>\n\n  static ghost predicate IsList(l: ListNode?<T>)\n    reads l, if l != null then l.Repr else {}\n  {\n    if l == null then\n      true\n    else if l.next == null then\n      l in l.Repr && l.Contents == [l.data]\n    else\n      {l, l.next} <= l.Repr && l.Contents == [l.data] + l.next.Contents && l.next.Repr <= l.Repr - {l} && IsList(l.next)\n  }\n\n  static method Create(x: T) returns (l: ListNode<T>)\n    ensures IsList(l) && l.Contents == [x] && fresh({l} + l.Repr);\n  {\n    // By using the following non-deterministic 'if' statement, the example shows that 'Create' can be\n    // implemented either directly or by call 'Cons'.\n    if (*) {\n      l := new ListNode<T>;\n      l.data := x;\n      l.next := null;\n      l.Repr := {l};\n      l.Contents := [x];\n    } else {\n      l := Cons(x, null);\n    }\n  }\n\n  static method Cons(x: T, tail: ListNode?<T>) returns (l: ListNode<T>)\n    requires IsList(tail)\n    ensures IsList(l)\n    ensures tail == null ==> l.Contents == [x] && fresh({l} + l.Repr)\n    ensures tail != null ==> l.Contents == [x] + tail.Contents && fresh({l} + l.Repr - tail.Repr)\n  {\n    l := new ListNode<T>;\n    l.data := x;\n    l.next := tail;\n    if tail != null {\n      l.Repr := tail.Repr + {l};\n      l.Contents := [x] + tail.Contents;\n    } else {\n      l.Repr := {l};\n      l.Contents := [x];\n    }\n  }\n}\n\n// In this final variation, a list, empty or not, is represented by a List object.  The representation\n// of a List object includes a number of linked-list nodes.  To make the treatment of the empty list\n// nicer than in the class above, the List object starts its list with a sentinel object whose 'data'\n// field is not used.\nclass List<T(0)>\n{\n  ghost var Contents: seq<T>\n  ghost var Repr: set<object>\n  var head: LLNode<T>\n\n  ghost predicate IsList()\n    reads this, Repr\n  {\n    this in Repr && head in Repr &&\n    head.Repr <= Repr && this !in head.Repr && head.IsWellFormed() &&\n    Contents == head.TailContents\n  }\n\n  constructor Init()\n    ensures IsList() && Contents == [] && fresh(Repr)\n  {\n    var h: LLNode<T> := new LLNode<T>;\n    h.next := null;\n    h.TailContents := [];\n    h.Repr := {h};\n\n    head := h;\n    Contents := [];\n    Repr := {this} + h.Repr;\n  }\n\n  method Cons(x: T)\n    requires IsList()\n    modifies Repr\n    ensures IsList() && Contents == [x] + old(Contents) && fresh(Repr - old(Repr))\n  {\n    head.data := x;\n    assert head.IsWellFormed();  // head remains well-formed even after assigning to an object (namely, head) in head.Repr\n\n    var h: LLNode<T> := new LLNode<T>;\n    h.next := head;\n    h.TailContents := [x] + head.TailContents;\n    h.Repr := {h} + head.Repr;\n\n    head := h;\n    Contents := [x] + Contents;\n    Repr := Repr + {h};\n  }\n}\n\nclass LLNode<T(0)>\n{\n  var data: T\n  var next: LLNode?<T>\n  ghost var TailContents: seq<T>\n  ghost var Repr: set<object>\n\n  ghost predicate IsWellFormed()\n    reads this, Repr\n  {\n    this in Repr &&\n    (next == null ==> TailContents == []) &&\n    (next != null ==>\n      next in Repr &&\n      next.Repr <= Repr && this !in next.Repr && next.IsWellFormed() &&\n      TailContents == [next.data] + next.TailContents)\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/KatzManna.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod NinetyOne(x: int, ghost proveFunctionalPostcondition: bool) returns (z: int)\n  ensures proveFunctionalPostcondition ==> z == if x > 101 then x-10 else 91\n{\n  var y1 := x;\n  var y2 := 1;\n  while (true)\n    // the following two invariants are needed only to prove the postcondition\n    invariant proveFunctionalPostcondition ==> 100 < x ==> y1 == x\n    invariant proveFunctionalPostcondition ==> x <= 100 < y1 && y2 == 1 ==> y1 == 101\n    // the following two lines justify termination, as in the paper by Katz and Manna\n    invariant (y1 <= 111 && y2 >= 1) || (y1 == x && y2 == 1)\n    decreases -2*y1 + 21*y2 + 2*(if x < 111 then 111 else x)\n  {\n    if (y1 > 100) {\n      if (y2 == 1) {\n        break;\n      } else {\n        y1 := y1 - 10;\n        y2 := y2 - 1;\n      }\n    } else {\n      y1 := y1 + 11;\n      y2 := y2 + 1;\n    }\n  }\n  z := y1 - 10;\n}\n\nmethod Gcd(x1: int, x2: int)\n  requires 1 <= x1 && 1 <= x2\n{\n  var y1 := x1;\n  var y2 := x2;\n  while (y1 != y2)\n    invariant 1 <= y1 && 1 <= y2\n    decreases y1 + y2\n  {\n    while (y1 > y2)\n      invariant 1 <= y1 && 1 <= y2\n    {\n      y1 := y1 - y2;\n    }\n    while (y2 > y1)\n      invariant 1 <= y1 && 1 <= y2\n    {\n      y2 := y2 - y1;\n    }\n  }\n}\n\nmethod Determinant(X: array2<int>, M: int) returns (z: int)\n  requires 1 <= M\n  requires M == X.Length0 && M == X.Length1\n  modifies X\n{\n  var y := X[1-1,1-1];\n  var a := 1;\n  while (a != M)\n    invariant 1 <= a <= M\n  {\n    var b := a + 1;\n    while (b != M+1)\n      invariant a+1 <= b <= M+1\n    {\n      var c := M;\n      while (c != a)\n        invariant a <= c <= M\n      {\n        assume X[a-1,a-1] != 0;\n        X[b-1, c-1] := X[b-1,c-1] - X[b-1,a-1] / X[a-1,a-1] * X[a-1,c-1];\n        c := c - 1;\n      }\n      b := b + 1;\n    }\n    a := a + 1;\n    y := y * X[a-1,a-1];\n  }\n  z := y;\n}\n"}
{"file": "../dafny/Test/dafny1/FindZero.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod FindZero(a: array<int>) returns (r: int)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i];\n  requires forall i :: 0 <= i && i+1 < a.Length ==> a[i]-1 <= a[i+1];\n  ensures 0 <= r ==> r < a.Length && a[r] == 0;\n  ensures r < 0 ==> forall i :: 0 <= i < a.Length ==> a[i] != 0;\n{\n  var n := 0;\n  while (n < a.Length)\n    invariant forall i :: 0 <= i < n && i < a.Length ==> a[i] != 0;\n  {\n    if (a[n] == 0) { r := n; return; }\n    Lemma(a, n, a[n]);\n    n := n + a[n];\n  }\n  r := -1;\n}\n\nlemma Lemma(a: array<int>, k: int, m: int)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i];\n  requires forall i :: 0 <= i && i+1 < a.Length ==> a[i]-1 <= a[i+1];\n  requires 0 <= k;\n  requires k < a.Length ==> m <= a[k];\n  ensures forall i :: k <= i < k+m && i < a.Length ==> a[i] != 0;\n  decreases m;\n{\n  if (0 < m && k < a.Length) {\n    assert a[k] != 0;\n    Lemma(a, k+1, m-1);\n  }\n}\n\n// -----------------------------------------------------------------\n\nmethod FindZero_GhostLoop(a: array<int>) returns (r: int)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i];\n  requires forall i :: 0 <= i && i+1 < a.Length ==> a[i]-1 <= a[i+1];\n  ensures 0 <= r ==> r < a.Length && a[r] == 0;\n  ensures r < 0 ==> forall i :: 0 <= i < a.Length ==> a[i] != 0;\n{\n  var n := 0;\n  while (n < a.Length)\n    invariant forall i :: 0 <= i < n && i < a.Length ==> a[i] != 0;\n  {\n    if (a[n] == 0) { return n; }\n    ghost var m := n;\n    while (m < n + a[n])\n      invariant m <= n + a[n] && m < a.Length;\n      invariant n + a[n] - m <= a[m];\n      invariant forall i :: 0 <= i < m && i < a.Length ==> a[i] != 0;\n    {\n      m := m + 1;\n      if (m == a.Length) { break; }\n    }\n    n := n + a[n];\n  }\n  return -1;\n}\n\n// -----------------------------------------------------------------\n\nmethod FindZero_Assert(a: array<int>) returns (r: int)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i];\n  requires forall i {:nowarn} {:matchinglooprewrite false}:: 0 <= i-1 && i < a.Length ==> a[i-1]-1 <= a[i];\n  ensures 0 <= r ==> r < a.Length && a[r] == 0;\n  ensures r < 0 ==> forall i :: 0 <= i < a.Length ==> a[i] != 0;\n{\n  var n := 0;\n  while (n < a.Length)\n    invariant forall i :: 0 <= i < n && i < a.Length ==> a[i] != 0;\n  {\n    if (a[n] == 0) { return n; }\n    assert forall m {:induction} :: n <= m < n + a[n] && m < a.Length ==> n+a[n]-m <= a[m];\n    n := n + a[n];\n  }\n  return -1;\n}\n"}
{"file": "../dafny/Test/dafny1/PriorityQueue.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass PriorityQueue {\n  var N: nat  // capacity\n  var n: nat  // current size\n  ghost var Repr: set<object>  // set of objects that make up the representation of a PriorityQueue\n\n  var a: array<int>  // private implementation of PriorityQueue\n\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    MostlyValid() &&\n    forall j :: 2 <= j <= n ==> a[j/2] <= a[j]\n  }\n\n  ghost predicate MostlyValid()\n    reads this, Repr\n  {\n    this in Repr && a in Repr &&\n    a.Length == N+1 &&\n    0 <= n <= N\n  }\n\n  constructor Init(capacity: nat)\n    ensures Valid() && fresh(Repr)\n    ensures N == capacity\n  {\n    N := capacity;\n    a := new int[capacity + 1];\n    n := 0;\n    Repr := {this, a};\n  }\n\n  method Insert(x: int)\n    requires Valid() && n < N\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures n == old(n) + 1 && N == old(N)\n  {\n    n := n + 1;\n    a[n] := x;\n    SiftUp(n);\n  }\n\n  method SiftUp(k: int)\n    requires 1 <= k <= n\n    requires MostlyValid()\n    requires forall j :: 2 <= j <= n && j != k ==> a[j/2] <= a[j]\n    requires forall j :: 1 <= j <= n ==> j/2 != k  // k is a leaf\n    modifies a\n    ensures Valid()\n  {\n    var i := k;\n    assert MostlyValid();\n    while 1 < i\n      invariant i <= k && MostlyValid()\n      invariant forall j :: 2 <= j <= n && j != i ==> a[j/2] <= a[j]\n      invariant forall j :: 1 <= j/2/2 && j/2 == i && j <= n ==> a[j/2/2] <= a[j]\n    {\n      if a[i/2] <= a[i] {\n        return;\n      }\n      a[i/2], a[i] := a[i], a[i/2];\n      i := i / 2;\n    }\n  }\n\n  method RemoveMin() returns (x: int)\n    requires Valid() && 1 <= n\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures n == old(n) - 1\n  {\n    x := a[1];\n    a[1] := a[n];\n    n := n - 1;\n    SiftDown(1);\n  }\n\n  method SiftDown(k: int)\n    requires 1 <= k\n    requires MostlyValid()\n    requires forall j :: 2 <= j <= n && j/2 != k ==> a[j/2] <= a[j]\n    requires forall j :: 2 <= j <= n && 1 <= j/2/2 != k ==> a[j/2/2] <= a[j]\n    // Alternatively, the line above can be expressed as:\n    //     requires forall j :: 1 <= k/2 && j/2 == k && j <= n ==> a[j/2/2] <= a[j]\n    modifies a\n    ensures Valid()\n  {\n    var i := k;\n    while 2*i <= n  // while i is not a leaf\n      invariant 1 <= i && MostlyValid()\n      invariant forall j :: 2 <= j <= n && j/2 != i ==> a[j/2] <= a[j]\n      invariant forall j :: 2 <= j <= n && 1 <= j/2/2 != i ==> a[j/2/2] <= a[j]\n    {\n      var smallestChild;\n      if 2*i + 1 <= n && a[2*i + 1] < a[2*i] {\n        smallestChild := 2*i + 1;\n      } else {\n        smallestChild := 2*i;\n      }\n      if a[i] <= a[smallestChild] {\n        return;\n      }\n      a[smallestChild], a[i] := a[i], a[smallestChild];\n      i := smallestChild;\n      assert 1 <= i/2/2 ==> a[i/2/2] <= a[i];\n    }\n  }\n}\n\n// ---------- Alternative specifications ----------\n\nclass PriorityQueue_Alternative {\n  var N: nat  // capacity\n  var n: nat  // current size\n  ghost var Repr: set<object>  // set of objects that make up the representation of a PriorityQueue\n\n  var a: array<int>  // private implementation of PriorityQueue\n\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    MostlyValid() &&\n    forall j :: 2 <= j <= n ==> a[j/2] <= a[j]\n  }\n\n  ghost predicate MostlyValid()\n    reads this, Repr\n  {\n    this in Repr && a in Repr &&\n    a.Length == N+1 &&\n    0 <= n && n <= N\n  }\n\n  constructor Init(capacity: nat)\n    ensures Valid() && fresh(Repr)\n    ensures N == capacity\n  {\n    N := capacity;\n    a := new int[capacity + 1];\n    n := 0;\n    Repr := {this, a};\n  }\n\n  method Insert(x: int)\n    requires Valid() && n < N\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures n == old(n) + 1 && N == old(N)\n  {\n    n := n + 1;\n    a[n] := x;\n    SiftUp();\n  }\n\n  method SiftUp()\n    requires MostlyValid()\n    requires forall j :: 2 <= j <= n && j != n ==> a[j/2] <= a[j]\n    modifies a\n    ensures Valid()\n  {\n    var i := n;\n    assert MostlyValid();\n    while 1 < i\n      invariant i <= n && MostlyValid()\n      invariant forall j :: 2 <= j <= n && j != i ==> a[j/2] <= a[j]\n      invariant forall j :: 1 <= j/2/2 && j/2 == i && j <= n ==> a[j/2/2] <= a[j]\n    {\n      if a[i/2] <= a[i] {\n        return;\n      }\n      a[i/2], a[i] := a[i], a[i/2];\n      i := i / 2;\n    }\n  }\n\n  method RemoveMin() returns (x: int)\n    requires Valid() && 1 <= n\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures n == old(n) - 1\n  {\n    x := a[1];\n    a[1] := a[n];\n    n := n - 1;\n    SiftDown();\n  }\n\n  method SiftDown()\n    requires MostlyValid()\n    requires forall j :: 4 <= j <= n ==> a[j/2] <= a[j]\n    modifies a\n    ensures Valid()\n  {\n    var i := 1;\n    while 2*i <= n  // while i is not a leaf\n      invariant 1 <= i && MostlyValid()\n      invariant forall j :: 2 <= j <= n && j/2 != i ==> a[j/2] <= a[j]\n      invariant forall j :: 1 <= j/2/2 && j/2 == i && j <= n ==> a[j/2/2] <= a[j]\n    {\n      var smallestChild;\n      if 2*i + 1 <= n && a[2*i + 1] < a[2*i] {\n        smallestChild := 2*i + 1;\n      } else {\n        smallestChild := 2*i;\n      }\n      if a[i] <= a[smallestChild] {\n        return;\n      }\n      a[smallestChild], a[i] := a[i], a[smallestChild];\n      i := smallestChild;\n      assert 1 <= i/2/2 ==> a[i/2/2] <= a[i];\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/pow2.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This is a Dafny adaptation of a Coq program by David Pichardie.\n\nghost function IsEven(n: int): bool\n  requires 0 <= n;\n  ensures IsEven(n) ==> n == (n/2)+(n/2);\n{\n  (n/2)*2 == n\n}\n\nghost function Square(n: int): int { n * n }\n\nghost function pow2(n: int): int\n  requires 0 <= n;\n  ensures 0 <= pow2(n);\n{\n  if n == 0 then\n    1\n  else if IsEven(n) then\n    Square(pow2(n / 2))\n  else\n    2*pow2(n-1)\n\n}\n\nghost function pow2_slow(n: int): int\n  requires 0 <= n;\n{\n  if n == 0 then\n    1\n  else\n    2*pow2_slow(n-1)\n}\n\nlemma Lemma(n: int)\n  requires 0 <= n && IsEven(n);\n  ensures pow2_slow(n) == Square(pow2_slow(n/2));\n{\n  if n != 0 {\n    Lemma(n-2);\n  }\n}\n\nlemma Theorem(n: int)\n  requires 0 <= n;\n  ensures pow2(n) == pow2_slow(n);\n{\n  if n == 0 {\n  } else if (IsEven(n)) {\n    Lemma(n);\n    Theorem(n/2);\n  } else {\n    Theorem(n-1);\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/ListContents.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Node<T> {\n  ghost var List: seq<T>\n  ghost var Repr: set<Node<T>>\n\n  var data: T\n  var next: Node?<T>\n\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    (next == null ==> List == [data]) &&\n    (next != null ==>\n        next in Repr && next.Repr <= Repr &&\n        this !in next.Repr &&\n        List == [data] + next.List &&\n        next.Valid())\n  }\n\n  constructor (d: T)\n    ensures Valid() && fresh(Repr)\n    ensures List == [d]\n  {\n    data, next := d, null;\n    List, Repr := [d], {this};\n  }\n\n  constructor InitAsPredecessor(d: T, succ: Node<T>)\n    requires succ.Valid()\n    ensures Valid() && fresh(Repr - succ.Repr)\n    ensures List == [d] + succ.List\n  {\n    data, next := d, succ;\n    List := [d] + succ.List;\n    Repr := {this} + succ.Repr;\n  }\n\n  method Prepend(d: T) returns (r: Node<T>)\n    requires Valid()\n    ensures r.Valid() && fresh(r.Repr - old(Repr))\n    ensures r.List == [d] + List\n  {\n    r := new Node.InitAsPredecessor(d, this);\n  }\n\n  method SkipHead() returns (r: Node?<T>)\n    requires Valid()\n    ensures r == null ==> |List| == 1\n    ensures r != null ==> r.Valid() && r.List == List[1..] && r.Repr <= Repr\n  {\n    r := next;\n  }\n\n  method ReverseInPlace() returns (reverse: Node<T>)\n    requires Valid()\n    modifies Repr\n    ensures reverse.Valid() && reverse.Repr <= old(Repr)\n    ensures |reverse.List| == |old(List)|\n    ensures forall i :: 0 <= i < |reverse.List| ==> reverse.List[i] == old(List)[|old(List)|-1-i]\n  {\n    var current := next;\n    reverse := this;\n    reverse.next := null;\n    reverse.Repr := {reverse};\n    reverse.List := [data];\n\n    while current != null\n      invariant reverse.Valid() && reverse.Repr <= old(Repr)\n      invariant current == null ==> |old(List)| == |reverse.List|\n      invariant current != null ==>\n        current.Valid() &&\n        current in old(Repr) && current.Repr <= old(Repr) &&\n        current.Repr !! reverse.Repr\n      invariant current != null ==>\n        |old(List)| == |reverse.List| + |current.List| &&\n        current.List == old(List)[|reverse.List|..]\n      invariant forall i :: 0 <= i < |reverse.List| ==> reverse.List[i] == old(List)[|reverse.List|-1-i]\n      decreases if current != null then |current.List| else -1\n    {\n      var nx := current.next;\n\n      // ..., reverse, current, nx, ...\n      current.next := reverse;\n      current.Repr := {current} + reverse.Repr;\n      current.List := [current.data] + reverse.List;\n\n      reverse := current;\n      current := nx;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/Celebrity.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Celebrity example, inspired by the Rodin tutorial\n\npredicate Knows<X>(a: X, b: X)\n  requires a != b  // forbid asking about the reflexive case\n\nghost predicate IsCelebrity<Y>(c: Y, people: set<Y>)\n{\n  c in people &&\n  forall p :: p in people && p != c ==> Knows(p, c) && !Knows(c, p)\n}\n\nmethod FindCelebrity0<Z>(people: set<Z>, ghost c: Z) returns (r: Z)\n  requires exists c :: IsCelebrity(c, people)\n  ensures r == c\n{\n  var cc :| assume cc == c;  // this line essentially converts ghost c to non-ghost cc\n  r := cc;\n}\n\nmethod FindCelebrity1<W>(people: set<W>, ghost c: W) returns (r: W)\n  requires IsCelebrity(c, people)\n  ensures r == c\n{\n  var Q := people;\n  var x :| x in Q;\n  while Q != {x}\n    //invariant Q <= people  // inv1 in Rodin's Celebrity_1, but it's not needed here\n    invariant IsCelebrity(c, Q)  // inv2\n    invariant x in Q\n    decreases Q\n  {\n    var y :| y in Q - {x};\n    if (Knows(x, y)) {\n      Q := Q - {x};  // remove_1\n    } else {\n      Q := Q - {y};  assert x in Q;  // remove_2\n    }\n    x :| x in Q;\n  }\n  r := x;\n}\n\nmethod FindCelebrity2<V>(people: set<V>, ghost c: V) returns (r: V)\n  requires IsCelebrity(c, people)\n  ensures r == c\n{\n  var b :| b in people;\n  var R := people - {b};\n  while R != {}\n    invariant R <= people  // inv1\n    invariant b in people  // inv2\n    invariant b !in R  // inv3\n    invariant IsCelebrity(c, R + {b})  // my non-refinement way of saying inv4\n    decreases R\n  {\n    var x :| x in R;\n    if Knows(x, b) {\n      R := R - {x};\n    } else {\n      b := x;\n      R := R - {x};\n    }\n  }\n  r := b;\n}\n\nmethod FindCelebrity3(n: int, people: set<int>, ghost c: int) returns (r: int)\n  requires 0 < n\n  requires forall p :: p in people <==> 0 <= p && p < n\n  requires IsCelebrity(c, people)\n  ensures r == c\n{\n  r := 0;\n  var a := 1;\n  var b := 0;\n  while a < n\n    invariant a <= n\n    invariant b < a  // Celebrity_2/inv3 and Celebrity_3/inv2\n    invariant c == b || (a <= c && c < n)\n  {\n    if Knows(a, b) {\n      a := a + 1;\n    } else {\n      b := a;\n      a := a + 1;\n    }\n  }\n  r := b;\n}\n"}
{"file": "../dafny/Test/dafny1/BDD.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule SimpleBDD\n{\n  class BDDNode\n  {\n    static ghost predicate bitfunc(f: map<seq<bool>, bool>, n: nat)\n    {\n       forall i:seq<bool> :: i in f <==> |i| == n\n    }\n    ghost var Contents: map<seq<bool>, bool>\n    ghost var Repr: set<object>\n    ghost var n: nat\n    var f: BDDNode?, t: BDDNode?\n    var b: bool\n    ghost predicate valid()\n      reads this, Repr\n    {\n      bitfunc(Contents,n) &&\n      (0 == n ==> (b <==> Contents[[]])) &&\n      (0 < n ==>\n        this in Repr &&\n        f != null && t != null && t in Repr && f in Repr &&\n        t.Repr <= Repr && f.Repr <= Repr &&\n        this !in f.Repr && this !in t.Repr &&\n        t.valid() && f.valid() &&\n        t.n == f.n == n-1 &&\n        (forall s | s in t.Contents :: Contents[[true]  + s] <==> t.Contents[s]) &&\n        (forall s | s in f.Contents :: Contents[[false] + s] <==> f.Contents[s]))\n    }\n  }\n  class BDD\n  {\n    var root: BDDNode\n    ghost predicate valid()\n      reads this, Repr\n    {\n      root in Repr && root.Repr <= Repr && root.valid() &&\n      n == root.n && Contents == root.Contents\n    }\n    constructor () {\n      root := new BDDNode;\n    }\n\n    ghost var Contents: map<seq<bool>, bool>\n    var n: nat\n    ghost var Repr: set<object>\n\n    method Eval(s: seq<bool>) returns(b: bool)\n      requires valid() && |s| == n\n      ensures b == Contents[s]\n    {\n      var node: BDDNode := root;\n      var i := n;\n      assert s[n-i..] == s;\n      while i > 0\n        invariant node.valid()\n        invariant 0 <= i == node.n <= n\n        invariant Contents[s] == node.Contents[s[n-i..]]\n      {\n        assert s[n-i..] == [s[n-i]] + s[n-i+1..];\n        node := if s[n-i] then node.t else node.f;\n        i := i - 1;\n      }\n      assert s[n-i..] == [];\n      b := node.b;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/Cubes.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Cubes(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == i*i*i\n{\n  var n := 0;\n  var c := 0;\n  var k := 1;\n  var m := 6;\n  while n < a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> a[i] == i*i*i\n    invariant c == n*n*n\n    invariant k == 3*n*n + 3*n + 1\n    invariant m == 6*n + 6\n  {\n    a[n] := c;\n    c := c + k;\n    k := k + m;\n    m := m + 6;\n    n := n + 1;\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/SumOfCubes.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass SumOfCubes {\n  static ghost function SumEmUp(n: int, m: int): int\n    requires 0 <= n && n <= m;\n    decreases m - n;\n  {\n    if m == n then 0 else n*n*n + SumEmUp(n+1, m)\n  }\n\n  static method Socu(n: int, m: int) returns (r: int)\n    requires 0 <= n && n <= m;\n    ensures r == SumEmUp(n, m);\n  {\n    var a := SocuFromZero(m);\n    var b := SocuFromZero(n);\n    r := a - b;\n    Lemma0(n, m);\n  }\n\n  static method SocuFromZero(k: int) returns (r: int)\n    requires 0 <= k;\n    ensures r == SumEmUp(0, k);\n  {\n    var g := Gauss(k);\n    r := g * g;\n    Lemma1(k);\n  }\n\n  ghost static method Lemma0(n: int, m: int)\n    requires 0 <= n && n <= m;\n    ensures SumEmUp(n, m) == SumEmUp(0, m) - SumEmUp(0, n);\n  {\n    var k := n;\n    while (k < m)\n      invariant n <= k && k <= m;\n      invariant SumEmDown(0, n) + SumEmDown(n, k) == SumEmDown(0, k);\n    {\n      k := k + 1;\n    }\n    Lemma3(0, n);\n    Lemma3(n, k);\n    Lemma3(0, k);\n  }\n\n  static ghost function GSum(k: int): int\n    requires 0 <= k;\n  {\n    if k == 0 then 0 else GSum(k-1) + k-1\n  }\n\n  static method Gauss(k: int) returns (r: int)\n    requires 0 <= k;\n    ensures r == GSum(k);\n  {\n    r := k * (k - 1) / 2;\n    Lemma2(k);\n  }\n\n  ghost static method Lemma1(k: int)\n    requires 0 <= k;\n    ensures SumEmUp(0, k) == GSum(k) * GSum(k);\n  {\n    var i := 0;\n    while (i < k)\n      invariant i <= k;\n      invariant SumEmDown(0, i) == GSum(i) * GSum(i);\n    {\n      Lemma2(i);\n      i := i + 1;\n    }\n    Lemma3(0, k);\n  }\n\n  ghost static method Lemma2(k: int)\n    requires 0 <= k;\n    ensures 2 * GSum(k) == k * (k - 1);\n  {\n    var i := 0;\n    while (i < k)\n      invariant i <= k;\n      invariant 2 * GSum(i) == i * (i - 1);\n    {\n      i := i + 1;\n    }\n  }\n\n  static ghost function SumEmDown(n: int, m: int): int\n    requires 0 <= n && n <= m;\n  {\n    if m == n then 0 else SumEmDown(n, m-1) + (m-1)*(m-1)*(m-1)\n  }\n\n  ghost static method Lemma3(n: int, m: int)\n    requires 0 <= n && n <= m;\n    ensures SumEmUp(n, m) == SumEmDown(n, m);\n  {\n    var k := n;\n    while (k < m)\n      invariant n <= k && k <= m;\n      invariant SumEmUp(n, m) == SumEmDown(n, k) + SumEmUp(k, m);\n    {\n      k := k + 1;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/UltraFilter.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// ultra filter\n\ntype G(==)\n\nghost predicate IsFilter(f: set<set<G>>, S: set<G>)\n{\n  (forall A, B :: A in f && A <= B ==> B in f) &&\n  (forall C, D :: C in f && D in f ==> C * D in f) &&\n  S in f &&\n  {} !in f\n}\n\nghost predicate IsUltraFilter(f: set<set<G>>, S: set<G>)\n{\n  IsFilter(f, S) &&\n  (forall g :: IsFilter(g, S) && f <= g ==> f == g)\n}\n\nlemma Theorem(f: set<set<G>>, S: set<G>, M: set<G>, N: set<G>)\n  requires IsUltraFilter(f, S)\n  requires M + N in f\n  ensures M in f || N in f\n{\n  if M !in f {\n    // instantiate 'g' with the following 'h'\n    var h := H(f, S, M);\n    Lemma_HIsFilter(h, f, S, M);\n    Lemma_FHOrdering(h, f, S, M);\n  }\n}\n\n// H is really just a name for a set comprehension\nlemma H(f: set<set<G>>, S: set<G>, M: set<G>) returns (h: set<set<G>>)\n  ensures forall X :: X in h <==> M + X in f\n{\n  h := set X,Y | Y in f && X <= Y && M + X == Y :: X;\n  forall X {\n    calc {\n      X in h;\n      exists Y :: Y in f && X <= Y && M + X == Y;\n      M + X in f;\n    }\n  }\n}\n\nlemma Lemma_HIsFilter(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)\n  requires IsFilter(f, S)\n  requires forall X :: X in h <==> M + X in f\n  requires M !in f\n  ensures IsFilter(h, S)\n{\n  forall A, B | A in h && A <= B\n    ensures B in h\n  {\n    assert M + A <= M + B;\n  }\n\n  forall C, D | C in h && D in h\n    ensures C * D in h\n  {\n    assert (M + C) * (M + D) == M + (C * D);\n  }\n\n  Lemma_H2(h, f, S, M);\n\n  Lemma_H3(h, f, S, M);\n}\n\nlemma Lemma_H2(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)\n  requires IsFilter(f, S)\n  requires forall X :: X in h <==> M + X in f\n  ensures S in h\n{\n  // S is intended to stand for the universal set, but this is the only place where that plays a role\n  assume M <= S;\n\n  assert M + S == S;\n}\n\nlemma Lemma_H3(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)\n  requires IsFilter(f, S)\n  requires forall X :: X in h <==> M + X in f\n  requires M !in f\n  ensures {} !in h\n{\n  assert M + {} == M;\n}\n\nlemma Lemma_FHOrdering(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)\n  requires IsFilter(f, S)\n  requires forall X :: X in h <==> M + X in f\n  requires IsFilter(h, S)\n  ensures f <= h\n{\n  forall Y | Y in f\n    ensures Y in h\n  {\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/UnboundedStack.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass UnboundedStack<T> {\n  ghost var representation: set<object>\n  ghost var content: seq<T>\n  var top: Node?<T>\n\n  ghost predicate IsUnboundedStack()\n    reads this, representation\n  {\n    this in representation &&\n    (top == null ==>\n      content == []) &&\n    (top != null ==>\n      top in representation && this !in top.footprint && top.footprint <= representation &&\n      content == top.content &&\n      top.Valid())\n  }\n\n  method InitUnboundedStack()\n    modifies this\n    ensures IsUnboundedStack()\n    ensures content == []\n  {\n    this.top := null;\n    this.content := [];\n    this.representation := {this};\n  }\n\n  method Push(val: T)\n    requires IsUnboundedStack()\n    modifies this\n    ensures IsUnboundedStack()\n    ensures content == [val] + old(content)\n  {\n    top := new Node<T>.InitNode(val,top);\n    representation := representation + top.footprint;\n    content := [val] + content;\n  }\n\n  method Pop() returns (result: T)\n    requires IsUnboundedStack()\n    requires content != []\n    modifies this\n    ensures IsUnboundedStack()\n    ensures content == old(content)[1..]\n  {\n    result := top.val;\n    top := top.next;\n    content := content[1..];\n  }\n\n  method isEmpty() returns (result: bool)\n    requires IsUnboundedStack()\n    ensures result <==> content == []\n  {\n    result := top == null;\n  }\n}\n\nclass Node<T> {\n  ghost var footprint: set<object>\n  ghost var content: seq<T>\n  var val: T\n  var next: Node?<T>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint &&\n    (next == null ==>\n      content == [val]) &&\n    (next != null ==>\n      next in footprint && next.footprint <= footprint && this !in next.footprint &&\n      content == [val] + next.content &&\n      next.Valid())\n  }\n\n  constructor InitNode(val: T, next: Node?<T>)\n    requires next != null ==> next.Valid()\n    ensures Valid()\n    ensures next != null ==> content == [val] + next.content &&\n                             footprint == {this} + next.footprint\n    ensures next == null ==> content == [val] &&\n                             footprint == {this}\n  {\n    this.val := val;\n    this.next := next;\n    if next == null {\n      this.footprint := {this};\n      this.content := [val];\n    } else {\n      this.footprint := {this} + next.footprint;\n      this.content := [val] + next.content;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny1/TreeDatatype.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// ------------------ generic list, non-generic tree\n\ndatatype List<T> = Nil | Cons(T, List<T>)\n\ndatatype Tree = Node(int, List<Tree>)\n\nghost function Inc(t: Tree): Tree\n{\n  match t\n  case Node(n, children) => Tree.Node(n+1, ForestInc(children))\n}\n\nghost function ForestInc(forest: List<Tree>): List<Tree>\n{\n  match forest\n  case Nil => forest\n  case Cons(tree, tail) => List.Cons(Inc(tree), ForestInc(tail))\n}\n\n// ------------------ generic list, generic tree (but GInc defined only for GTree<int>\n\ndatatype GTree<T> = Node(T, List<GTree<T>>)\n\nghost function GInc(t: GTree<int>): GTree<int>\n{\n  match t\n  case Node(n, children) => GTree.Node(n+1, GForestInc(children))\n}\n\nghost function GForestInc(forest: List<GTree<int>>): List<GTree<int>>\n{\n  match forest\n  case Nil => forest\n  case Cons(tree, tail) => List.Cons(GInc(tree), GForestInc(tail))\n}\n\n// ------------------ non-generic structures\n\ndatatype TreeList = Nil | Cons(OneTree, TreeList)\n\ndatatype OneTree = Node(int, TreeList)\n\nghost function XInc(t: OneTree): OneTree\n{\n  match t\n  case Node(n, children) => OneTree.Node(n+1, XForestInc(children))\n}\n\nghost function XForestInc(forest: TreeList): TreeList\n{\n  match forest\n  case Nil => forest\n  case Cons(tree, tail) => TreeList.Cons(XInc(tree), XForestInc(tail))\n}\n\n// ------------------ fun with recursive functions\n\nghost function len<T>(l: List<T>): int\n{\n  match l\n  case Nil => 0\n  case Cons(h,t) => 1 + len(t)\n}\n\nghost function SingletonList<T>(h: T): List<T>\n  ensures len(SingletonList(h)) == 1;\n{\n  List.Cons(h, List.Nil)\n}\n\nghost function Append<T>(a: List<T>, b: List<T>): List<T>\n  ensures len(Append(a,b)) == len(a) + len(b);\n{\n  match a\n  case Nil => b\n  case Cons(h,t) => List.Cons(h, Append(t, b))\n}\n\nghost function Rotate<T>(n: int, l: List<T>): List<T>\n  requires 0 <= n;\n  ensures len(Rotate(n, l)) == len(l);\n{\n  match l\n  case Nil => l\n  case Cons(h, t) =>\n    if n == 0 then l else\n      Rotate(n-1, Append(t, SingletonList(h)))\n}\n\n\n"}
{"file": "../dafny/Test/dafny1/ListReverse.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Node {\n  var nxt: Node?\n\n  method ReverseInPlace(x: Node?, r: set<Node>) returns (reverse: Node?)\n    requires x == null || x in r;\n    requires (forall y :: y in r ==> y.nxt == null || y.nxt in r);  // region closure\n    modifies r;\n    ensures reverse == null || reverse in r;\n    ensures (forall y :: y in r ==> y.nxt == null || y.nxt in r);  // region closure\n    decreases *;\n  {\n    var current: Node? := x;\n    reverse := null;\n    while (current != null)\n      invariant current == null || current in r;\n      invariant reverse == null || reverse in r;\n      invariant (forall y :: y in r ==> y.nxt == null || y.nxt in r);  // region closure\n      decreases *;  // omit loop termination check\n    {\n      var tmp := current.nxt;\n      current.nxt := reverse;\n      reverse := current;\n      current := tmp;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/lambdas/StateMonad.dfy", "dafny": "// RUN: %dafny /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nabstract module Monad {\n  type M<A>\n\n  function Return<A>(x: A): M<A>\n  function Bind<A,B>(m: M<A>, f:A -> M<B>): M<B>\n\n  // return x >>= f = f x\n  lemma LeftIdentity<A,B>(x : A, f : A -> M<B>)\n    ensures Bind(Return(x),f) == f(x)\n\n  // m >>= return = m\n  lemma RightIdentity<A>(m : M<A>)\n    ensures Bind(m, x => Return(x)) == m // problem: can't prove it for Bind(m, Return)\n\n  // (m >>= f) >>= g = m >>= (x => f(x) >>= g)\n  lemma Associativity<A,B,C>(m : M<A>, f:A -> M<B>, g: B -> M<C>)\n    ensures Bind(Bind(m,f),g) ==\n            Bind(m,x => Bind(f(x),g))\n}\n\nmodule State refines Monad {\n//   type S // doesn't work because S is used left of an arrow\n  datatype M<A> = State(runState: int -> (A, int))\n\n  function Return<A>(x: A): M<A>\n  { State(s => (x, s)) }\n\n  function Bind<A,B>(m: M<A>, f:A -> M<B>): M<B>\n  {\n    match m case State(h) =>\n      State(s =>\n            match h(s) case (a, newState) =>\n              match f(a) case State(g) => g(newState))\n  }\n\n  lemma {:axiom} FunEq<X, Y>(f: X -> Y, g: X -> Y)\n    requires forall x :: f(x) == g(x)\n    ensures f == g\n\n  lemma LeftIdentity<A,B>(x : A, f : A -> M<B>)\n    ensures Bind(Return(x), f) == f(x)\n  {\n      var State(h) := State(s => (x, s));\n      var State(g2) := f(x);\n      calc {\n          Bind(Return(x), f);\n      ==\n          Bind(State(s => (x, s)), f);\n      ==\n          State(s =>\n                match ((s => (x, s))(s))\n                case (a, newState) =>\n                  match f(a) case State(g) =>\n                    g(newState));\n      == {\n            FunEq(s =>\n                    match ((s => (x, s))(s))\n                    case (a, newState) =>\n                      match f(a)\n                      case State(g) => g(newState),\n                  s =>\n                    match (x, s)\n                    case (a, newState) =>\n                      match f(a)\n                      case State(g) => g(newState));\n         }\n          State(s =>\n                  match (x, s) case (a, newState) =>\n                    match f(a) case State(g) =>\n                      g(newState));\n      == {\n            FunEq((s =>\n                    match (x, s) case (a, newState) =>\n                      match f(a) case State(g) => g(newState)),\n                  (s => match f(x) case State(g) => g(s)));\n         }\n          State(s => match f(x) case State(g) => g(s));\n      == { FunEq(s => match f(x) case State(g) => g(s), g2); }\n          State(g2);\n      ==\n          f(x);\n    }\n  }\n\n  lemma RightIdentity<A>(m : M<A>)\n  {\n      match m case State(h) =>\n        calc {\n          Bind(m, x => Return(x));\n        ==\n          State(s =>\n                  match h(s) case (a, newState) =>\n                    match (x => Return(x))(a)\n                    case State(g) => g(newState));\n        == {\n            FunEq((s =>\n                    match h(s) case (a, newState) =>\n                      match (x => Return(x))(a) case State(g) => g(newState)),\n                  (s => h(s)));\n          }\n          State(s => h(s));\n        == { FunEq(s => h(s), h); }\n          State(h);\n        ==\n          m;\n        }\n  }\n\n  lemma Associativity<A,B,C>(m : M<A>, f:A -> M<B>, g: B -> M<C>)\n    ensures Bind(Bind(m, f), g) == Bind(m, x => Bind(f(x), g))\n  {\n    match m case State(h) =>\n        calc {\n          Bind(Bind(m, f), g);\n        ==\n          match Bind(m, f) case State(h1) =>\n            State(s =>\n                    match h1(s) case (a, newState) =>\n                      match g(a) case State(h1) =>\n                        h1(newState));\n        ==\n          match (State(s =>\n                        match h(s) case (a, newState) =>\n                          match f(a) case State(g2) => g2(newState)))\n          case State(h1) =>\n            State(s =>\n                    match h1(s) case (a, newState) =>\n                      match g(a) case State(h1) =>\n                        h1(newState));\n        ==\n          State(s =>\n                  match (s => match h(s) case (a, newState) => match f(a) case State(g2) => g2(newState))(s)\n                  case (a, newState) =>\n                    match g(a) case State(h1) =>\n                      h1(newState));\n        == {\n              FunEq(s =>\n                      match (s => match h(s) case (a, newState) => match f(a) case State(g2) => g2(newState))(s)\n                      case (a, newState) =>\n                        match g(a) case State(h1) =>\n                          h1(newState),\n                    s =>\n                      match (match h(s) case (a, newState) => match f(a) case State(g2) => g2(newState))\n                      case (a, newState) =>\n                        match g(a) case State(h1) =>\n                          h1(newState));\n           }\n          State(s =>\n                  match (match h(s) case (a, newState) => match f(a) case State(g2) => g2(newState))\n                  case (a, newState) =>\n                    match g(a) case State(h1) =>\n                      h1(newState));\n        ==\n\t{ /* OS: Added for PM */\n             FunEq(s =>\n                      match (match h(s) case (a, newState) => match f(a) case State(g2) => g2(newState))\n                      case (a, newState) =>\n                        match g(a) case State(h1) =>\n                          h1(newState),\n\t\t  s => match h(s) case (a, newState) =>\n                    match f(a) case State(g2) =>\n                      match g2(newState) case (b, newState2) =>\n                          match g(b) case State(h1) =>\n                            h1(newState2));\n           }\n          State(s =>\n                  match h(s) case (a, newState) =>\n                    match f(a) case State(g2) =>\n                      match g2(newState) case (b, newState2) =>\n                          match g(b) case State(h1) =>\n                            h1(newState2));\n      }\n\n      calc {\n        Bind(m, x => Bind(f(x), g));\n      ==\n        Bind(State(h), x => Bind(f(x), g));\n      ==\n        State(s =>\n                match h(s) case (a, newState) =>\n                  match (x => Bind(f(x), g))(a) case State(g2) =>\n                    g2(newState));\n      == {\n            FunEq(s => match h(s) case (a, newState) => match (x => Bind(f(x), g))(a) case State(g2) => g2(newState),\n                  s => match h(s) case (a, newState) => match Bind(f(a), g) case State(g2) => g2(newState));\n         }\n        State(s =>\n                match h(s) case (a, newState) =>\n                  match Bind(f(a), g) case State(g2) =>\n                    g2(newState));\n      == {\n            FunEq((s => match h(s) case (a, newState) => match Bind(f(a), g) case State(g2) => g2(newState)),\n                  (s => match h(s) case (a, newState) =>\n                    match (match f(a) case State(h2) =>\n                            State(s =>\n                                  match h2(s) case (a2, newState2) =>\n                                    match g(a2) case State(g2) => g2(newState2)))\n                    case State(g3) =>\n                      g3(newState)));\n         }\n        State(s =>\n                match h(s) case (a, newState) =>\n                  match (match f(a) case State(h2) =>\n                          State(s =>\n                                match h2(s) case (a2, newState2) =>\n                                  match g(a2) case State(g2) => g2(newState2)))\n                  case State(g3) =>\n                    g3(newState));\n      == { /* OS: Added for PM */\n            FunEq(s => match h(s) case (a, newState) =>\n                    match (match f(a) case State(h2) =>\n                            State(s =>\n                                  match h2(s) case (a2, newState2) =>\n                                    match g(a2) case State(g2) => g2(newState2)))\n                    case State(g3) =>\n                      g3(newState),\n\t\t   s =>\n                match h(s) case (a, newState) =>\n                  match f(a) case State(h2) =>\n                      match State(s => match h2(s) case (a2, newState2) =>\n                                        match g(a2) case State(g2) => g2(newState2))\n                      case State(g3) =>\n                        g3(newState));\n         }\n        State(s =>\n                match h(s) case (a, newState) =>\n                  match f(a) case State(h2) =>\n                      match State(s => match h2(s) case (a2, newState2) =>\n                                        match g(a2) case State(g2) => g2(newState2))\n                      case State(g3) =>\n                        g3(newState));\n      == { FunEq(s => match h(s) case (a, newState) =>\n                        match f(a) case State(h2) =>\n                          match State(s => match h2(s) case (a2, newState2) =>\n                            match g(a2) case State(g2) =>\n                              g2(newState2)) case State(g3) =>\n                                g3(newState),\n                   s => match h(s) case (a, newState) =>\n                          match f(a) case State(h2) =>\n                            (s => match h2(s) case (a2, newState2) =>\n                              match g(a2) case State(g2) =>\n                                g2(newState2))(newState));\n         }\n        State(s =>\n                match h(s) case (a, newState) =>\n                  match f(a) case State(h2) =>\n                    (s => match h2(s) case (a2, newState2) =>\n                            match g(a2) case State(g2) => g2(newState2))(newState));\n      == {\n            FunEq(s => match h(s) case (a, newState) =>\n                        match f(a) case State(h2) =>\n                 (s => match h2(s) case (a2, newState2) =>\n                        match g(a2) case State(g2) =>\n                          g2(newState2))(newState),\n                  s => match h(s) case (a, newState) =>\n                        match f(a) case State(h2) =>\n                          match h2(newState) case (a2, newState2) =>\n                            match g(a2) case State(g2) =>\n                              g2(newState2));\n         }\n        State(s =>\n                match h(s) case (a, newState) =>\n                  match f(a) case State(h2) =>\n                    match h2(newState) case (a2, newState2) =>\n                      match g(a2) case State(g2) =>\n                        g2(newState2));\n      }\n  }\n}\n"}
{"file": "../dafny/Test/legacy-help.dfy", "dafny": "// RUN: %baredafny -?\n"}
{"file": "../dafny/Test/autoRevealDependencies/datatype-reveals.dfy", "dafny": "// RUN: %baredafny verify %args --default-function-opacity autoRevealDependencies \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction two() : int { 2 }\ndatatype t = Nat(val :nat := two())\n"}
{"file": "../dafny/Test/autoRevealDependencies/func-depth-fail.dfy", "dafny": "// RUN: %exits-with 4 %baredafny verify %args --default-function-opacity autoRevealDependencies \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction f() : bool { true }\nfunction g() : bool { f() }\nfunction h() : bool { g() }\nfunction i() : bool { h() }\n\nfunction {:autoRevealDependencies 3} p() : (r: bool)\n  ensures r\n{ \n  i() \n}\n"}
{"file": "../dafny/Test/autoRevealDependencies/tree-map-simple.dfy", "dafny": "// RUN: %baredafny verify %args --default-function-opacity autoRevealDependencies \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  TestY();\n}\n\ndatatype List<A> = Nil | Cons(head: A, tail: List<A>)\n\ndatatype Tree<A> = Branch(val: A, trees: List<Tree<A>>)\n\nghost function ListData(xs: List): set\n  ensures forall x :: x in ListData(xs) ==> x < xs\n{\n  match xs\n  case Nil => {}\n  case Cons(x,xs) => {x} + ListData(xs)\n}\n\nghost function {:transparent} TreeData(t0: Tree): set\n  ensures forall t :: t in TreeData(t0) ==> t < t0\n{\n  var Branch(x, ts) := t0;\n  {x} + set t, y | t in ListData(ts) && y in TreeData(t) :: y\n}\n\n// ---------- Partial functions ----------\n\nghost predicate {:transparent} PreY<A,B>(f: A --> B, s: set<A>) {\n  forall x :: x in s ==> f.requires(x)\n}\n\nfunction MapY<A,B>(xs: List<A>, f: A --> B): List<B>\n  requires PreY(f, ListData(xs))\n  decreases xs\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, xs) => Cons(f(x), MapY(xs, f))\n}\n\nfunction TreeMapY<A,B>(t0: Tree<A>, f: A --> B): Tree<B>\n  requires PreY(f, TreeData(t0))\n  decreases t0\n{\n  var Branch(x, ts) := t0;\n  Branch(f(x), MapY(ts, t requires t in ListData(ts) && PreY(f, TreeData(t)) => TreeMapY(t, f)))\n}\n\nmethod TestY() {\n  var f := x requires x != 0 => 100 / x;\n  var t := TreeMapY(Branch(1, Cons(Branch(2, Nil), Nil)), f);\n  assert t == Branch(100, Cons(Branch(50, Nil), Nil));  // proved via Lit axioms\n  print t, \"\\n\";\n}\n"}
{"file": "../dafny/Test/autoRevealDependencies/ast.dfy", "dafny": "// RUN: %baredafny verify %args --default-function-opacity autoRevealDependencies \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule Utils {\n  function Max(x: int, y: int): int\n  {\n    if x > y then x else y\n  }\n\n  function {:opaque} MaxF<T(!new)>(f: T ~> int, ts: seq<T>, default: int) : (m: int)\n    reads set t, o | t in ts && o in f.reads(t) :: o \n    requires forall t | t in ts :: f.requires(t)\n    requires forall t | t in ts :: default <= f(t)\n    ensures if ts == [] then m == default else exists t | t in ts :: f(t) == m\n    ensures forall t | t in ts :: f(t) <= m\n    ensures default <= m\n  {\n    if ts == [] then default\n    else\n      Max(f(ts[0]), MaxF(f, ts[1..], default))\n  }\n\n  datatype Result<T> = | Success(value: T) | Failure\n  {\n    predicate IsFailure() {\n      Failure?\n    }\n\n    function PropagateFailure<U>(): Result<U>\n      requires Failure?\n    {\n      Failure\n    }\n\n    function Extract(): T\n      requires Success?\n    {\n      value\n    }\n  }\n\n  datatype Option<T> = Some(value: T) | None\n}\n\nmodule AST {\n  import opened Utils\n\n  datatype BinOp =\n    | Add\n    | Sub\n    | Mul\n  \n  datatype Expr_Raw =\n    | Var(name: string)\n    | Literal(n: int)\n    | Bind(bvars: seq<string>, bvals: seq<Expr_Raw>, body: Expr_Raw)\n    | Assign(avars: seq<string>, avals: seq<Expr_Raw>)\n    | If(cond: Expr_Raw, thn: Expr_Raw, els: Expr_Raw)\n    | Op(op: BinOp, oe1: Expr_Raw, oe2: Expr_Raw)\n    | Seq(es: seq<Expr_Raw>)\n  {\n    function Depth() : nat\n    {\n      1 + match this {\n        case Var(_) =>\n          0\n        case Literal(lit) =>\n          0\n        case Bind(bvars, bvals, body) =>\n          var m := MaxF(var f := (e: Expr_Raw) requires e in bvals => e.Depth(); f, bvals, 0);\n          Max(m, body.Depth())\n        case Assign(avars, avals) =>\n          MaxF(var f := (e: Expr_Raw) requires e in avals => e.Depth(); f, avals, 0)\n        case If(cond, thn, els) =>\n          Max(cond.Depth(), Max(thn.Depth(), els.Depth()))\n        case Op(op, e1, e2) =>\n          Max(e1.Depth(), e2.Depth())\n        case Seq(es: seq<Expr_Raw>) =>\n          MaxF(var f := (e: Expr_Raw) requires e in es => e.Depth(); f, es, 0)\n      }\n    }\n\n    static predicate All(e: Expr_Raw, p: (Expr_Raw) -> bool)\n    {\n      p(e) &&\n      (match e\n         case Var(name) => true\n         case Literal(n) => true\n         case Bind(bvars, bvals, body) =>\n          && (forall e | e in bvals :: e.All(e, p))\n          && All(body, p)\n         case Assign(avars, avals) =>\n          && forall e | e in avals :: e.All(e, p)\n         case If(cond, thn, els) =>\n          All(cond, p) && All(thn, p) && All(els, p)\n         case Op(op, oe1, oe2) =>\n          All(oe1, p) && All(oe2, p)\n         case Seq(es) =>\n          && forall e | e in es :: e.All(e, p)\n      )\n    }\n\n    static predicate All_Es(es: seq<Expr_Raw>, p: (Expr_Raw) -> bool)\n      // Rem.: we pay attention of not making ``All_Es`` and ``All`` mutually\n      // recursive, otherwise it causes problems in the proofs.\n    {\n      forall e | e in es :: e.All(e, p)\n    }\n\n    static ghost predicate WellFormed_Single(e: Expr_Raw)\n    {\n      match e\n        case Var(name) => true\n        case Literal(n) => true\n        case Bind(bvars, bvals, body) => |bvars| == |bvals|\n        case Assign(avars, avals) => |avars| == |avals|\n        case If(cond, thn, els) => true\n        case Op(op, oe1, oe2) => true\n        case Seq(es) => true\n    }\n\n    ghost predicate WellFormed()\n    {\n      All(this, WellFormed_Single)\n    }\n  }\n\n  type Expr = e:Expr_Raw | e.WellFormed() witness Var(\"x\")\n}\n"}
{"file": "../dafny/Test/autoRevealDependencies/power.dfy", "dafny": "// RUN: %exits-with 4 %baredafny verify %args --default-function-opacity autoRevealDependencies \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction power(b: int, n: nat): int\n{\n  if (n==0) then 1 else b*power(b, n-1)\n}\n\nmethod test_power()\n  ensures power(power(2, 2), 2)==16\n{\n  // Enabling following assert makes the test pass\n  //assert power(8, 5) == 32768;\n} "}
{"file": "../dafny/Test/autoRevealDependencies/subset-types.dfy", "dafny": "// RUN: %baredafny verify %args --default-function-opacity autoRevealDependencies \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n  function one() : (r:int) {\n  \n    1\n  }\n\n  datatype Test = | Int(i:int)\n  {\n    predicate Nat() {\n      match this\n        case Int(i) => i >= 0\n    }\n  }\n\n  type Test_Nat = e:Test | e.Nat() witness Int(0)\n}\n\nmodule N {\n  import opened M\n\n  function two() : (r: Test_Nat)\n    ensures r.i == 2 \n  {\n    Int( Int(one() + one()).i )\n  }\n}"}
{"file": "../dafny/Test/autoRevealDependencies/typecasting.dfy", "dafny": "// RUN: %baredafny verify %args --default-function-opacity autoRevealDependencies \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n  function one() : (r:int) {\n  \n    1\n  }\n\n  datatype Test = | Int(i:int)\n  {\n    predicate Nat() {\n      match this\n        case Int(i) => i >= 0\n    }\n  }\n\n  type Test_Nat = e:Test | e.Nat() witness Int(0)\n}\n\nmodule N {\n  import opened M\n\n  function two() : (r: Test_Nat)\n    ensures r.i == 2 \n  {\n    Int( Int(one() + one()).i )\n  }\n}"}
{"file": "../dafny/Test/autoRevealDependencies/func-depth-succ.dfy", "dafny": "// RUN: %baredafny verify %args --default-function-opacity autoRevealDependencies \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction f() : bool { true }\nfunction g() : bool { f() }\nfunction h() : bool { g() }\nfunction i() : bool { h() }\n\nfunction {:autoRevealDependencies 4} p() : (r: bool)\n  ensures r\n{ \n  i() \n}\n"}
{"file": "../dafny/Test/c++/recursion.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype uint32 = i:int | 0 <= i < 0x100000000\n\nmethod R0(x:bool)\n{\n  if x {\n    print \"x\\n\";\n    R1(false);\n  } else {\n    print \"!x\\n\";\n  }\n}\n\nmethod R1(y:bool)\n{\n  if y {\n    print \"y\\n\";\n    R0(false);\n  } else {\n    print \"!y\\n\";\n  }\n}\n\nmethod CallSelf(x:uint32) {\n  if x == 0 {\n    print \"Done\\n\";\n  } else {\n    print x, \"\\n\";\n    CallSelf(x - 1);\n  }\n}\n\nmethod Main() {\n  R0(true);\n  CallSelf(3);\n}\n"}
{"file": "../dafny/Test/c++/functions.dfy", "dafny": "// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:cpp /unicodeChar:0 \"%s\" ExternDefs.h > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule {:extern \"Extern\"} Extern {\n  newtype uint64 = i:int | 0 <= i < 0x10000000000000000\n\n  method {:extern \"Extern\", \"Caller\"} Caller(inc:uint64-->uint64, x:uint64) returns (y:uint64)\n    requires inc.requires(x)\n\n  method {:extern \"Extern\", \"GenericCaller\"} GenericCaller<A>(inc:A-->A, x:A) returns (y:A)\n    requires inc.requires(x)\n\n  class {:extern} GenericClass<A>\n  {\n    constructor {:extern \"Extern\", \"GenericClass\"} (inc:A-->A, x:A)\n      requires inc.requires(x)\n\n    method {:extern \"Extern\", \"get\"} get() returns (y:A)\n  }\n}\n\nmodule Test {\n  import opened Extern\n\n  newtype uint32  = i:int | 0 <= i < 0x100000000\n\n  // Function-method tests\n  function Test(x:uint32) : uint64 {\n    x as uint64 + 1\n  }\n\n  function Seqs<T>(s:seq<T>, x:uint32, default_val:T) : T\n    requires |s| < 1000\n  {\n    if |s| as uint32 > x then s[x] else default_val\n  }\n\n  // Function pointer tests\n  function AddOne(x:uint64) : uint64\n    requires x < 100\n  {\n    x + 1\n  }\n\n  method CallTest() {\n    var x := Caller(AddOne, 5);\n    print x, \"\\n\";\n    var y := GenericCaller(AddOne, 6);\n    print y, \"\\n\";\n    var c := new GenericClass(AddOne, 7);\n    var z := c.get();\n    print z, \"\\n\";\n  }\n\n\n  method Main() {\n    var y := Test(12);  // Basic function-method test\n    CallTest();         // Function pointer tests\n    print y, \"\\n\";\n  }\n}\n\n"}
{"file": "../dafny/Test/c++/seqs.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype uint8 = i:int | 0 <= i < 0x100\nnewtype uint32 = i:int | 0 <= i < 0x100000000\n\nclass C {\n  var x:uint8\n}\n\nmethod TestSeqOfClass() returns (s:seq<C>)\n{\n  return [];\n}\n\ntype fixed = t:seq<uint32> | |t| == 2 witness [0,0]\n\ntype buffer<T> = a:array?<T> | a == null || a.Length < 0x100000000\ntype buffer_t = buffer<uint8>\n\nmethod BoundedLength(s:seq<uint8>)\n  requires |s| < 10\n{\n  var x := |s| as uint32;\n  print x;\n}\n\nmethod BufferTest(b:buffer_t)\n  requires b != null\n{\n  var t := b[..];\n  print t;\n}\n\nmethod Test(name:string, b:bool)\n  requires b\n{\n  if b {\n    print name, \": This is expected\\n\";\n  } else {\n    print name, \": This is *** UNEXPECTED *** !!!!\\n\";\n  }\n}\n\nmethod Print(s:string) {\n   print s, \"\\n\";\n}\n\nmethod PrintTest() {\n  Print(\"Hello world!\");\n}\n\nmethod Basic() {\n  var s:seq<uint32> := [1, 2, 3, 4];\n  print \"Head second:\", s[1], \"\\n\";\n  var end := s[1..];\n  print \"Trunc first:\", end[0], \"\\n\";\n\n  Test(\"Head trunc\", end != s);\n  var start := s[..1];\n  var combine := start + end;\n\n  Test(\"Combine\", combine == s);\n\n  var s' := s[0 := 330];\n  Test(\"Replace1\", s[0] != 330);\n  Test(\"Replace2\", s[0] == 1);\n\n  var a := new uint32[3][12, 13, 14];\n  var a_seq := a[..];\n  a[0] := 42;\n  var a_seq' := a[..];\n\n  Test(\"Immutability\", a_seq != a_seq');\n}\n\nmethod ValueEquality() {\n  var m0:seq<uint32> := [1, 2, 3];\n  var m1:seq<uint32> := m0[1..];\n  var m2:seq<uint32> := [2, 3];\n  Test(\"ValueEquality\", m1 == m2);\n}\n\nmethod Contains() {\n  var m1:seq<uint32> := [1];\n  var m2:seq<uint32> := [1, 2];\n  var m3:seq<uint32> := [1, 2, 3];\n  var m3identical:seq<uint32> := [1, 2, 3];\n  var mm := [m1, m3, m1];\n\n  Test(\"Membership 1\", m1 in mm);\n  Test(\"Membership 2\", !(m2 in mm));\n  Test(\"Membership 3\", m3 in mm);\n  Test(\"Membership 3 value equality\", m3identical in mm);\n}\n\nmethod Main() {\n  Basic();\n  ValueEquality();\n  Contains();\n  PrintTest();\n  var c := TestSeqOfClass();\n}\n"}
{"file": "../dafny/Test/c++/returns.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype uint64 = i:int | 0 <= i < 0x10000000000000000\n\nmethod multi() returns (x:uint64, y:uint64)\n{\n  x := 1;\n  y := 2;\n}\n\nmethod Main()\n{\n  var x, y := multi();\n  print x, y, \"\\n\";\n}\n"}
{"file": "../dafny/Test/c++/datatypes.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype uint32 = i:int | 0 <= i < 0x100000000\n\ndatatype Op =\n  | NoOp\n  | PushOp(ghost id: int)\n\ndatatype Example1 = Example1(u:uint32, b:bool)\ndatatype Example2 = Ex2a(u:uint32) | Ex2b(b:bool)\ndatatype Example3 = Example3(e:Example1)\ndatatype Example4 = Ex4a | Ex4b\ndatatype Example5<V> = Ex5a(v:V) | Ex5b(b:bool)\ndatatype Example6 = Ex6a(u:uint32) | Ex6b(b:bool) | Ex6c(u:uint32, s:seq<bool>)\ntype Ex1Sub = d:Example1 | d.u == 0 witness Example1(0, true)\ntype Ex2Sub = d:Example2 | d.Ex2a? && d.u == 0 witness Ex2a(0)\ntype Ex3Sub = d:Example3 | d.e.b witness Example3(Example1(42, true))\n\ndatatype DtPointer = DtPointer(s:seq<uint32>)\ndatatype DtPointerHolder = DtPointerHolder(e:DtPointer) | Other(f:bool)\n\nmethod Matcher(e:Example1) {\n  match e {\n    case Example1(u, b) => print u, b;\n  }\n}\n\nmethod TupleMatch(e1:Example2, e2:Example2) {\n  match (e1, e2) {\n    case (Ex2a(u1), Ex2a(u2)) => print u1, u2, \"\\n\";\n    case (Ex2b(u1), Ex2a(u2)) => print u1, u2, \"\\n\";\n    case (Ex2a(u1), Ex2b(u2)) => print u1, u2, \"\\n\";\n    case (Ex2b(u1), Ex2b(u2)) => print u1, u2, \"\\n\";\n  }\n}\n\nmethod Callee(e:Example2) {\n  match e {\n    case Ex2a(u) => print \"Case A: \", u, \"\\n\";\n    case Ex2b(b) => print \"Case B: \", b, \"\\n\";\n  }\n}\n\nmethod DtUpdate(e:Example1)\n{\n  var x := e.(u := 0);\n}\n\nmethod TestDestructor() {\n  var e1 := Example1(22, false);\n  var x := e1.u;\n  if x == 22 {\n    print \"This is expected\\n\";\n  } else {\n    assert false;\n    print \"This is unexpected!!!\\n\";\n  }\n}\n\ndatatype Option<V> = None | Some(value:V)\n\nmethod TestGenericDefault() {\n  var x:Option<Example5<bool>>;\n}\n\ndatatype Err<V> = Fail(err:bool) | Ok(value:V)\n\nmethod matcher(e:Err<uint32>) {\n  match e {\n    case Fail(s) => print s;\n    case Ok(v) => print v;\n  }\n  print \"\\n\";\n}\n\nmethod GenericTest() {\n  var v:Option<uint32> := Some(32);\n  matcher(Ok(42));\n  matcher(Fail(true));\n  if v.Some? { print \"Got some:\", v.value, \"\\n\"; }\n}\n\nmethod Comparison(x0:Example1, x1:Example1, y0:Example4, y1:Example4) {\n  if x0 == x1 {\n    print \"Example1s are equal\\n\";\n  }\n  if x0 != x1 {\n    print \"Example1s are not equal\\n\";\n  }\n  if y0 == y1 {\n    print \"Example4s are equal\\n\";\n  }\n  if y0 != y1 {\n    print \"Example4s are not equal\\n\";\n  }\n}\n\n\ndatatype Dup = Dup1(b:bool, x:uint32) | Dup2(x:uint32)\n\nmethod DupTest(d:Dup)\n{\n  var y := d.x;\n  print y;\n  print \"\\n\";\n}\n\nmethod DupTestTest()\n{\n  DupTest(Dup1(false, 42));\n  DupTest(Dup2(330));\n}\n\ndatatype IntList =\n  | Nil\n  | Cons(hd:uint32, tl:IntList)\n\nmethod IntListLen(l:IntList) returns (len:uint32)\n{\n  match l {\n    case Nil => len := 0;\n    case Cons(hd, tl) =>\n      var len_rest := IntListLen(tl);\n      if len_rest < 0xFFFFFFFF {\n        len := len_rest + 1;\n      } else {\n        len := len_rest;\n      }\n  }\n}\n\n// Test generic datatype methods\ndatatype Foo<A> = Foo(a: A) {\n  static method Alloc(a: A) returns (f: Foo<A>) {\n    f := Foo(a);\n  }\n}\n\ndatatype Test<A> = Test(a:A) | Empty\n{\n  static method Alloc() returns (t:Test<A>) {\n    return Empty;\n  }\n\n  static method Invoke() {\n    var a := Alloc();\n  }\n}\n\nmethod Main() {\n  var e1 := Example1(22, false);\n  var e2 := Ex2a(42);\n  Callee(e2);\n  e2 := Ex2b(true);\n  Callee(e2);\n  TestDestructor();\n  GenericTest();\n  Comparison(Example1(42, true), Example1(42, true), Ex4b, Ex4b);\n  Comparison(Example1(42, false), Example1(42, true), Ex4a, Ex4a);\n  Comparison(Example1(2,  false), Example1(42, false), Ex4a, Ex4b);\n  DupTestTest();\n\n  var len := IntListLen(Cons(15, Cons(18, Cons(330, Nil))));\n  print len, \"\\n\";\n}\n\n"}
{"file": "../dafny/Test/c++/const.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nmodule Holder {\n  const x:bool := false\n}\n\nmodule User {\n  import opened Holder\n\n  method Use() {\n    var b := x;\n  }\n\n  method Main() {\n    Use();\n  }\n}\n"}
{"file": "../dafny/Test/c++/tuple.dfy", "dafny": "// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:cpp /unicodeChar:0 ExternDefs.h \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nnewtype uint32 = i:int | 0 <= i < 0x100000000\n\nmethod ReturnTuple() returns (x:(uint32,uint32))\n{\n  return (1, 2);\n}\n\nfunction EmptyTuple() : () {\n  ()\n}\n\nfunction GetEmptyTuple() : () {\n  EmptyTuple()\n}\n\nfunction Test() : (bool, bool) {\n  (false, true)\n}\n\nmethod BoolCallee(a:bool) returns (a0:bool, a1:bool)\n{\n  return a, a;\n}\n\nmethod BoolCaller(a:bool)\n{\n  var a0, a1 := BoolCallee(a);\n}\n\nmethod GenericCallee<A>(a:A) returns (a0:A, a1:A)\n{\n  return a, a;\n}\n\nmethod GenericCaller<A>(a:A)\n{\n  var a0, a1 := GenericCallee(a);\n}\n\nmethod Main() {\n  var x := ReturnTuple();\n  var y := x.0;\n  print y, \"\\n\";\n}\n"}
{"file": "../dafny/Test/c++/bit-vectors.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype uint64 = i:int | 0 <= i < 0x10000000000000000\n\nfunction bit(i: uint64) : bv64\n  requires i < 64\n  {\n    1 as bv64 << i\n  }\n\nmethod BasicOps(b0:bv64, b1:bv64) {\n  var r0:bv64 := b0 & b1;\n  var r1:bv64 := b0 | b1;\n  var r2:bv64 := b0 ^ b1;\n  var r3:bv64 := b0 ^ 0xffff_ffff_ffff_ffff;\n  var r4:bv64 := b0 << 4;\n\n  var r5 := r0 & r1 & r2 & r3 & r4;\n  print r5;\n\n}\n\nlemma {:axiom} as_int_as_bv64(a: bv64)\n  ensures (a as int) as bv64 == a\n  ensures (a as int) < 0x10000000000000000\n\nmethod Casts(u0:uint64)\n{\n  var r0:bv64 := u0 as bv64 << 1;\n  as_int_as_bv64(u0 as bv64 << 1);\n  var r1:uint64 := (u0 as bv64 << 1) as uint64;\n  print r0, r1;\n}\n\nmethod Main() {\n  BasicOps(72, 15);\n  Casts(42);\n  var b := bit(10);\n  print b, \"\\n\";\n}\n"}
{"file": "../dafny/Test/c++/class.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype uint32 = i:int | 0 <= i < 0x100000000\n\nclass MyClass {\n  var a: uint32\n  const b: uint32\n  const c:uint32 := 17\n  static const d: uint32\n  static const e:uint32 := 18\n\n  var ar: array<uint32>\n\n  constructor (x: uint32)\n    requires x < 100\n    ensures this.a < 300\n    ensures this.b < 300\n    ensures fresh(this.ar)\n  {\n    a := 100 + x;\n    b := 200 + x;\n    ar := new uint32[5];\n  }\n\n  function F(): uint32 { 8 }\n  static function G(): uint32 { 9 }\n  method M() returns (r: uint32) { r := 69; }\n  static method N() returns (r: uint32) { return 70; }\n\n  method stuffWithAr()\n    modifies this\n    modifies this.ar\n  {\n    print \"stuffWithAr\\n\";\n    this.ar := new uint32[5];\n    this.ar[0] := 5;\n    print this.ar[0];\n    print \"\\n\";\n  }\n}\n\nmethod CallEm(c: MyClass, t: MyClass, i: MyClass)\n  requires c.a as int + t.a as int + i.a as int < 1000\n  ensures c.ar == old(c.ar)\n  modifies c, t, i\n{\n  // instance fields\n\n  print c.a, \" \", t.a, \" \", i.a, \" \";\n  c.a := c.a + 3;\n  t.a := t.a + 3;\n  i.a := i.a + 3;\n  print c.a, \" \", t.a, \" \", i.a, \"\\n\";\n\n  // (instance and static) members via instance\n\n  var u;\n\n  print c.b, \" \";\n  print c.c, \" \";\n  print c.d, \" \";\n  print c.e, \" \";\n  print c.F(), \" \";\n  print c.G(), \" \";\n  u := c.M();\n  print u, \" \";\n  u := c.N();\n  print u, \"\\n\";\n\n  print t.b, \" \";\n  print t.c, \" \";\n  print t.d, \" \";\n  print t.e, \" \";\n  print t.F(), \" \";\n  print t.G(), \" \";\n  u := t.M();\n  print u, \" \";\n  u := t.N();\n  print u, \"\\n\";\n\n  print i.b, \" \";\n  print i.c, \" \";\n  print i.d, \" \";\n  print i.e, \" \";\n  print i.F(), \" \";\n  print i.G(), \" \";\n  u := i.M();\n  print u, \" \";\n  u := i.N();\n  print u, \"\\n\";\n\n  // static members via type name\n\n  print MyClass.d, \" \";\n  print MyClass.e, \" \";\n  print MyClass.G(), \" \";\n  u := MyClass.N();\n  print u, \"\\n\";\n\n  print MyClass.d, \" \";\n  print MyClass.e, \" \";\n  print MyClass.G(), \" \";\n  u := MyClass.N();\n  print u, \"\\n\";\n\n  print MyClass.d, \" \";\n  print MyClass.e, \" \";\n  print MyClass.G(), \" \";\n  u := MyClass.N();\n  print u, \"\\n\";\n}\n\n\nmethod TestMyClass()\n{\n  var c := new MyClass(3);\n  var t := new MyClass(2);\n  var i := new MyClass(2);\n  print t == t, \" \", i == i, \" \", i == t, \"\\n\";\n  var t2 : MyClass := t;\n  var t3 : MyClass;\n  t3 := t;\n  CallEm(c, t, i);\n  c.stuffWithAr();\n}\n\n\nclass AClass {\n  var x:uint32\n  var y:uint32\n\n  constructor()\n  {\n    x := 0;\n    y := 0;\n  }\n}\n\nmethod TestEquality() {\n  var a := new AClass();\n  a.x := 25;\n  a.y := 15;\n\n  if a == a {\n    print \"EqualityReflexive: This is expected\\n\";\n  } else {\n    print \"EqualityReflexive: This is unexpected\\n\";\n    assert false;\n  }\n\n  var b := new AClass();\n  b.x := 1;\n  b.y := 2;\n\n  if a == b {\n    print \"ClassAndPtrDiffer: This is unexpected\\n\";\n    assert false;\n  } else {\n    print \"ClassAndPtrDiffer: This is expected\\n\";\n  }\n\n  var c := new AClass();\n  c.x := 25;\n  c.y := 15;\n\n\n  if a == c {\n    print \"DeepEquality: This is unexpected\\n\";\n    assert false;\n  } else {\n    print \"DeepEquality: This is expected\\n\";\n  }\n}\n\nmethod Main() {\n  TestMyClass();\n  TestEquality();\n}\n\n"}
{"file": "../dafny/Test/c++/arrays.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype uint32 = i:int | 0 <= i < 0x100000000\n\nmethod returnANullArray() returns (a: array?<uint32>)\n  ensures a == null\n{\n  a := null;\n}\n\nmethod returnANonNullArray() returns (a: array?<uint32>)\n  ensures a != null\n  ensures a.Length == 5\n{\n  a := new uint32[5];\n  a[0] := 1;\n  a[1] := 2;\n  a[2] := 3;\n  a[3] := 4;\n  a[4] := 5;\n}\n\nmethod LinearSearch(a: array<uint32>, len:uint32, key: uint32) returns (n: uint32)\n  requires a.Length == len as int\n  ensures 0 <= n <= len\n  ensures n == len || a[n] == key\n{\n  n := 0;\n  while n < len\n    invariant n <= len\n  {\n    if a[n] == key {\n      return;\n    }\n    n := n + 1;\n  }\n}\n\nmethod PrintArray<A>(a:array?<A>, len:uint32)\n  requires a != null ==> len as int == a.Length\n{\n  if (a == null) {\n    print \"It's null\\n\";\n  } else {\n    var i:uint32 := 0;\n    while i < len {\n      print a[i], \" \";\n      i := i + 1;\n    }\n    print \"\\n\";\n  }\n}\n\ndatatype ArrayDatatype = AD(ar: array<uint32>)\n\nmethod Main() {\n  var a := new uint32[23];\n  var i := 0;\n  while i < 23 {\n    a[i] := i;\n    i := i + 1;\n  }\n  PrintArray(a, 23);\n  var n := LinearSearch(a, 23, 17);\n  print n, \"\\n\";\n  var s : seq<uint32> := a[..];\n  print s, \"\\n\";\n  s := a[2..16];\n  print s, \"\\n\";\n  s := a[20..];\n  print s, \"\\n\";\n  s := a[..8];\n  print s, \"\\n\";\n\n  // Conversion to sequence should copy elements (sequences are immutable!)\n  a[0] := 42;\n  print s, \"\\n\";\n\n  PrintArray<uint32>(null, 0);\n\n  print \"Null array:\\n\";\n  var a1 := returnANullArray();\n  PrintArray<uint32>(a1, 5);\n\n  print \"Non-Null array:\\n\";\n  var a2 := returnANonNullArray();\n  PrintArray<uint32>(a2, 5);\n\n  print \"Array in datatype:\\n\";\n  var someAr := new uint32[3];\n  someAr[0] := 1;\n  someAr[1] := 3;\n  someAr[2] := 9;\n  var ad := AD(someAr);\n  PrintArray<uint32>(ad.ar, 3);\n}\n\n\n"}
{"file": "../dafny/Test/c++/hello.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nmethod Main() {\n  print \"Hello world\\n\";\n}\n"}
{"file": "../dafny/Test/c++/extern.dfy", "dafny": "// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:cpp /unicodeChar:0 \"%s\" ExternDefs.h > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule {:extern \"Extern\"} Extern {\n  newtype uint64 = i:int | 0 <= i < 0x10000000000000000\n\n  method {:extern \"Extern\", \"newArrayFill\"} newArrayFill<T>(n: uint64, t: T) returns (ar: array<T>)\n\n  type {:extern \"struct\"} state\n\n  class {:extern} ExternClass {\n    constructor {:extern \"Extern\", \"ExternClass\"}()\n    method {:extern \"Extern\", \"my_method0\"} my_method0(a:uint64) returns (b:bool)\n    method {:extern \"Extern\", \"my_method1\"} my_method1(c:uint64) returns (d:bool)\n  }\n\n  class {:extern} ExternClass2 {\n    constructor {:extern \"Extern\", \"ExternClass2\"}(x:uint64)\n  }\n}\n\nmodule TestMod {\n  import opened Extern\n\n  // Test a templated extern declaration\n  type {:extern \"struct\"} DestructorFunction<A>\n\n  class C {\n    var s:state\n\n    constructor (i:state) {\n      this.s := i;\n    }\n  }\n\n  class D {\n    var s:uint64\n\n    constructor (i:uint64) {\n      this.s := i;\n    }\n  }\n\n  method TestClass(e:ExternClass) {\n    var x := e.my_method0(0);\n    var y := e.my_method1(1);\n    print x, y, \"\\n\";\n  }\n\n  method TestExternClass2() {\n    var x := new ExternClass2(42);\n  }\n\n  method Main() {\n    var a:array<uint64> := newArrayFill(5, 42);\n    var d := new D(21);\n    var b:array<D> := newArrayFill(3, d);\n\n    var e:ExternClass := new ExternClass();\n    TestClass(e);\n  }\n}\n"}
{"file": "../dafny/Test/c++/maps.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype uint32 = i:int | 0 <= i < 0x100000000\n\nmethod Test(name:string, b:bool)\n  requires b\n{\n  if b {\n    print name, \": This is expected\\n\";\n  } else {\n    print name, \": This is *** UNEXPECTED *** !!!!\\n\";\n  }\n}\n\ndatatype map_holder = map_holder(m:map<bool, bool>)\n\nmethod Basic() {\n  var f:map_holder;\n  var s:map<uint32,uint32> := map[1 := 0, 2 := 1, 3 := 2, 4 := 3];\n  var t:map<uint32,uint32> := map[1 := 0, 2 := 1, 3 := 2, 4 := 3];\n\n  Test(\"Identity\", s == s);\n  Test(\"ValuesIdentity\", s == t);\n  Test(\"KeyMembership\", 1 in s);\n  Test(\"Value1\", s[1] == 0);\n  Test(\"Value2\", t[2] == 1);\n\n  var u := s[1 := 42];\n  Test(\"Update Inequality\", s != u);\n  Test(\"Update Immutable 1\", s == s);\n  Test(\"Update Immutable 2\", s[1] == 0);\n  Test(\"Update Result\", u[1] == 42);\n  Test(\"Update Others\", u[2] == 1);\n\n  var s_keys := s.Keys;\n  var t_keys := t.Keys;\n  Test(\"Keys equal\", s_keys == t_keys);\n  Test(\"Keys membership 1\", 1 in s_keys);\n  Test(\"Keys membership 2\", 2 in s_keys);\n  Test(\"Keys membership 3\", 3 in s_keys);\n  Test(\"Keys membership 4\", 4 in s_keys);\n}\n\n\nmethod Main() {\n  Basic();\n  TestMapMergeSubtraction();\n}\n\nmethod TestMapMergeSubtraction() {\n  TestMapMerge();\n  TestMapSubtraction();\n  TestNullsAmongKeys();\n  TestNullsAmongValues();\n}\n\nmethod TestMapMerge() {\n  var a := map[\"ronald\" := 66 as uint32, \"jack\" := 70, \"bk\" := 8];\n  var b := map[\"wendy\" := 52, \"bk\" := 67];\n  var ages := a + b;\n  assert ages[\"jack\"] == 70;\n  assert ages[\"bk\"] == 67;\n  assert \"sanders\" !in ages;\n  print |a|, \" \", |b|, \" \", |ages|, \"\\n\";  // 3 2 4\n  print ages[\"jack\"], \" \", ages[\"wendy\"], \" \", ages[\"ronald\"], \"\\n\";  // 70 52 66\n  print a[\"bk\"], \" \", b[\"bk\"], \" \", ages[\"bk\"], \"\\n\";  // 8 67 67\n}\n\nmethod TestMapSubtraction() {\n  var ages := map[\"ronald\" := 66 as uint32, \"jack\" := 70, \"bk\" := 67, \"wendy\" := 52];\n  var d := ages - {};\n  var e := ages - {\"jack\", \"sanders\"};\n  print |ages|, \" \", |d|, \" \", |e|, \"\\n\";  // 4 4 3\n  print \"ronald\" in d, \" \", \"sanders\" in d, \" \", \"jack\" in d, \" \", \"sibylla\" in d, \"\\n\";  // true false true false\n  print \"ronald\" in e, \" \", \"sanders\" in e, \" \", \"jack\" in e, \" \", \"sibylla\" in e, \"\\n\";  // true false false false\n}\n\nclass MyClass {\n  const name: string\n  constructor (name: string) {\n    this.name := name;\n  }\n}\n\nmethod TestNullsAmongKeys() {\n  var a := new MyClass(\"ronald\");\n  var b := new MyClass(\"wendy\");\n  var c: MyClass? := null;\n  var d := new MyClass(\"jack\");\n  var e := new MyClass(\"sibylla\");\n\n  var m := map[a := 0 as uint32, b := 1, c := 2, d := 3];\n  var n := map[a := 0, b := 10, c := 20, e := 4];\n  var o := map[b := 199, a := 198];\n\n  var o' := map[b := 199, c := 55, a := 198];\n  var o'' := map[b := 199, c := 56, a := 198];\n  var o3 := map[c := 3, d := 16];\n  var x0, x1, x2 := o == o', o' == o'', o' == o';\n  print x0, \" \" , x1, \" \", x2, \"\\n\";  //  false false true\n\n  var p := m + n;\n  var q := n + o;\n  var r := o + m;\n  var s := o3 + o;\n  var y0, y1, y2, y3 := p == n + m, q == o + n, r == m + o, s == o + o3;\n  print y0, \" \" , y1, \" \", y2, \" \", y3, \"\\n\";  // false false false true\n\n  print p[a], \" \", p[c], \" \", p[e], \"\\n\";  // 0 20 4\n  print q[a], \" \", q[c], \" \", q[e], \"\\n\";  // 198 20 4\n  print r[a], \" \", r[c], \" \", e in r, \"\\n\";  // 0 2 false\n\n  p, q, r := GenericMap(m, n, o, a, e);\n  print p[a], \" \", p[c], \" \", p[e], \"\\n\";  // 0 20 4\n  print q[a], \" \", q[c], \" \", q[e], \"\\n\";  // 198 20 4\n  print r[a], \" \", r[c], \" \", e in r, \"\\n\";  // 0 2 false\n}\n\nmethod GenericMap<K, V>(m: map<K, V>, n: map<K, V>, o: map<K, V>, a: K, b: K)\n    returns (p: map<K, V>, q: map<K, V>, r: map<K, V>)\n  requires a in m.Keys && a in n.Keys\n  requires b !in m.Keys && b !in o.Keys\n  ensures p == m + n && q == n + o && r == o + m\n{\n  p := m + n;\n  q := n + o;\n  r := o + m;\n  print a in m.Keys, \" \", a in n.Keys, \" \", a in p, \" \", b in r, \"\\n\";  // true true true false\n\n  assert p.Keys == m.Keys + n.Keys;\n  assert q.Keys == o.Keys + n.Keys;\n  assert r.Keys == m.Keys + o.Keys;\n}\n\nmethod TestNullsAmongValues() {\n  var a := new MyClass(\"ronald\");\n  var b := new MyClass(\"wendy\");\n  var d := new MyClass(\"jack\");\n  var e := new MyClass(\"sibylla\");\n\n  var m: map<uint32, MyClass?> := map[0 := a, 1 := b, 2 := null, 3 := null];\n  var n: map<uint32, MyClass?> := map[0 := d, 10 := b, 20 := null, 4 := e];\n  var o: map<uint32, MyClass?> := map[199 := null, 198 := a];\n\n  var o': map<uint32, MyClass?> := map[199 := b, 55 := null, 198 := a];\n  var o'': map<uint32, MyClass?> := map[199 := b, 56 := null, 198 := a];\n  var o3: map<uint32, MyClass?> := map[3 := null, 16 := d];\n  var x0, x1, x2 := o == o', o' == o'', o' == o';\n  print x0, \" \" , x1, \" \", x2, \"\\n\";  //  false false true\n\n  var p := m + n;\n  var q := n + o;\n  var r := o + m;\n  var s := o3 + o;\n  var y0, y1, y2, y3 := p == n + m, q == o + n, r == m + o, s == o + o3;\n  print y0, \" \" , y1, \" \", y2, \" \", y3, \"\\n\";  // false true true true\n\n  print p[0].name, \" \", p[1].name, \" \", p[20], \"\\n\";  // jack wendy null\n  print q[0].name, \" \", q[199], \" \", q[20], \"\\n\";  // jack null null\n  print r[0].name, \" \", r[198].name, \" \", 20 in r, \"\\n\";  // ronald ronald false\n\n  p, q, r := GenericMap(m, n, o, 0, 321);\n  print p[0].name, \" \", p[1].name, \" \", p[20], \"\\n\";  // jack wendy null\n  print q[0].name, \" \", q[199], \" \", q[20], \"\\n\";  // jack null null\n  print r[0].name, \" \", r[198].name, \" \", 20 in r, \"\\n\";  // ronald ronald false\n}\n"}
{"file": "../dafny/Test/c++/generic.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nclass Test<T> {\n  var t:T\n\n  constructor (e:T) {\n    t := e;\n  }\n}\n\nclass UseTest<T> {\n  constructor () {}\n  method DoSomething(t:Test<T>)\n  {\n    var x:Test<T> := t;\n  }\n}\n\n\ndatatype Err<V> = Fail(b:bool) | Ok(value:V)\nmethod ErrTest() returns (e:Err<bool>)\n{\n  return Fail(false);\n}\n\nmethod GenericIO<A>(a:A) returns (a':A)\n{\n  a' := a;\n}\n\nmethod Main() {\n  var t := new Test(true);\n  var u := new UseTest();\n  u.DoSomething(t);\n}\n"}
{"file": "../dafny/Test/c++/while.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype uint32 = i:int | 0 <= i < 0x100000000\n\nmethod Main() {\n  var x:uint32 := 0;\n\n  while (x < 10) {\n    print x, \"\\n\";\n    x := x + 1;\n  }\n\n  print \"\\n\";\n\n  x := 0;\n  while (x < 10) {\n    print x, \"\\n\";\n    if (x == 5) { break; }\n    x := x + 1;\n }\n}\n"}
{"file": "../dafny/Test/c++/sets.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype uint32 = i:int | 0 <= i < 0x100000000\n\ndatatype Example0 = Example0(u:uint32, b:bool)\n\nmethod Test0(e0:Example0)\n{\n  var s := { e0 };\n}\n\ndatatype Example1 = Ex1a(u:uint32) |  Ex1b(b:bool)\nmethod Test1(t0:Example1)\n{\n  var t := { t0 };\n}\n\nmethod Test(name:string, b:bool)\n  requires b\n{\n  if b {\n    print name, \": This is expected\\n\";\n  } else {\n    print name, \": This is *** UNEXPECTED *** !!!!\\n\";\n  }\n}\n\nmethod Basic() {\n  var s:set<uint32> := {1, 2, 3, 4};\n  var t:set<uint32> := {1, 2, 3, 4};\n\n  Test(\"Identity\", s == s);\n  Test(\"ValuesIdentity\", s == t);\n  Test(\"DiffIdentity\", s - {1} == t - {1});\n  Test(\"DiffIdentitySelf\", s - {2} != s - {1});\n  Test(\"ProperSubsetIdentity\", !(s < s));\n  Test(\"ProperSubset\", !(s < t));\n  Test(\"SelfSubset\", s <= s);\n  Test(\"OtherSubset\", t <= s && s <= t);\n  Test(\"UnionIdentity\", s + s == s);\n  Test(\"Membership\", 1 in s);\n  Test(\"NonMembership1\", !(5 in s));\n  Test(\"NonMembership2\", !(1 in (s - {1})));\n}\n\nmethod SetSeq() {\n  var m1:seq<uint32> := [1];\n  var m2:seq<uint32> := [1, 2];\n  var m3:seq<uint32> := [1, 2, 3];\n  var m4:seq<uint32> := [1, 2, 3, 4];\n  var n1:seq<uint32> := [1];\n  var n2:seq<uint32> := [1, 2];\n  var n3:seq<uint32> := [1, 2, 3];\n\n  var s1:set<seq<uint32>> := { m1, m2, m3 };\n  var s2:set<seq<uint32>> := s1 - { m1 };\n\n  Test(\"SeqMembership1\", m1 in s1);\n  Test(\"SeqMembership2\", m2 in s1);\n  Test(\"SeqMembership3\", m3 in s1);\n  Test(\"SeqNonMembership1\", !(m1 in s2));\n  Test(\"SeqNonMembership2\", !(m4 in s1));\n  Test(\"SeqNonMembership3\", !(m4 in s2));\n\n  Test(\"SeqMembershipValue1\", n1 in s1);\n  Test(\"SeqMembershipValue2\", n2 in s1);\n  Test(\"SeqMembershipValue3\", n3 in s1);\n}\n\nmethod SetComprehension(s:set<uint32>)\n  requires forall i :: 0 <= i < 10 ==> i in s\n  requires |s| == 10\n{\n  var t:set<uint32> := set y:uint32 | y in s;\n  Test(\"SetComprehensionInEquality\", t == s);\n  Test(\"SetComprehensionInMembership\", 0 in t);\n}\n\nmethod LetSuchThat() {\n  var s:set<uint32> := { 0, 1, 2, 3 };\n  var e:uint32 :| e in s;\n\n  //print e, \"\\n\";\n  Test(\"LetSuchThatMembership\", e in s);\n  Test(\"LetSuchThatValue\", e == 0 || e == 1 || e == 2 || e == 3);\n}\n\nmethod Contains() {\n  var m1:seq<uint32> := [1];\n  var m2:seq<uint32> := [1, 2];\n  var m3:seq<uint32> := [1, 2, 3];\n  var m3identical:seq<uint32> := [1, 2, 3];\n  var mm := [m1, m3, m1];\n\n  if m1 in mm {\n    print \"Membership 1: This is expected\\n\";\n  } else {\n    print \"Membership 1: This is unexpected\\n\";\n    assert false;\n  }\n  if m2 in mm {\n    print \"Membership 2: This is unexpected\\n\";\n    assert false;\n  } else {\n    print \"Membership 2: This is expected\\n\";\n  }\n  if m3 in mm {\n    print \"Membership 3: This is expected\\n\";\n  } else {\n    print \"Membership 3: This is unexpected\\n\";\n    assert false;\n  }\n  if m3identical in mm {\n    print \"Membership 3 value equality: This is expected\\n\";\n  } else {\n    print \"Membership 3 value equality: This is unexpected\\n\";\n    assert false;\n  }\n}\n\nmethod Main() {\n  Basic();\n  SetSeq();\n  var s := { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  SetComprehension(s);\n  LetSuchThat();\n}\n"}
{"file": "../dafny/Test/c++/ints.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment --spill-translation --unicode-char:false\n\nnewtype sbyte = i:int | -0x80 <= i < 0x80\nnewtype byte = i:int | 0 <= i < 0x100\nnewtype int16 = i:int | -0x8000 <= i < 0x8000\nnewtype uint16 = i:int | 0 <= i < 0x10000\nnewtype int32 = i:int | -0x80000000 <= i < 0x80000000\nnewtype uint32 = i:int | 0 <= i < 0x100000000\nnewtype int64 = i:int | -0x8000000000000000 <= i < 0x8000000000000000\nnewtype uint64 = i:int | 0 <= i < 0x10000000000000000\nnewtype nat8 = i:int | 0 <= i < 0x80\nnewtype nat16 = i:int | 0 <= i < 0x8000\nnewtype nat32 = i:int | 0 <= i < 0x80000000\nnewtype nat64 = i:int | 0 <= i < 0x8000000000000000\n\nmethod Division(a:int64)\n  requires 0 <= a < 0x1_0000_0000\n{\n  var z := a / 2;\n  print z;\n}\n\nmethod Main() {\n  var x:uint32 := 40;\n  var y:uint32 := 2;\n  var z := x + y;\n\n  print \"Result is z = \", z, \"\\n\";\n}\n"}
{"file": "../dafny/Test/exports/ExportRefinement.dfy", "dafny": "// NONUNIFORM: Multiple testing scenarios (could be split)\n// RUN: %dafny /env:0 /compile:3 /dprint:\"%t.dfy\" \"%s\" > \"%t.result\"\n// RUN: %dafny /env:0 /printMode:DllEmbed /dprint:\"%t1.dfy\" \"%t.dfy\"\n// RUN: %dafny /env:0 /printMode:DllEmbed /dprint:\"%t2.dfy\" /compile:3 \"%t1.dfy\" > \"%t\"\n// RUN: %diff \"%t1.dfy\" \"%t2.dfy\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nabstract module A {\n  export Spec provides f, T, m, C\n  export Body provides m reveals f, T, C\n  type T\n  ghost function f(): T\n  method m()\n\n  class C {\n    method m()\n  }\n}\n\nmodule B refines A {\n  type T = int\n  ghost function f(): T { 0 }\n  method m() { print \"B\\n\"; }\n\n  class C ... {\n     method m() { print \"B.C.m\\n\"; }\n     method n() { print \"B.C.n\\n\"; }\n  }\n}\n\nabstract module C {\n  export Body provides AF reveals g\n\n  import AF : A`Spec\n\n  ghost function g(): AF.T\n}\n\nmodule DBBody refines C {\n  import AF = B`{Body,Spec}\n\n  ghost function g(): AF.T { 0 }\n\n}\n\nmodule DBSpec refines C {\n  import AF = B`Spec\n\n  ghost function g(): AF.T { AF.f() }\n\n}\n\nmodule E {\n  import D = DBBody`Body\n\n  ghost function h(): int { D.g() }\n}\n\nmodule F {\n  import D = DBSpec`Body\n\n  ghost function h(): D.AF.T { D.g() }\n}\n\n//Extending existing exports\n\nmodule A2 refines A {\n  export Spec ... provides m reveals T\n  export Body ... extends Spec provides C, C.m, C.Init\n\n  type T = int\n  ghost function f(): T { 0 }\n  method m() { print \"A2\\n\"; }\n\n  class C ... {\n    method m() { print \"A2.C.m\\n\"; }\n    method n() { print \"A2.C.n\\n\"; }\n    constructor Init() { }\n  }\n}\n\nmodule B2 {\n  import A2`Spec\n\n  ghost function g(): int { A2.f() }\n  method m() { print \"B2.m()\\n\"; A2.m(); }\n}\n\n//Facades must be refined by a base module\n\nabstract module C2 {\n  import ASpec : A`Spec\n}\n\nmodule C3 refines C2 {\n  import ASpec = A2`{Spec,Body}\n}\n\nmethod Main(){\n  C3.ASpec.m();\n  B2.m();\n  var c := new C3.ASpec.C.Init();\n  c.m();\n}\n\n// ---------- regressions -------------\n\nabstract module Regression_A {\n  export Spec provides x\n  export Body reveals x\n  const x: int := 80\n}\n\nabstract module Regression_B {\n  // once upon a time, merging two export sets of an abstract module caused a crash\n  import Regression_A`{Body,Spec}\n}\n"}
{"file": "../dafny/Test/exports/xrefine2.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n\nmodule ProtocolImpl {\n    export reveals *\n    export Spec provides ProtoT, Init\n\n    type ProtoT = bool\n\n    ghost predicate Init(p:ProtoT) { p }\n\n    method orange(i:nat) returns (j:nat)\n    {\n        j := i + 1;\n    }\n}\n\nmodule HostImpl {\n    export reveals *\n    export Spec provides HostT, foo, P\n\n    import P = ProtocolImpl\n\n    type HostT = int\n\n    function foo(h:HostT) : P.ProtoT\n    {\n        h != 0\n    }\n\n    method apple(i:nat) returns (j:nat)\n    {\n        j := i + 1;\n    }\n}\n\nmodule MainImpl {\n    export reveals *\n    export Spec provides Test, HISpec, PISpec\n\n    import HISpec = HostImpl`Spec\n    import PISpec = ProtocolImpl`Spec\n\n    import HI = HostImpl\n    import PI = ProtocolImpl\n\n    method Test(h1:HISpec.HostT, h2:HISpec.HostT)\n        requires HISpec.foo(h1) == HISpec.foo(h2)\n        requires PISpec.Init(HISpec.foo(h1))\n    {\n        var a := HI.foo(h1);\n        print \"HI.foo(h1) => \", a, \"\\n\";\n        var b := HI.foo(h2);\n        print \"HI.foo(h2) => \", b, \"\\n\";\n        var i := PI.orange(1);\n        print \"PI.orange(1) => \", i, \"\\n\";\n        var j := HI.apple(2);\n        print \"PI.apple(2) => \", j, \"\\n\";\n    }\n\n    method Main()\n    {\n        Test(-1, 1);\n    }\n}\n\n\n\n\n"}
{"file": "../dafny/Test/exports/AliasedImportConsistency.dfy", "dafny": "// RUN: %dafny /env:0 /dprint:\"%t.dfy\" /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n\nmodule A {\n  export Spec provides T\n  export Body reveals T\n\n  type T = int\n\n}\n\nmodule B {\n  export GoodSpec provides f, ASpec\n  export AnotherGoodSpec provides f, ABody\n  export YetAnotherGoodSpec provides f, ABody, ASpec\n  export GoodBody reveals f provides ABody\n\n  import ASpec = A`Spec\n  import ABody = A`Body\n\n  ghost function f(): ABody.T { 0 }\n\n}\n\nmodule C {\n  module InnerC {\n     export Spec provides T\n     export Body reveals T\n\n     type T = nat\n  }\n\n  import ASpec = InnerC`Spec\n  import ABody = InnerC`Body\n\n  export provides ASpec, ABody\n\n}\n\nmodule D {\n  import C\n\n  import ASpec = C.ASpec\n  import ABody = C.ABody\n\n  export provides ASpec, ABody\n\n}\n\nmodule E {\n  import C\n  import D\n\n  import CASpec = C.ASpec\n  import CABody = C.ABody\n  import DASpec = D.ASpec\n  import DABody = D.ABody\n\n  export Spec provides f, CASpec\n  export AnotherSpec provides f,g, CASpec\n\n  export Body reveals f,g provides CABody\n  export AnotherBody reveals f,g provides DABody\n\n  ghost function f(): CABody.T { 0 }\n  ghost function g(): DABody.T { f() }\n\n}\n\n"}
{"file": "../dafny/Test/exports/ClassMemberExport.dfy", "dafny": "// RUN: %dafny /env:0 /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n   export Spec reveals AClass provides T, AClass.f, AClass.Init\n   export Body reveals T, AClass provides AClass.Init, AClass.f, AClass.g\n\n   type T = int\n   class AClass {\n     function f(): T { 0 }\n     function g(): int { f() }\n     constructor Init() { }\n   }\n}\n\nmodule B {\n  import A = A`Spec\n\n  method Test() {\n    var a := new A.AClass.Init();\n    var f : A.T := a.f();\n  }\n\n}\n\nmodule C {\n  import A = A`Body\n\n  method Test() {\n    var a := new A.AClass.Init();\n    var f : int := a.f();\n    var g : A.T := a.g();\n    var e := f == g;\n  }\n\n}\n"}
{"file": "../dafny/Test/exports/DecreasesExports.dfy", "dafny": "// RUN: %dafny /env:0 /dprint:\"%t.dfy\" /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n\nmodule A {\n  export Specf provides T, f\n  export Bodyg provides T, g\n\n  export SpecF provides T, F\n  export BodyG provides T, G\n\n  type T = T2\n  datatype T2 = C(x: T2) | N\n\n  ghost function f(x: T, y: int): T { if y <= 0 then x else f(x, y-1) }\n\n  ghost function g(x: T): T\n   decreases x\n   { match x\n     case C(x') => g(x')\n     case N => x\n   }\n\n  method F(x: T, y: int) {\n    if (y > 0) {\n       F(x, y-1);\n    }\n\n  }\n\n  method G(x: T)\n  decreases x\n  {\n    match (x) {\n       case C(x') =>\n            G(x');\n       case N =>\n           assert true;\n    }\n  }\n\n}\n\nmodule B {\n  import A`Specf\n\n  ghost function h(x: A.T): A.T { A.f(x, 1) }\n}\n\nmodule C {\n  import A`Bodyg\n  ghost function i(x: A.T): A.T { A.g(x) }\n}\n\nmodule D {\n  import A`SpecF\n\n  method H(x: A.T) {\n     A.F(x, 2);\n  }\n}\n\nmodule E {\n  import A`BodyG\n\n  method I(x: A.T) {\n    A.G(x);\n  }\n\n}\n\n\n\n"}
{"file": "../dafny/Test/exports/ExportInductivePredicate.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule M {\n  least predicate P(x: int)\n  {\n    x < 100\n  }\n\n  greatest predicate Q(x: int)\n  {\n    x < 100\n  }\n\n  lemma K(x: int)\n    requires P(x)\n  {\n  }\n  lemma K'(x: int)\n    requires P#[3](x)\n  {\n  }\n  lemma CoK(x: int)\n    requires x < 100\n    ensures Q(x)\n  {\n  }\n  lemma CoK'(x: int)\n    requires x < 100\n    ensures Q#[3](x)\n  {\n  }\n}\n\nmodule M' {\n  import opened M\n\n  lemma H(x: int)\n    requires M.P(x)\n  {\n  }\n  lemma H'(x: int)\n     requires M.P#[3](x)\n  {\n  }\n  lemma CoH(x: int)\n    requires x < 100\n    ensures M.Q(x)\n  {\n  }\n  lemma CoH'(x: int)\n    requires x < 100\n    ensures M.Q#[3](x)\n  {\n  }\n\n  lemma L(x: int)\n    requires P(x)\n  {\n  }\n  lemma L'(x: int)\n    requires P#[3](x)\n  {\n  }\n  lemma CoL(x: int)\n    requires x < 100\n    ensures Q(x)\n  {\n  }\n  lemma CoL'(x: int)\n    requires x < 100\n    ensures Q#[3](x)\n  {\n  }\n\n  least lemma V(x: int)\n    requires P(x)\n  {\n  }\n  least lemma W(x: int)\n    requires M.P(x)\n  {\n  }\n  greatest lemma CoV(x: int)\n    requires x < 100\n    ensures Q(x)\n  {\n  }\n  greatest lemma CoW(x: int)\n    requires x < 100\n    ensures M.Q(x)\n  {\n  }\n}\n"}
{"file": "../dafny/Test/exports/ImportPathNonShadow.dfy", "dafny": "// RUN: %dafny /env:0 /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule A {\n  export fandg provides f, g\n  export justf provides f\n\n  ghost function f(): int { 0 }\n  ghost function g(): int { 1 }\n\n}\n\nabstract module B {\n  import Afandg = A`fandg\n  import A : A`justf\n\n  ghost function h(): int { A.f() + Afandg.g() + Afandg.f() }\n}\n\nabstract module BB {\n  import A : A`justf\n  import Afandg = A`fandg\n\n  ghost function h(): int { A.f() + Afandg.g() + Afandg.f() }\n}\n\nmodule C {\n  import Afandg = A`fandg\n  import A = A`justf\n\n  ghost function h(): int { A.f() + Afandg.g() + Afandg.f() }\n}\n\nmodule CC {\n  import A = A`justf\n  import Afandg = A`fandg\n\n  ghost function h(): int { A.f() + Afandg.g() + Afandg.f() }\n}\n"}
{"file": "../dafny/Test/logger/VerboseName.dfy", "dafny": "// RUN: %dafny /compile:0 /trace \"%s\" > \"%t\"\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK-L:Verifying AM1.T2Client.Calc (override check) ...\n// CHECK-L:Verifying posIdMeth (correctness) ...\n// CHECK-L:Verifying smallPrime (well-formedness) ...\nnewtype smallPrime = x: int | x in {2, 3, 5, 7} witness 2\n\nfunction posId(x: smallPrime): smallPrime {\n  x\n}\n\nmethod posIdMeth(x: smallPrime) returns (r: int)\n  ensures r > 0\n{\n  r := posId(x) as int;\n}\n\nabstract module AM1\n{\n  trait T2\n  {\n    method Calc(i:int, j:int) returns (k:int)\n  }\n\n  class T2Client extends T2\n  {\n    method Calc(ii:int, jj:int) returns (kk:int)\n  }\n}\n"}
{"file": "../dafny/Test/logger/ProofDependencyLogging.dfy", "dafny": "// RUN: %baredafny verify --log-format:text --boogie -trackVerificationCoverage \"%s\" > \"%t\"\n// RUN: %OutputCheck --file-to-check \"%t\" \"%s\"\n// CHECK: Results for RedundantAssumeMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(177,12\\)-\\(177,16\\): assume statement\n// CHECK:       ProofDependencyLogging.dfy\\(178,12\\)-\\(178,12\\): assertion always holds\n//\n// CHECK: Results for ContradictoryAssumeMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(183,12\\)-\\(183,16\\): assume statement\n// CHECK:       ProofDependencyLogging.dfy\\(184,12\\)-\\(184,16\\): assume statement\n//\n// CHECK: Results for AssumeFalseMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(192,12\\)-\\(192,12\\): assume statement\n//\n// CHECK: Results for ObviouslyContradictoryRequiresFunc \\(well-formedness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(198,12\\)-\\(198,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(199,12\\)-\\(199,16\\): requires clause\n//\n// CHECK: Results for ObviouslyContradictoryRequiresMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(207,12\\)-\\(207,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(208,12\\)-\\(208,16\\): requires clause\n//\n// CHECK: Results for ObviouslyRedundantRequiresFunc \\(well-formedness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(216,1\\)-\\(222,1\\): function definition for ObviouslyRedundantRequiresFunc\n// CHECK:       ProofDependencyLogging.dfy\\(217,12\\)-\\(217,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(219,11\\)-\\(219,15\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(221,3\\)-\\(221,7\\): function call result\n// CHECK:       ProofDependencyLogging.dfy\\(221,5\\)-\\(221,5\\): value always satisfies the subset constraints of 'nat'\n//\n// CHECK: Results for ObviouslyRedundantRequiresMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(225,12\\)-\\(225,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(227,11\\)-\\(227,15\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(229,12\\)-\\(229,12\\): value always satisfies the subset constraints of 'nat'\n// CHECK:       ProofDependencyLogging.dfy\\(229,3\\)-\\(229,15\\): assignment \\(or return\\)\n//\n// CHECK: Results for ObviouslyUnnecessaryRequiresFunc \\(well-formedness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(237,21\\)-\\(237,21\\): value always satisfies the subset constraints of 'nat'\n// CHECK:       ProofDependencyLogging.dfy\\(237,32\\)-\\(237,32\\): value always satisfies the subset constraints of 'nat'\n//\n// CHECK: Results for ObviouslyUnnecessaryRequiresMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(244,25\\)-\\(244,25\\): value always satisfies the subset constraints of 'nat'\n// CHECK:       ProofDependencyLogging.dfy\\(244,48\\)-\\(244,48\\): value always satisfies the subset constraints of 'nat'\n//\n// CHECK: Results for ObviouslyUnconstrainedCodeFunc \\(well-formedness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(248,1\\)-\\(256,1\\): function definition for ObviouslyUnconstrainedCodeFunc\n// CHECK:       ProofDependencyLogging.dfy\\(249,12\\)-\\(249,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(250,11\\)-\\(250,17\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(252,12\\)-\\(252,16\\): let expression binding RHS well-formed\n// CHECK:       ProofDependencyLogging.dfy\\(252,7\\)-\\(252,7\\): let expression binding\n// CHECK:       ProofDependencyLogging.dfy\\(254,3\\)-\\(254,3\\): let expression result\n//\n// CHECK: Results for ObviouslyUnconstrainedCodeMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(259,12\\)-\\(259,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(260,11\\)-\\(260,17\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(262,9\\)-\\(262,17\\): assignment \\(or return\\)\n// CHECK:       ProofDependencyLogging.dfy\\(264,3\\)-\\(266,8\\): assignment \\(or return\\)\n//\n// CHECK: Results for PartiallyRedundantRequiresFunc \\(well-formedness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(270,1\\)-\\(275,1\\): function definition for PartiallyRedundantRequiresFunc\n// CHECK:       ProofDependencyLogging.dfy\\(271,23\\)-\\(271,27\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(272,11\\)-\\(272,15\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(274,3\\)-\\(274,7\\): function call result\n// CHECK:       ProofDependencyLogging.dfy\\(274,5\\)-\\(274,5\\): value always satisfies the subset constraints of 'nat'\n//\n// CHECK: Results for PartiallyUnnecessaryRequiresFunc \\(well-formedness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(279,22\\)-\\(279,26\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(282,21\\)-\\(282,21\\): value always satisfies the subset constraints of 'nat'\n// CHECK:       ProofDependencyLogging.dfy\\(282,32\\)-\\(282,32\\): value always satisfies the subset constraints of 'nat'\n//\n// CHECK: Results for MultiPartRedundantRequiresFunc \\(well-formedness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(288,1\\)-\\(295,1\\): function definition for MultiPartRedundantRequiresFunc\n// CHECK:       ProofDependencyLogging.dfy\\(291,12\\)-\\(291,17\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(292,11\\)-\\(292,16\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(294,3\\)-\\(294,3\\): function call result\n//\n// CHECK: Results for MultiPartRedundantRequiresMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(300,12\\)-\\(300,17\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(301,11\\)-\\(301,16\\): ensures clause\n//\n// CHECK: Results for MultiPartContradictoryRequiresFunc \\(well-formedness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(309,1\\)-\\(316,1\\): function definition for MultiPartContradictoryRequiresFunc\n// CHECK:       ProofDependencyLogging.dfy\\(310,12\\)-\\(310,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(311,12\\)-\\(311,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(313,11\\)-\\(313,16\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(315,3\\)-\\(315,3\\): function call result\n//\n// CHECK: Results for MultiPartContradictoryRequiresMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(319,12\\)-\\(319,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(320,12\\)-\\(320,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(322,11\\)-\\(322,16\\): ensures clause\n//\n// CHECK: Results for CallContradictoryFunctionFunc \\(well-formedness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(336,1\\)-\\(342,1\\): function definition for CallContradictoryFunctionFunc\n// CHECK:       ProofDependencyLogging.dfy\\(337,12\\)-\\(337,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(338,11\\)-\\(338,15\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(341,3\\)-\\(341,3\\): function precondition satisfied\n// CHECK:       ProofDependencyLogging.dfy\\(341,3\\)-\\(341,39\\): function call result\n//\n// CHECK: Results for CallContradictoryMethodMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(345,12\\)-\\(345,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(348,9\\)-\\(348,47\\): ensures clause at ProofDependencyLogging.dfy\\(333,12\\)-\\(333,25\\) from call\n// CHECK:       ProofDependencyLogging.dfy\\(348,9\\)-\\(348,47\\): ensures clause at ProofDependencyLogging.dfy\\(333,12\\)-\\(333,25\\) from call\n// CHECK:       ProofDependencyLogging.dfy\\(348,9\\)-\\(348,47\\): requires clause at ProofDependencyLogging.dfy\\(332,12\\)-\\(332,16\\) from call\n//\n// CHECK: Results for FalseAntecedentRequiresClauseMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(357,3\\)-\\(357,15\\): assignment \\(or return\\)\n//\n// CHECK: Results for FalseAntecedentAssertStatementMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(362,9\\)-\\(362,15\\): assignment \\(or return\\)\n// CHECK:       ProofDependencyLogging.dfy\\(363,20\\)-\\(363,20\\): assertion always holds\n//\n// CHECK: Results for FalseAntecedentEnsuresClauseMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(368,11\\)-\\(368,25\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(370,3\\)-\\(370,13\\): assignment \\(or return\\)\n//\n// CHECK: Results for ObviouslyUnreachableIfExpressionBranchFunc \\(well-formedness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(373,1\\)-\\(380,1\\): function definition for ObviouslyUnreachableIfExpressionBranchFunc\n// CHECK:       ProofDependencyLogging.dfy\\(374,12\\)-\\(374,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(375,11\\)-\\(375,15\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(379,8\\)-\\(379,12\\): if expression else branch\n//\n// CHECK: Results for ObviouslyUnreachableIfStatementBranchMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(383,12\\)-\\(383,16\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(384,11\\)-\\(384,15\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(389,5\\)-\\(389,17\\): assignment \\(or return\\)\n//\n// CHECK: Results for ObviouslyUnreachableMatchExpressionCaseFunction \\(well-formedness\\)\n//\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(395,1\\)-\\(403,1\\): function definition for ObviouslyUnreachableMatchExpressionCaseFunction\n// CHECK:       ProofDependencyLogging.dfy\\(396,12\\)-\\(396,17\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(397,11\\)-\\(397,15\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(401,15\\)-\\(401,15\\): match expression branch result\n//\n// CHECK: Results for ObviouslyUnreachableMatchStatementCaseMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(406,12\\)-\\(406,17\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(407,11\\)-\\(407,15\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(411,15\\)-\\(411,23\\): assignment \\(or return\\)\n//\n// CHECK: Results for ObviouslyUnreachableReturnStatementMethod \\(correctness\\)\n// CHECK:     Proof dependencies:\n// CHECK:       ProofDependencyLogging.dfy\\(416,12\\)-\\(416,17\\): requires clause\n// CHECK:       ProofDependencyLogging.dfy\\(417,13\\)-\\(417,17\\): ensures clause\n// CHECK:       ProofDependencyLogging.dfy\\(420,7\\)-\\(420,15\\): assignment \\(or return\\)\n\n\n\n\nmethod RedundantAssumeMethod(n: int)\n{\n    // either one or the other assumption shouldn't be covered\n    assume n > 4;\n    assume n > 3;\n    assert n > 1;\n}\n\nmethod ContradictoryAssumeMethod(n: int)\n{\n    assume n > 0;\n    assume n < 0;\n    assume n == 5; // shouldn't be covered\n    assert n < 10; // shouldn't be covered\n}\n\nmethod AssumeFalseMethod(n: int)\n{\n    assume n == 15; // shouldn't be covered\n    assume false;\n    assert n < 10; // shouldn't be covered\n}\n\n// Obvious contradiction in requires clauses.\nfunction ObviouslyContradictoryRequiresFunc(x: nat): (r: nat)\n  requires x > 10\n  requires x < 10\n  ensures r < x // only provable vacuously \n{\n  assert x == 10; // contradicts both requires clauses\n  x - 1 // not necessarily a valid nat\n}\n\nmethod ObviouslyContradictoryRequiresMethod(x: nat) returns (r: nat)\n  requires x > 10\n  requires x < 10\n  ensures r < x // only provable vacuously\n{\n  assert x == 10; // contradicts both requires clauses\n  return x - 1; // not necessarily a valid nat\n}\n\n// Obvious redundancy in requires clauses.\nfunction ObviouslyRedundantRequiresFunc(x: nat): (r: nat)\n  requires x < 10\n  requires x < 100 // implied by previous requires clause\n  ensures r < 11 // should cause body and first requires clause to be covered\n{\n  x + 1\n}\n\nmethod ObviouslyRedundantRequiresMethod(x: nat) returns (r: nat)\n  requires x < 10\n  requires x < 100 // implied by previous requires clause\n  ensures r < 11 // should cause body and first requires clause to be covered\n{\n  return x + 1;\n}\n\n// Obviously unnecessary requires clauses.\nfunction ObviouslyUnnecessaryRequiresFunc(x: nat): (r: nat)\n  requires x < 10 // not required for the proof\n{\n  // cause at least a little proof work to be necessary, for nat bounds\n  if (x > 5) then x + 2 else x + 1\n}\n\nmethod ObviouslyUnnecessaryRequiresMethod(x: nat) returns (r: nat)\n  requires x < 10 // not required for the proof\n{\n  // cause at least a little proof work to be necessary, for nat bounds\n  if (x > 5) { return x + 2; } else { return x + 1; }\n}\n\n// Code obviously not constrained by ensures clause.\nfunction ObviouslyUnconstrainedCodeFunc(x: int): (r: (int, int))\n  requires x > 10\n  ensures r.0 > 10\n{\n  var a := x + 1; // constrained by ensures clause\n  var b := x - 1; // not constrained by ensures clause \n  (a,\n   b)\n}\n\nmethod ObviouslyUnconstrainedCodeMethod(x: int) returns (r: (int, int))\n  requires x > 10\n  ensures r.0 > 10\n{\n  var a := x + 1; // constrained by ensures clause\n  var b := x - 1; // not constrained by ensures clause\n  return\n    (a,\n     b);\n}\n\n// Partial redundancy in requires clauses.\nfunction PartiallyRedundantRequiresFunc(x: nat): (r: nat)\n  requires x < 100 && x < 10 // LHS implied by RHS\n  ensures r < 11 // should cause body and RHS clause to be covered\n{\n  x + 1\n}\n\n// Partly unnecessary requires clause.\nfunction PartiallyUnnecessaryRequiresFunc(x: int): (r: nat)\n  requires x < 10 && x > 0 // RHS required for proof, but not LHS\n{\n  // cause at least a little proof work to be necessary, for nat bounds\n  if (x > 5) then x - 1 else x + 1\n}\n\n\n// Redundancy of one requires clause due to at least two others, with at least\n// one of the three being partly in a separately-defined function.\nfunction MultiPartRedundantRequiresFunc(x: int): (r: int)\n  requires x > 10\n  requires x < 12\n  requires x == 11 // implied by the previous two, but neither individually\n  ensures r == 11\n{\n  x\n}\n\nmethod MultiPartRedundantRequiresMethod(x: int) returns (r: int)\n  requires x > 10\n  requires x < 12\n  requires x == 11 // implied by the previous two, but neither individually\n  ensures r == 11\n{\n  return x;\n}\n\n// Contradiction between three different requires clauses, with at least one of\n// the three being partly in a separately-defined function (function and\n// method).\nfunction MultiPartContradictoryRequiresFunc(x: int, y: int): (r: int)\n  requires x > 10\n  requires x < 12\n  requires y != 11 // contradicts the previous two\n  ensures r == 11 // provable from first two preconditions, but shouldn't be covered\n{\n  x\n}\n\nmethod MultiPartContradictoryRequiresMethod(x: int, y: int) returns (r: int)\n  requires x > 10\n  requires x < 12\n  requires y != 11 // contradicts the previous two\n  ensures r == 11 // provable from first two preconditions, but shouldn't be covered\n{\n  return x;\n}\n\nfunction ContradictoryEnsuresClauseFunc(x: int): (r: int)\n  requires x > 1\n  ensures  r > x && r < 0\n\nmethod ContradictoryEnsuresClauseMethod(x: int) returns (r: int)\n  requires x > 1\n  ensures  r > x && r < 0\n\n// Call function that has contradictory ensures clauses.\nfunction CallContradictoryFunctionFunc(x: int): (r: int)\n  requires x > 1\n  ensures r < 0\n{\n  // TODO: Dafny doesn't generate sufficient Boogie code to make the contradiction detectable\n  ContradictoryEnsuresClauseFunc(x) - 1\n}\n\nmethod CallContradictoryMethodMethod(x: int) returns (r: int)\n  requires x > 1\n  ensures r < 0\n{\n  var y := ContradictoryEnsuresClauseMethod(x);\n  return y - 1;\n}\n\n// False antecedent requires clause\nmethod FalseAntecedentRequiresClauseMethod(x: int) returns (r: int)\n  requires x*x < 0 ==> x == x + 1\n  ensures r > x\n{\n  return x + 1;\n}\n\n// False antecedent assert statement.\nmethod FalseAntecedentAssertStatementMethod(x: int) {\n  var y := x*x;\n  assert y < 0 ==> x < 0;\n}\n\n// False antecedent ensures clause.\nmethod FalseAntecedentEnsuresClauseMethod(x: int) returns (r: int)\n  ensures r < 0 ==> x < 0\n{\n  return x*x;\n}\n\nfunction ObviouslyUnreachableIfExpressionBranchFunc(x: int): (r:int)\n  requires x > 0\n  ensures r > 0\n{\n  if x < 0\n  then x - 1 // unreachable\n  else x + 1\n}\n\nmethod ObviouslyUnreachableIfStatementBranchMethod(x: int) returns (r:int)\n  requires x > 0\n  ensures r > 0\n{\n  if x < 0 {\n    return x - 1; // unreachable\n  } else {\n    return x + 1;\n  }\n}\n\ndatatype T = A | B\n\nfunction ObviouslyUnreachableMatchExpressionCaseFunction(t: T): (r:int)\n  requires t != A\n  ensures r > 1 // alt: r > 0\n{\n  match t {\n    case A => 1 // unreachable\n    case B => 2\n  }\n}\n\nmethod ObviouslyUnreachableMatchStatementCaseMethod(t: T) returns (r:int)\n  requires t != A\n  ensures r > 1 // alt: r > 0\n{\n  match t {\n    case A => return 1; // unreachable\n    case B => return 2;\n  }\n}\n\nmethod ObviouslyUnreachableReturnStatementMethod(t: T) returns (r:int)\n  requires t != A\n    ensures r > 1 // alt: r > 0\n  {\n    if !t.A? {\n      return 2;\n    }\n\n    return 1; // unreachable\n  }\n"}
{"file": "../dafny/Test/concurrency/01-InnerOuter.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This program shows how to model an outer type whose invariant refers to the invariant of an inner type.\n\n// A universe of objects playing under LCI rules \ntrait S {\n  // The set of objects in the universe\n  ghost var obs: set<O>\n\n  // Workaround Dafny not supporting _ as object\n  ghost function upCast(o: object): object {o}\n  \n  // Universe invariant: the universe doesn't contain itself, \n  // and its objects in this universe agree that they are in this universe.\n  // We define this to allow a generic object operation (O.join below) to add the object to the universe, \n  // without having to check the object invariants.\n  ghost predicate i0() reads this, obs { forall o: O | o in obs :: o.s == this && upCast(o) != this }\n  \n  // Global 1-state invariant: all objects satisfy their individual invariants.\n  ghost predicate i() reads * { i0() && forall o: O | o in obs :: o.i() }\n  \n  // Global 2-state invariant: all old objects satisfy their 2-state invariants.\n  twostate predicate i2() reads * { forall o: O | o in old(obs) :: o in obs && o.i2() }\n  \n  // The first condition for legality: old objects that change a field must obey their 1- and 2-state invariants.\n  twostate predicate legal0() reads * { forall o: O | o in old(obs) :: unchanged(o) || (o.i2() && o.i()) }\n  \n  // The second condition for legality: new objects must satisfy their invariants.\n  twostate predicate legal1() reads * { forall o: O | o in obs && o !in old(obs) :: o.i() }\n  \n  // A legal transition is one that starts from a good state, preserves the universe invariant, and meets the legality conditions. \n  twostate predicate legal() reads * { old(i()) && i0() && old(obs) <= obs && legal0() && legal1() }\n  \n  // LCI soundness: legal transitions are good. This makes use of the admissibility obligations build into O's.\n  twostate lemma lci() requires legal() ensures i() && i2() {\n    forall o: O | o in old(obs) && o.admPre() ensures o.i2() && o.i() { o.adm(); }\n  }\n}\n\n// A generic object trait\ntrait O {\n  // Universe of which O is a member.\n  // This should really be a constant, but I don't know how to do that while factoring out join below,\n  // because traits can't have constructors.\n  ghost const s: S\n\n  // Base invariant: we're in the universe, and the universe satisfies its base.\n  ghost predicate i0() reads * { this in s.obs && s.i0() }\n  \n  // Join universe s\n  ghost method join()\n    requires s.i0() && s.upCast(this) != s\n    modifies s \n    ensures i0() && s.obs == old(s.obs) + { this }\n  {\n    s.obs := s.obs + { this }; \n  }\n\n  // Precondition for the admissibility check.\n  // This is broken into a separate predicate because Dafny currently doesn't allow adm.requires() in a 1-state context\n  twostate predicate admPre() reads * { i0() && old(i0() && s.i()) && unchanged(this) && s.legal() }\n\n  // Global invariant (from o's perspective) - I am in the universe and the universe is good. (This implies I am good also.)\n  ghost predicate gi() reads * { i0() && s.i() }\n\n  // Global 2-state invariant (from o's perspective).\n  twostate predicate gi2() requires old(gi()) reads * { i0() && s.i2() }\n\n  // To be implemented in the class: 1-state invariant, 2-state invariant, and admissibility proof.\n  ghost predicate i() reads *\n  twostate predicate i2() reads *\n  twostate lemma adm() requires admPre() ensures i2() && i()\n}\n\nclass Inner extends O {\n  var data: int\n\n  // Invariant\n  ghost predicate i() reads * {\n    && i0()\n  }\n  twostate predicate i2() reads * {\n    && old(data) <= data\n  }\n\n  twostate lemma adm() requires admPre() {}\n\n  constructor (ghost s: S, initial_data: int)\n    requires s.i()\n    modifies s\n    ensures s.i()\n  {\n    this.s := s;\n    data := initial_data;\n    new;\n    join();\n    s.lci();\n  }\n}\n\nclass Outer extends O {\n  var inner: Inner\n\n  // Invariant\n  ghost predicate i() reads * {\n    && i0()\n    && s == inner.s\n    && inner.i()\n  }\n  twostate predicate i2() reads * {\n    && inner == old(inner)\n    && inner.i2()\n  }\n\n  twostate lemma adm() requires admPre() ensures i2() && i() {\n  }\n\n  constructor (ghost s: S, inner: Inner)\n    requires s.i() && s == inner.s && inner.i()\n    modifies s\n    ensures s.i()\n  {   \n    this.s := s;\n    this.inner := inner;\n    new;\n    join();\n    s.lci();\n  }\n}\n"}
{"file": "../dafny/Test/concurrency/04-LeastGreatest.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Simple least predicate\n\n// Note: `least predicate P(x: int) { true && P(x) }` would be equivalent to `false`.\n\nleast predicate P(x: int) {\n  x == 123 || P(x)\n}\n\nlemma BuildP(x: int) requires x == 123 ensures P(x) {}\n\n// Simple greatest predicate\n\ngreatest predicate Q(x: int) {\n  true && Q(x)\n}\n\ngreatest lemma BuildQ(x: int)\n  ensures Q(x)\n{\n}\n\nlemma AdvBuildQ(x: int)\n  ensures Q(x)\n{\n  forall k: ORDINAL { AdvBuildQAux(k, x); }\n}\n\nlemma AdvBuildQAux(k: ORDINAL, x: int) ensures Q#[k](x) {}\n\n// Another simple greatest predicate\n\ngreatest predicate R(x: bool) {\n  x ==> R(x)\n}\n\ngreatest lemma BuildR(x: bool) ensures R(true) {}\n\n// Mutually recursive\n\ntrait Object {}\n\ngreatest predicate A(x: Object) {\n  B(x)\n}\n\ngreatest predicate B(x: Object) {\n  A(x)\n}\n\nlemma BuildA(x: Object) ensures A(x) {\n  forall k: ORDINAL { BuildAAux(k, x); }\n}\n\nlemma BuildAAux(k: ORDINAL, x: Object) ensures A#[k](x) {\n  forall j: ORDINAL | j < k { BuildBAux(j, x); }\n}\n\nlemma BuildBAux(k: ORDINAL, x: Object) ensures B#[k](x) {\n  forall j: ORDINAL | j < k { BuildAAux(j, x); }\n}\n\n// Mutually recursive, using two different traits\n\ntrait TraitA {\n  var b: TraitB\n}\n\ntrait TraitB {\n  var a: TraitA\n}\n\ngreatest predicate invA(self: TraitA) reads * {\n  invB(self.b)\n}\n\ngreatest predicate invB(self: TraitB) reads * {\n  invA(self.a)\n}\n\nlemma EstablishInvA(self: TraitA)\n  ensures invA(self)\n{\n  forall k: ORDINAL { EstablishInvAuxA(k, self); }\n}\n\nlemma EstablishInvAuxA(k: ORDINAL, self: TraitA)\n  ensures invA#[k](self)\n{\n  forall j: ORDINAL | j < k { EstablishInvAuxB(j, self.b); }\n}\n\nlemma EstablishInvB(self: TraitB)\n  ensures invB(self)\n{\n  forall k: ORDINAL { EstablishInvAuxB(k, self); }\n}\n\nlemma EstablishInvAuxB(k: ORDINAL, self: TraitB)\n  ensures invB#[k](self)\n{\n  forall j: ORDINAL | j < k { EstablishInvAuxA(j, self.a); }\n}\n\ngreatest lemma AlternativeEstablishInvA(self: TraitA) ensures invA(self) && invB(self.b) {}\n\ngreatest lemma AlternativeEstablishInvB(self: TraitB) ensures invB(self) && invA(self.a) {}\n"}
{"file": "../dafny/Test/ghost/Comp.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment --spill-translation\n\ndatatype PhantomData<T> = PhantomData(ghost value: T)\n\nmethod Test0(t0: (ghost int)) { print \"Test0: \", t0, \"\\n\"; }\nmethod Test1(t1: (ghost int, int)) { print \"Test1: \", t1, \"\\n\"; }\nmethod Test2(t2: (int, ghost int, int)) { print \"Test2: \", t2, \"\\n\"; }\nmethod Test3(t3: ((ghost int), (ghost int, int), ghost int)) { print \"Test3: \", t3, \"\\n\"; }\n\nmethod Main() {\n  var p := PhantomData(123);\n  var t0, t1, t2, t3 := *, *, *, *;\n  Test0(t0);\n  Test1(t1);\n  Test2(t2);\n  Test3(t3);\n  t0 := (ghost 00);\n  t1 := (ghost 11, 22);\n  t2 := (33, ghost 44, 55);\n  t3 := ((ghost 66), (ghost 77, 88), ghost 99);\n  Test0(t0);\n  Test1(t1);\n  Test2(t2);\n  Test3(t3);\n  TestDestructors();\n  TestMatchDestructions();\n  var sss := TestSingletons();\n  print sss.1, \"\\n\"; // 1213\n  MoreSingletonTests();\n}\n\nmethod TestDestructors() {\n  var u := (100, 200);\n  print u.0, \" \", u.1, \"\\n\"; // 100 200\n\n  var a, b, c, d := *, *, *, *; // will be initialized to default values\n  print a, \" \", b, \" \", c, \" \", d, \"\\n\"; // \n\n  a := (5, ghost 7, 9);\n  b := (ghost 9, ghost 16, 25, 36);\n  c := (ghost 7, 5);\n  d := (ghost 9, ghost 16, 25);\n\n  print a.2, \" \", b.2, \"\\n\"; // 9 25\n  print c.1, \" \", d.2, \"\\n\"; // 5 25\n}\n\nmethod TestMatchDestructions() {\n  var e := (ghost 15);\n  var a := (5, ghost 7, 9);\n  var b := (ghost 9, ghost 16, 25, 36);\n  var c := (ghost 7, 5);\n  var d := (ghost 9, ghost 16, 25);\n\n  // match statements\n\n  match e {\n    case (_) => print e, \"\\n\"; // ()\n  }\n  match a {\n    case (x, _, y) => print x, \" \", y, \"\\n\"; // 5 9\n  }\n  match b {\n    case (_, _, x, y) => print x, \" \", y, \"\\n\"; // 25 36\n  }\n  match c {\n    case (_, x) => print x, \"\\n\"; // 5\n  }\n  match d {\n    case (_, _, x) => print x, \"\\n\"; // 25\n  }\n\n  // match expressions\n\n  var ee := match e case (_) => e;\n  var aa := match a case (x, _, y) => x + y; // 14\n  var bb := match b case (_, _, x, y) => x + y; // 61\n  var cc := match c case (_, x) => x; // 5\n  var dd := match d case (_, _, x) => x; // 25\n  print ee, \" \", aa, \" \", bb, \" \", cc, \" \", dd, \"\\n\";\n}\n\nmethod TestSingletons() returns (r: (ghost int, int, ghost real, ghost real)) {\n  var s0 := Singleton0();\n  var s1 := Singleton1();\n  print s1, \"\\n\"; // as usual for datatypes, ghost components are omitted\n  var s2 := Singleton2();\n  var c := SingletonConst;\n  var u := (if s0.1 == s1.0 then 1100 else 1099) + s2.2 + c.0;\n  assert u == 1212;\n  r := (ghost u + 50, u, ghost s0.1, ghost s2.0);\n\n  var x;\n  match s2 {\n    case (a, b, c, d) => x := c;\n  }\n  x := x + match s2 case (a, b, c, d) => 1 - c;\n  assert x == 1;\n\n  return r.(1 := r.1 + x);\n}\n\nfunction Singleton0(): (ghost int, real) {\n  (ghost 2, 3.2)\n}\n\nfunction Singleton1(): (real, ghost int) {\n  (3.2, ghost 2)\n}\n\nfunction Singleton2(): (ghost real, ghost (), int, ghost char) {\n  (ghost 5.0, ghost (), 100, ghost 'D')\n}\n\nconst SingletonConst := (12, ghost 13)\n\ntype SX = (ghost int, int, ghost int)\ntype SX2 = (SX, ghost real)\ndatatype SX3 = SX3(a: SX, ghost b: real)\n\nmethod MoreSingletonTests() {\n  var r := (ghost 2, 3, ghost 4);\n  print r, \"\\n\"; // 3\n  var arr := new SX[20];\n  arr[3] := (ghost 200, 100, ghost 400);\n  PrintOneSx(arr[3]); // 100\n  print arr[0], \" \", arr[3], \"\\n\"; // 0 100\n  UpdateArray(arr, (ghost 99, 9, ghost 999));\n  print arr[1], \" \", arr[2], \"\\n\"; // 0 9\n  UpdateSxArray(arr, (ghost 99, 19, ghost 999));\n  print arr[4], \" \", arr[5], \"\\n\"; // 0 19\n\n  var sx2 := (arr[5], ghost 2.0);\n  print sx2, \"\\n\"; // 19\n  var arr2 := new SX2[20];\n  UpdateArray(arr2, ((ghost 5, 15, ghost 25), ghost 3.0));\n  print arr2[1], \" \", arr2[2], \"\\n\"; // 0 15\n\n  var sx3 := SX3(arr[2], 4.0);\n  print sx3, \"\\n\"; // 9\n  var arr3 := new SX3[20];\n  UpdateArray(arr3, sx3);\n  print arr3[1], \" \", arr3[2], \"\\n\"; // 0 9\n}\n\nmethod PrintOneSx(g: SX) {\n  print g, \"\\n\";\n}\n\nmethod UpdateArray<T(0)>(arr: array<T>, t: T)\n  requires 10 <= arr.Length\n  modifies arr\n{\n  var tt: T := *;\n  arr[1] := tt;\n  arr[2] := t;\n}\n\nmethod UpdateSxArray(arr: array<SX>, t: SX)\n  requires 10 <= arr.Length\n  modifies arr\n{\n  var tt: SX := *;\n  arr[4] := tt;\n  arr[5] := t;\n}\n"}
{"file": "../dafny/Test/ghost/Aliasing.dfy", "dafny": "// RUN: %dafny /compile:0 /print:\"%t.print\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Test1(a: array<(int, int)>, b: array<(int, int, ghost int)>) {\n  assert a as object != b;\n}\n\nmethod Test2(a: array<(int, int)>, b: array<(int, ghost int)>) {\n  assert a as object != b;\n}\n"}
{"file": "../dafny/Test/ghost/AllowedGhostBindings.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:- \"%s\" /env:0 > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Test1()\n{\n  var tuple0 := (ghost 0:=123, ghost 1:=234);\n  var tuple1 := (ghost 123, ghost 234);\n  assert tuple0 == tuple1;\n}\n\nmethod Test2()\n{\n  var tuple0 := (ghost 10:=10, 3:=3, 0:=0, 1:=1, 2:=2, 4:=4, 5:=5, 6:=6, 7:=7, 8:=8, 9:=9);\n  var tuple1 := (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ghost 10);\n  assert tuple0 == tuple1;\n}\n"}
{"file": "../dafny/Test/ghost/AllowedGhost.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:- \"%s\" /env:0 > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Test()\n{\n  // Tuples with a single ghost component are allowed and they are compiled to empty tuples.\n  var x := (ghost 123);\n  var (y) := (ghost 123);\n  ghost var z: (ghost int) := (ghost 123);\n  var t: (int, ghost int, int) := (20, 2 := 50, ghost 1 := 30);\n  var u: () := ();\n}\n"}
{"file": "../dafny/Test/ghost/AmbiguousGhost.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:- \"%s\" /env:0 > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Test that the `IsTypeSequence` method of the parser allows tuples with ghost components.\nfunction F(x: int): () { () }\nfunction a<T,U>(x: int): int { x }\nmethod M<b, c>(d: int) {\n  var u;\n  u := F( a < (b, ghost b), c > (d) );\n  u := F( a < (b, (ghost b, ghost b)), c > (d) );\n  u := F( a < (b, ((ghost b, b), ghost b)), c > (d) );\n}\n"}
{"file": "../dafny/Test/ghost/Signature.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:- \"%s\" /env:0 > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// The following signature used to cause the error \"Undeclared top-level type or type parameter: _tuple#2OG\".\nmethod Test(ghost c: (int, ghost (int, int)))\n{\n}\n"}
{"file": "../dafny/Test/dafny3/SimpleCoinduction.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ncodatatype Stream<T> = Cons(head: T, tail: Stream)\ncodatatype IList<T> = Nil | ICons(head: T, tail: IList)\n\n// -----------------------------------------------------------------------\n\ngreatest predicate Pos(s: Stream<int>)\n{\n  s.head > 0 && Pos(s.tail)\n}\n\nghost function Up(n: int): Stream<int>\n{\n  Cons(n, Up(n+1))\n}\n\nghost function Inc(s: Stream<int>): Stream<int>\n{\n  Cons(s.head + 1, Inc(s.tail))\n}\n\nlemma {:induction false} UpLemma(k: nat, n: int)\n  ensures Inc(Up(n)) ==#[k] Up(n+1);\n{\n  if (k != 0) {\n    UpLemma(k-1, n+1);\n  }\n}\n\ngreatest lemma {:induction false} CoUpLemma(n: int)\n  ensures Inc(Up(n)) == Up(n+1);\n{\n  CoUpLemma(n+1);\n}\n\nlemma UpLemma_Auto(k: nat, n: int, nn: int)\n  ensures nn == n+1 ==> Inc(Up(n)) ==#[k] Up(nn);  // note: it would be nice to do an automatic rewrite (from \"ensures Inc(Up(n)) ==#[k] Up(n+1)\") to obtain the good trigger here\n{\n}\n\ngreatest lemma CoUpLemma_Auto(n: int, nn: int)\n  ensures nn == n+1 ==> Inc(Up(n)) == Up(nn);  // see comment above\n{\n}\n\n// -----------------------------------------------------------------------\n\nghost function Repeat(n: int): Stream<int>\n{\n  Cons(n, Repeat(n))\n}\n\ngreatest lemma RepeatLemma(n: int)\n  ensures Inc(Repeat(n)) == Repeat(n+1);\n{\n}\n\n// -----------------------------------------------------------------------\n\ngreatest predicate True(s: Stream)\n{\n  True(s.tail)\n}\n\ngreatest lemma AlwaysTrue(s: Stream)\n  ensures True(s);\n{\n}\n\ngreatest predicate AlsoTrue(s: Stream)\n{\n  AlsoTrue(s)\n}\n\ngreatest lemma AlsoAlwaysTrue(s: Stream)\n  ensures AlsoTrue(s);\n{\n}\n\ngreatest predicate TT(y: int)\n{\n  TT(y+1)\n}\n\ngreatest lemma AlwaysTT(y: int)\n  ensures TT(y);\n{\n}\n\n// -----------------------------------------------------------------------\n\nghost function Append(M: IList, N: IList): IList\n{\n  match M\n  case Nil => N\n  case ICons(x, M') => ICons(x, Append(M', N))\n}\n\nghost function zeros(): IList<int>\n{\n  ICons(0, zeros())\n}\n\nghost function ones(): IList<int>\n{\n  ICons(1, ones())\n}\n\ngreatest predicate AtMost(a: IList<int>, b: IList<int>)\n{\n  match a\n  case Nil => true\n  case ICons(h,t) => b.ICons? && h <= b.head && AtMost(t, b.tail)\n}\n\ngreatest lemma ZerosAndOnes_Theorem0()\n  ensures AtMost(zeros(), ones());\n{\n}\n\ngreatest lemma ZerosAndOnes_Theorem1()\n  ensures Append(zeros(), ones()) == zeros();\n{\n}\n"}
{"file": "../dafny/Test/dafny3/EWD-1062.dfy", "dafny": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Rustan Leino, 17 Jan 2018.\n// A transcription of a little proof calculation by E.W. Dijkstra, see:\n// http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1062.PDF\n\n// Let \"Below\" be a reflexive, transitive relation over some type T.\n// These properties are introduced as axioms, that is, as lemmas without\n// proofs.\n\ntype T\n\nghost predicate Below(x: T, y: T)\n\nlemma Reflexive(x: T)\n  ensures Below(x, x)\n\nlemma Transitive(x: T, y: T, z: T)\n  ensures Below(x, y) && Below(y, z) ==> Below(x, z)\n\n// Let \"f\" and \"g\" be functions satisfying the Galois connection:\n\nghost function f(x: T): T\nghost function g(x: T): T\n\nlemma Connection(x: T, y: T)\n  ensures Below(f(x), y) == Below(x, g(y))\n\n// From the above, prove that \"f\" and \"g\" are monotonic with respect to \"Below\".\n\nlemma Monotonic(u: T, v: T)\n  requires Below(u, v)\n  ensures Below(f(u), f(v)) && Below(g(u), g(v))\n{\n  FMonotonic(u, v);\n  GMonotonic(u, v);\n}\n\nlemma FMonotonic(u: T, v: T)\n  requires Below(u, v)\n  ensures Below(f(u), f(v))\n{\n  calc {\n    Below(f(u), f(v));\n  ==  { Reflexive(f(v)); }\n    Below(f(v), f(v)) ==> Below(f(u), f(v));\n  ==  { Connection(v, f(v)); Connection(u, f(v)); }\n    Below(v, g(f(v))) ==> Below(u, g(f(v)));\n  <== { Transitive(u, v, g(f(v))); }\n    Below(u, v);\n  }\n}\n\n// Dijkstra justifies \"GMonotonic\" by symmetry, after introducing \"Above\", the dual of \"Below\".\n\nghost predicate Above(x: T, y: T)\n{\n  Below(y, x)\n}\n\nlemma AboveReflexive(x: T)\n  ensures Above(x, x)\n{\n  Reflexive(x);\n}\n\nlemma AboveTransitive(x: T, y: T, z: T)\n  ensures Above(x, y) && Above(y, z) ==> Above(x, z)\n{\n  Transitive(z, y, x);\n}\n\n// To say that \"GMonotonic\" follows from \"FMonotonic\" and symmetry,\n// we need a more parameterized version of \"FMonotonic\".  Here is one\n// way of doing that. (Another way would be to use modules and refinement.)\n\nlemma GeneralMonotonic(u: T, v: T, below: (T, T) -> bool, a: T -> T, b: T -> T)\n  requires forall x :: below(x, x)  // \"below\" is reflexive\n  requires forall x, y, z :: below(x, y) && below(y, z) ==> below(x, z)  // \"below\" is transitive\n  requires forall x, y :: below(a(x), y) == below(x, b(y))  // Galois connection\n  requires below(u, v)\n  ensures below(a(u), a(v))\n{\n  calc {\n    below(a(u), a(v));\n  ==  // reflexivity\n    below(a(v), a(v)) ==> below(a(u), a(v));\n  ==  // Galois connection\n    below(v, b(a(v))) ==> below(u, b(a(v)));\n  <== // transitivity\n    below(u, v);\n  }\n}\n\n// Before proving \"GMonotonic\", let's just show that \"FMonotonic\" is indeed an instance\n// of \"GeneralMonotonic\" as well.\n\nlemma FMonotonic'(u: T, v: T)\n  requires Below(u, v)\n  ensures Below(f(u), f(v))\n{\n  // To call \"GeneralMonotonic\", we need to establish its precondition.  It holds on\n  // behalf of the axioms above. The axioms were conveniently stated as holding for\n  // given \"x\", \"y\", and \"z\", but here we need them explicitly universally quantified.\n  // We apply this \"universal introduction\" rule by invoking the axioms for all\n  // possible values, which is done using the \"forall\" statement.\n  forall x {\n    Reflexive(x);\n  }\n  forall x, y, z {\n    Transitive(x, y, z);\n  }\n  forall x, y {\n    Connection(x, y);\n  }\n  GeneralMonotonic(u, v, Below, f, g);\n}\n\nlemma GMonotonic(u: T, v: T)\n  requires Below(u, v)\n  ensures Below(g(u), g(v))\n{\n  forall x {\n    AboveReflexive(x);\n  }\n  forall x, y, z {\n    AboveTransitive(x, y, z);\n  }\n  forall x, y {\n    calc {\n      Above(g(x), y);\n    ==  // def. Above\n      Below(y, g(x));\n    ==  { Connection(y, x); }\n      Below(f(y), x);\n    ==  // def. Above\n      Above(x, f(y));\n    }\n  }\n  GeneralMonotonic(v, u, Above, g, f);\n}\n"}
{"file": "../dafny/Test/dafny3/Iter.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\nclass List<T> {\n  ghost var Contents: seq<T>\n  ghost var Repr: set<object>\n\n  var a: array<T>\n  var n: nat\n\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr &&\n    a in Repr &&\n    n <= a.Length &&\n    Contents == a[..n]\n  }\n\n  constructor Init()\n    ensures Valid() && fresh(Repr)\n    ensures Contents == []\n  {\n    Contents, n := [], 0;\n    a := new T[0];\n    Repr := {this, a};\n  }\n\n  method Add(t: T)\n    requires Valid()\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures Contents == old(Contents) + [t]\n  {\n    if (n == a.Length) {\n      var b := new T[2 * a.Length + 1](i requires 0 <= i reads this, a =>\n                                       if i < a.Length then a[i] else t);\n      assert b[..n] == a[..n] == Contents;\n      a, Repr := b, Repr + {b};\n      assert b[..n] == Contents;\n    }\n    a[n], n, Contents := t, n + 1, Contents + [t];\n  }\n}\n\nclass Cell { var data: int }\n\niterator M<T(0)>(l: List<T>, c: Cell) yields (x: T)\n  requires l.Valid()\n  reads l.Repr\n  modifies c\n  yield requires true\n  yield ensures xs <= l.Contents  // this is needed in order for the next line to be well-formed\n  yield ensures x == l.Contents[|xs|-1]\n  ensures xs == l.Contents\n{\n  var i := 0;\n  while i < l.n\n    invariant i <= l.n && i == |xs| && xs <= l.Contents\n  {\n    if (*) { assert l.Valid(); }  // this property is maintained, due to the reads clause\n    if (*) {\n      x := l.a[i]; yield;  // or, equivalently, 'yield l.a[i]'\n      i := i + 1;\n    } else {\n      x, i := l.a[i], i + 1;\n      yield;\n    }\n  }\n}\n\nmethod Client<T(==,0)>(l: List, stop: T) returns (s: seq<T>)\n  requires l.Valid()\n{\n  var c := new Cell;\n  var iter := new M(l, c);\n  s := [];\n  while true\n    invariant iter.Valid() && fresh(iter._new)\n    invariant iter.xs <= l.Contents\n    decreases |l.Contents| - |iter.xs|\n  {\n    var more := iter.MoveNext();\n    if (!more) { break; }\n    s := s + [iter.x];\n    if (iter.x == stop) { return; }  // if we ever see 'stop', then just end\n  }\n}\n\nmethod PrintSequence<T>(s: seq<T>)\n{\n  var i := 0;\n  while i < |s|\n  {\n    print s[i], \" \";\n    i := i + 1;\n  }\n  print \"\\n\";\n}\n\nmethod Main()\n{\n  var myList := new List.Init();\n  var i := 0;\n  while i < 100\n    invariant myList.Valid() && fresh(myList.Repr)\n  {\n    myList.Add(i);\n    i := i + 2;\n  }\n  var s := Client(myList, 89);\n  PrintSequence(s);\n  s := Client(myList, 14);\n  PrintSequence(s);\n}\n"}
{"file": "../dafny/Test/dafny3/SetIterations.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function Count<T>(s: set<T>): int\n{\n  if s == {} then 0 else\n    var x :| x in s;  // let x be such that \"x in s\"\n    1 + Count(s - {x})\n}\n\nmethod Copy<T>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := {};\n  var r := s;\n  while r != {}\n    invariant s == r + t\n    decreases r\n  {\n    var x :| x in r;\n    r, t := r - {x}, t + {x};\n  }\n}\n\nmethod CopyFaster<T>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := {};\n  var r := s;\n  while r != {}\n    invariant s == r + t\n    decreases r\n  {\n    var p :| p != {} && p <= r;  // pick a nonempty subset of r\n    r, t := r - p, t + p;\n  }\n}\n\nmethod CopyFastest<T>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := s;  // :)\n}\n\niterator Iter<T(0)>(s: set<T>) yields (x: T)\n  yield ensures x in s && x !in xs[..|xs|-1]\n  ensures s == set z | z in xs\n{\n  var r := s;\n  while r != {}\n    invariant forall z :: z in xs ==> z !in r  // r and xs are disjoint\n    invariant s == r + set z | z in xs\n  {\n    var y :| y in r;\n    r, x := r - {y}, y;\n    yield;\n    assert y == xs[|xs|-1];  // needed as a lemma to prove loop invariant\n  }\n}\n\nmethod UseIterToCopy<T(0)>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := {};\n  var m := new Iter(s);\n  while true\n    invariant m.Valid() && fresh(m._new)\n    invariant t == set z | z in m.xs\n    decreases s - t\n  {\n    var more := m.MoveNext();\n    if !more { break; }\n    t := t + {m.x};\n  }\n}\n"}
{"file": "../dafny/Test/dafny3/Dijkstra.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Example taken from:\n// Edsger W. Dijkstra: Heuristics for a Calculational Proof. Inf. Process. Lett. (IPL) 53(3):141-143 (1995)\n// Transcribed into Dafny by Valentin Wüstholz and Nadia Polikarpova.\n\n// f is an arbitrary function on the natural numbers\nghost function f(n: nat) : nat\n\n// Predicate P() says that f satisfies a peculiar property\nghost predicate P()\n{\n  forall m: nat :: f(f(m)) < f(m + 1)\n}\n\n// The following theorem says that if f satisfies the peculiar property,\n// then f is the identity function.  The body of the method, and the methods\n// that follow, give the proof.\nlemma theorem()\n  requires P()\n  ensures forall n: nat :: f(n) == n\n{\n  forall n: nat\n    ensures f(n) == n\n  {\n    calc {\n      f(n);\n    ==  { lemma_ping(n, n); lemma_pong(n); }\n      n;\n    }\n  }\n}\n\n// Aiming at n <= f(n), but strengthening it for induction\nlemma lemma_ping(j: nat, n: nat)\n  requires P()\n  ensures j <= n ==> j <= f(n)\n{\n  // The case for j == 0 is trivial\n  if 0 < j\n  {\n    calc {\n      j <= f(n);\n    ==\n      j - 1 < f(n);\n    <== // P with m := n - 1\n      j - 1 <= f(f(n - 1)) && 1 <= n;\n    <== { lemma_ping(j - 1, f(n - 1)); }\n      j - 1 <= f(n - 1) && 1 <= n;\n    <== { lemma_ping(j - 1, n - 1); }\n      j - 1 <= n - 1 && 1 <= n;\n    == // 0 < j\n      j <= n;\n    }\n  }\n}\n\n// The other direction: f(n) <= n\nlemma lemma_pong(n: nat)\n  requires P()\n  ensures f(n) <= n\n{\n  calc {\n    f(n) <= n;\n  ==\n    f(n) < n + 1;\n  <==  { lemma_monotonicity_0(n + 1, f(n)); }\n    f(f(n)) < f(n + 1);\n  ==  // P with m := n\n    true;\n  }\n}\n\nlemma lemma_monotonicity_0(a: nat, b: nat)\n  requires P()\n  ensures a <= b ==> f(a) <= f(b)  // or, equivalently:  f(b) < f(a) ==> b < a\n  decreases b - a\n{\n  // The case for a == b is trivial\n  if a < b {\n    calc {\n      f(a);\n    <=  { lemma_monotonicity_1(a); }\n      f(a + 1);\n    <=  { lemma_monotonicity_0(a + 1, b); }\n      f(b);\n    }\n  }\n}\n\nlemma lemma_monotonicity_1(n: nat)\n  requires P()\n  ensures f(n) <= f(n + 1)\n{\n  calc {\n    f(n);\n  <=  { lemma_ping(f(n), f(n)); }\n    f(f(n));\n  <=  // (0)\n    f(n + 1);\n  }\n}\n"}
{"file": "../dafny/Test/dafny3/InductionVsCoinduction.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// A definition of a co-inductive datatype Stream, whose values are possibly\n// infinite lists.\ncodatatype Stream<T> = SNil | SCons(head: T, tail: Stream<T>)\n\n/*\n  A function that returns a stream consisting of all integers upwards of n.\n  The self-call sits in a productive position and is therefore not subject to\n  termination checks.  The Dafny compiler turns this co-recursive call into a\n  lazily evaluated call, evaluated at the time during the program execution\n  when the SCons is destructed (if ever).\n*/\n\nghost function Up(n: int): Stream<int>\n{\n  SCons(n, Up(n+1))\n}\n\n/*\n  A function that returns a stream consisting of all multiples\n  of 5 upwards of n.  Note that the first self-call sits in a\n  productive position and is thus co-recursive.  The second self-call\n  is not in a productive position and therefore it is subject to\n  termination checking; in particular, each recursive call must\n  decrease the specific variant function.\n */\n\nghost function FivesUp(n: int): Stream<int>\n  decreases 4 - (n-1) % 5;\n{\n  if n % 5 == 0 then SCons(n, FivesUp(n+1))\n  else FivesUp(n+1)\n}\n\n// A co-predicate that holds for those integer streams where every value is greater than 0.\ngreatest predicate Pos(s: Stream<int>)\n{\n  match s\n  case SNil => true\n  case SCons(x, rest) => x > 0 && Pos(rest)\n}\n\n// SAppend looks almost exactly like Append, but cannot have 'decreases'\n// clause, as it is possible it will never terminate.\nghost function SAppend(xs: Stream, ys: Stream): Stream\n{\n  match xs\n  case SNil => ys\n  case SCons(x, rest) => SCons(x, SAppend(rest, ys))\n}\n\n/*\n  Example: associativity of append on streams.\n\n  The first method proves that append is associative when we consider first\n  \\S{k} elements of the resulting streams.  Equality is treated as any other\n  recursive co-predicate, and has it k-th unfolding denoted as ==#[k].\n\n  The second method invokes the first one for all ks, which lets us prove the\n  assertion (included for clarity only).  The assertion implies the\n  postcondition (by (F_=)).  Interestingly, in the SNil case in the first\n  method, we actually prove ==, but by (F_=) applied in the opposite direction\n  we also get ==#[k].\n*/\n\nlemma {:induction false} SAppendIsAssociativeK(k:nat, a:Stream, b:Stream, c:Stream)\n  ensures SAppend(SAppend(a, b), c) ==#[k] SAppend(a, SAppend(b, c));\n  decreases k;\n{\n  match (a) {\n  case SNil =>\n  case SCons(h, t) => if (k > 0) { SAppendIsAssociativeK(k - 1, t, b, c); }\n  }\n}\n\nlemma SAppendIsAssociative(a:Stream, b:Stream, c:Stream)\n  ensures SAppend(SAppend(a, b), c) == SAppend(a, SAppend(b, c));\n{\n  forall k:nat { SAppendIsAssociativeK(k, a, b, c); }\n  // assert for clarity only, postcondition follows directly from it\n  assert (forall k:nat {:autotriggers false} :: SAppend(SAppend(a, b), c) ==#[k] SAppend(a, SAppend(b, c))); //FIXME: Should Dafny generate a trigger here? If so then which one?\n}\n\n// Equivalent proof using the greatest lemma syntax.\ngreatest lemma {:induction false} SAppendIsAssociativeC(a:Stream, b:Stream, c:Stream)\n  ensures SAppend(SAppend(a, b), c) == SAppend(a, SAppend(b, c));\n{\n  match (a) {\n  case SNil =>\n  case SCons(h, t) => SAppendIsAssociativeC(t, b, c);\n  }\n}\n\n// In fact the proof can be fully automatic.\ngreatest lemma SAppendIsAssociative_Auto(a:Stream, b:Stream, c:Stream)\n  ensures SAppend(SAppend(a, b), c) == SAppend(a, SAppend(b, c));\n{\n}\n\ngreatest lemma {:induction false} UpPos(n:int)\n  requires n > 0;\n  ensures Pos(Up(n));\n{\n  UpPos(n+1);\n}\n\ngreatest lemma UpPos_Auto(n:int)\n  requires n > 0;\n  ensures Pos(Up(n));\n{\n}\n\n// This does induction and coinduction in the same proof.\ngreatest lemma {:induction false} FivesUpPos(n:int)\n  requires n > 0;\n  ensures Pos(FivesUp(n));\n  decreases 4 - (n-1) % 5;\n{\n  if (n % 5 == 0) {\n    FivesUpPos#[_k - 1](n + 1);\n  } else {\n    FivesUpPos#[_k](n + 1);\n  }\n}\n\n// Again, Dafny can just employ induction tactic and do it automatically.\n// The only hint required is the decrease clause.\ngreatest lemma FivesUpPos_Auto(n:int)\n  requires n > 0;\n  ensures Pos(FivesUp(n));\n  decreases 4 - (n-1) % 5;\n{\n}\n\n"}
{"file": "../dafny/Test/dafny3/OpaqueTrees.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Tree<T> = Leaf(T) | Node(Tree, Tree)\n\nghost function {:opaque} size(t: Tree): nat\n{\n  match t\n  case Leaf(_) => 1\n  case Node(left, right) => 1 + size(left) + size(right)\n}\n\nghost function {:opaque} mirror<T>(t: Tree<T>): Tree<T>\n{\n  match t\n  case Leaf(_) => t\n  case Node(left, right) => Node(mirror(right), mirror(left))\n}\n\nlemma {:induction false} MirrorSize(t: Tree)\n  ensures size(mirror(t)) == size(t)\n{\n  match t {\n    case Leaf(x) =>\n      calc {\n        size(mirror(Leaf(x)));\n      ==  { reveal mirror(); }\n        size(Leaf(x));\n      }\n    case Node(left, right) =>\n      calc {\n        size(mirror(Node(left, right)));\n      ==  { reveal mirror(); }\n        size(Node(mirror(right), mirror(left)));\n      ==  { reveal size(); }\n        1 + size(mirror(right)) + size(mirror(left));\n      ==  { MirrorSize(right); MirrorSize(left); }  // induction hypothesis\n        1 + size(right) + size(left);\n      ==  { reveal size(); }\n        size(Node(left, right));\n      }\n  }\n}\n"}
{"file": "../dafny/Test/dafny3/Abstemious.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// Examples from https://www.haskell.org/tutorial/functions.html\n\nmethod Main()\n{\n  var n := 7;\n  Print(n, \"ones()\", ones());\n  Print(n, \"from(3)\", from(3));\n  Print(n, \"Map(plus1, ones())\", Map(plus1, ones()));\n  Print(n, \"Map(plus1, from(3))\", Map(plus1, from(3)));\n  Print(n, \"squares()\", squares());\n  PrintList(\"take(5, from(3))\", take(5, from(3)));\n  Print(n, \"zip(ones(), from(3)\", zip(ones(), from(3)));\n  Print(n, \"addPair(zip(ones(), from(3))\", addPair(zip(ones(), from(3))));\n  Print(n, \"fib()\", fib());\n  Print(n, \"add(ones(), from(3))\", add(ones(), from(3)));\n  Print(n, \"Fib()\", Fib());\n  Print(n, \"Fib0()\", Fib0());\n  Print(n, \"Fib1()\", Fib1());\n  Print(n, \"OhOnes()\", OhOnes());\n  Print(n, \"Combine(plus, ones(), from(3))\", Combine(plus, ones(), from(3)));\n}\n\nmethod Print<T>(n: nat, msg: string, s: Stream<T>) {\n  print msg, \": \";\n  var i, s := 0, s;\n  while i < n {\n    print s.head, \" \";\n    i, s := i + 1, s.tail;\n  }\n  print \"...\\n\";\n}\n\nmethod PrintList<T>(msg: string, s: List<T>) {\n  print msg, \": \";\n  var s := s;\n  while s != Nil\n    decreases s\n  {\n    print s.head, \" \";\n    s := s.tail;\n  }\n  print \"\\n\";\n}\n\nfunction plus1(x: int): int { x + 1 }\nfunction plus(x: int, y: int): int { x + y }\n\ndatatype List<T> = Nil | ListCons(head: T, tail: List<T>)\ncodatatype Stream<T> = Cons(head: T, tail: Stream<T>)\n\nfunction ones(): Stream<int>\n{\n  Cons(1, ones())\n}\n\nfunction from(n: int): Stream<int>\n{\n  Cons(n, from(n+1))\n}\n\nfunction Map<T,U>(f: T -> U, s: Stream<T>): Stream<U>\n{\n  Cons(f(s.head), Map(f, s.tail))\n}\n\nfunction squares(): Stream<int>\n{\n  Map(x => x*x, from(0))\n}\n\nfunction take(n: nat, s: Stream): List\n{\n  if n == 0 then Nil else ListCons(s.head, take(n-1, s.tail))\n}\n\nfunction {:abstemious} zip<T,U>(a: Stream<T>, b: Stream<U>): Stream<(T,U)>\n{\n  Cons((a.head, b.head), zip(a.tail, b.tail))\n}\n\nfunction {:abstemious} addPair(a: Stream<(int,int)>): Stream<int>\n{\n  Cons(a.head.0 + a.head.1, addPair(a.tail))\n}\n\nfunction fib(): Stream<int>\n{\n  Cons(0, Cons(1, addPair(zip(fib(), fib().tail))))\n}\n\nfunction {:abstemious} add(a: Stream<int>, b: Stream<int>): Stream<int>\n{\n  Cons(a.head + b.head, add(a.tail, b.tail))\n}\n\nfunction Fib(): Stream<int>\n{\n  Cons(0, Cons(1, add(Fib(), Fib().tail)))\n}\n\nfunction Fib0(): Stream<int>\n{\n  Cons(0, Fib1())\n}\n\nfunction Fib1(): Stream<int>\n{\n  Cons(1, add(Fib0(), Fib1()))\n}\n\nfunction OhOnes(): Stream<int>\n{\n  Cons(0, Cons(1, OhOnes().tail))\n}\n\nfunction {:abstemious}\n  Combine<T>(f: (T,T) -> T, a: Stream, b: Stream): Stream\n{\n  Cons(f(a.head, b.head), Combine(f, a.tail, b.tail))\n}\n\n// ---- various fun lemmas ----\n\nghost function nth<T>(n: nat, s: Stream<T>): T\n{\n  if n == 0 then s.head else nth(n-1, s.tail)\n}\n\nghost function nfib(n: nat): nat\n{\n  if n < 2 then n else nfib(n-2) + nfib(n-1)\n}\n\nlemma Ones_Correct(n: nat)\n  ensures nth(n, ones()) == 1\n{\n}\n\ngreatest lemma OhOnesTail_Correct()\n  ensures OhOnes().tail == ones()\n{\n}\n\ngreatest lemma OhOnes_Correct()\n  ensures OhOnes() == Cons(0, ones())\n{\n}\n\nlemma OhOnes_Correct'(n: nat)\n  ensures nth(n, OhOnes()) == if n == 0 then 0 else 1\n{\n  OhOnes_Correct();\n  if n != 0 {\n    Ones_Correct(n-1);\n  }\n}\n\nlemma C_Correct(n: nat, k: int)\n  ensures nth(n, Combine(plus, ones(), from(k))) == k + 1 + n\n{\n}\n\ngreatest lemma CombinePlus_Correct(a: Stream<int>, b: Stream<int>)\n  ensures Combine(plus, a, b) == add(a, b)\n{\n}\n\nlemma add_Correct(n: nat, a: Stream<int>, b: Stream<int>)\n  ensures nth(n, add(a, b)) == nth(n, a) + nth(n, b)\n{\n}\n\nghost function StraightFibonacci(n: nat): Stream<int>\n{\n  Cons(nfib(n), StraightFibonacci(n+1))\n}\n\nlemma StraightFibonacci_Correct(n: nat, k: nat)\n  ensures nth(n, StraightFibonacci(k)) == nfib(k + n)\n{\n}\n\nlemma Fib_Correct(n: nat)\n  ensures nth(n, Fib()) == nfib(n)\n{\n  if n < 2 {\n  } else {\n    var F  := Fib();\n    calc {\n      nth(n, F);\n    ==\n      nth(n-2, F.tail.tail);\n    ==\n      nth(n-2, add(Fib(), Fib().tail));\n    ==  { add_Correct(n-2, Fib(), Fib().tail); }\n      nth(n-2, Fib()) + nth(n-2, Fib().tail);\n    ==\n      nth(n-2, Fib()) + nth(n-1, Fib());\n    ==  { Fib_Correct(n-2); Fib_Correct(n-1); }\n      nfib(n-2) + nfib(n-1);\n    ==\n      nfib(n);\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny3/CalcExample.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Here is a function \"f\" and three axioms (that is, unproved lemmas) about \"f\":\n\nghost function f(x: int, y: int): int\n\nlemma Associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma Monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall x :: f(x, y) <= f(x, z)\n\nlemma DiagonalIdentity(x: int)\n  ensures f(x, x) == x\n\n// From these axioms, we can prove a lemma about \"f\":\n\nmethod CalculationalStyleProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { Associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; Monotonicity(c, x); }\n    f(x, x);\n  ==  { DiagonalIdentity(x); }\n    x;\n  }\n}\n\n// Here's the same lemma, but with a proof written in a different style.\n// (An explanation of the constructs in this lemma is found below.)\n\nmethod DifferentStyleProof(a: int, b: int, c: int, x: int)\n  requires A: c <= x\n  requires B: x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    Associativity(a, b, c);\n  }\n\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal B;\n  }\n\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal A; }\n    Monotonicity(c, x);\n  }\n\n  assert 3: f(x, x) == x by {\n    DiagonalIdentity(x);\n  }\n\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}\n\n// To understand the lemma above, here's what you need to know (and then some):\n//\n// * An ordinary \"assert P;\" statement instructs the verifier to verify\n//   the boolean condition \"P\" and then to assume \"P\" from here on (that\n//   is, in the control flow that continues from here).\n//\n// * An assert with a proof is written \"assert P by { S }\" where \"S\" is\n//   a list of statements (typically other assertions and lemma calls).\n//   This statement instructs the verifier to do \"S\" and then prove \"P\".\n//   Once this is done, the verifier assumes \"P\" from here on, but it\n//   \"forgets\" anything it learnt or was able to assume on account of\n//   doing \"S\". In other words, an assertion like this is like a local\n//   lemma--the proof \"S\" is used only to establish \"P\" and is then\n//   forgotten, and after the statement, only \"P\" remains. Note, the\n//   body of the \"by\" clause does \"S\" and then stops; that is, there are\n//   no control paths out of the body of the \"by\" clause.\n//\n// * An assertion (either an ordinary assertion or an assertion with a\n//   proof) can start with a label, as in:\n//\n//     assert L: P;\n//\n//   or:\n//\n//     assert L: P by { S }\n//\n//   This instructs the verifier to prove the assertion as described in the\n//   previous two bullets, but then to forget about \"P\". In other words, the\n//   difference between a labeled assertion and and an unlabeled assertion\n//   is that an unlabeled assertion ends by assuming \"P\" whereas the labeled\n//   assertion does not assume anything.\n//\n// * Syntactically, the label \"L\" in a labeled assertion is the same as in\n//   a statement prefix \"label L:\", namely, \"L\" is either an identifier or\n//   a (decimal) numeric literal.\n//\n// * The condition \"P\" proved by a labeled assertion can later be recalled\n//   using a \"reveal\" statement. The \"reveal\" statement takes a list of\n//   arguments, each of which can be a label occurring in a previous\n//   assertion.\n//\n// * A precondition (or think of it as an antecedent of a lemma) is given by\n//   a \"requires\" clause. Ordinarily, the precondition is assumed on entry\n//   to the body of a method or lemma. Like an assert statement, a precondition\n//   can also be labeled. Such a precondition is not automatically assumed on\n//   entry to the body, but can be recalled by a \"reveal\" statement.\n//\n// * Fine points: Some exclusions apply. For example, labeled preconditions are\n//   not supported for functions and cannot be used to hide/reveal conditions\n//   while checking the well-formedness of a specification. Labeled assertions are\n//   not supported in expression contexts. The \"reveal\" described is the \"reveal\"\n//   statement. A labeled assertion can be revealed only at those program points\n//   that are dominated by the assertion, that is, in places that are reached\n//   only after definitely first having reached the assertion.\n//\n// * Fine point: The label \"L\" introduced by an assertion can also be used in\n//   \"old@L(E)\" expressions, where \"E\" is an expression. However, note that\n//   \"old@L(E)\" differs from \"E\" only in how the heap is dereferenced. That is,\n//   \"old@L\" has no effect on local variables. In contrast, a labeled assertion\n//   speaks about the values of the heap and locals at the time the assertion is\n//   mentioned. So, even if the heap or locals mentioned in a labeled assertion\n//   change after the assertion is mentioned, recalling the assertion condition\n//   with a \"reveal\" statement always recall the condition with the heap and locals\n//   as they were when the assert was stated. For example, suppose \"P\" is an\n//   expression that mentions a local variable \"x\". Then, the second assertion in\n//\n//     assert L: P by { ... }\n//     x := x + 1;\n//     ...make changes to the heap...\n//     reveal L;\n//     assert old@L(P);\n//\n//   does not necessarily hold. The first assertion uses the initial value of the\n//   heap and the initial value of \"x\". Consequently, \"reveal L;\" recalls the\n//   asserted condition, with that initial heap and that initial value of \"x\",\n//   despite the fact that the code changes both \"x\" and the heap between the\n//   assert and the reveal. The expression \"old@L(P)\" essentially rolls\n//   back to the initial heap, but it uses the current value of \"x\".\n"}
{"file": "../dafny/Test/dafny3/Paulson.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// The following are Dafny versions from Section 8 of\n// \"Mechanizing Coinduction and Corecursion in Higher-order Logic\"\n// by Lawrence C. Paulson, 1996.\n\ncodatatype LList<T> = Nil | Cons(head: T, tail: LList)\n\n// Simulate function as arguments\ndatatype FunctionHandle<T> = FH(T)\nghost function Apply<T>(f: FunctionHandle<T>, argument: T): T\n\n// Function composition\nghost function After(f: FunctionHandle, g: FunctionHandle): FunctionHandle\nlemma Definition_After<T>(f: FunctionHandle<T>, g: FunctionHandle<T>, arg: T)\n  ensures Apply(After(f, g), arg) == Apply(f, Apply(g, arg));\n\nghost function Lmap(f: FunctionHandle, a: LList): LList\n{\n  match a\n  case Nil => Nil\n  case Cons(x, xs) => Cons(Apply(f, x), Lmap(f, xs))\n}\n\nghost function Lappend(a: LList, b: LList): LList\n{\n  match a\n  case Nil => b\n  case Cons(x, xs) => Cons(x, Lappend(xs, b))\n}\n\n// ---------- Section 8.3 ----------\n\ngreatest lemma Example6(f: FunctionHandle, g: FunctionHandle, M: LList)\n  ensures Lmap(After(f, g), M) == Lmap(f, Lmap(g, M));\n{\n  match M {\n  case Nil =>\n  case Cons(x, xs) =>\n    calc {\n      Lmap(After(f, g), M);\n      Lmap(After(f, g), Cons(x, xs));\n      // def. Lmap\n      Cons(Apply(After(f, g), x), Lmap(After(f, g), xs));\n      { Definition_After(f, g, x); }\n      Cons(Apply(f, Apply(g, x)), Lmap(After(f, g), xs));\n    ==#[_k] // use co-induction hypothesis\n      Cons(Apply(f, Apply(g, x)), Lmap(f, Lmap(g, xs)));\n      // def. Lmap\n      Lmap(f, Cons(Apply(g, x), Lmap(g, xs)));\n      // def. Lmap\n      Lmap(f, Lmap(g, Cons(x, xs)));\n      Lmap(f, Lmap(g, M));\n    }\n  }\n}\n\n// ---------- Section 8.4 ----------\n\n// Iterates(f, M) == [M, f M, f^2 M, ..., f^n M, ...]\nghost function Iterates<A>(f: FunctionHandle<LList<A>>, M: LList<A>): LList<LList<A>>\n{\n  Cons(M, Iterates(f, Apply(f, M)))\n}\n\ngreatest lemma Eq24<A>(f: FunctionHandle<LList<A>>, M: LList<A>)\n  ensures Lmap(f, Iterates(f, M)) == Iterates(f, Apply(f, M));\n{\n  calc {\n    Lmap(f, Iterates(f, M));\n    Lmap(f, Cons(M, Iterates(f, Apply(f, M))));\n    Cons(Apply(f, M), Lmap(f, Iterates(f, Apply(f, M))));\n  ==#[_k]\n      calc {\n        Lmap(f, Iterates(f, Apply(f, M)));\n      ==#[_k-1] { Eq24(f, Apply(f, M)); } // co-induction hypothesis\n        Iterates(f, Apply(f, Apply(f, M)));\n      }\n    Cons(Apply(f, M), Iterates(f, Apply(f, Apply(f, M))));\n    // def. Iterates\n    Iterates(f, Apply(f, M));\n  }\n}\n\nlemma CorollaryEq24<A>(f: FunctionHandle<LList<A>>, M: LList<A>)\n  ensures Iterates(f, M) == Cons(M, Lmap(f, Iterates(f, M)));\n{\n  Eq24(f, M);\n}\n\n// Now prove that equation in CorollaryEq24 uniques characterizes Iterates.\n// Paulson says \"The bisimulation for this proof is unusually complex\".\n\n// Let h be any function\nghost function h<A>(f: FunctionHandle<LList<A>>, M: LList<A>): LList<LList<A>>\n// ... that satisfies the property in CorollaryEq24:\nlemma Definition_h<A>(f: FunctionHandle<LList<A>>, M: LList<A>)\n  ensures h(f, M) == Cons(M, Lmap(f, h(f, M)));\n\n// Functions to support the proof:\n\nghost function Iter<A>(n: nat, f: FunctionHandle<A>, arg: A): A\n{\n  if n == 0 then arg else Apply(f, Iter(n-1, f, arg))\n}\n\nghost function LmapIter(n: nat, f: FunctionHandle, arg: LList): LList\n{\n  if n == 0 then arg else Lmap(f, LmapIter(n-1, f, arg))\n}\n\nlemma Lemma25<A>(n: nat, f: FunctionHandle<A>, b: A, M: LList<A>)\n  ensures LmapIter(n, f, Cons(b, M)) == Cons(Iter(n, f, b), LmapIter(n, f, M));\n{\n  // proof is by (automatic) induction\n}\n\nlemma Lemma26<A>(n: nat, f: FunctionHandle, x: LList)  // (26) in the paper, but with f := LMap f\n  ensures LmapIter(n, f, Lmap(f, x)) == LmapIter(n+1, f, x);\n{\n  // proof is by (automatic) induction\n}\n\ngreatest lemma BisimulationLemma<A>(n: nat, f: FunctionHandle<LList<A>>, u: LList<A>)\n  ensures LmapIter(n, f, h(f, u)) == LmapIter(n, f, Iterates(f, u));\n{\n  calc {\n    LmapIter(n, f, h(f, u));\n    { Definition_h(f, u); }\n    LmapIter(n, f, Cons(u, Lmap(f, h(f, u))));\n    { Lemma25(n, f, u, Lmap(f, h(f, u))); }\n    Cons(Iter(n, f, u), LmapIter(n, f, Lmap(f, h(f, u))));\n    { Lemma26(n, f, h(f, u)); }\n    Cons(Iter(n, f, u), LmapIter(n+1, f, h(f, u)));\n  ==#[_k]\n    calc {\n      LmapIter(n+1, f, h(f, u));\n    ==#[_k-1]\n      LmapIter(n+1, f, Iterates(f, u));\n    }\n    Cons(Iter(n, f, u), LmapIter(n+1, f, Iterates(f, u)));\n    { Lemma26(n, f, Iterates(f, u)); }\n    Cons(Iter(n, f, u), LmapIter(n, f, Lmap(f, Iterates(f, u))));\n    { Lemma25(n, f, u, Lmap(f, Iterates(f, u))); }\n    LmapIter(n, f, Cons(u, Lmap(f, Iterates(f, u))));\n    { CorollaryEq24(f, u); }\n    LmapIter(n, f, Iterates(f, u));\n  }\n}\n\nlemma Example7<A>(f: FunctionHandle<LList<A>>)\n  // Given the definition of h, prove h(f, _) == Iterates(f, _):\n  ensures forall M :: h(f, M) == Iterates(f, M);\n{\n  forall M {\n    BisimulationLemma(0, f, M);\n  }\n}\n\n// ---------- Section 8.5 ----------\n\ngreatest lemma Example8<A>(f: FunctionHandle<A>, M: LList<A>, N: LList<A>)\n  ensures Lmap(f, Lappend(M, N)) == Lappend(Lmap(f, M), Lmap(f, N));\n{\n  // A proof doesn't get any simpler than this\n}\n\ngreatest lemma Associativity(a: LList, b: LList, c: LList)\n  ensures Lappend(Lappend(a, b), c) == Lappend(a, Lappend(b, c));\n{\n  // Again, Dafny does this proof completely automatically\n}\n"}
{"file": "../dafny/Test/dafny3/WideTrees.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ncodatatype Stream<T> = SNil | SCons(head: T, tail: Stream)\ndatatype Tree = Node(children: Stream<Tree>)\n\n// return an infinite stream of trees\nghost function BigTree(): Tree\n{\n  Node(BigTrees())\n}\nghost function BigTrees(): Stream<Tree>\n  decreases 0;\n{\n  SCons(BigTree(), BigTrees())\n}\n\n// say whether a tree has finite height\nghost predicate HasBoundedHeight(t: Tree)\n{\n  exists n :: 0 <= n && LowerThan(t.children, n)\n}\ngreatest predicate LowerThan(s: Stream<Tree>, n: nat)\n{\n  match s\n  case SNil => true\n  case SCons(t, tail) =>\n    1 <= n && LowerThan(t.children, n-1) && LowerThan(tail, n)\n}\n\n// return a finite tree\nghost function SmallTree(n: nat): Tree\n{\n  Node(SmallTrees(n))\n}\nghost function SmallTrees(n: nat): Stream<Tree>\n  decreases -1;\n{\n  if n == 0 then SNil else SCons(SmallTree(n-1), SmallTrees(n))\n}\n// prove that the tree returned by SmallTree is finite\nlemma Theorem(n: nat)\n  ensures HasBoundedHeight(SmallTree(n));\n{\n  Lemma(n);\n}\ngreatest lemma Lemma(n: nat)\n  ensures LowerThan(SmallTrees(n), n);\n{\n  if 0 < n {\n    Lemma(n-1);\n  }\n}\n"}
{"file": "../dafny/Test/dafny3/SimpleInduction.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n/*\n  The well-known Fibonacci function defined in Dafny.  The postcondition of\n  method FibLemma states a property about Fib, and the body of the method is\n  code that convinces the program verifier that the postcondition does indeed\n  hold.  Thus, effectively, the method states a lemma and its body gives the\n  proof.\n  */\n\nghost function Fib(n: nat): nat\n  decreases n;\n{ if n < 2 then n else Fib(n-2) + Fib(n-1) }\n\nlemma FibLemma(n: nat)\n  ensures Fib(n) % 2 == 0 <==> n % 3 == 0;\n  decreases n;\n{\n  if (n < 2) {\n  } else {\n    FibLemma(n-2);\n    FibLemma(n-1);\n  }\n}\n\n/*\n  The 'forall' statement has the effect of applying its body simultaneously\n  to all values of the bound variables---in the first example, to all k\n  satisfying 0 <= k < n, and in the second example, to all non-negative n.\n*/\n\nlemma FibLemma_Alternative(n: nat)\n  ensures Fib(n) % 2 == 0 <==> n % 3 == 0;\n{\n  forall k | 0 <= k < n {\n    FibLemma_Alternative(k);\n  }\n}\n\nlemma FibLemma_All()\n  ensures forall n :: 0 <= n ==> (Fib(n) % 2 == 0 <==> n % 3 == 0);\n{\n  forall n | 0 <= n {\n    FibLemma(n);\n  }\n}\n\n/*\n  A standard inductive definition of a generic List type and a function Append\n  that concatenates two lists.  The lemma states that Append is associative,\n  and its recursive body gives the inductive proof.\n\n  We omitted the explicit declaration and uses of the List type parameter in\n  the signature of the method, since in simple cases like this, Dafny is able\n  to fill these in automatically.\n  */\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nghost function Append<T>(xs: List<T>, ys: List<T>): List<T>\n  decreases xs;\n{\n  match xs\n  case Nil => ys\n  case Cons(x, rest) => Cons(x, Append(rest, ys))\n}\n\n// The {:induction false} attribute disables automatic induction tactic,\n// so we can make the proof explicit.\nlemma {:induction false} AppendIsAssociative(xs: List, ys: List, zs: List)\n  ensures Append(Append(xs, ys), zs) == Append(xs, Append(ys, zs));\n  decreases xs;\n{\n  match (xs) {\n    case Nil =>\n    case Cons(x, rest) =>\n      AppendIsAssociative(rest, ys, zs);\n  }\n}\n\n// Here the proof is fully automatic - the body of the method is empty,\n// yet still verifies.\nlemma AppendIsAssociative_Auto(xs: List, ys: List, zs: List)\n  ensures Append(Append(xs, ys), zs) == Append(xs, Append(ys, zs));\n{\n}\n\n"}
{"file": "../dafny/Test/dafny3/Streams.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// ----- Stream\n\ncodatatype Stream<T> = Nil | Cons(head: T, tail: Stream)\n\nghost function append(M: Stream, N: Stream): Stream\n{\n  match M\n  case Nil => N\n  case Cons(t, M') => Cons(t, append(M', N))\n}\n\n// ----- f, g, and maps\n\ntype X\n\nghost function f(x: X): X\nghost function g(x: X): X\n\nghost function map_f(M: Stream<X>): Stream<X>\n{\n  match M\n  case Nil => Nil\n  case Cons(x, N) => Cons(f(x), map_f(N))\n}\n\nghost function map_g(M: Stream<X>): Stream<X>\n{\n  match M\n  case Nil => Nil\n  case Cons(x, N) => Cons(g(x), map_g(N))\n}\n\nghost function map_fg(M: Stream<X>): Stream<X>\n{\n  match M\n  case Nil => Nil\n  case Cons(x, N) => Cons(f(g(x)), map_fg(N))\n}\n\n// ----- Theorems\n\n// map (f * g) M = map f (map g M)\ngreatest lemma Theorem0(M: Stream<X>)\n  ensures map_fg(M) == map_f(map_g(M));\n{\n  match (M) {\n    case Nil =>\n    case Cons(x, N) =>\n      Theorem0(N);\n  }\n}\ngreatest lemma Theorem0_Alt(M: Stream<X>)\n  ensures map_fg(M) == map_f(map_g(M));\n{\n  if (M.Cons?) {\n    Theorem0_Alt(M.tail);\n  }\n}\nlemma Theorem0_Par(M: Stream<X>)\n  ensures map_fg(M) == map_f(map_g(M));\n{\n  forall k: nat {\n    Theorem0_Ind(k, M);\n  }\n}\nlemma Theorem0_Ind(k: nat, M: Stream<X>)\n  ensures map_fg(M) ==#[k] map_f(map_g(M));\n{\n  if (k != 0) {\n    match (M) {\n      case Nil =>\n      case Cons(x, N) =>\n        Theorem0_Ind(k-1, N);\n    }\n  }\n}\nlemma Theorem0_AutoInd(k: nat, M: Stream<X>)\n  ensures map_fg(M) ==#[k] map_f(map_g(M));\n{\n}\n\n// map f (append M N) = append (map f M) (map f N)\ngreatest lemma Theorem1(M: Stream<X>, N: Stream<X>)\n  ensures map_f(append(M, N)) == append(map_f(M), map_f(N));\n{\n  match (M) {\n    case Nil =>\n    case Cons(x, M') =>\n      Theorem1(M', N);\n  }\n}\ngreatest lemma Theorem1_Alt(M: Stream<X>, N: Stream<X>)\n  ensures map_f(append(M, N)) == append(map_f(M), map_f(N));\n{\n  if (M.Cons?) {\n    Theorem1_Alt(M.tail, N);\n  }\n}\nlemma Theorem1_Par(M: Stream<X>, N: Stream<X>)\n  ensures map_f(append(M, N)) == append(map_f(M), map_f(N));\n{\n  forall k: nat {\n    Theorem1_Ind(k, M, N);\n  }\n}\nlemma Theorem1_Ind(k: nat, M: Stream<X>, N: Stream<X>)\n  ensures map_f(append(M, N)) ==#[k] append(map_f(M), map_f(N));\n{\n  // this time, try doing the 'if' inside the 'match' (instead of the other way around)\n  match (M) {\n    case Nil =>\n    case Cons(x, M') =>\n      if (k != 0) {\n        Theorem1_Ind(k-1, M', N);\n      }\n  }\n}\nlemma Theorem1_AutoInd(k: nat, M: Stream<X>, N: Stream<X>)\n  ensures map_f(append(M, N)) ==#[k] append(map_f(M), map_f(N));\n{\n}\nlemma Theorem1_AutoForall()\n{\n  // assert forall k: nat, M, N :: map_f(append(M, N)) ==#[k] append(map_f(M), map_f(N));  // TODO: this is not working yet, apparently\n}\n\n// append NIL M = M\nlemma Theorem2(M: Stream<X>)\n  ensures append(Nil, M) == M;\n{\n  // trivial\n}\n\n// append M NIL = M\ngreatest lemma Theorem3(M: Stream<X>)\n  ensures append(M, Nil) == M;\n{\n  match (M) {\n    case Nil =>\n    case Cons(x, N) =>\n      Theorem3(N);\n  }\n}\ngreatest lemma Theorem3_Alt(M: Stream<X>)\n  ensures append(M, Nil) == M;\n{\n  if (M.Cons?) {\n    Theorem3_Alt(M.tail);\n  }\n}\n\n// append M (append N P) = append (append M N) P\ngreatest lemma Theorem4(M: Stream<X>, N: Stream<X>, P: Stream<X>)\n  ensures append(M, append(N, P)) == append(append(M, N), P);\n{\n  match (M) {\n    case Nil =>\n    case Cons(x, M') =>\n      Theorem4(M', N, P);\n  }\n}\ngreatest lemma Theorem4_Alt(M: Stream<X>, N: Stream<X>, P: Stream<X>)\n  ensures append(M, append(N, P)) == append(append(M, N), P);\n{\n  if (M.Cons?) {\n    Theorem4_Alt(M.tail, N, P);\n  }\n}\n\n// ----- Flatten\n\n// Flatten can't be written as just:\n//\n//     function SimpleFlatten(M: Stream<Stream>): Stream\n//     {\n//       match M\n//       case Nil => Nil\n//       case Cons(s, N) => append(s, SimpleFlatten(N))\n//     }\n//\n// because this function fails to be productive given an infinite stream of Nil's.\n// Instead, here are two variations of SimpleFlatten.  The first variation (FlattenStartMarker)\n// prepends a \"startMarker\" to each of the streams in \"M\".  The other (FlattenNonEmpties)\n// insists that \"M\" contain no empty streams.  One can prove a theorem that relates these\n// two versions.\n\n// This first variation of Flatten returns a stream of the streams in M, each preceded with\n// \"startMarker\".\n\nghost function FlattenStartMarker<T>(M: Stream<Stream>, startMarker: T): Stream\n{\n  PrependThenFlattenStartMarker(Nil, M, startMarker)\n}\n\nghost function PrependThenFlattenStartMarker<T>(prefix: Stream, M: Stream<Stream>, startMarker: T): Stream\n{\n  match prefix\n  case Cons(hd, tl) =>\n    Cons(hd, PrependThenFlattenStartMarker(tl, M, startMarker))\n  case Nil =>\n    match M\n    case Nil => Nil\n    case Cons(s, N) => Cons(startMarker, PrependThenFlattenStartMarker(s, N, startMarker))\n}\n\n// The next variation of Flatten requires M to contain no empty streams.\n\ngreatest predicate StreamOfNonEmpties(M: Stream<Stream>)\n{\n  match M\n  case Nil => true\n  case Cons(s, N) => s.Cons? && StreamOfNonEmpties(N)\n}\n\nghost function FlattenNonEmpties(M: Stream<Stream>): Stream\n  requires StreamOfNonEmpties(M);\n{\n  PrependThenFlattenNonEmpties(Nil, M)\n}\n\nghost function PrependThenFlattenNonEmpties(prefix: Stream, M: Stream<Stream>): Stream\n  requires StreamOfNonEmpties(M);\n{\n  match prefix\n  case Cons(hd, tl) =>\n    Cons(hd, PrependThenFlattenNonEmpties(tl, M))\n  case Nil =>\n    match M\n    case Nil => Nil\n    case Cons(s, N) => Cons(s.head, PrependThenFlattenNonEmpties(s.tail, N))\n}\n\n// We can prove a theorem that links the previous two variations of flatten.  To\n// do that, we first define a function that prepends an element to each stream\n// of a given stream of streams.\n\nghost function Prepend<T>(x: T, M: Stream<Stream>): Stream<Stream>\n{\n  match M\n  case Nil => Nil\n  case Cons(s, N) => Cons(Cons(x, s), Prepend(x, N))\n}\n\ngreatest lemma Prepend_Lemma<T>(x: T, M: Stream<Stream>)\n  ensures StreamOfNonEmpties(Prepend(x, M));\n{\n  match M {\n    case Nil =>\n    case Cons(s, N) =>  Prepend_Lemma(x, N);\n  }\n}\n\nlemma Theorem_Flatten<T>(M: Stream<Stream>, startMarker: T)\n  ensures\n    StreamOfNonEmpties(Prepend(startMarker, M)) ==> // always holds, on account of Prepend_Lemma;\n                                          // but until (co-)method can be called from functions,\n                                          // this condition is used as an antecedent here\n    FlattenStartMarker(M, startMarker) == FlattenNonEmpties(Prepend(startMarker, M));\n{\n  Prepend_Lemma(startMarker, M);\n  Lemma_Flatten(Nil, M, startMarker);\n}\n\ngreatest lemma Lemma_Flatten<T>(prefix: Stream, M: Stream<Stream>, startMarker: T)\n  ensures\n    StreamOfNonEmpties(Prepend(startMarker, M)) ==> // always holds, on account of Prepend_Lemma;\n                                          // but until (co-)method can be called from functions,\n                                          // this condition is used as an antecedent here\n    PrependThenFlattenStartMarker(prefix, M, startMarker) == PrependThenFlattenNonEmpties(prefix, Prepend(startMarker, M));\n{\n  Prepend_Lemma(startMarker, M);\n  match (prefix) {\n    case Cons(hd, tl) =>\n    Lemma_Flatten(tl, M, startMarker);\n    case Nil =>\n      match (M) {\n        case Nil =>\n        case Cons(s, N) =>\n          if (*) {\n            // This is all that's needed for the proof\n            Lemma_Flatten(s, N, startMarker);\n          } else {\n            // ...but here are some calculations that try to show more of what's going on\n            // (It would be nice to have ==#[...] available as an operator in calculations.)\n\n            // massage the LHS:\n            calc {\n              PrependThenFlattenStartMarker(prefix, M, startMarker);\n            ==  // def. PrependThenFlattenStartMarker\n              Cons(startMarker, PrependThenFlattenStartMarker(s, N, startMarker));\n            }\n            // massage the RHS:\n            calc {\n              PrependThenFlattenNonEmpties(prefix, Prepend(startMarker, M));\n            ==  // M == Cons(s, N)\n              PrependThenFlattenNonEmpties(prefix, Prepend(startMarker, Cons(s, N)));\n            ==  // def. Prepend\n              PrependThenFlattenNonEmpties(prefix, Cons(Cons(startMarker, s), Prepend(startMarker, N)));\n            ==  // def. PrependThenFlattenNonEmpties\n              Cons(Cons(startMarker, s).head, PrependThenFlattenNonEmpties(Cons(startMarker, s).tail, Prepend(startMarker, N)));\n            ==  // Cons, head, tail\n              Cons(startMarker, PrependThenFlattenNonEmpties(s, Prepend(startMarker, N)));\n            }\n\n            // all together now:\n            calc {\n              PrependThenFlattenStartMarker(prefix, M, startMarker) ==#[_k] PrependThenFlattenNonEmpties(prefix, Prepend(startMarker, M));\n              { // by the calculation above, we have:\n                assert PrependThenFlattenStartMarker(prefix, M, startMarker) == Cons(startMarker, PrependThenFlattenStartMarker(s, N, startMarker)); }\n              Cons(startMarker, PrependThenFlattenStartMarker(s, N, startMarker)) ==#[_k] PrependThenFlattenNonEmpties(prefix, Prepend(startMarker, M));\n              { // and by the other calculation above, we have:\n                assert PrependThenFlattenNonEmpties(prefix, Prepend(startMarker, M)) == Cons(startMarker, PrependThenFlattenNonEmpties(s, Prepend(startMarker, N))); }\n              Cons(startMarker, PrependThenFlattenStartMarker(s, N, startMarker)) ==#[_k] Cons(startMarker, PrependThenFlattenNonEmpties(s, Prepend(startMarker, N)));\n            ==  // def. of ==#[_k] for _k != 0\n              startMarker == startMarker &&\n              PrependThenFlattenStartMarker(s, N, startMarker) ==#[_k-1] PrependThenFlattenNonEmpties(s, Prepend(startMarker, N));\n              { Lemma_Flatten(s, N, startMarker);\n                // the postcondition of the call we just made (which invokes the co-induction hypothesis) is:\n                assert PrependThenFlattenStartMarker(s, N, startMarker) ==#[_k-1] PrependThenFlattenNonEmpties(s, Prepend(startMarker, N));\n              }\n              true;\n            }\n          }\n      }\n  }\n}\n\ngreatest lemma Lemma_FlattenAppend0<T>(s: Stream, M: Stream<Stream>, startMarker: T)\n  ensures PrependThenFlattenStartMarker(s, M, startMarker) == append(s, PrependThenFlattenStartMarker(Nil, M, startMarker));\n{\n  match (s) {\n    case Nil =>\n    case Cons(hd, tl) =>\n      Lemma_FlattenAppend0(tl, M, startMarker);\n  }\n}\n\ngreatest lemma Lemma_FlattenAppend1<T>(s: Stream, M: Stream<Stream>)\n  requires StreamOfNonEmpties(M);\n  ensures PrependThenFlattenNonEmpties(s, M) == append(s, PrependThenFlattenNonEmpties(Nil, M));\n{\n  match (s) {\n    case Nil =>\n    case Cons(hd, tl) =>\n      Lemma_FlattenAppend1(tl, M);\n  }\n}\n"}
{"file": "../dafny/Test/dafny3/Zip.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n/*\nHere, we define infinite streams with some functions and prove a few\nproperties, drawing from:\n\n  Daniel Hausmann, Till Mossakowski and Lutz Schroder:\n  Iterative Circular Coinduction for CoCasl in Isabelle/HOL.\n\nSome proofs are automatic (EvenZipLemma), whereas some others require a single\nrecursive call to be made explicitly.\n\nNote that the automatically inserted forall statement\nis in principle strong enough in all cases above, but the incompletness\nof reasoning with quantifiers in SMT solvers make the explicit calls\nnecessary.\n*/\n\ncodatatype Stream<T> = Cons(hd: T, tl: Stream)\n\nghost function zip(xs: Stream, ys: Stream): Stream\n  { Cons(xs.hd, Cons(ys.hd, zip(xs.tl, ys.tl))) }\nghost function even(xs: Stream): Stream\n  { Cons(xs.hd, even(xs.tl.tl)) }\nghost function odd(xs: Stream): Stream\n  { even(xs.tl) }\n\ngreatest lemma EvenOddLemma(xs: Stream)\n  ensures zip(even(xs), odd(xs)) == xs;\n{ EvenOddLemma(xs.tl.tl); }\n\ngreatest lemma EvenZipLemma(xs:Stream, ys:Stream)\n  ensures even(zip(xs, ys)) == xs;\n{ /* Automatic. */ }\n\nghost function bzip(xs: Stream, ys: Stream, f:bool) : Stream\n  { if f then Cons(xs.hd, bzip(xs.tl, ys, !f))\n    else      Cons(ys.hd, bzip(xs, ys.tl, !f)) }\n\ngreatest lemma BzipZipLemma(xs:Stream, ys:Stream)\n  ensures zip(xs, ys) == bzip(xs, ys, true);\n{ BzipZipLemma(xs.tl, ys.tl); }\n\n\n/*\n   More examples from CoCasl.\n */\n\nghost function constr(n:int): Stream<int>\n{\n  Cons(n, constr(n))\n}\n\nghost function blink(): Stream<int>\n{\n  Cons(0, Cons(1, blink()))\n}\n\ngreatest lemma BzipBlinkLemma()\n  ensures zip(constr(0), constr(1)) == blink();\n{\n  BzipBlinkLemma();\n}\n\n\nghost function zip2(xs: Stream, ys: Stream): Stream\n{\n  Cons(xs.hd, zip2(ys, xs.tl))\n}\n\ngreatest lemma Zip201Lemma()\n  ensures zip2(constr(0), constr(1)) == blink();\n{\n  Zip201Lemma();\n}\n\ngreatest lemma ZipZip2Lemma(xs:Stream, ys:Stream)\n  ensures zip(xs, ys) == zip2(xs, ys);\n{\n  ZipZip2Lemma(xs.tl, ys.tl);\n}\n\nghost function bswitch(xs: Stream, f:bool) : Stream\n{\n  if f then Cons(xs.tl.hd, bswitch(Cons(xs.hd, xs.tl.tl), !f))\n  else      Cons(xs.hd,      bswitch(xs.tl, !f))\n}\n\ngreatest lemma BswitchLemma(xs:Stream)\n  ensures zip(odd(xs), even(xs)) == bswitch(xs, true);\n{\n  BswitchLemma(xs.tl.tl);\n}\n\ngreatest lemma Bswitch2Lemma(xs:Stream, ys:Stream)\n  ensures zip(xs, ys) == bswitch(zip(ys, xs), true);\n{\n  Bswitch2Lemma(xs.tl, ys.tl);\n}\n"}
{"file": "../dafny/Test/metatests/TestWrongVerifierExpect.dfy", "dafny": "// RUN: ! %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 > \"%t\"\n// RUN: %diff \"%s.testdafny.expect\" \"%t\"\n\nmethod Main() {\n  ghost var n := 15;\n  if j :| 0 <= j < n { // this gives a no-trigger warning\n  }\n  print \"hello\\n\";\n}\n"}
{"file": "../dafny/Test/metatests/RefreshResolverFails.dfy", "dafny": "// RUN: %testDafnyForEachResolver \"%s\" --refresh-exit-code=2\n\ntrait Trait { }\nclass Class extends Trait { }\n\nmethod M(c: Class) {\n  var t: Trait := c;\n  var d: Class := t; // error: needs an \"as Class\" in refresh resolver\n}\n"}
{"file": "../dafny/Test/metatests/EachResolverUniformSuccess.dfy", "dafny": "// RUN: %testDafnyForEachResolver \"%s\"\n\n// This little program type checks and verifies with both the legacy resolver and the refresh resolver.\n\n// This is a Main method, but the compiler is not run as part of this test. Hence, the meta-test also tests\n// that the compiler is not run.\n\nmethod Main() {\n  var x: nat := 17;\n  var y := x;\n  for i := 0 to 3 {\n    y := x;\n  }\n  print y, \"\\n\";\n}\n"}
{"file": "../dafny/Test/metatests/InconsistentCompilerBehavior.dfy", "dafny": "// RUN: ! %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 > \"%t\"\n// RUN: %diff \"%s.testdafny.expect\" \"%t\"\n\n// A %testdafny test case expected to fail, since the given\n// output is different than any actual output\n\nmethod Main() {\n  var i := 0;\n  print i, \"\\n\";\n}\n"}
{"file": "../dafny/Test/metatests/ConsistentWhenSupported.dfy", "dafny": "\n// Old way:\n\n// RUN: %exits-with 0 %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %exits-with 0 %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %exits-with 0 %dafny /noVerify /compile:4 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %exits-with 0 %dafny /noVerify /compile:4 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %exits-with 3 %dafny /noVerify /compile:4 /compileTarget:cpp \"%s\" >> \"%t\"\n// RUN: %exits-with 0 %dafny /noVerify /compile:4 /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %diff \"%s.oldway.expect\" \"%t\"\n\n// New way:\n\n// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\niterator EmptyIterator() yields (r: bool) \n  ensures false\n{}\n\nmethod Main() {\n  var i := new EmptyIterator();\n  var more := i.MoveNext();\n  expect !more;\n  print \"All done iterating!\\n\";\n}\n"}
{"file": "../dafny/Test/metatests/OutputEncoding.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0\n\nmethod Main() {\n  // This works fine in all languages because € is a single UTF-16 code unit.\n  print \"Euro sign: \" + [0x20AC as char], \"\\n\"; // €\n\n  // Unfortunately, the following does *not* work in all languages: some of our\n  // compilers don't correctly handle paired UTF-16 code units (e.g. Go)\n  // print \"Emoji: \" + [0xD83D as char, 0xDE14 as char], \"\\n\"; // 😔\n}\n"}
{"file": "../dafny/Test/metatests/TestMissingVerifierExpect.dfy", "dafny": "// RUN: ! %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 > \"%t\"\n// RUN: %diff \"%s.testdafny.expect\" \"%t\"\n\nmethod Main() {\n  ghost var n := 15;\n  if j :| 0 <= j < n { // this gives a no-trigger warning\n  }\n  print \"hello\\n\";\n}\n"}
{"file": "../dafny/Test/metatests/TestBeyondVerifierExpect.dfy", "dafny": "// RUN: ! %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 > \"%t\"\n// RUN: %diff \"%s.testdafny.expect\" \"%t\"\n\nmethod Main() {\n  ghost var n := 15;\n  if j :| 0 <= j < n { // this gives a no-trigger warning\n  }\n  print \"hello\\n\";\n}\n"}
{"file": "../dafny/Test/name with space/run.dfy", "dafny": "// RUN: %exits-with 0 %dafny /compile:3 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod Main() {\n  print \"hello\";\n}"}
{"file": "../dafny/Test/new-cli-help.dfy", "dafny": "// RUN: %baredafny -h > \"%t\"\n// RUN: %baredafny --help > \"%t_X\"\n// RUN: %diff \"%t\" \"%t_X\"\n"}
{"file": "../dafny/Test/dafny2/MajorityVote.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Rustan Leino, June 2012.\n// This file verifies an algorithm, due to Boyer and Moore, that finds the majority choice\n// among a sequence of votes, see http://www.cs.utexas.edu/~moore/best-ideas/mjrty/.\n// Actually, this algorithm is a slight variation on theirs, but the general idea for why\n// it is correct is the same.  In the Boyer and Moore algorithm, the loop counter is advanced\n// by exactly 1 each iteration, which means that there may or may not be a \"current leader\".\n// In my program below, I had instead written the loop invariant to say there is always a\n// \"current leader\", which requires the loop index sometimes to skip a value.\n//\n// This file has two versions of the algorithm.  In the first version, the given sequence\n// of votes is assumed to have a (strict) majority choice, meaning that strictly more than\n// 50% of the votes are for one candidate.  It is convenient to have a name for the majority\n// choice, in order to talk about it in specifications.  The easiest way to do this in\n// Dafny is probably to introduce a ghost parameter with the given properties.  That's what\n// the algorithm does, see parameter K.  The postcondition is thus to output the value of\n// K, which is done in the non-ghost out-parameter k.\n// The proof of the algorithm requires two lemmas.  These lemmas are proved automatically\n// by Dafny's induction tactic.\n//\n// In the second version of the program, the main method does not assume there is a majority\n// choice.  Rather, it eseentially uses the first algorithm and then checks if what it\n// returns really is a majority choice.  To do this, the specification of the first algorithm\n// needs to be changed slightly to accommodate the possibility that there is no majority\n// choice.  That change in specification is also reflected in the loop invariant.  Moreover,\n// the algorithm itself now needs to extra 'if' statements to see if the entire sequence\n// has been searched through.  (This extra 'if' is essentially already handled by Boyer and\n// Moore's algorithm, because it increments the loop index by 1 each iteration and therefore\n// already has a special case for the case of running out of sequence elements without a\n// current leader.)\n// The calling harness, DetermineElection, somewhat existentially comes up with the majority\n// choice, if there is such a choice, and then passes in that choice as the ghost parameter K\n// to the main algorithm.  Neat, huh?\n\n// Language comment:\n// The \"(==)\" that sits after some type parameters in this program says that the actual\n// type argument must support equality.\n\n// Advanced remark:\n// There is a subtle situation in the verification of DetermineElection.  Suppose the type\n// parameter Candidate denotes some type whose instances depend on which object are\n// allocated.  For example, if Candidate is some class type, then more candidates can come\n// into being by object allocations (using \"new\").  What does the quantification of\n// candidates \"c\" in the postcondition of DetermineElection now mean--all candidates that\n// existed in the pre-state or (the possibly larger set of) all candidates that exist in the\n// post-state?  (It means the latter.)  And if there does not exist a candidate in majority\n// in the pre-state, could there be a (newly created) candidate in majority in the post-state?\n// This will require some proof.  The simplest argument seems to be that even if more candidates\n// are created during the course of DetermineElection, such candidates cannot possibly\n// be in majority in the sequence \"a\", since \"a\" can only contain candidates that were already\n// created in the pre-state.  This property is easily specified by adding a postcondition\n// to the Count function.  Alternatively, one could have added the antecedent \"c in a\" or\n// \"old(allocated(c))\" to the \"forall c\" quantification in the postcondition of DetermineElection.\n\n// About reading the proofs:\n// Dafny proves the FindWinner algorithm from the given loop invariants and the two lemmas\n// Lemma_Unique and Lemma_Split.  In showing this proof to some colleagues, they found they\n// were not as quick as Dafny in constructing the proof from these ingredients.  For a human\n// to understand the situation better, it helps to take smaller (and more) steps in the proof.\n// At the end of this file, Nadia Polikarpova has written two versions of FindWinner that does\n// that, using Dafny's support for calculational proofs.\n\nfunction Count<T(==)>(a: seq<T>, s: int, t: int, x: T): int\n  requires 0 <= s <= t <= |a|\n{\n  if s == t then 0 else\n  Count(a, s, t-1, x) + if a[t-1] == x then 1 else 0\n}\n\nghost predicate HasMajority<T>(a: seq<T>, s: int, t: int, x: T)\n  requires 0 <= s <= t <= |a|\n{\n  2 * Count(a, s, t, x) > t - s\n}\n\n// Here is the first version of the algorithm, the one that assumes there is a majority choice.\n\nmethod FindWinner<Candidate(==)>(a: seq<Candidate>, ghost K: Candidate) returns (k: Candidate)\n  requires HasMajority(a, 0, |a|, K) // K has a (strict) majority of the votes\n  ensures k == K  // find K\n{\n  k := a[0];\n  var n, c, s := 1, 1, 0;\n  while n < |a|\n    invariant 0 <= s <= n <= |a|\n    invariant 2 * Count(a, s, |a|, K) > |a| - s  // K has majority among a[s..]\n    invariant 2 * Count(a, s, n, k) > n - s  // k has majority among a[s..n]\n    invariant c == Count(a, s, n, k)\n  {\n    if a[n] == k {\n      n, c := n + 1, c + 1;\n    } else if 2 * c > n + 1 - s {\n      n := n + 1;\n    } else {\n      n := n + 1;\n      // We have 2*Count(a, s, n, k) == n-s, and thus the following lemma\n      // lets us conclude 2*Count(a, s, n, K) <= n-s.\n      Lemma_Unique(a, s, n, K, k);\n      // We also have 2*Count(a, s, |a|, K) > |a|-s, and the following lemma\n      // tells us Count(a, s, |a|, K) == Count(a, s, n, K) + Count(a, n, |a|, K),\n      // and thus we can conclude 2*Count(a, n, |a|, K) > |a|-n.\n      Lemma_Split(a, s, n, |a|, K);\n      k, n, c, s := a[n], n + 1, 1, n;\n    }\n  }\n  Lemma_Unique(a, s, |a|, K, k);  // both k and K have a majority, so K == k\n}\n\n// ------------------------------------------------------------------------------\n\n// Here is the second version of the program, the one that also computes whether or not\n// there is a majority choice.\n\ndatatype Result<Candidate> = NoWinner | Winner(cand: Candidate)\n\nmethod DetermineElection<Candidate(==,0,!new)>(a: seq<Candidate>) returns (result: Result<Candidate>)\n  ensures result.Winner? ==> 2 * Count(a, 0, |a|, result.cand) > |a|\n  ensures result.NoWinner? ==> forall c :: 2 * Count(a, 0, |a|, c) <= |a|\n{\n  if |a| == 0 { return NoWinner; }\n  ghost var b := exists c :: 2 * Count(a, 0, |a|, c) > |a|;\n  ghost var w :| b ==> 2 * Count(a, 0, |a|, w) > |a|;\n  var cand := SearchForWinner(a, b, w);\n  return if 2 * Count(a, 0, |a|, cand) > |a| then Winner(cand) else NoWinner;\n}\n\n// The difference between SearchForWinner for FindWinner above are the occurrences of the\n// antecedent \"hasWinner ==>\" and the two checks for no-more-votes that may result in a \"return\"\n// statement.\n\nmethod SearchForWinner<Candidate(==)>(a: seq<Candidate>, ghost hasWinner: bool, ghost K: Candidate) returns (k: Candidate)\n  requires |a| != 0\n  requires hasWinner ==> 2 * Count(a, 0, |a|, K) > |a|  // K has a (strict) majority of the votes\n  ensures hasWinner ==> k == K  // find K\n{\n  k := a[0];\n  var n, c, s := 1, 1, 0;\n  while n < |a|\n    invariant 0 <= s <= n <= |a|\n    invariant hasWinner ==> 2 * Count(a, s, |a|, K) > |a| - s  // K has majority among a[s..]\n    invariant 2 * Count(a, s, n, k) > n - s  // k has majority among a[s..n]\n    invariant c == Count(a, s, n, k)\n  {\n    if a[n] == k {\n      n, c := n + 1, c + 1;\n    } else if 2 * c > n + 1 - s {\n      n := n + 1;\n    } else {\n      n := n + 1;\n      // We have 2*Count(a, s, n, k) == n-s, and thus the following lemma\n      // lets us conclude 2*Count(a, s, n, K) <= n-s.\n      Lemma_Unique(a, s, n, K, k);\n      // We also have 2*Count(a, s, |a|, K) > |a|-s, and the following lemma\n      // tells us Count(a, s, |a|, K) == Count(a, s, n, K) + Count(a, n, |a|, K),\n      // and thus we can conclude 2*Count(a, n, |a|, K) > |a|-n.\n      Lemma_Split(a, s, n, |a|, K);\n      if |a| == n { return; }\n      k, n, c, s := a[n], n + 1, 1, n;\n    }\n  }\n  Lemma_Unique(a, s, |a|, K, k);  // both k and K have a majority, so K == k\n}\n\n// ------------------------------------------------------------------------------\n\n// Here are two lemmas about Count that are used in the methods above.\n\nlemma Lemma_Split<T>(a: seq<T>, s: int, t: int, u: int, x: T)\n  requires 0 <= s <= t <= u <= |a|\n  ensures Count(a, s, t, x) + Count(a, t, u, x) == Count(a, s, u, x)\n{\n  /* The postcondition of this method is proved automatically via Dafny's\n     induction tactic.  But if a manual proof had to be provided, it would\n     look like this:\n  if s != t {\n    Lemma_Split(a, s, t-1, u, x);\n  }\n  */\n}\n\nlemma Lemma_Unique<T>(a: seq<T>, s: int, t: int, x: T, y: T)\n  requires 0 <= s <= t <= |a|\n  ensures x != y ==> Count(a, s, t, x) + Count(a, s, t, y) <= t - s\n{\n  /* The postcondition of this method is proved automatically via Dafny's\n     induction tactic.  But if a manual proof had to be provided, it would\n     look like this:\n  if s != t {\n    Lemma_Unique(a, s, t-1, x, y);\n  }\n  */\n}\n\n// ------------------------------------------------------------------------------\n\n// This version uses more calculations with integer formulas\nmethod FindWinner'<Candidate(==)>(a: seq<Candidate>, ghost K: Candidate) returns (k: Candidate)\n  requires HasMajority(a, 0, |a|, K) // K has a (strict) majority of the votes\n  ensures k == K  // find K\n{\n  k := a[0]; // Current candidate: the first element\n  var lo, up, c := 0, 1, 1; // Window: [0..1], number of occurrences of k in the window: 1\n  while up < |a|\n    invariant 0 <= lo < up <= |a| // (0)\n    invariant HasMajority(a, lo, |a|, K) // (1) K has majority among a[lo..]\n    invariant HasMajority(a, lo, up, k) // (2) k has majority among a[lo..up] (in the current window)\n    invariant c == Count(a, lo, up, k) // (3)\n  {\n    if a[up] == k {\n      // One more occurrence of k\n      up, c := up + 1, c + 1;\n    } else if 2 * c > up + 1 - lo {\n      // An occurrence of another value, but k still has the majority\n      up := up + 1;\n    } else {\n      // An occurrence of another value and k just lost the majority.\n      // Prove that k has exactly 50% in the future window a[lo..up + 1]:\n      calc /* k has 50% among a[lo..up + 1] */ {\n        true;\n      ==  // negation of the previous branch condition;\n        2 * c <= up + 1 - lo;\n      ==  // loop invariant (3)\n        2 * Count(a, lo, up, k) <= up + 1 - lo;\n      == calc {\n           true;\n         ==  // loop invariant (2)\n           HasMajority(a, lo, up, k);\n         ==  // def. HasMajority\n           2 * Count(a, lo, up, k) > up - lo;\n         ==\n           2 * Count(a, lo, up, k) >= up + 1 - lo;\n         }\n        2 * Count(a, lo, up, k) == up + 1 - lo;\n      }\n      up := up + 1;\n      assert 2 * Count(a, lo, up, k) == up - lo; // k has exactly 50% in the current window a[lo..up]\n\n      // We are going to start a new window a[up..up + 1] and choose a new candidate,\n      // so invariants (2) and (3) will be easy to re-establish.\n      // To re-establish (1) we have to prove that K has majority among a[up..], as up will become the new lo.\n      // The main idea is that we had enough K's in a[lo..], and there cannot be too many in a[lo..up].\n      calc /* K has majority among a[up..] */ {\n        2 * Count(a, up, |a|, K);\n      ==  { Lemma_Split(a, lo, up, |a|, K); }\n        2 * Count(a, lo, |a|, K) - 2 * Count(a, lo, up, K);\n      >  { assert HasMajority(a, lo, |a|, K); } // loop invariant (1)\n        |a| - lo - 2 * Count(a, lo, up, K);\n      >=  { if k == K {\n              calc {\n                2 * Count(a, lo, up, K);\n              ==\n                2 * Count(a, lo, up, k);\n              ==  { assert 2 * Count(a, lo, up, k) == up - lo; } // k has 50% among a[lo..up]\n                up - lo;\n              }\n            } else {\n              calc {\n                2 * Count(a, lo, up, K);\n              <=  { Lemma_Unique(a, lo, up, k, K); }\n                2 * ((up - lo) - Count(a, lo, up, k));\n              ==  { assert 2 * Count(a, lo, up, k) == up - lo; } // k has 50% among a[lo..up]\n                up - lo;\n              }\n            }\n            assert 2 * Count(a, lo, up, K) <= up - lo;\n          }\n        |a| - lo - (up - lo);\n      ==\n        |a| - up;\n      }\n      assert HasMajority(a, up, |a|, K);\n\n      k, lo, up, c := a[up], up, up + 1, 1;\n      assert HasMajority(a, lo, |a|, K);\n    }\n  }\n  Lemma_Unique(a, lo, |a|, K, k);  // both k and K have a majority among a[lo..], so K == k\n}\n\n// This version uses more calculations with boolean formulas\nmethod FindWinner''<Candidate(==)>(a: seq<Candidate>, ghost K: Candidate) returns (k: Candidate)\n  requires HasMajority(a, 0, |a|, K)  // K has a (strict) majority of the votes\n  ensures k == K  // find K\n{\n  k := a[0]; // Current candidate: the first element\n  var lo, up, c := 0, 1, 1; // Window: [0..1], number of occurrences of k in the window: 1\n  while up < |a|\n    invariant 0 <= lo < up <= |a| // (0)\n    invariant HasMajority(a, lo, |a|, K) // (1) K has majority among a[lo..]\n    invariant HasMajority(a, lo, up, k) // (2) k has majority among a[lo..up] (in the current window)\n    invariant c == Count(a, lo, up, k) // (3)\n  {\n    if a[up] == k {\n      // One more occurrence of k\n      up, c := up + 1, c + 1;\n    } else if 2 * c > up + 1 - lo {\n      // An occurrence of another value, but k still has the majority\n      up := up + 1;\n    } else {\n      // An occurrence of another value and k just lost the majority.\n      // Prove that k has exactly 50% in the future window a[lo..up + 1]:\n      calc /* k has 50% among a[lo..up + 1] */ {\n        true;\n      ==  // negation of the previous branch condition\n        2 * c <= up + 1 - lo;\n      ==  // loop invariant (3)\n        2 * Count(a, lo, up, k) <= up + 1 - lo;\n      ==  calc {\n            true;\n          ==  // loop invariant (2)\n            HasMajority(a, lo, up, k);\n          ==  // def. HasMajority\n            2 * Count(a, lo, up, k) > up - lo;\n          ==\n            2 * Count(a, lo, up, k) >= up + 1 - lo;\n          }\n        2 * Count(a, lo, up, k) == up + 1 - lo;\n      }\n      up := up + 1;\n      assert 2 * Count(a, lo, up, k) == up - lo; // k has exactly 50% in the current window a[lo..up]\n\n      // We are going to start a new window a[up..up + 1] and choose a new candidate,\n      // so invariants (2) and (3) will be easy to re-establish.\n      // To re-establish (1) we have to prove that K has majority among a[up..], as up will become the new lo.\n      // The main idea is that we had enough K's in a[lo..], and there cannot be too many in a[lo..up].\n      calc /* K has majority among a[up..] */ {\n        true;\n      ==  // loop invariant (1)\n        HasMajority(a, lo, |a|, K);\n      ==\n        2 * Count(a, lo, |a|, K) > |a| - lo;\n      ==  { Lemma_Split(a, lo, up, |a|, K); }\n        2 * Count(a, lo, up, K) + 2 * Count(a, up, |a|, K) > |a| - lo;\n      ==>\n        { if k == K {\n            calc {\n              2 * Count(a, lo, up, K);\n            ==\n              2 * Count(a, lo, up, k);\n            ==  { assert 2 * Count(a, lo, up, k) == up - lo; } // k has 50% among a[lo..up]\n              up - lo;\n            }\n          } else {\n            calc {\n              true;\n            ==  { Lemma_Unique(a, lo, up, k, K); }\n              Count(a, lo, up, K) + Count(a, lo, up, k) <= up - lo;\n            ==\n              2 * Count(a, lo, up, K) + 2 * Count(a, lo, up, k) <= 2 * (up - lo);\n            ==  { assert 2 * Count(a, lo, up, k) == up - lo; } // k has 50% among a[lo..up]\n              2 * Count(a, lo, up, K) <= up - lo;\n            }\n          }\n          assert 2 * Count(a, lo, up, K) <= up - lo;\n        }\n        // subtract off Count(a, lo, up, K) from the LHS and subtract off the larger amount up - lo from the RHS\n        2 * Count(a, up, |a|, K) > (|a| - lo) - (up - lo);\n      ==\n        2 * Count(a, up, |a|, K) > |a| - up;\n      ==\n        HasMajority(a, up, |a|, K);\n      }\n      k, lo, up, c := a[up], up, up + 1, 1;\n      assert HasMajority(a, lo, |a|, K);\n    }\n  }\n  Lemma_Unique(a, lo, |a|, K, k);  // both k and K have a majority among a[lo..], so K == k\n}\n"}
{"file": "../dafny/Test/dafny2/TuringFactorial.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n-1)\n}\n\nmethod ComputeFactorial(n: int) returns (u: int)\n  requires 1 <= n;\n  ensures u == Factorial(n);\n{\n  var r := 1;\n  u := 1;\n  while (r < n)\n    invariant r <= n;\n    invariant u == Factorial(r);\n  {\n    var v, s := u, 1;\n    while (s < r + 1)\n      invariant s <= r + 1;\n      invariant v == Factorial(r) && u == s * Factorial(r);\n    {\n      u := u + v;\n      s := s + 1;\n    }\n    r := r + 1;\n  }\n}\n"}
{"file": "../dafny/Test/dafny2/SegmentSum.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nghost function Sum(a: seq<int>, s: int, t: int): int\n  requires 0 <= s <= t <= |a|\n{\n  if s == t then 0 else Sum(a, s, t-1) + a[t-1]\n}\n\nmethod MaxSegSum(a: seq<int>) returns (k: int, m: int)\n  ensures 0 <= k <= m <= |a|\n  ensures forall p,q :: 0 <= p <= q <= |a| ==> Sum(a, p, q) <= Sum(a, k, m)\n{\n  k, m := 0, 0;\n  var s := 0;  // invariant s == Sum(a, k, m)\n  var n := 0;\n  var c, t := 0, 0;  // invariant t == Sum(a, c, n)\n  while n < |a|\n    invariant 0 <= c <= n <= |a| && t == Sum(a, c, n)\n    invariant forall b :: 0 <= b <= n ==> Sum(a, b, n) <= Sum(a, c, n)\n    invariant 0 <= k <= m <= n && s == Sum(a, k, m)\n    invariant forall p,q :: 0 <= p <= q <= n ==> Sum(a, p, q) <= Sum(a, k, m)\n  {\n    t, n := t + a[n], n + 1;\n    if t < 0 {\n      c, t := n, 0;\n    } else if s < t {\n      k, m, s := c, n, t;\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny2/StoreAndRetrieve.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\n// This file shows an example program that uses both refinement and :autocontracts\n// specify a class that stores a set of things that can be retrieved using a query.\n//\n// (For another example that uses these features, see Test/dafny3/CachedContainer.dfy.)\n\nabstract module AbstractInterface {\n  class {:autocontracts} StoreAndRetrieve<Thing(==)> {\n    ghost var Contents: set<Thing>\n    ghost predicate Valid() {\n      Valid'()\n    }\n    ghost predicate {:autocontracts false} Valid'()\n      reads this, Repr\n    constructor Init()\n      ensures Contents == {}\n    method Store(t: Thing)\n      ensures Contents == old(Contents) + {t}\n    method Retrieve(matchCriterion: Thing -> bool) returns (thing: Thing)\n      requires exists t :: t in Contents && matchCriterion(t)\n      ensures Contents == old(Contents)\n      ensures thing in Contents && matchCriterion(thing)\n  }\n}\n\nabstract module A refines AbstractInterface {\n  class StoreAndRetrieve<Thing(==)> ... {\n    constructor Init...\n    {\n      Contents := {};\n      Repr := {this};\n      new;\n      assume Valid'();  // to be checked in module B\n    }\n    method Store...\n    {\n      Contents := Contents + {t};\n      assume Valid'();  // to be checked in module B\n    }\n    method Retrieve...\n    {\n      var k :| assume k in Contents && matchCriterion(k);\n      thing := k;\n    }\n  }\n}\n\nabstract module B refines A {\n  class StoreAndRetrieve<Thing(==)> ... {\n    var arr: seq<Thing>\n    ghost predicate Valid'...\n    {\n      Contents == set x | x in arr\n    }\n    constructor Init...\n    {\n      arr := [];\n      new;\n      assert ...;\n    }\n    method Store...\n    {\n      arr := arr + [t];\n      ...;\n      assert ...;\n    }\n    method Retrieve...\n    {\n      var i := 0;\n      while (i < |arr|)\n        invariant i < |arr|\n        invariant forall j :: 0 <= j < i ==> !matchCriterion(arr[j])\n      {\n        if matchCriterion(arr[i]) {\n          break;\n        }\n        i := i + 1;\n      }\n      var k := arr[i];\n      ...;\n      var a: seq<Thing> :| assume Contents == set x | x in a;\n      arr := a;\n    }\n  }\n}\n\nmodule abC refines B { // TODO module C causes Go to fail\n  class StoreAndRetrieve<Thing(==)> ... {\n    method Retrieve...\n    {\n      ...;\n      var a := [thing] + arr[..i] + arr[i+1..];  // LRU behavior\n    }\n  }\n}\n\nabstract module AbstractClient {\n  import S : AbstractInterface\n\n  method Test() {\n    var s := new S.StoreAndRetrieve<real>.Init();\n    s.Store(20.3);\n    var fn := r => true;\n    var r := s.Retrieve(fn);\n    print r, \"\\n\";  // 20.3\n  }\n}\n\nmodule Client refines AbstractClient {\n  import S = abC\n  method Main() {\n    Test();\n  }\n}\n"}
{"file": "../dafny/Test/dafny2/COST-verif-comp-2011-2-MaxTree-datatype.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This Dafny program was inspired by Claude Marche's Why3ML program that solves\n// Challenge 2 of the COST Verification Competition.  It particular, it uses an\n// inductive datatype for the Tree data structure, and it uses a Contains function\n// defined on such trees.  This makes the whole program short and sweet, keeps\n// proof annotation overhead to a minimum, and--best of all--makes for a convincing\n// specification of Max.\n// Rustan Leino, 7 Oct 2011\n\n// Remarks:\n\n// A little detail about the implementation of 'Max' below is that the precondition\n// 't != Null' means that the 'match' statement does not need to include a case\n// for 'Null'.  The correctness of the omission of cases is checked by the program\n// verifier.\n\n// About Dafny:\n// As always (when it is successful), Dafny verifies that the program does not\n// cause any run-time errors (like array index bounds errors), that the program\n// terminates, that expressions and functions are well defined, and that all\n// specifications are satisfied.  The language prevents type errors by being type\n// safe, prevents dangling pointers by not having an \"address-of\" or \"deallocate\"\n// operation (which is accommodated at run time by a garbage collector), and\n// prevents arithmetic overflow errors by using mathematical integers (which\n// is accommodated at run time by using BigNum's).  By proving that programs\n// terminate, Dafny proves that a program's time usage is finite, which implies\n// that the program's space usage is finite too.  However, executing the\n// program may fall short of your hopes if you don't have enough time or\n// space; that is, the program may run out of space or may fail to terminate in\n// your lifetime, because Dafny does not prove that the time or space needed by\n// the program matches your execution environment.  The only input fed to\n// the Dafny verifier/compiler is the program text below; Dafny then automatically\n// verifies and compiles the program (for this program in less than 2 seconds)\n// without further human intervention.\n\ndatatype Tree = Null | Node(Tree, int, Tree)\n\nghost function Contains(t: Tree, v: int): bool\n{\n  match t\n  case Null => false\n  case Node(left, x, right) => x == v || Contains(left, v) || Contains(right, v)\n}\n\nmethod Max(t: Tree) returns (result: int)\n  requires t != Null;\n  ensures Contains(t, result) && forall v :: Contains(t, v) ==> v <= result;\n{\n  match (t) {\n    case Node(left, x, right) =>\n      result := MaxAux(right, x);\n      result := MaxAux(left, result);\n  }\n}\n\nmethod MaxAux(t: Tree, acc: int) returns (result: int)\n  ensures result == acc || Contains(t, result);\n  ensures acc <= result && forall v :: Contains(t, v) ==> v <= result;\n{\n  match (t) {\n    case Null => result := acc;\n    case Node(left, x, right) =>\n      result := MaxAux(right, if x < acc then acc else x);\n      result := MaxAux(left, result);\n  }\n}\n"}
{"file": "../dafny/Test/dafny2/COST-verif-comp-2011-1-MaxArray.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n/*\nRustan Leino, 5 Oct 2011\n\nCOST Verification Competition, Challenge 1: Maximum in an array\nhttp://foveoos2011.cost-ic0701.org/verification-competition\n\nGiven: A non-empty integer array a.\n\nVerify that the index returned by the method max() given below points to\nan element maximal in the array.\n\npublic class Max {\n    public static int max(int[] a) {\n        int x = 0;\n        int y = a.length-1;\n\n        while (x != y) {\n            if (a[x] <= a[y]) x++;\n                else y--;\n        }\n        return x;\n    }\n}\n*/\n\n// Remarks:\n\n// The verification of the loop makes use of a local ghost variable 'm'.  To the\n// verifier, this variable is like any other, but the Dafny compiler ignores it.\n// In other words, ghost variables and ghost assignments (and specifications,\n// for that matter) are included in the program just for the purpose of reasoning\n// about the program, and they play no role at run time.\n\n// The only thing that needs to be human-trusted about this program is the\n// specification of 'max' (and, since verification challenge asked to prove\n// something about a particular piece of code, that the body of 'max', minus\n// the ghost constructs, is really that code).\n\n// About Dafny:\n// As always (when it is successful), Dafny verifies that the program does not\n// cause any run-time errors (like array index bounds errors), that the program\n// terminates, that expressions and functions are well defined, and that all\n// specifications are satisfied.  The language prevents type errors by being type\n// safe, prevents dangling pointers by not having an \"address-of\" or \"deallocate\"\n// operation (which is accommodated at run time by a garbage collector), and\n// prevents arithmetic overflow errors by using mathematical integers (which\n// is accommodated at run time by using BigNum's).  By proving that programs\n// terminate, Dafny proves that a program's time usage is finite, which implies\n// that the program's space usage is finite too.  However, executing the\n// program may fall short of your hopes if you don't have enough time or\n// space; that is, the program may run out of space or may fail to terminate in\n// your lifetime, because Dafny does not prove that the time or space needed by\n// the program matches your execution environment.  The only input fed to\n// the Dafny verifier/compiler is the program text below; Dafny then automatically\n// verifies and compiles the program (for this program in less than 2 seconds)\n// without further human intervention.\n\nmethod max(a: array<int>) returns (x: int)\n  requires a.Length != 0\n  ensures 0 <= x < a.Length\n  ensures forall i :: 0 <= i < a.Length ==> a[i] <= a[x]\n{\n  x := 0;\n  var y := a.Length - 1;\n  ghost var m := y;\n  while x != y\n    invariant 0 <= x <= y < a.Length\n    invariant m == x || m == y\n    invariant forall i :: 0 <= i < x ==> a[i] <= a[m]\n    invariant forall i :: y < i < a.Length ==> a[i] <= a[m]\n  {\n    if a[x] <= a[y] {\n      x := x + 1;  m := y;\n    } else {\n      y := y - 1;  m := x;\n    }\n  }\n  return x;\n}\n"}
{"file": "../dafny/Test/dafny2/TreeFill.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Tree<T> = Leaf | Node(Tree, T, Tree)\n\nghost function Contains<T>(t: Tree, v: T): bool\n{\n  match t\n  case Leaf => false\n  case Node(left, x, right) => x == v || Contains(left, v) || Contains(right, v)\n}\n\nmethod Fill<T>(t: Tree, a: array<T>, start: int) returns (end: int)\n  requires 0 <= start <= a.Length\n  modifies a\n  ensures start <= end <= a.Length\n  ensures forall i :: 0 <= i < start ==> a[i] == old(a[i])\n  ensures forall i :: start <= i < end ==> Contains(t, a[i])\n{\n  match t\n  case Leaf =>\n    end := start;\n  case Node(left, x, right) =>\n    end := Fill(left, a, start);\n    if end < a.Length {\n      a[end] := x;\n      end := Fill(right, a, end + 1);\n    }\n}\n\n"}
{"file": "../dafny/Test/dafny2/COST-verif-comp-2011-2-MaxTree-class.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n/*\nRustan Leino, 5 Oct 2011\n\nCOST Verification Competition, Challenge 2: Maximum in a tree\nhttp://foveoos2011.cost-ic0701.org/verification-competition\n\nGiven: A non-empty binary tree, where every node carries an integer.\n\nImplement and verify a program that computes the maximum of the values\nin the tree.\n\nPlease base your program on the following data structure signature:\n\npublic class Tree {\n    int value;\n    Tree left;\n    Tree right;\n}\n\nYou may represent empty trees as null references or as you consider\nappropriate.\n*/\n\n// Remarks:\n\n// The specification of this program uses the common dynamic-frames idiom in Dafny:  the\n// ghost field 'Contents' stores the abstract value of an object, the ghost field 'Repr'\n// stores the set of (references to) objects that make up the representation of the object\n// (which in this case is the Tree itself plus the 'Repr' sets of the left and right\n// subtrees), and a function 'Valid()' that returns 'true' when an object is in a\n// consistent state (that is, when an object satisfies the \"class invariant\").\n\n// The design I used was to represent an empty tree as a Tree object whose left and\n// right pointers point to the object iself.  This is convenient, because it lets\n// clients of Tree and the implementation of Tree always use non-null pointers to\n// Tree objects.\n\n// What needs to be human-trusted about this program is that the 'requires' and\n// 'ensures' clauses (that is, the pre- and postconditions, respectively) of\n// 'ComputeMax' are correct.  And, since the specification talks about the ghost\n// variable 'Contents', one also needs to trust that the 'Valid()' function\n// constrains 'Contents' in a way that a human thinks matches the intuitive\n// definition of what the contents of a tree is.\n\n// To give a taste of that the 'Valid()' function does not over-constrain the\n// object, I have included two instance constructors, 'Empty()' and 'Node(...)'.\n// To take this a step further, one could also write a 'Main' method that\n// builds somme tree and then calls 'ComputeMax', but I didn't do that here.\n\n// About Dafny:\n// As always (when it is successful), Dafny verifies that the program does not\n// cause any run-time errors (like array index bounds errors), that the program\n// terminates, that expressions and functions are well defined, and that all\n// specifications are satisfied.  The language prevents type errors by being type\n// safe, prevents dangling pointers by not having an \"address-of\" or \"deallocate\"\n// operation (which is accommodated at run time by a garbage collector), and\n// prevents arithmetic overflow errors by using mathematical integers (which\n// is accommodated at run time by using BigNum's).  By proving that programs\n// terminate, Dafny proves that a program's time usage is finite, which implies\n// that the program's space usage is finite too.  However, executing the\n// program may fall short of your hopes if you don't have enough time or\n// space; that is, the program may run out of space or may fail to terminate in\n// your lifetime, because Dafny does not prove that the time or space needed by\n// the program matches your execution environment.  The only input fed to\n// the Dafny verifier/compiler is the program text below; Dafny then automatically\n// verifies and compiles the program (for this program in less than 2.5 seconds)\n// without further human intervention.\n\nclass Tree {\n  // an empty tree is represented by a Tree object with left==this==right\n  var value: int\n  var left: Tree?\n  var right: Tree?\n\n  ghost var Contents: seq<int>\n  ghost var Repr: set<object>\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr &&\n    left != null && right != null &&\n    ((left == this == right && Contents == []) ||\n     (left in Repr && left.Repr <= Repr && this !in left.Repr &&\n      right in Repr && right.Repr <= Repr && this !in right.Repr &&\n      left.Valid() && right.Valid() &&\n      Contents == left.Contents + [value] + right.Contents))\n  }\n\n  function IsEmpty(): bool\n    requires Valid();\n    reads this, Repr;\n    ensures IsEmpty() <==> Contents == [];\n  {\n    left == this\n  }\n\n  constructor Empty()\n    ensures Valid() && Contents == [];\n  {\n    left, right := this, this;\n    Contents := [];\n    Repr := {this};\n  }\n\n  constructor Node(lft: Tree, val: int, rgt: Tree)\n    requires lft.Valid() && rgt.Valid();\n    ensures Valid() && Contents == lft.Contents + [val] + rgt.Contents;\n  {\n    left, value, right := lft, val, rgt;\n    Contents := lft.Contents + [val] + rgt.Contents;\n    Repr := lft.Repr + {this} + rgt.Repr;\n  }\n\n  lemma exists_intro<T>(P: T ~> bool, x: T)\n    requires P.requires(x)\n    requires P(x)\n    ensures exists y :: P.requires(y) && P(y)\n  {\n  }\n\n  method ComputeMax() returns (mx: int)\n    requires Valid() && !IsEmpty();\n    ensures forall x :: x in Contents ==> x <= mx;\n    ensures exists x :: x in Contents && x == mx;\n    decreases Repr;\n  {\n    mx := value;\n\n    if (!left.IsEmpty()) {\n      var m := left.ComputeMax();\n      mx := if mx < m  then m else mx;\n    }\n\n    if (!right.IsEmpty()) {\n      var m := right.ComputeMax();\n      mx := if mx < m then m else mx;\n    }\n\n    exists_intro(x reads this => x in Contents && x == mx, mx);\n  }\n}\n"}
{"file": "../dafny/Test/dafny2/SmallestMissingNumber-imperative.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\n// Smallest missing number.\n// An imperative solution to the programming problem in Richard Bird's\n// \"Pearls of Functional Algorithm Design\".\n// Rustan Leino, 19 Feb 2018\n\nmethod Main() {\n  var a := new nat[][3, 6, 23, 9];\n  var s := SmallestMissing(a);\n  print s, \"\\n\";  // 0\n  a := new nat[][3, 2, 0, 5, 4];\n  s := SmallestMissing(a);\n  print s, \"\\n\";  // 1\n  a := new nat[][2, 4, 6, 0, 1, 3, 100];\n  s := SmallestMissing(a);\n  print s, \"\\n\";  // 5\n  a := new nat[0];  // empty array\n  s := SmallestMissing(a);\n  print s, \"\\n\";  // 0\n}\n\nghost predicate Has<T>(a: array<T>, x: T)\n  reads a\n{\n  exists i :: 0 <= i < a.Length && a[i] == x\n}\n\nmethod SmallestMissing(a: array<nat>) returns (s: nat)\n  ensures forall i :: 0 <= i < a.Length ==> a[i] != s  // s is missing\n  ensures forall x :: 0 <= x < s ==> Has(a, x)  // all numbers smaller than s are present\n{\n  var N := a.Length;  // for brevity\n  // Insight: Because we're only given N numbers, we know the result will be at most N.\n  // Strategy: First, record which numbers in the range 0..N exist in \"a\". Second, pick the smallest\n  // one not encountered.\n  // Note: Apparently, Richard Bird's book unnecessarily uses N+1 instead of N as the length\n  // of the auxiliary array.\n  var e := new bool[N](_ => false);  // new array initialized with all \"false\"\n  forall n | 0 <= n < N && a[n] < N {\n    e[a[n]] := true;\n  }\n  s := 0;\n  while s < N && e[s]\n    invariant 0 <= s <= N\n    invariant forall j :: 0 <= j < s ==> Has(a, j)\n  {\n    s := s + 1;\n  }\n  if s == N {\n    Lemma(a);\n  }\n}\n\n// If an array \"a\" contains every number below \"a.Length\", then it only contains numbers below \"a.Length\"\nlemma Lemma(a: array<nat>)\n  requires forall x :: 0 <= x < a.Length ==> Has(a, x)\n  ensures forall i :: 0 <= i < a.Length ==> a[i] < a.Length\n{\n  var ms := multiset(a[..]);\n  var i, ns := 0, multiset{};\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall x :: x in ns ==> 0 <= x < i\n    invariant |ns| == i && ns <= ms\n  {\n    assert Has(a, i);\n    ns := ns + multiset{i};\n    i := i + 1;\n  }\n  assert |ms - ns| == 0;\n  forall i | 0 <= i < a.Length\n    ensures a[i] < a.Length\n  {\n    assert a[i] in ms;\n  }\n}\n\n// Alternative implementation\n\n// This version uses a loop to initialize \"e\".\nmethod SmallestMissing_Loop(a: array<nat>) returns (s: nat)\n  ensures forall i :: 0 <= i < a.Length ==> a[i] != s  // s is missing\n  ensures forall x :: 0 <= x < s ==> Has(a, x)  // all numbers smaller than s are present\n{\n  var N := a.Length;  // for brevity\n  // Insight: Because we're only given N numbers, we know the result will be at most N.\n  // Strategy: First, record which numbers in the range 0..N exist in \"a\". Second, pick the smallest\n  // one not encountered.\n  var e := new bool[N](_ => false);  // new array initialized with all \"false\"\n  var n := 0;\n  while n < N\n    invariant 0 <= n <= N\n    // every number in the range 0..N encountered in \"a\" so far has been marked off in \"e\"\n    invariant forall i :: 0 <= i < n && a[i] < N ==> e[a[i]]\n    // every number that is marked off in \"e\" exists in \"a\"\n    invariant forall j :: 0 <= j < N && e[j] ==> Has(a, j)\n  {\n    if a[n] < N {\n      e[a[n]] := true;\n    }\n    n := n + 1;\n  }\n  s := 0;\n  while s < N && e[s]\n    invariant 0 <= s <= N\n    invariant forall j :: 0 <= j < s ==> Has(a, j)\n  {\n    s := s + 1;\n  }\n  if s == N {\n    Lemma(a);\n  }\n}\n"}
{"file": "../dafny/Test/dafny2/Intervals.dfy", "dafny": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// The RoundDown and RoundUp methods in this file are the ones in the Boogie\n// implementation Source/AbsInt/IntervalDomain.cs.\n\nclass Rounding {\n  var thresholds: array<int>\n\n  ghost function Valid(): bool\n    reads this, thresholds\n  {\n    forall m,n :: 0 <= m < n < thresholds.Length ==> thresholds[m] <= thresholds[n]\n  }\n\n  method RoundDown(k: int) returns (r: int)\n    requires Valid()\n    ensures -1 <= r < thresholds.Length\n    ensures forall m :: r < m < thresholds.Length ==> k < thresholds[m]\n    ensures 0 <= r ==> thresholds[r] <= k\n  {\n    if (thresholds.Length == 0 || k < thresholds[0]) {\n      return -1;\n    }\n    var i, j := 0, thresholds.Length - 1;\n    while (i < j)\n      invariant 0 <= i <= j < thresholds.Length\n      invariant thresholds[i] <= k\n      invariant forall m :: j < m < thresholds.Length ==> k < thresholds[m]\n    {\n      var mid := i + (j - i + 1) / 2;\n      assert i < mid <= j;\n      if (thresholds[mid] <= k) {\n        i := mid;\n      } else {\n        j := mid - 1;\n      }\n    }\n    return i;\n  }\n\n  method RoundUp(k: int) returns (r: int)\n    requires Valid()\n    ensures 0 <= r <= thresholds.Length\n    ensures forall m :: 0 <= m < r ==> thresholds[m] < k\n    ensures r < thresholds.Length ==> k <= thresholds[r]\n  {\n    if (thresholds.Length == 0 || thresholds[thresholds.Length-1] < k) {\n      return thresholds.Length;\n    }\n    var i, j := 0, thresholds.Length - 1;\n    while (i < j)\n      invariant 0 <= i <= j < thresholds.Length\n      invariant k <= thresholds[j]\n      invariant forall m :: 0 <= m < i ==> thresholds[m] < k\n    {\n      var mid := i + (j - i) / 2;\n      assert i <= mid < j;\n      if (thresholds[mid] < k) {\n        i := mid + 1;\n      } else {\n        j := mid;\n      }\n    }\n    return i;\n  }\n}\n"}
{"file": "../dafny/Test/dafny2/COST-verif-comp-2011-3-TwoDuplicates.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n/*\nRustan Leino, 5 Oct 2011\n\nCOST Verification Competition, Challenge 3: Two equal elements\nhttp://foveoos2011.cost-ic0701.org/verification-competition\n\nGiven: An integer array a of length n+2 with n>=2. It is known that at\nleast two values stored in the array appear twice (i.e., there are at\nleast two duplets).\n\nImplement and verify a program finding such two values.\n\nYou may assume that the array contains values between 0 and n-1.\n*/\n\n// Remarks:\n\n// The implementation of method 'Search' takes one pass through the elements of\n// the given array.  To keep track of what it has seen, it allocates an array as\n// temporary storage--I imagine that this is what the competition designers\n// had in mind, since the problem description says one can assume the values\n// of the given array to lie in the range 0..n.\n\n// To keep track of whether it already has found one duplicate, the method\n// sets the output variables p and q as follows:\n//   p != q   - no duplicates found yet\n//   p == q   - one duplicate found so far, namely the value stored in p and q\n// Note, the loop invariant does not need to say anything about the state\n// of two duplicates having been found, because when the second duplicate is\n// found, the method returns.\n\n// What needs to be human-trusted about this program is the specification of\n// 'Search'.  The specification straightforwardly lists the assumptions stated\n// in the problem description, including the given fact that the array contains\n// (at least) two distinct elements that each occurs (at least) twice.  To\n// trust the specification of 'Search', a human also needs to trust the definition\n// of 'IsDuplicate' and its auxiliary function 'IsPrefixDuplicate'.\n\n// About Dafny:\n// As always (when it is successful), Dafny verifies that the program does not\n// cause any run-time errors (like array index bounds errors), that the program\n// terminates, that expressions and functions are well defined, and that all\n// specifications are satisfied.  The language prevents type errors by being type\n// safe, prevents dangling pointers by not having an \"address-of\" or \"deallocate\"\n// operation (which is accommodated at run time by a garbage collector), and\n// prevents arithmetic overflow errors by using mathematical integers (which\n// is accommodated at run time by using BigNum's).  By proving that programs\n// terminate, Dafny proves that a program's time usage is finite, which implies\n// that the program's space usage is finite too.  However, executing the\n// program may fall short of your hopes if you don't have enough time or\n// space; that is, the program may run out of space or may fail to terminate in\n// your lifetime, because Dafny does not prove that the time or space needed by\n// the program matches your execution environment.  The only input fed to\n// the Dafny verifier/compiler is the program text below; Dafny then automatically\n// verifies and compiles the program (for this program in less than 11 seconds)\n// without further human intervention.\n\nghost predicate IsDuplicate(a: array<int>, p: int)\n  reads a\n{\n  IsPrefixDuplicate(a, a.Length, p)\n}\n\nghost predicate IsPrefixDuplicate(a: array<int>, k: int, p: int)\n  requires 0 <= k <= a.Length;\n  reads a;\n{\n  exists i,j :: 0 <= i < j < k && a[i] == a[j] == p\n}\n\nmethod Search(a: array<int>) returns (p: int, q: int)\n  requires 4 <= a.Length;\n  requires exists p,q :: p != q && IsDuplicate(a, p) && IsDuplicate(a, q);  // two distinct duplicates exist\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] < a.Length - 2;  // the elements of \"a\" in the range [0.. a.Length-2]\n  ensures p != q && IsDuplicate(a, p) && IsDuplicate(a, q);\n{\n  // allocate an array \"d\" and initialize its elements to -1.\n  var d := new int[a.Length-2];\n  var i := 0;\n  while (i < d.Length)\n    invariant 0 <= i <= d.Length && forall j :: 0 <= j < i ==> d[j] == -1;\n  {\n    d[i], i := -1, i+1;\n  }\n\n  i, p, q := 0, 0, 1;\n  while (true)\n    invariant 0 <= i < a.Length;\n    invariant forall j :: 0 <= j < d.Length ==>\n                (d[j] == -1 && forall k :: 0 <= k < i ==> a[k] != j) ||\n                (0 <= d[j] < i && a[d[j]] == j);\n    invariant p == q ==> IsDuplicate(a, p); //WISH remove the trigger on the next line\n    invariant forall k {:trigger old(a[k])} :: 0 <= k < i && IsPrefixDuplicate(a, i, a[k]) ==> p == q == a[k];\n    decreases a.Length - i;\n  {\n    var k := d[a[i]];\n    assert k < i;  // note, this assertion is really for human consumption; it is not needed by the verifier, and it does not change the performance of the verifier\n    if (k == -1) {\n      // a[i] does not exist in a[..i]\n      d[a[i]] := i;\n    } else {\n      // we have encountered a duplicate\n      assert a[i] == a[k] && IsDuplicate(a, a[i]);  // note, this assertion is really for human consumption; it is not needed by the verifier, and it does not change the performance of the verifier\n      if (p != q) {\n        // this is the first duplicate encountered\n        p, q := a[i], a[i];\n      } else if (p == a[i]) {\n        // this is another copy of the same duplicate we have seen before\n      } else {\n        // this is the second duplicate\n        q := a[i];\n        return;\n      }\n    }\n    i := i + 1;\n  }\n}\n"}
{"file": "../dafny/Test/dafny2/Classics.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// A version of Turing's additive factorial program [Dr. A. Turing, \"Checking a large routine\",\n// In \"Report of a Conference of High Speed Automatic Calculating Machines\", pp. 67-69, 1949].\n\nghost function Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n-1)\n}\n\nmethod AdditiveFactorial(n: nat) returns (u: nat)\n  ensures u == Factorial(n);\n{\n  u := 1;\n  var r := 0;\n  while (r < n)\n    invariant 0 <= r <= n;\n    invariant u == Factorial(r);\n  {\n    var v := u;\n    var s := 1;\n    while (s <= r)\n      invariant 1 <= s <= r+1;\n      invariant u == s * Factorial(r);\n    {\n      u := u + v;\n      s := s + 1;\n    }\n    r := r + 1;\n  }\n}\n\n// Hoare's FIND program [C.A.R. Hoare, \"Proof of a program: FIND\", CACM 14(1): 39-45, 1971].\n// The proof annotations here are not the same as in Hoare's article.\n\n// In Hoare's words:\n//   This program operates on an array A[1:N], and a value of f (1 <= f <= N).\n//   Its effect is to rearrange the elements of A in such a way that:\n//     forall p,q (1 <= p <= f <= q <= N ==> A[p] <= A[f] <= A[q]).\n//\n// Here, we use 0-based indices, so we would say:\n//   This method operates on an array A[0..N], and a value of f (0 <= f < N).\n//   Its effect is to rearrange the elements of A in such a way that:\n//     forall p,q :: 0 <= p <= f <= q < N ==> A[p] <= A[f] <= A[q]).\n\nmethod FIND(A: array<int>, N: int, f: int)\n  requires A.Length == N;\n  requires 0 <= f < N;\n  modifies A;\n  ensures forall p,q :: 0 <= p <= f <= q < N ==> A[p] <= A[q];\n{\n  var m, n := 0, N-1;\n  while (m < n)\n    invariant 0 <= m <= f <= n < N;\n    invariant forall p,q :: 0 <= p < m <= q < N ==> A[p] <= A[q];\n    invariant forall p,q :: 0 <= p <= n < q < N ==> A[p] <= A[q];\n  {\n    var r, i, j := A[f], m, n;\n    while (i <= j)\n      invariant m <= i && j <= n;\n      invariant -1 <= j && i <= N;\n      invariant i <= j ==> exists g :: i <= g < N && r <= A[g];\n      invariant i <= j ==> exists g :: 0 <= g <= j && A[g] <= r;\n      invariant forall p :: 0 <= p < i ==> A[p] <= r;\n      invariant forall q :: j < q < N ==> r <= A[q];\n      // the following two invariants capture (and follow from) the fact that the array is not modified outside the [m:n] range\n      invariant forall p,q :: 0 <= p < m <= q < N ==> A[p] <= A[q];\n      invariant forall p,q :: 0 <= p <= n < q < N ==> A[p] <= A[q];\n      // the following invariant is used to prove progress of the outer loop\n      invariant (i==m && j==n && r==A[f]) || (m<i && j<n);\n    {\n      ghost var firstIteration := i==m && j==n;\n      while (A[i] < r)\n        invariant m <= i <= N && (firstIteration ==> i <= f);\n        invariant exists g :: i <= g < N && r <= A[g];\n        invariant exists g :: 0 <= g <= j && A[g] <= r;\n        invariant forall p :: 0 <= p < i ==> A[p] <= r;\n        decreases j - i;\n      { i := i + 1; }\n\n      while (r < A[j])\n        invariant 0 <= j <= n && (firstIteration ==> f <= j);\n        invariant exists g :: i <= g < N && r <= A[g];\n        invariant exists g :: 0 <= g <= j && A[g] <= r;\n        invariant forall q :: j < q < N ==> r <= A[q];\n        decreases j;\n      { j := j - 1; }\n\n      assert A[j] <= r <= A[i];\n      if (i <= j) {\n        var w := A[i]; A[i] := A[j]; A[j] := w;  // swap A[i] and A[j] (which may be referring to the same location)\n        assert A[i] <= r <= A[j];\n        i, j := i + 1, j - 1;\n      }\n    }\n\n    if (f <= j) {\n      n := j;\n    } else if (i <= f) {\n      m := i;\n    } else {\n      break;  // Hoare used a goto\n    }\n  }\n}\n"}
{"file": "../dafny/Test/dafny2/Calculations.dfy", "dafny": "// RUN: %dafny /compile:0 /deprecation:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n/* Lists */\n// Here are some standard definitions of List and functions on Lists\n\ndatatype List<T> = Nil | Cons(T, List)\n\nghost function length(l: List): nat\n{\n  match l\n  case Nil => 0\n  case Cons(x, xs) => 1 + length(xs)\n}\n\nghost function concat(l: List, ys: List): List\n{\n  match l\n  case Nil => ys\n  case Cons(x, xs) => Cons(x, concat(xs, ys))\n}\n\nghost function reverse(l: List): List\n{\n  match l\n  case Nil => Nil\n  case Cons(x, xs) => concat(reverse(xs), Cons(x, Nil))\n}\n\nghost function revacc(l: List, acc: List): List\n{\n  match l\n  case Nil => acc\n  case Cons(x, xs) => revacc(xs, Cons(x, acc))\n}\n\nghost function qreverse(l: List): List\n{\n  revacc(l, Nil)\n}\n\n// Here are two lemmas about the List functions.\n\nlemma Lemma_ConcatNil(xs : List)\n  ensures concat(xs, Nil) == xs;\n{\n}\n\nlemma Lemma_RevCatCommute(xs : List)\n  ensures forall ys, zs :: revacc(xs, concat(ys, zs)) == concat(revacc(xs, ys), zs);\n{\n}\n\n// Here is a theorem that says \"qreverse\" and \"reverse\" calculate the same result.  The proof\n// is given in a calculational style.  The proof is not minimal--some lines can be omitted\n// and Dafny will still fill in the details.\n\nlemma Theorem_QReverseIsCorrect_Calc(l: List)\n  ensures qreverse(l) == reverse(l);\n{\n  calc {\n    qreverse(l);\n    // def. qreverse\n    revacc(l, Nil);\n    { Lemma_Revacc_calc(l, Nil); }\n    concat(reverse(l), Nil);\n    { Lemma_ConcatNil(reverse(l)); }\n    reverse(l);\n  }\n}\n\nlemma Lemma_Revacc_calc(xs: List, ys: List)\n  ensures revacc(xs, ys) == concat(reverse(xs), ys);\n{\n  match (xs) {\n    case Nil =>\n    case Cons(x, xrest) =>\n      calc {\n        concat(reverse(xs), ys);\n        // def. reverse\n        concat(concat(reverse(xrest), Cons(x, Nil)), ys);\n        // induction hypothesis: Lemma_Revacc_calc(xrest, Cons(x, Nil))\n        concat(revacc(xrest, Cons(x, Nil)), ys);\n        { Lemma_RevCatCommute(xrest); } // forall xs,ys,zs :: revacc(xs, concat(ys, zs)) == concat(revacc(xs, ys), zs)\n        revacc(xrest, concat(Cons(x, Nil), ys));\n        // def. concat (x2)\n        revacc(xrest, Cons(x, ys));\n        // def. revacc\n        revacc(xs, ys);\n      }\n  }\n}\n\n// Here is a version of the same proof, as it was constructed before Dafny's \"calc\" construct.\n\nlemma Theorem_QReverseIsCorrect(l: List)\n  ensures qreverse(l) == reverse(l);\n{\n  assert qreverse(l)\n      == // def. qreverse\n         revacc(l, Nil);\n  Lemma_Revacc(l, Nil);\n  assert revacc(l, Nil)\n      == concat(reverse(l), Nil);\n  Lemma_ConcatNil(reverse(l));\n}\n\nlemma Lemma_Revacc(xs: List, ys: List)\n  ensures revacc(xs, ys) == concat(reverse(xs), ys);\n{\n  match (xs) {\n    case Nil =>\n    case Cons(x, xrest) =>\n      assert revacc(xs, ys)\n          == // def. revacc\n              revacc(xrest, Cons(x, ys));\n\n      assert concat(reverse(xs), ys)\n          == // def. reverse\n              concat(concat(reverse(xrest), Cons(x, Nil)), ys)\n          == // induction hypothesis:  Lemma_Revacc(xrest, Cons(x, Nil))\n              concat(revacc(xrest, Cons(x, Nil)), ys);\n          Lemma_RevCatCommute(xrest);  // forall xs,ys,zs :: revacc(xs, concat(ys, zs)) == concat(revacc(xs, ys), zs)\n      assert concat(revacc(xrest, Cons(x, Nil)), ys)\n          == revacc(xrest, concat(Cons(x, Nil), ys));\n\n      assert forall g: _T0, gs :: concat(Cons(g, Nil), gs) == Cons(g, gs);\n\n      assert revacc(xrest, concat(Cons(x, Nil), ys))\n          == // the assert lemma just above\n              revacc(xrest, Cons(x, ys));\n  }\n}\n\n/* Fibonacci */\n// To further demonstrate what the \"calc\" construct can do, here are some proofs about the Fibonacci function.\n\nghost function Fib(n: nat): nat\n{\n  if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n}\n\nlemma Lemma_Fib()\n  ensures Fib(5) < 6;\n{\n  calc {\n    Fib(5);\n    Fib(4) + Fib(3);\n  <\n    calc {\n      Fib(2);\n      Fib(0) + Fib(1);\n      0 + 1;\n      1;\n    }\n    6;\n  }\n}\n\n/* List length */\n// Here are some proofs that show the use of nested calculations.\n\nlemma Lemma_Concat_Length(xs: List, ys: List)\n  ensures length(concat(xs, ys)) == length(xs) + length(ys);\n{}\n\nlemma Lemma_Reverse_Length(xs: List)\n  ensures length(xs) == length(reverse(xs));\n{\n  match (xs) {\n    case Nil =>\n    case Cons(x, xrest) =>\n      calc {\n        length(reverse(xs));\n        // def. reverse\n        length(concat(reverse(xrest), Cons(x, Nil)));\n        { Lemma_Concat_Length(reverse(xrest), Cons(x, Nil)); }\n        length(reverse(xrest)) + length(Cons(x, Nil));\n        // induction hypothesis\n        length(xrest) + length(Cons(x, Nil));\n        calc {\n          length(Cons(x, Nil));\n          // def. length\n          // 1 + length(Nil);  // ambigious type parameter\n          // def. length\n          1 + 0;\n          1;\n        }\n        length(xrest) + 1;\n        // def. length\n        length(xs);\n      }\n  }\n}\n\nlemma Window(xs: List, ys: List)\n  ensures length(xs) == length(ys) ==> length(reverse(xs)) == length(reverse(ys));\n{\n  calc {\n    length(xs) == length(ys) ==> length(reverse(xs)) == length(reverse(ys));\n    { if (length(xs) == length(ys)) {\n      calc {\n        length(reverse(xs));\n        { Lemma_Reverse_Length(xs); }\n        length(xs);\n        length(ys);\n        { Lemma_Reverse_Length(ys); }\n        length(reverse(ys));\n    } } }\n    length(xs) == length(ys) ==> length(reverse(xs)) == length(reverse(xs));\n    true;\n  }\n}\n\n// In the following we use a combination of calc and forall\n\nghost function ith<a>(xs: List, i: nat): a\n  requires i < length(xs);\n{\n  match xs\n  case Cons(x, xrest) => if i == 0 then x else ith(xrest, i - 1)\n}\n\nlemma lemma_zero_length(xs: List)\n  ensures length(xs) == 0 <==> xs.Nil?;\n{}\n\nlemma lemma_extensionality(xs: List, ys: List)\n  requires length(xs) == length(ys); // (0)\n  requires forall i: nat | i < length(xs) :: ith(xs, i) == ith(ys, i); // (1)\n  ensures xs == ys;\n{\n  match xs {\n    case Nil =>\n      calc {\n        true;\n        // (0)\n        length(xs) == length(ys);\n        0 == length(ys);\n        { lemma_zero_length(ys); }\n        Nil == ys;\n        xs == ys;\n      }\n    case Cons(x, xrest) =>\n      match ys {\n        case Cons(y, yrest) =>\n          calc {\n            xs;\n            Cons(x, xrest);\n            calc {\n              x;\n              ith(xs, 0);\n              // (1) with i = 0\n              ith(ys, 0);\n              y;\n            }\n            Cons(y, xrest);\n            {\n              forall (j: nat | j < length(xrest)) {\n                calc {\n                  ith(xrest, j);\n                  ith(xs, j + 1);\n                  // (1) with i = j + 1\n                  ith(ys, j + 1);\n                  ith(yrest, j);\n                }\n              }\n              lemma_extensionality(xrest, yrest);\n            }\n            Cons(y, yrest);\n            ys;\n          }\n      }\n  }\n}\n\n"}
{"file": "../dafny/Test/dafny2/Z-BirthdayBook.dfy", "dafny": "// NONUNIFORM: https://github.com/dafny-lang/dafny/issues/4108\n// RUN: %dafny /compile:3 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// The birthday book example from the Z Reference Manual\n// Rustan Leino, 22 Feb 2018\n\n// This file contains the BirthdayBook example from the Z Reference\n// manual. The comments in the code remark on similarities and\n// differences between Z and Dafny.\n\nabstract module Specification {\n  // Names and dates are two types. We leave these types as opaque\n  // for now.\n  // We need to say that names support equality in compiled\n  // code. This is done with the `(==)` suffix.\n  type Name(==)\n  type Date\n\n  // Here are some example names and types\n  const John: Name\n  const Mike: Name\n  const Susan: Name\n  const Mar25: Date\n  const Dec20: Date\n\n  // We declare a class and mark it with `{:autocontracts}`. This attribute\n  // will simplify our task of writing specifications by supplying various\n  // method pre- and postconditions. Of interest to us is the following:\n  //   * The auto-contracts feature allows us to declare an invariant.  It\n  //     expects this invariant to be declared in a predicate called `Valid()`.\n  //   * The invariant will be added as postcondition constructors and as\n  //     a pre- and postcondition to every method.\n  // The auto-contracts feature also performs some other rewrites. These\n  // are not important for our example, but they can always be inspected\n  // by looking at hover text in the Dafny IDEs.\n  class {:autocontracts} BirthdayBook {\n    // To allow them to change, we declare `known` and `birthday` as fields.\n    // We could declare `birthday` to be a partial function, that is, to\n    // have type `Name --> Date`. However, this example will be simpler to\n    // do with a finite map in Dafny.\n    var known: set<Name>\n    var birthday: map<Name, Date>\n\n    ghost predicate Valid() {\n      // In Z notation:  known = dom birthday\n      known == birthday.Keys\n    }\n\n    // In Z, the convention is that inputs have names that end with a question\n    // mark. You can do that in Dafny as well. However, this feels to me a little\n    // confusing in Dafny, because a question mark at the end of an identifier is\n    // sometimes used in different ways (datatype selectors and possibly null\n    // reference types).  Moreover, since Dafny methods declare in-parameters\n    // explictly, I don't think the need for Z's naming convention is crucial.\n    // Therefore, instead of calling the in-parameters `name?` and `date?`, I\n    // will simply call them `name` and `date`.\n    method AddBirthday(name: Name, date: Date)\n      // A precondition for this operation is that the given name is unknown.\n      requires name !in known\n      // In Z, one writes `\\Delta BirthdayBook` to indicate that this operation\n      // describes a state change. In Dafny, one instead says that the fields\n      // of `this` may be modified. (Actually, the auto-contracts feature will\n      // add this `modifies` clause automatically, so we don't need to show it\n      // here.)\n      modifies this\n      // Here is the postcondition. Like in the Z example, we mention explicitly\n      // only the change to `birthday`. Since the invariant (that is, the condition\n      // given by predicate `Valid()`) is implicit in the postcondition (since\n      // we used `{:autocontracts}`, a logical consequence of this specification is\n      // that `known` will change correspondingly.\n      ensures birthday == old(birthday)[name := date]\n\n    // To make sure the specification of `AddBirthday` really does imply a\n    // corresponding change to `known`, we give a proof by writing some code\n    // that calls `AddBirthday` and observes, afterwards, that `known` has the\n    // expected value.\n    method ConsequenceOfAddBirthday(name: Name, date: Date)\n      requires name !in known\n    {\n      AddBirthday(name, date);\n      assert known == old(known) + {name};  // that's it, we proved it!\n\n      // Well, if you want to see a longer proof in the proof-calculation style\n      // of the proof in the Z Reference Manual, here is one:\n      calc {\n        known;\n      ==  { assert Valid(); }  // invariant after\n        birthday.Keys;\n      ==  // specification of `AddBirthday`\n        (old(birthday)[name := date]).Keys;\n      ==  // fact about .Keys\n        old(birthday).Keys + (map[name := date]).Keys;\n      ==  // fact about .Keys\n        old(birthday).Keys + {name};\n      == { assert old(Valid()); }  // invariant before\n        old(known) + {name};\n      }\n\n      // Note: It is common that proofs about programs are confined to \"ghost\"\n      // declarations, that is, declarations for which the compiler will not\n      // generate any code. In such a case, it would be natural to declare\n      // `ConsequenceOfAddBirthday` as a `lemma`.  However, a lemma is\n      // not allowed to change the program state, so it would not be allowed\n      // to call method `AddBirthday`.\n    }\n\n    // Z's convention is to name outputs with something that ends with an\n    // exclamation point. Exclamation points are not allowed in identifiers\n    // in Dafny. However, since Dafny methods have to declare their\n    // out-parameters, I think it's plenty clear in the following line that\n    // `name` is an input and `date` is an output.\n    method FindBirthday(name: Name) returns (date: Date)\n      // Here is the precondition of the operation:\n      requires name in known\n      // The Z notation uses `\\Xi BirthdayBook` to indicate that this operation\n      // does not change the state of the birthday book. In Dafny, this is\n      // normally done by just omitting a `modifies` clause. However, we\n      // are using `{:autocontracts}` and it, in effect, adds `modifies this`.\n      // We could therefore add a postcondition like:\n      //     ensures known == old(known) && birthday == old(birthday)\n      // but a more concise postcondition is the following:\n      ensures unchanged(this)\n      // In addition, we want to say that the method sets the out-parameter\n      // to the birthday of `name`.\n      ensures date == birthday[name]\n\n    // Here is the `Remind` operation, which returns the set of names whose\n    // birthday is is today\n    method Remind(today: Date) returns (cards: set<Name>)\n      ensures unchanged(this)  // again, this is `\\Xi BirthdayBook` in Z\n      // The following line shows some minor differences in the set-comprehension\n      // notation in Z and Dafny. In Z, the \"type\" of `n` is `known`. But\n      // in Dafny, `known` cannot be used as a type. Instead, the type of\n      // `n` is (inferred to be) `Name` and `n in known` is a predicate that\n      // is included in the range predicate of the set comprehension.\n      ensures cards == set n | n in known && birthday[n] == today\n\n    // Here is something we can prove from the postcondition of `Remind`.\n    // The Z Reference Manual shows a formula like this, too.\n    method ConsequenceOfRemind(today: Date, m: Name)\n    {\n      var cards := Remind(today);\n      assert m in cards <==> m in known && birthday[m] == today;\n    }\n\n    // Finally, here is the specification of a constructor that initializes\n    // `BirthdayBook` instances.  The Z Reference Manual calls this\n    // operation `InitBirthdayBook`, but the last part of this name seems\n    // a bit redundant, since the enclosing class is called `BirthdayBook`.\n    // Hence, I'll just call it `Init`.\n    constructor Init()\n      ensures known == {}\n\n    method ConsequenceOfInit()\n    {\n      var bb := new BirthdayBook.Init();\n      assert bb.birthday == map[];\n    }\n  }\n}\n\nmodule Implementation refines Specification {\n  type Name = string\n  type Date = int\n\n  const John := \"John\"\n  const Mike := \"Mike\"\n  const Susan := \"Susan\"\n  const Mar25 := 325\n  const Dec20 := 1220\n\n  class BirthdayBook ... {\n    method AddBirthday...\n    {\n      known := known + {name};\n      birthday := birthday[name := date];\n    }\n\n    method FindBirthday(name: Name) returns (date: Date)\n    {\n      date := birthday[name];\n    }\n\n    method Remind(today: Date) returns (cards: set<Name>)\n    {\n      cards := set n | n in known && birthday[n] == today;\n    }\n\n    constructor Init...\n    {\n      known, birthday := {}, map[];\n      Repr := {this};\n    }\n  }\n}\n\nmethod Main() {\n  var bb := new Implementation.BirthdayBook.Init();\n\n  bb.AddBirthday(Implementation.John, Implementation.Mar25);\n  bb.AddBirthday(Implementation.Mike, Implementation.Dec20);\n  bb.AddBirthday(Implementation.Susan, Implementation.Dec20);\n\n  var f := bb.FindBirthday(Implementation.John);\n  assert f == Implementation.Mar25;\n\n  var cards := bb.Remind(Implementation.Dec20);\n  print \"Send cards to: \", cards, \"\\n\";\n}\n"}
{"file": "../dafny/Test/traits/TraitExample.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ntrait Automobile {\n  ghost var Repr: set<object>\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  function Brand(): string\n  var position: int\n  method Drive()\n    requires Valid()\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures old(position) <= position\n}\n\nclass Fiat extends Automobile {\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr && position <= 100\n  }\n  constructor (pos: int)\n    requires pos <= 100\n    ensures Valid() && fresh(Repr) && position == pos\n  {\n    position, Repr := pos, {this};\n  }\n  function Brand(): string {\n    \"Fiat\"\n  }\n  method Drive()\n    requires Valid()\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures old(position) <= position\n  {\n    position := if position < 97 then position + 3 else 100;\n  }\n}\n\nclass Volvo extends Automobile {\n  var odometer: Odometer\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr && odometer in Repr &&\n    position % 10 == 0 &&  // position is always a multiple of 10\n    odometer.value == position\n  }\n  constructor ()\n    ensures Valid() && fresh(Repr)\n  {\n    position, Repr := 0, {this};\n    odometer := new Odometer();\n    Repr := Repr + {odometer};\n  }\n  function Brand(): string {\n    \"Volvo\"\n  }\n  method Drive()\n    requires Valid()\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures old(position) < position  // always promises to make a move\n  {\n    position := position + 10;\n    odometer.Advance(10);\n  }\n}\n\nclass Odometer {\n  var value: int\n  constructor ()\n    ensures value == 0\n  {\n    value := 0;\n  }\n  method Advance(d: int)\n    requires 0 <= d\n    modifies this\n    ensures value == old(value) + d\n  {\n    value := value + d;\n  }\n}\n\nclass Catacar extends Automobile {\n  var f: Fiat\n  var v: Volvo\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr &&\n    f in Repr && this !in f.Repr && f.Repr <= Repr && f.Valid() &&\n    v in Repr && this !in v.Repr && v.Repr <= Repr && v.Valid() &&\n    f.Repr !! v.Repr &&\n    position == f.position + v.position\n  }\n  constructor ()\n    ensures Valid() && fresh(Repr)\n  {\n    var fiat := new Fiat(0);\n    var volvo := new Volvo();\n    f, v := fiat, volvo;\n    Repr := {this} + fiat.Repr + volvo.Repr;\n    position := volvo.position;\n  }\n  function Brand(): string {\n    \"Catacar\"\n  }\n  method Drive()\n    requires Valid()\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures old(position) <= position\n  {\n    f := new Fiat(f.position);\n    f.Drive();  v.Drive();\n    Repr := Repr + v.Repr + f.Repr;\n    position := f.position + v.position;\n  }\n}\n\nmethod Main() {\n  var auto: Automobile;\n  auto := new Fiat(0);\n  WorkIt(auto);\n  auto := new Volvo();\n  WorkIt(auto);\n  auto := new Catacar();\n  WorkIt(auto);\n}\n\nmethod WorkIt(auto: Automobile)\n  requires auto.Valid()\n  modifies auto.Repr\n{\n  auto.Drive();\n  auto.Drive();\n  assert old(auto.position) <= auto.position;\n  print auto.Brand(), \": \", auto.position, \"\\n\";\n  auto.position := 18;  // note, this may destroy the automobile's consistency condition (given by Valid)\n}\n"}
{"file": "../dafny/Test/traits/TraitsMultipleInheritance.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ntrait J1{\n  var x: int\n}\n\ntrait J2{\n  var y: int\n}\n\nclass C extends J1, J2{\n}\n\nmethod Main()\n{\n  var c := new C;\n  var j1: J1 := new C;\n  var j2: J2 := new C;\n\n  c.x := 10;\n  c.y := 20;\n  j1.x := 20;\n  j2.y := 10;\n\n  print \"c.x + c.y = \" , c.x + c.y, \"\\n\";\n  print \"j1.x + j2.y = \" , j1.x + j2.y, \"\\n\";\n\n  assert c.x + c.y == j1.x + j2.y;\n}\n"}
{"file": "../dafny/Test/traits/Traits-Fields.dfy", "dafny": "// RUN: %testDafnyForEachCompiler \"%s\" --refresh-exit-code=0 -- --relax-definite-assignment\n\ntrait J\n{\n  var x: int\n}\n\nclass C extends J\n{\n\n}\n\nmethod Main()\n{\n  var c := new C;\n  var j: J? := new C;\n\n  j.x := 8;\n  c.x := 9;\n  assert j.x + 1 == c.x;\n\n  j := c;\n  assert j.x == 9;\n\n  print \"j\"; Print(j);\n  print \"c\"; Print(c);\n\n  c := null;\n  assert j != null;\n  j := null;\n}\n\nmethod Print(j: J)\n{\n  print \".x = \", j.x, \"\\n\";\n}\n"}
{"file": "../dafny/Test/traits/TraitCompileErrors.dfy", "dafny": "// RUN: %exits-with 3 %dafny /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmodule StaticMembers {\n  trait Tr {\n    // the following static members must also be given bodies, but that's checked by the compiler\n    static ghost function Func(): int\n    static method Method()\n    static twostate function TwoF(): int\n    static twostate lemma TwoL()\n    static least predicate P()\n    static greatest predicate Q()\n    static least lemma IL()\n    static greatest lemma CL()\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/canyon_search/canyon_search_strong.dfy", "dafny": "method CanyonSearch(a: array<int>, b: array<int>) returns (d:nat)\n  requires a.Length !=0 && b.Length!=0\n  requires forall i,j :: 0<=i<j<a.Length ==> a[i]<=a[j]\n  requires forall i,j :: 0<=i<j<b.Length ==> b[i]<=b[j]\n  ensures exists i,j:: 0<=i<a.Length && 0<=j<b.Length && d==if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n  ensures forall i,j:: 0<=i<a.Length && 0<=j<b.Length ==> d<=if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n{\n  var m,n:=0,0;\n  d:=if a[0] < b[0] then (b[0]-a[0]) else (a[0]-b[0]);\n  while m<a.Length && n<b.Length\n    invariant 0<=m<=a.Length && 0<=n<=b.Length\n    decreases a.Length -m+b.Length-n\n    invariant exists i,j:: 0<=i<a.Length && 0<=j<b.Length && d==if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n    invariant forall i,j:: 0<=i<a.Length && 0<=j<b.Length ==> d<=(if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j]))|| (m<=i&&n<=j)\n  {\n    var t := if a[m] < b[n] then (b[n]-a[m]) else (a[m]-b[n]);\n    d:=if t<d then t else d;\n    if\n    case a[m]<=b[n] =>\n      m:=m+1;\n    case b[n]<=a[m] =>\n      n:=n+1;\n\n  }\n}\n\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/remove_front/remove_front_strong.dfy", "dafny": "method remove_front(a:array<int>) returns (c:array<int>)\n  requires a.Length>0\n  ensures  a[1..] == c[..]\n{\n  c := new int[a.Length-1];\n  var i:= 1;\n  while (i < a.Length)\n    invariant 1 <= i <= a.Length\n    invariant forall ii::1<=ii<i ==> c[ii-1]==a[ii]\n  {\n    c[i-1] := a[i];\n    i:=i+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/longest_prefix/longest_prefix_strong.dfy", "dafny": "method LongestCommonPrefix(str1: seq<char>, str2: seq<char>) returns (prefix: seq<char>)\n  ensures |prefix| <= |str1| && prefix == str1[0..|prefix|]&& |prefix| <= |str2| && prefix == str2[0..|prefix|]\n  ensures |prefix|==|str1| || |prefix|==|str2| || (str1[|prefix|]!=str2[|prefix|])\n{\n  prefix := [];\n  var minLength := if |str1| <|str2| then |str1| else |str2|;\n\n  for idx:= 0 to minLength\n    invariant |prefix|==idx <=  minLength<=|str1| && minLength<=|str2|\n    invariant |prefix| <= |str1| && prefix == str1[0..|prefix|]&& |prefix| <= |str2| && prefix == str2[0..|prefix|]\n  {\n    if str1[idx] != str2[idx] {\n      return;\n    }\n    prefix := prefix + [str1[idx]];\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/integer_square_root/integer_square_root_strong.dfy", "dafny": "method SquareRoot(N:nat) returns (r:nat)\n  ensures r*r <= N < (r+1)*(r+1)\n{\n  r:=0;\n  while (r+1)*(r+1)<=N\n    invariant r*r<=N\n  {\n    r:=r+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/reverse/reverse_strong.dfy", "dafny": "method reverse(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i       := 0;\n  var aLength := a.Length;\n\n  var b := new int[a.Length];\n\n  while i < aLength\n    invariant 0 <= i && i <= aLength\n    invariant forall k :: 0 <= k < i ==> b[k] == a[aLength - 1 - k]\n    invariant forall k :: 0 <= k < aLength ==> a[k] == old(a[k])\n  {\n    b[i] := a[aLength - 1 - i];\n    i := i + 1;\n  }\n\n  i := 0;\n  while i < aLength\n    invariant 0 <= i && i <= aLength\n    invariant forall k :: 0 <= k < aLength ==> b[k] == old(a[aLength - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[k] == b[k]\n  {\n      a[i] := b[i];\n      i := i + 1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/insert/insert_strong.dfy", "dafny": "method insert(line:array<char>, l:int, nl:array<char>, p:int, at:int)\n  requires 0 <= l+p <= line.Length \n  requires 0 <= p <= nl.Length \n  requires 0 <= at <= l \n  modifies line\n  ensures forall i :: (0<=i<p) ==> line[at+i] == nl[i] \n  ensures forall i :: (0<=i<at) ==> line[i] == old(line[i])\n  ensures forall i :: (at+p<=i<l+p) ==> line[i] == old(line[i-p])\n{\n  ghost var initialLine := line[..];\n\n  var i:int := l;\n  while(i>at)\n    invariant line[0..i] == initialLine[0..i]\n    invariant line[i+p..l+p] == initialLine[i..l]\n    invariant at<=i<=l\n  {\n    i := i - 1;\n    line[i+p] := line[i];\n  }\n\n  assert line[0..at] == initialLine[0..at];\n  assert line[at+p..l+p] == initialLine[at..l];\n\n  i := 0;\n  while(i<p)\n    invariant 0<=i<=p\n    invariant line[0..at] == initialLine[0..at]\n    invariant line[at..at+i] == nl[0..i]\n    invariant line[at+p..l+p] == initialLine[at..l]\n  {\n    line[at + i] := nl[i];\n    i := i + 1;\n  }\n\n  assert line[0..at] == initialLine[0..at];\n  assert line[at..at+p] == nl[0..p];\n  assert line[at+p..l+p] == initialLine[at..l];\n}"}
{"file": "../Clover/dataset/Dafny/textbook_algo/update_array/update_array_strong.dfy", "dafny": "method UpdateElements(a: array<int>)\n  requires a.Length >=9\n  modifies a\n  ensures old(a[4]) +3 == a[4]\n  ensures a[8] == old(a[8])\n  ensures a[7]==516\n{\n  a[4], a[8] := a[4] + 3, a[8] + 1;\n  a[7], a[8] := 516, a[8] - 1;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/rotate/rotate_strong.dfy", "dafny": "method rotate(a: array<int>, offset:int) returns (b: array<int> )\n  requires 0<=offset<=a.Length\n  ensures b.Length==a.Length\n  ensures forall i ::0<=i<a.Length ==>  b[(i+offset)%a.Length]==a[i]\n{\n  b:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\n    invariant 0<=i<=a.Length\n    invariant forall j::0<=j<i ==> b[(j+offset)%a.Length]==a[j]\n  {\n    assert (i+offset)%a.Length == (if i+offset>=a.Length then i+offset-a.Length else i+offset);\n    var dest:= (i+offset)%a.Length;\n    b[dest]:=a[i];\n    i:=i+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/update_map/update_map_strong.dfy", "dafny": "method update_map<K(!new), V>(m1: map<K, V>, m2: map<K, V>) returns (r: map<K, V>)\n  ensures (forall k :: k in m2 ==> k in r)\n  ensures (forall k :: k in m1 ==> k in r)\n  ensures  (forall k :: k in m2 ==> r[k] == m2[k])\n  ensures  (forall k :: !(k in m2) && k in m1 ==> r[k] == m1[k])\n  ensures  (forall k :: !(k in m2) && !(k in m1) ==> !(k in r))\n{\n  r:= map k | k in (m1.Keys + m2.Keys) :: if k in m2 then m2[k] else m1[k];\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/min_of_two/min_of_two_strong.dfy", "dafny": "method Min(x: int, y:int) returns (z: int)\n  ensures x<=y ==> z==x\n  ensures x>y ==> z==y\n{\n  if x < y {\n    return x;\n  } else {\n    return y;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/has_close_elements/has_close_elements_strong.dfy", "dafny": "method has_close_elements(numbers: seq<real>, threshold: real) returns (res: bool)\n  ensures res ==> exists i: int, j: int :: 0 <= i < |numbers| && 0 <= j < |numbers| && i != j && (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) < threshold\n  ensures !res ==> (forall i: int, j: int :: 1 <= i < |numbers| && 0 <= j < i ==>  (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) >= threshold)\n\n\n{\n\n  res := false;\n  var idx: int := 0;\n  while idx < |numbers| && !res\n    invariant 0 <= idx <= |numbers|\n    invariant !res\n    invariant forall i: int, j: int :: 0 <= i < idx && 0 <= j < i ==> (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) >= threshold\n  {\n    var idx2: int := 0;\n    while idx2 < idx && !res\n      invariant 0 <= idx <= |numbers|\n      invariant 0 <= idx2 <= idx\n      invariant !res\n      invariant forall j: int :: 0 <= j < idx2 ==> (if numbers[idx] - numbers[j] < 0.0 then numbers[j] - numbers[idx] else numbers[idx] - numbers[j]) >= threshold\n    {\n\n      var distance :=  (if numbers[idx2] - numbers[idx] < 0.0 then numbers[idx] - numbers[idx2] else numbers[idx2] - numbers[idx]);\n      if distance < threshold  {\n        res := true;\n        return;\n      }\n\n      idx2 := idx2 + 1;\n    }\n    idx := idx + 1;\n  }\n}\n\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/array_sum/array_sum_strong.dfy", "dafny": "method arraySum(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] + b[i]==c[i]\n{\n  c:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\n    invariant 0<=i<=a.Length\n    invariant forall j:: 0 <= j< i==> a[j] + b[j]==c[j]\n  {\n    c[i]:=a[i]+b[i];\n    i:=i+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/avg/avg_strong.dfy", "dafny": "method ComputeAvg(a: int, b: int) returns (avg:int)\n  ensures avg == (a+b)/2\n{\n  avg:= (a + b) / 2;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/cal_ans/cal_ans_strong.dfy", "dafny": "method CalDiv() returns (x:int, y:int)\n  ensures x==191/7\n  ensures y==191%7\n{\n\n  x, y := 0, 191;\n  while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191\n  {\n    x := x+1;\n    y:=191-7*x;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/swap_in_array/swap_in_array_strong.dfy", "dafny": "method swap(arr: array<int>, i: int, j: int)\n  requires 0 <= i < arr.Length && 0 <= j < arr.Length\n  modifies arr\n  ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n  ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n{\n  var tmp := arr[i];\n  arr[i] := arr[j];\n  arr[j] := tmp;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/find/find_strong.dfy", "dafny": "method Find(a: array<int>, key: int) returns (index: int)\n  ensures -1<=index<a.Length\n  ensures index!=-1 ==> a[index]==key && (forall i :: 0 <= i < index ==> a[i] != key)\n  ensures index == -1 ==> (forall i::0 <= i < a.Length ==> a[i] != key)\n{\n  index := 0;\n  while index < a.Length\n    invariant 0<=index<=a.Length\n    invariant (forall i::0 <= i < index==>a[i] != key)\n  {\n    if a[index] == key { return; }\n    index := index + 1;\n  }\n  if index >= a.Length  {\n    index := -1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/replace/replace_strong.dfy", "dafny": "method replace(arr: array<int>, k: int)\n  modifies arr\n  ensures forall i :: 0 <= i < arr.Length ==> (((old(arr[i]) > k) ==> arr[i] == -1) && ((old(arr[i]) <= k) ==> arr[i] == old(arr[i])))\n{\n  var i := 0;\n  while i < arr.Length\n    decreases arr.Length - i\n    invariant 0 <= i <= arr.Length\n    invariant forall j :: 0 <= j < i ==>\n                            (((old(arr[j]) > k) ==> arr[j] == -1) &&\n                             ((old(arr[j]) <= k) ==> arr[j] == old(arr[j])))\n    invariant forall j :: i <= j < arr.Length ==> old(arr[j]) == arr[j]\n  {\n    if arr[i] > k {\n      arr[i] := -1;\n    }\n    i := i + 1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/bubble_sort/bubble_sort_strong.dfy", "dafny": "method BubbleSort(a: array<int>)\n  modifies a\n  ensures forall i,j::0<= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..])==multiset(old(a[..]))\n{\n  var i := a.Length - 1;\n  while (i > 0)\n    invariant i < 0 ==> a.Length == 0\n    invariant -1 <= i < a.Length\n    invariant forall ii,jj::i <= ii< jj <a.Length ==> a[ii] <= a[jj]\n    invariant forall k,k'::0<=k<=i<k'<a.Length==>a[k]<=a[k']\n    invariant multiset(a[..])==multiset(old(a[..]))\n  {\n    var j := 0;\n    while (j < i)\n      invariant 0 < i < a.Length && 0 <= j <= i\n      invariant forall ii,jj::i<= ii <= jj <a.Length ==> a[ii] <= a[jj]\n      invariant forall k, k'::0<=k<=i<k'<a.Length==>a[k]<=a[k']\n      invariant forall k :: 0 <= k <= j ==> a[k] <= a[j]\n      invariant multiset(a[..])==multiset(old(a[..]))\n    {\n      if (a[j] > a[j + 1])\n      {\n        a[j], a[j + 1] := a[j + 1], a[j];\n      }\n      j := j + 1;\n    }\n    i := i - 1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/triple3/triple3_strong.dfy", "dafny": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  if x==0 {\n    r:=0;\n  }\n  else{\n    var y:=2*x;\n    r:= x+y;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/linear_search3/linear_search3_strong.dfy", "dafny": "method LinearSearch3<T>(a: array<T>, P: T -> bool) returns (n: int)\n  requires exists i :: 0 <= i < a.Length && P(a[i])\n  ensures 0 <= n < a.Length && P(a[n])\n  ensures forall k :: 0 <= k < n ==> !P(a[k])\n{\n  n := 0;\n  while true\n    invariant 0 <= n < a.Length\n    invariant exists i :: n <= i < a.Length && P(a[i])\n    invariant  forall k :: 0 <= k < n ==> !P(a[k])\n    decreases a.Length - n\n  {\n    if P(a[n]) {\n      return;\n    }\n    n := n + 1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/convert_map_key/convert_map_key_strong.dfy", "dafny": "method convert_map_key(inputs: map<nat, bool>, f: nat->nat) returns(r:map<nat, bool>)\n  requires forall n1: nat, n2: nat :: n1 != n2 ==> f(n1) != f(n2)\n  ensures forall k :: k in inputs <==> f(k) in r\n  ensures forall k :: k in inputs ==> r[f(k)] == inputs[k]\n{\n  r:= map k | k in inputs :: f(k) := inputs[k];\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/modify_2d_array/modify_2d_array_strong.dfy", "dafny": "method modify_array_element(arr: array<array<nat>>, index1: nat, index2: nat, val: nat)\n  requires index1 < arr.Length\n  requires index2 < arr[index1].Length\n  requires forall i: nat, j:nat :: i < arr.Length && j < arr.Length && i != j ==> arr[i] != arr[j]\n  modifies arr[index1]\n  ensures forall some_index1: nat, some_index2: nat ::\n            some_index1 < arr.Length && some_index2 < arr[some_index1].Length ==>\n              arr[some_index1][some_index2] == if index1 == some_index1 && index2 == some_index2\n              then val else old(arr[some_index1][some_index2])\n{\n  arr[index1][index2] := val;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/triple4/triple4_strong.dfy", "dafny": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  var y:= x*2;\n  r := y+x;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/only_once/only_once_strong.dfy", "dafny": "method only_once<T(==)>(a: array<T>, key: T) returns (b:bool)\n  ensures (multiset(a[..])[key] ==1 ) <==> b\n{\n  var i := 0;\n  b := false;\n  var keyCount := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant multiset(a[..i])[key] == keyCount\n    invariant b <==> (keyCount == 1)\n  {\n    if (a[i] == key)\n    {\n      keyCount := keyCount + 1;\n    }\n    if (keyCount == 1)\n    { b := true; }\n    else\n    { b := false; }\n    i := i + 1;\n  }\n\n  assert a[..a.Length] == a[..];\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/return_seven/return_seven_strong.dfy", "dafny": "method M(x: int) returns (seven: int)\n  ensures seven==7\n{\n  seven := 7;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/cal_sum/cal_sum_strong.dfy", "dafny": "method Sum() returns (s:int, n:int)\n  ensures s == n * (n + 1) / 2\n  ensures n==33\n{\n  n, s := 0, 0;\n  while n != 33\n    invariant s == n * (n + 1) / 2\n  {\n    n := n + 1;\n    s := s + n;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/binary_search/binary_search_strong.dfy", "dafny": "method BinarySearch(a: array<int>, key: int) returns (n: int)\n  requires forall i,j :: 0<=i<j<a.Length ==> a[i]<=a[j]\n  ensures 0<= n <=a.Length\n  ensures forall i :: 0<= i < n ==> a[i] < key\n  ensures n == a.Length ==> forall i :: 0 <= i < a.Length ==> a[i] < key;\n  ensures forall i :: n<= i < a.Length ==> a[i]>=key\n{\n  var lo, hi := 0, a.Length;\n  while lo<hi\n    invariant 0<= lo <= hi <= a.Length\n    invariant forall i :: 0<=i<lo ==> a[i] < key\n    invariant forall i :: hi<=i<a.Length ==> a[i] >= key\n  {\n    var mid := (lo + hi) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else {\n      hi := mid;\n    }\n  }\n  n:=lo;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/array_product/array_product_strong.dfy", "dafny": "method arrayProduct(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] * b[i]==c[i]\n{\n  c:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\n    invariant 0<=i<=a.Length\n    invariant forall j:: 0 <= j< i==> a[j] * b[j]==c[j]\n  {\n    c[i]:=a[i]*b[i];\n    i:=i+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/max_array/max_array_strong.dfy", "dafny": "method maxArray(a: array<int>) returns (m: int)\n  requires a.Length >= 1\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var index := 1;\n  while (index < a.Length)\n    invariant 0 <= index <= a.Length\n    invariant forall k :: 0 <= k < index ==> m >= a[k];\n    invariant exists k :: 0 <= k < index && m == a[k];\n    decreases a.Length - index\n  {\n    m := if m>a[index] then  m else a[index];\n    index := index + 1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/min_array/min_array_strong.dfy", "dafny": "method minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n{\n  r:=a[0];\n  var i:=1;\n  while i<a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall x :: 0 <= x < i ==> r <= a[x]\n    invariant exists x :: 0 <= x < i && r == a[x]\n  {\n    if r>a[i]{\n      r:=a[i];\n    }\n    i:=i+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/array_concat/array_concat_strong.dfy", "dafny": "method concat(a:array<int>, b:array<int>) returns (c:array<int>)\n  ensures c.Length==b.Length+a.Length\n  ensures forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n  ensures forall k :: 0 <= k < b.Length ==> c[k+a.Length] == b[k]\n{\n  c := new int[a.Length+b.Length];\n  var i:= 0;\n  while (i < c.Length)\n    invariant 0 <= i <= c.Length\n    invariant if i<a.Length then c[..i]==a[..i] else c[..i]==a[..]+b[..(i-a.Length)]\n  {\n    c[i] := if i<a.Length then a[i] else b[i-a.Length];\n    i:=i+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/set_to_seq/set_to_seq_strong.dfy", "dafny": "method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)\n  ensures multiset(s) == multiset(xs)\n{\n  xs := [];\n  var left: set<T> := s;\n  while left != {}\n    invariant multiset(left) + multiset(xs) == multiset(s)\n  {\n    var x :| x in left;\n    left := left - {x};\n    xs := xs + [x];\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/all_digits/all_digits_strong.dfy", "dafny": "  method allDigits(s: string) returns (result: bool)\n  ensures  result <==> (forall i :: 0 <= i < |s| ==> s[i] in \"0123456789\")\n{\n  result:=true ;\n  for i := 0 to |s|\n    invariant result <==> (forall ii :: 0 <= ii < i ==> s[ii] in \"0123456789\")\n  {\n    if ! (s[i] in \"0123456789\"){\n      return false;\n    }\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/triple2/triple2_strong.dfy", "dafny": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  if {\n    case x<18 =>\n      var a,b := 2*x, 4*x;\n      r:=(a+b)/2;\n    case 0<=x =>\n      var y:=2*x;\n      r:= x+y;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/linear_search2/linear_search2_strong.dfy", "dafny": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  requires exists i::0<=i<a.Length && a[i]==e\n  ensures 0<=n<a.Length && a[n]==e\n  ensures forall k :: 0 <= k < n ==> a[k]!=e\n\n{\n  n :=0;\n  while n!=a.Length\n    invariant 0<=n<=a.Length\n    invariant forall i::0<=i<n ==> e!=a[i]\n  {\n    if e==a[n]{\n      return;\n    }\n    n:=n+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/selectionsort/selectionsort_strong.dfy", "dafny": "method SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n:= 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i, j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n    invariant forall i,j :: 0 <= i < j < n ==> a[i] <= a[j]\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var mindex, m := n, n+1;\n    while m != a.Length\n      invariant n <= mindex < m <= a.Length\n      invariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m+1;\n    }\n    a[n], a[mindex] := a[mindex], a[n];\n    n := n+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/below_zero/below_zero_strong.dfy", "dafny": "method below_zero(operations: seq<int>) returns (s:array<int>, result:bool)\n  ensures s.Length == |operations| + 1\n  ensures s[0]==0\n  ensures forall i :: 0 <= i < s.Length-1 ==> s[i+1]==s[i]+operations[i]\n  ensures result == true ==> (exists i :: 1 <= i <= |operations| && s[i] < 0)\n  ensures result == false ==> forall i :: 0 <= i < s.Length ==> s[i] >= 0\n{\n  result := false;\n  s := new int[|operations| + 1];\n  var i := 0;\n  s[i] := 0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant s[0]==0\n    invariant s.Length == |operations| + 1\n    invariant forall x :: 0 <= x < i-1 ==> s[x+1]==s[x]+operations[x]\n  {\n    if i>0{\n        s[i] := s[i - 1] + operations[i - 1];\n    }\n    i := i + 1;\n  }\n  i:=0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall x :: 0 <= x < i ==> s[x] >= 0\n  {\n    if s[i] < 0 {\n      result := true;\n      return;\n    }\n    i := i + 1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/online_max/online_max_strong.dfy", "dafny": "method onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)\n  requires 1<=x<a.Length\n  requires a.Length!=0\n  ensures x<=p<a.Length\n  ensures forall i::0<=i<x==> a[i]<=m\n  ensures exists i::0<=i<x && a[i]==m\n  ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])\n  ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1\n{\n  p:= 0;\n  var best := a[0];\n  var i:=1;\n  while i<x\n    invariant 0<=i<=x\n    invariant forall j::0<=j<i==> a[j]<=best\n    invariant exists j::0<=j<i && a[j]==best\n  {\n    if a[i]>best{\n      best:=a[i];\n    }\n    i:=i+1;\n  }\n  m:=best;\n  i:=x;\n  while i<a.Length\n    invariant x<=i<=a.Length\n    invariant forall j::x<=j<i ==> a[j]<=m\n  {\n    if a[i]>best{\n      p:=i;\n      return;\n    }\n    i:=i+1;\n  }\n  p:=a.Length-1;\n\n}\n\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/array_copy/array_copy_strong.dfy", "dafny": "method iter_copy<T(0)>(s: array<T>) returns (t: array<T>)\n  ensures s.Length==t.Length\n  ensures forall i::0<=i<s.Length ==> s[i]==t[i]\n{\n  t := new T[s.Length];\n  var i:= 0;\n  while (i < s.Length)\n    invariant 0 <= i <= s.Length\n    invariant forall x :: 0 <= x < i ==> s[x] == t[x]\n  {\n    t[i] := s[i];\n    i:=i+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/swap_bitvector/swap_bitvector_strong.dfy", "dafny": "method SwapBitvectors(X: bv8, Y: bv8) returns(x: bv8, y: bv8)\n  ensures x==Y\n  ensures y==X\n{\n  x, y := X, Y;\n\n  x := x ^ y;\n  y := x ^ y;\n  x := x ^ y;\n\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/multi_return/multi_return_strong.dfy", "dafny": "method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n  ensures more == x+y\n  ensures less == x-y\n{\n  more := x + y;\n  less := x - y;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/double_quadruple/double_quadruple_strong.dfy", "dafny": "method DoubleQuadruple(x: int) returns (a: int, b: int)\n  ensures a == 2 * x && b == 4 * x\n{\n  a := 2 * x;\n  b := 2 * a;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/swap/swap_strong.dfy", "dafny": "method Swap(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n{\n  x, y := X, Y;\n\n  var tmp := x;\n  x := y;\n  y := tmp;\n\n  assert x == Y && y == X;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/slope_search/slope_search_strong.dfy", "dafny": "method SlopeSearch(a: array2<int>, key: int) returns (m:int, n:int)\n  requires forall i,j,j'::0<=i<a.Length0 && 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j']\n  requires forall i,i',j::0<=i<i'<a.Length0 && 0<=j<a.Length1 ==> a[i,j]<=a[i',j]\n  requires exists i,j :: 0<=i<a.Length0 && 0<=j<a.Length1 && a[i,j]==key\n  ensures 0<=m<a.Length0 && 0<=n<a.Length1\n  ensures a[m,n]==key\n{\n  m,n:=0, a.Length1-1;\n  while a[m,n] !=key\n    invariant 0<=m<a.Length0 && 0<=n<a.Length1\n    invariant exists i,j :: m<=i<a.Length0 && 0<=j<=n && a[i,j]==key\n    decreases a.Length0-m+n\n  {\n    if a[m,n] < key {\n      m:=m+1;\n\n    }else{\n      n:=n-1;\n    }\n  }\n}\n\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/swap_sim/swap_sim_strong.dfy", "dafny": "method SwapSimultaneous(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n{\n  x, y := X, Y;\n  x, y := y, x;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/array_append/array_append_strong.dfy", "dafny": "method append(a:array<int>, b:int) returns (c:array<int>)\n  ensures  a[..] + [b] == c[..]\n{\n  c := new int[a.Length+1];\n  var i:= 0;\n  while (i < a.Length)\n    invariant 0 <= i <= a.Length\n    invariant forall ii::0<=ii<i ==> c[ii]==a[ii]\n  {\n    c[i] := a[i];\n    i:=i+1;\n  }\n  c[a.Length]:=b;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/triple/triple_strong.dfy", "dafny": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  r:= x*3;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/linear_search1/linear_search1_strong.dfy", "dafny": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  ensures 0<=n<=a.Length\n  ensures n==a.Length || a[n]==e\n  ensures forall i::0<=i < n ==> e!=a[i]\n{\n  n :=0;\n  while n!=a.Length\n    invariant 0<=n<=a.Length\n    invariant forall i::0<=i<n ==> e!=a[i]\n  {\n    if e==a[n]{\n      return;\n    }\n    n:=n+1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/is_palindrome/is_palindrome_strong.dfy", "dafny": "method IsPalindrome(x: seq<char>) returns (result: bool)\n  ensures result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - i - 1])\n{\n  if |x|==0 {\n    return true;\n  }\n  var i := 0;\n  var j := |x| - 1;\n  result := true;\n  while (i < j)\n    invariant 0<=i<=j+1 && 0<=j < |x|\n    invariant i+j==|x|-1\n    invariant (forall k :: 0 <= k < i ==> x[k] == x[|x| - k - 1])\n  {\n    if x[i] != x[j] {\n      result := false;\n      return;\n    }\n    i := i + 1;\n    j := j - 1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/quotient/quotient_strong.dfy", "dafny": "method Quotient(x: nat, y:nat) returns (r:int, q:int)\n  requires y != 0\n  ensures q*y+r==x && y>r>=0 && q>=0\n{\n  r:=x;\n  q:=0;\n  while y<=r\n    invariant q*y+r==x && r>=0\n    decreases r\n  {\n    r:=r-y;\n    q:=q+1;\n\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/swap_arith/swap_arith_strong.dfy", "dafny": "method SwapArithmetic(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n\n{\n  x, y := X, Y;\n\n  x := y - x;\n  y := y - x;\n  x := y + x;\n\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/even_list/even_list_strong.dfy", "dafny": "method FindEvenNumbers (arr: array<int>) returns (evenNumbers: array<int>)\n  ensures forall x {:trigger (x%2) }:: x in arr[..] &&  (x%2==0)==> x in evenNumbers[..];\n  ensures forall x :: x !in arr[..] ==> x !in evenNumbers[..]\n  ensures forall k :: 0 <= k < evenNumbers.Length ==> evenNumbers[k] % 2 == 0\n  ensures forall k, l :: 0 <= k < l < evenNumbers.Length ==>\n                           exists n, m :: 0 <= n < m < arr.Length && evenNumbers[k] == arr[n] && evenNumbers[l] == arr[m]\n\n{\n  var evenList: seq<int> := [];\n  ghost var indices: seq<int> := [];\n\n  for i := 0 to arr.Length\n    invariant 0 <= i <= arr.Length\n    invariant 0 <= |evenList| <= i\n    invariant forall x  {:trigger (x%2) }:: (x in arr[..i] && (x%2==0) )==> x in evenList[..]\n    invariant forall k :: 0 <= k < |evenList| ==> evenList[k] % 2 == 0\n    invariant forall x :: x !in arr[..i] ==> x !in evenList\n    invariant |evenList| == |indices|\n    invariant forall k :: 0 <= k < |indices| ==> indices[k] < i\n    invariant forall k, l :: 0 <= k < l < |indices| ==> indices[k] < indices[l]\n    invariant forall k :: 0 <= k < |evenList| ==> 0 <= indices[k] < i <= arr.Length && arr[indices[k]] == evenList[k]\n  {\n    if arr[i]%2==0\n    {\n      evenList := evenList + [arr[i]];\n      indices := indices + [i];\n    }\n  }\n\n  evenNumbers := new int[|evenList|](i requires 0 <= i < |evenList| => evenList[i]);\n  assert evenList == evenNumbers[..];\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/two_sum/two_sum_strong.dfy", "dafny": "method twoSum(nums: array<int>, target: int) returns (i: int, j: int)\n  requires nums.Length > 1\n  requires exists i,j::0 <= i < j < nums.Length &&  nums[i] + nums[j] == target\n  ensures 0 <= i < j < nums.Length && nums[i] + nums[j] == target\n  ensures forall ii,jj:: (0 <= ii < i && ii < jj < nums.Length) || (ii == i && ii < jj < j) ==> nums[ii] + nums[jj] != target\n\n{\n  var n := nums.Length;\n  i := 0;\n  j := 1;\n  while i < n - 1\n    invariant 0 <= i < j <= n\n    invariant forall ii, jj :: 0 <= ii < i && ii < jj < n ==> nums[ii] + nums[jj] != target\n  {\n    j := i + 1;\n    while j < n\n      invariant 0 <= i < j <= n\n      invariant forall jj :: i < jj < j ==> nums[i] + nums[jj] != target\n    {\n      if nums[i] + nums[j] == target {\n        return;\n      }\n      j := j + 1;\n    }\n\n    i := i + 1;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/is_even/is_even_strong.dfy", "dafny": "method ComputeIsEven(x:int) returns (is_even:bool)\n  ensures (x % 2 == 0)==is_even\n{\n  is_even:=false;\n  if x%2==0{\n    is_even:=true;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/count_lessthan/count_lessthan_strong.dfy", "dafny": "method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n{\n  count := 0;\n  var shrink := numbers;\n  var grow := {};\n  while |shrink | > 0\n    decreases shrink\n    invariant shrink + grow == numbers\n    invariant grow !! shrink\n    invariant count == |set i | i in grow && i < threshold|\n  {\n    var i: int :| i in shrink;\n    shrink := shrink - {i};\n    var grow' := grow+{i};\n    assert (set i | i in grow' && i < threshold) ==\n           (set i | i in grow && i < threshold )+ if i < threshold then {i} else {};\n    grow := grow + {i};\n    if i < threshold {\n      count := count + 1;\n    }\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/test_array/test_array_strong.dfy", "dafny": "method TestArrayElements(a:array<int>, j: nat, k: nat)\n  requires 0<=j < a.Length\n  modifies a\n  ensures a[j] == 60\n{\n  a[j] := 60;\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/abs/abs_strong.dfy", "dafny": "method Abs(x: int) returns (y: int)\n  ensures x>=0 ==> x==y\n  ensures x<0 ==> x+y==0\n{\n  if x < 0 {\n    return -x;\n  } else {\n    return x;\n  }\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/seq_to_array/seq_to_array_strong.dfy", "dafny": "  method ToArray<T>(xs: seq<T>) returns (a: array<T>)\n  ensures fresh(a)\n  ensures a.Length == |xs|\n  ensures forall i :: 0 <= i < |xs| ==> a[i] == xs[i]\n{\n  a := new T[|xs|](i requires 0 <= i < |xs| => xs[i]);\n}\n"}
{"file": "../Clover/dataset/Dafny/textbook_algo/compare/compare_strong.dfy", "dafny": "method Compare<T(==)>(a: T, b: T) returns (eq: bool)\n  ensures a==b ==> eq==true\n  ensures a!=b ==> eq==false\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n"}
